
Tx_MPU.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000238  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000174b0  08000240  08000240  00010240  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000004d8  080176f0  080176f0  000276f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08017bc8  08017bc8  0003006c  2**0
                  CONTENTS
  4 .ARM          00000008  08017bc8  08017bc8  00027bc8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08017bd0  08017bd0  0003006c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08017bd0  08017bd0  00027bd0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08017bd4  08017bd4  00027bd4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000006c  20000000  08017bd8  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000f7fc  2000006c  08017c44  0003006c  2**2
                  ALLOC
 10 ._user_heap_stack 00000c00  2000f868  08017c44  0003f868  2**0
                  ALLOC
 11 .ARM.attributes 00000036  00000000  00000000  0003006c  2**0
                  CONTENTS, READONLY
 12 .comment      00000043  00000000  00000000  000300a2  2**0
                  CONTENTS, READONLY
 13 .debug_line   0006e251  00000000  00000000  000300e5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line_str 00000248  00000000  00000000  0009e336  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_info   0006f664  00000000  00000000  0009e57e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_abbrev 00013ffd  00000000  00000000  0010dbe2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_aranges 00003030  00000000  00000000  00121be0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00159c5f  00000000  00000000  00124c10  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 000020d6  00000000  00000000  0027e86f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  000477aa  00000000  00000000  00280945  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_frame  00009250  00000000  00000000  002c80f0  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000240 <__do_global_dtors_aux>:
 8000240:	b510      	push	{r4, lr}
 8000242:	4c05      	ldr	r4, [pc, #20]	; (8000258 <__do_global_dtors_aux+0x18>)
 8000244:	7823      	ldrb	r3, [r4, #0]
 8000246:	b933      	cbnz	r3, 8000256 <__do_global_dtors_aux+0x16>
 8000248:	4b04      	ldr	r3, [pc, #16]	; (800025c <__do_global_dtors_aux+0x1c>)
 800024a:	b113      	cbz	r3, 8000252 <__do_global_dtors_aux+0x12>
 800024c:	4804      	ldr	r0, [pc, #16]	; (8000260 <__do_global_dtors_aux+0x20>)
 800024e:	f3af 8000 	nop.w
 8000252:	2301      	movs	r3, #1
 8000254:	7023      	strb	r3, [r4, #0]
 8000256:	bd10      	pop	{r4, pc}
 8000258:	2000006c 	.word	0x2000006c
 800025c:	00000000 	.word	0x00000000
 8000260:	080176d8 	.word	0x080176d8

08000264 <frame_dummy>:
 8000264:	b508      	push	{r3, lr}
 8000266:	4b03      	ldr	r3, [pc, #12]	; (8000274 <frame_dummy+0x10>)
 8000268:	b11b      	cbz	r3, 8000272 <frame_dummy+0xe>
 800026a:	4903      	ldr	r1, [pc, #12]	; (8000278 <frame_dummy+0x14>)
 800026c:	4803      	ldr	r0, [pc, #12]	; (800027c <frame_dummy+0x18>)
 800026e:	f3af 8000 	nop.w
 8000272:	bd08      	pop	{r3, pc}
 8000274:	00000000 	.word	0x00000000
 8000278:	20000070 	.word	0x20000070
 800027c:	080176d8 	.word	0x080176d8

08000280 <_tx_initialize_low_level>:
    .thumb_func
.type _tx_initialize_low_level, function
_tx_initialize_low_level:

    /* Disable interrupts during ThreadX initialization.  */
    CPSID   i
 8000280:	b672      	cpsid	i
    LDR     r1, =__RAM_segment_used_end__           // Build first free address
    ADD     r1, r1, #4                              //
    STR     r1, [r0]                                // Setup first unused memory pointer
#endif
    /* Setup Vector Table Offset Register.  */
    MOV     r0, #0xE000E000                         // Build address of NVIC registers
 8000282:	f04f 20e0 	mov.w	r0, #3758153728	; 0xe000e000
    LDR     r1, =g_pfnVectors                       // Pickup address of vector table
 8000286:	4917      	ldr	r1, [pc, #92]	; (80002e4 <__tx_DBGHandler+0x4>)
    STR     r1, [r0, #0xD08]                        // Set vector table address
 8000288:	f8c0 1d08 	str.w	r1, [r0, #3336]	; 0xd08

    /* Enable the cycle count register.  */
    LDR     r0, =0xE0001000                         // Build address of DWT register
 800028c:	4816      	ldr	r0, [pc, #88]	; (80002e8 <__tx_DBGHandler+0x8>)
    LDR     r1, [r0]                                // Pickup the current value
 800028e:	6801      	ldr	r1, [r0, #0]
    ORR     r1, r1, #1                              // Set the CYCCNTENA bit
 8000290:	f041 0101 	orr.w	r1, r1, #1
    STR     r1, [r0]                                // Enable the cycle count register
 8000294:	6001      	str	r1, [r0, #0]

    /* Set system stack pointer from vector value.  */
    LDR     r0, =_tx_thread_system_stack_ptr        // Build address of system stack pointer
 8000296:	4815      	ldr	r0, [pc, #84]	; (80002ec <__tx_DBGHandler+0xc>)
    LDR     r1, =g_pfnVectors                       // Pickup address of vector table
 8000298:	4912      	ldr	r1, [pc, #72]	; (80002e4 <__tx_DBGHandler+0x4>)
    LDR     r1, [r1]                                // Pickup reset stack pointer
 800029a:	6809      	ldr	r1, [r1, #0]
    STR     r1, [r0]                                // Save system stack pointer
 800029c:	6001      	str	r1, [r0, #0]

    /* Configure SysTick.  */
    MOV     r0, #0xE000E000                         // Build address of NVIC registers
 800029e:	f04f 20e0 	mov.w	r0, #3758153728	; 0xe000e000
    LDR     r1, =SYSTICK_CYCLES
 80002a2:	4913      	ldr	r1, [pc, #76]	; (80002f0 <__tx_DBGHandler+0x10>)
    STR     r1, [r0, #0x14]                         // Setup SysTick Reload Value
 80002a4:	6141      	str	r1, [r0, #20]
    MOV     r1, #0x7                                // Build SysTick Control Enable Value
 80002a6:	f04f 0107 	mov.w	r1, #7
    STR     r1, [r0, #0x10]                         // Setup SysTick Control
 80002aa:	6101      	str	r1, [r0, #16]

    /* Configure handler priorities.  */
    LDR     r1, =0x00000000                         // Rsrv, UsgF, BusF, MemM
 80002ac:	f04f 0100 	mov.w	r1, #0
    STR     r1, [r0, #0xD18]                        // Setup System Handlers 4-7 Priority Registers
 80002b0:	f8c0 1d18 	str.w	r1, [r0, #3352]	; 0xd18

    LDR     r1, =0xFF000000                         // SVCl, Rsrv, Rsrv, Rsrv
 80002b4:	f04f 417f 	mov.w	r1, #4278190080	; 0xff000000
    STR     r1, [r0, #0xD1C]                        // Setup System Handlers 8-11 Priority Registers
 80002b8:	f8c0 1d1c 	str.w	r1, [r0, #3356]	; 0xd1c
                                                    // Note: SVC must be lowest priority, which is 0xFF

    LDR     r1, =0x40FF0000                         // SysT, PnSV, Rsrv, DbgM
 80002bc:	490d      	ldr	r1, [pc, #52]	; (80002f4 <__tx_DBGHandler+0x14>)
    STR     r1, [r0, #0xD20]                        // Setup System Handlers 12-15 Priority Registers
 80002be:	f8c0 1d20 	str.w	r1, [r0, #3360]	; 0xd20
                                                    // Note: PnSV must be lowest priority, which is 0xFF

    /* Return to caller.  */
    BX      lr
 80002c2:	4770      	bx	lr

080002c4 <__tx_BadHandler>:
    .eabi_attribute Tag_ABI_align_preserved, 1
    .global  __tx_BadHandler
    .thumb_func
.type __tx_BadHandler, function
__tx_BadHandler:
    B       __tx_BadHandler
 80002c4:	f7ff bffe 	b.w	80002c4 <__tx_BadHandler>

080002c8 <__tx_IntHandler>:
    .thumb_func
.type __tx_IntHandler, function
__tx_IntHandler:
// VOID InterruptHandler (VOID)
// {
    PUSH    {r0,lr}     // Save LR (and dummy r0 to maintain stack alignment)
 80002c8:	b501      	push	{r0, lr}
    /* Do interrupt handler work here */
    /* .... */
#if (defined(TX_ENABLE_EXECUTION_CHANGE_NOTIFY) || defined(TX_EXECUTION_PROFILE_ENABLE))
    BL      _tx_execution_isr_exit              // Call the ISR exit function
#endif
    POP     {r0,lr}
 80002ca:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    BX      lr
 80002ce:	4770      	bx	lr

080002d0 <SysTick_Handler>:
    .thumb_func
.type SysTick_Handler, function
SysTick_Handler:
// VOID TimerInterruptHandler (VOID)
// {
    PUSH    {r0,lr}     // Save LR (and dummy r0 to maintain stack alignment)
 80002d0:	b501      	push	{r0, lr}
#if (defined(TX_ENABLE_EXECUTION_CHANGE_NOTIFY) || defined(TX_EXECUTION_PROFILE_ENABLE))
    BL      _tx_execution_isr_enter             // Call the ISR enter function
#endif
    BL      _tx_timer_interrupt
 80002d2:	f000 f811 	bl	80002f8 <_tx_timer_interrupt>
#if (defined(TX_ENABLE_EXECUTION_CHANGE_NOTIFY) || defined(TX_EXECUTION_PROFILE_ENABLE))
    BL      _tx_execution_isr_exit              // Call the ISR exit function
#endif
    POP     {r0,lr}
 80002d6:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    BX      lr
 80002da:	4770      	bx	lr

080002dc <__tx_NMIHandler>:
    .eabi_attribute Tag_ABI_align_preserved, 1
    .global  __tx_NMIHandler
    .thumb_func
.type __tx_NMIHandler, function
__tx_NMIHandler:
    B       __tx_NMIHandler
 80002dc:	f7ff bffe 	b.w	80002dc <__tx_NMIHandler>

080002e0 <__tx_DBGHandler>:
    .eabi_attribute Tag_ABI_align_preserved, 1
    .global  __tx_DBGHandler
    .thumb_func
.type __tx_DBGHandler, function
__tx_DBGHandler:
    B       __tx_DBGHandler
 80002e0:	f7ff bffe 	b.w	80002e0 <__tx_DBGHandler>
    LDR     r1, =g_pfnVectors                       // Pickup address of vector table
 80002e4:	08000000 	.word	0x08000000
    LDR     r0, =0xE0001000                         // Build address of DWT register
 80002e8:	e0001000 	.word	0xe0001000
    LDR     r0, =_tx_thread_system_stack_ptr        // Build address of system stack pointer
 80002ec:	2000efb4 	.word	0x2000efb4
    LDR     r1, =SYSTICK_CYCLES
 80002f0:	001869ff 	.word	0x001869ff
    LDR     r1, =0x40FF0000                         // SysT, PnSV, Rsrv, DbgM
 80002f4:	40ff0000 	.word	0x40ff0000

080002f8 <_tx_timer_interrupt>:
       for use.  */

    /* Increment the system clock.  */
    // _tx_timer_system_clock++;

    LDR     r1, =_tx_timer_system_clock             // Pickup address of system clock
 80002f8:	4922      	ldr	r1, [pc, #136]	; (8000384 <__tx_timer_nothing_expired+0x8>)
    LDR     r0, [r1, #0]                            // Pickup system clock
 80002fa:	6808      	ldr	r0, [r1, #0]
    ADD     r0, r0, #1                              // Increment system clock
 80002fc:	f100 0001 	add.w	r0, r0, #1
    STR     r0, [r1, #0]                            // Store new system clock
 8000300:	6008      	str	r0, [r1, #0]

    /* Test for time-slice expiration.  */
    // if (_tx_timer_time_slice)
    // {

    LDR     r3, =_tx_timer_time_slice               // Pickup address of time-slice
 8000302:	4b21      	ldr	r3, [pc, #132]	; (8000388 <__tx_timer_nothing_expired+0xc>)
    LDR     r2, [r3, #0]                            // Pickup time-slice
 8000304:	681a      	ldr	r2, [r3, #0]
    CBZ     r2, __tx_timer_no_time_slice            // Is it non-active?
 8000306:	b13a      	cbz	r2, 8000318 <__tx_timer_no_time_slice>
                                                    // Yes, skip time-slice processing

       /* Decrement the time_slice.  */
       // _tx_timer_time_slice--;

    SUB     r2, r2, #1                              // Decrement the time-slice
 8000308:	f1a2 0201 	sub.w	r2, r2, #1
    STR     r2, [r3, #0]                            // Store new time-slice value
 800030c:	601a      	str	r2, [r3, #0]

       /* Check for expiration.  */
       // if (__tx_timer_time_slice == 0)

    CBNZ    r2, __tx_timer_no_time_slice            // Has it expired?
 800030e:	b91a      	cbnz	r2, 8000318 <__tx_timer_no_time_slice>
                                                    // No, skip expiration processing

       /* Set the time-slice expired flag.  */
       // _tx_timer_expired_time_slice =  TX_TRUE;

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup address of expired flag
 8000310:	4b1e      	ldr	r3, [pc, #120]	; (800038c <__tx_timer_nothing_expired+0x10>)
    MOV     r0, #1                                  // Build expired value
 8000312:	f04f 0001 	mov.w	r0, #1
    STR     r0, [r3, #0]                            // Set time-slice expiration flag
 8000316:	6018      	str	r0, [r3, #0]

08000318 <__tx_timer_no_time_slice>:

    /* Test for timer expiration.  */
    // if (*_tx_timer_current_ptr)
    // {

    LDR     r1, =_tx_timer_current_ptr              // Pickup current timer pointer address
 8000318:	491d      	ldr	r1, [pc, #116]	; (8000390 <__tx_timer_nothing_expired+0x14>)
    LDR     r0, [r1, #0]                            // Pickup current timer
 800031a:	6808      	ldr	r0, [r1, #0]
    LDR     r2, [r0, #0]                            // Pickup timer list entry
 800031c:	6802      	ldr	r2, [r0, #0]
    CBZ     r2, __tx_timer_no_timer                 // Is there anything in the list?
 800031e:	b122      	cbz	r2, 800032a <__tx_timer_no_timer>
                                                    // No, just increment the timer

        /* Set expiration flag.  */
        // _tx_timer_expired =  TX_TRUE;

    LDR     r3, =_tx_timer_expired                  // Pickup expiration flag address
 8000320:	4b1c      	ldr	r3, [pc, #112]	; (8000394 <__tx_timer_nothing_expired+0x18>)
    MOV     r2, #1                                  // Build expired value
 8000322:	f04f 0201 	mov.w	r2, #1
    STR     r2, [r3, #0]                            // Set expired flag
 8000326:	601a      	str	r2, [r3, #0]
    B       __tx_timer_done                         // Finished timer processing
 8000328:	e008      	b.n	800033c <__tx_timer_done>

0800032a <__tx_timer_no_timer>:
__tx_timer_no_timer:

        /* No timer expired, increment the timer pointer.  */
        // _tx_timer_current_ptr++;

    ADD     r0, r0, #4                              // Move to next timer
 800032a:	f100 0004 	add.w	r0, r0, #4

        /* Check for wrap-around.  */
        // if (_tx_timer_current_ptr == _tx_timer_list_end)

    LDR     r3, =_tx_timer_list_end                 // Pickup addr of timer list end
 800032e:	4b1a      	ldr	r3, [pc, #104]	; (8000398 <__tx_timer_nothing_expired+0x1c>)
    LDR     r2, [r3, #0]                            // Pickup list end
 8000330:	681a      	ldr	r2, [r3, #0]
    CMP     r0, r2                                  // Are we at list end?
 8000332:	4290      	cmp	r0, r2
    BNE     __tx_timer_skip_wrap                    // No, skip wrap-around logic
 8000334:	d101      	bne.n	800033a <__tx_timer_skip_wrap>

            /* Wrap to beginning of list.  */
            // _tx_timer_current_ptr =  _tx_timer_list_start;

    LDR     r3, =_tx_timer_list_start               // Pickup addr of timer list start
 8000336:	4b19      	ldr	r3, [pc, #100]	; (800039c <__tx_timer_nothing_expired+0x20>)
    LDR     r0, [r3, #0]                            // Set current pointer to list start
 8000338:	6818      	ldr	r0, [r3, #0]

0800033a <__tx_timer_skip_wrap>:

__tx_timer_skip_wrap:

    STR     r0, [r1, #0]                            // Store new current timer pointer
 800033a:	6008      	str	r0, [r1, #0]

0800033c <__tx_timer_done>:

    /* See if anything has expired.  */
    // if ((_tx_timer_expired_time_slice) || (_tx_timer_expired))
    // {

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup addr of expired flag
 800033c:	4b13      	ldr	r3, [pc, #76]	; (800038c <__tx_timer_nothing_expired+0x10>)
    LDR     r2, [r3, #0]                            // Pickup time-slice expired flag
 800033e:	681a      	ldr	r2, [r3, #0]
    CBNZ    r2, __tx_something_expired              // Did a time-slice expire?
 8000340:	b912      	cbnz	r2, 8000348 <__tx_something_expired>
                                                    // If non-zero, time-slice expired
    LDR     r1, =_tx_timer_expired                  // Pickup addr of other expired flag
 8000342:	4914      	ldr	r1, [pc, #80]	; (8000394 <__tx_timer_nothing_expired+0x18>)
    LDR     r0, [r1, #0]                            // Pickup timer expired flag
 8000344:	6808      	ldr	r0, [r1, #0]
    CBZ     r0, __tx_timer_nothing_expired          // Did a timer expire?
 8000346:	b1c8      	cbz	r0, 800037c <__tx_timer_nothing_expired>

08000348 <__tx_something_expired>:
                                                    // No, nothing expired

__tx_something_expired:

    PUSH    {r0, lr}                                // Save the lr register on the stack
 8000348:	b501      	push	{r0, lr}

    /* Did a timer expire?  */
    // if (_tx_timer_expired)
    // {

    LDR     r1, =_tx_timer_expired                  // Pickup addr of expired flag
 800034a:	4912      	ldr	r1, [pc, #72]	; (8000394 <__tx_timer_nothing_expired+0x18>)
    LDR     r0, [r1, #0]                            // Pickup timer expired flag
 800034c:	6808      	ldr	r0, [r1, #0]
    CBZ     r0, __tx_timer_dont_activate            // Check for timer expiration
 800034e:	b108      	cbz	r0, 8000354 <__tx_timer_dont_activate>
                                                    // If not set, skip timer activation

        /* Process timer expiration.  */
        // _tx_timer_expiration_process();

    BL      _tx_timer_expiration_process            // Call the timer expiration handling routine
 8000350:	f00c ffbe 	bl	800d2d0 <_tx_timer_expiration_process>

08000354 <__tx_timer_dont_activate>:

    /* Did time slice expire?  */
    // if (_tx_timer_expired_time_slice)
    // {

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup addr of time-slice expired
 8000354:	4b0d      	ldr	r3, [pc, #52]	; (800038c <__tx_timer_nothing_expired+0x10>)
    LDR     r2, [r3, #0]                            // Pickup the actual flag
 8000356:	681a      	ldr	r2, [r3, #0]
    CBZ     r2, __tx_timer_not_ts_expiration        // See if the flag is set
 8000358:	b172      	cbz	r2, 8000378 <__tx_timer_not_ts_expiration>
                                                    // No, skip time-slice processing

        /* Time slice interrupted thread.  */
        // _tx_thread_time_slice();

    BL      _tx_thread_time_slice                   // Call time-slice processing
 800035a:	f00c fc99 	bl	800cc90 <_tx_thread_time_slice>
    LDR     r0, =_tx_thread_preempt_disable         // Build address of preempt disable flag
 800035e:	4810      	ldr	r0, [pc, #64]	; (80003a0 <__tx_timer_nothing_expired+0x24>)
    LDR     r1, [r0]                                // Is the preempt disable flag set?
 8000360:	6801      	ldr	r1, [r0, #0]
    CBNZ    r1, __tx_timer_skip_time_slice          // Yes, skip the PendSV logic
 8000362:	b949      	cbnz	r1, 8000378 <__tx_timer_not_ts_expiration>
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
 8000364:	480f      	ldr	r0, [pc, #60]	; (80003a4 <__tx_timer_nothing_expired+0x28>)
    LDR     r1, [r0]                                // Pickup the current thread pointer
 8000366:	6801      	ldr	r1, [r0, #0]
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
 8000368:	4a0f      	ldr	r2, [pc, #60]	; (80003a8 <__tx_timer_nothing_expired+0x2c>)
    LDR     r3, [r2]                                // Pickup the execute thread pointer
 800036a:	6813      	ldr	r3, [r2, #0]
    LDR     r0, =0xE000ED04                         // Build address of control register
 800036c:	480f      	ldr	r0, [pc, #60]	; (80003ac <__tx_timer_nothing_expired+0x30>)
    LDR     r2, =0x10000000                         // Build value for PendSV bit
 800036e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    CMP     r1, r3                                  // Are they the same?
 8000372:	4299      	cmp	r1, r3
    BEQ     __tx_timer_skip_time_slice              // If the same, there was no time-slice performed
 8000374:	d000      	beq.n	8000378 <__tx_timer_not_ts_expiration>
    STR     r2, [r0]                                // Not the same, issue the PendSV for preemption
 8000376:	6002      	str	r2, [r0, #0]

08000378 <__tx_timer_not_ts_expiration>:
__tx_timer_skip_time_slice:
    // }

__tx_timer_not_ts_expiration:

    POP     {r0, lr}                                // Recover lr register (r0 is just there for
 8000378:	e8bd 4001 	ldmia.w	sp!, {r0, lr}

0800037c <__tx_timer_nothing_expired>:

    // }

__tx_timer_nothing_expired:

    DSB                                             // Complete all memory access
 800037c:	f3bf 8f4f 	dsb	sy
    BX      lr                                      // Return to caller
 8000380:	4770      	bx	lr
 8000382:	0000      	.short	0x0000
    LDR     r1, =_tx_timer_system_clock             // Pickup address of system clock
 8000384:	2000f064 	.word	0x2000f064
    LDR     r3, =_tx_timer_time_slice               // Pickup address of time-slice
 8000388:	2000f5fc 	.word	0x2000f5fc
    LDR     r3, =_tx_timer_expired_time_slice       // Pickup address of expired flag
 800038c:	2000f068 	.word	0x2000f068
    LDR     r1, =_tx_timer_current_ptr              // Pickup current timer pointer address
 8000390:	2000f0f4 	.word	0x2000f0f4
    LDR     r3, =_tx_timer_expired                  // Pickup expiration flag address
 8000394:	2000f0f8 	.word	0x2000f0f8
    LDR     r3, =_tx_timer_list_end                 // Pickup addr of timer list end
 8000398:	2000f0f0 	.word	0x2000f0f0
    LDR     r3, =_tx_timer_list_start               // Pickup addr of timer list start
 800039c:	2000f0ec 	.word	0x2000f0ec
    LDR     r0, =_tx_thread_preempt_disable         // Build address of preempt disable flag
 80003a0:	2000f054 	.word	0x2000f054
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
 80003a4:	2000efb8 	.word	0x2000efb8
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
 80003a8:	2000efbc 	.word	0x2000efbc
    LDR     r0, =0xE000ED04                         // Build address of control register
 80003ac:	e000ed04 	.word	0xe000ed04

080003b0 <_tx_thread_interrupt_control>:
#ifdef TX_PORT_USE_BASEPRI
    MRS     r1, BASEPRI                         // Pickup current interrupt posture
    MSR     BASEPRI, r0                         // Apply the new interrupt posture
    MOV     r0, r1                              // Transfer old to return register
#else
    MRS     r1, PRIMASK                         // Pickup current interrupt lockout
 80003b0:	f3ef 8110 	mrs	r1, PRIMASK
    MSR     PRIMASK, r0                         // Apply the new interrupt lockout
 80003b4:	f380 8810 	msr	PRIMASK, r0
    MOV     r0, r1                              // Transfer old to return register
 80003b8:	1c08      	adds	r0, r1, #0
#endif
    BX      lr                                  // Return to caller
 80003ba:	4770      	bx	lr
 80003bc:	0000      	movs	r0, r0
	...

080003c0 <_tx_thread_schedule>:
    /* This function should only ever be called on Cortex-M
       from the first schedule request. Subsequent scheduling occurs
       from the PendSV handling routine below. */

    /* Clear the preempt-disable flag to enable rescheduling after initialization on Cortex-M targets.  */
    MOV     r0, #0                                  // Build value for TX_FALSE
 80003c0:	f04f 0000 	mov.w	r0, #0
    LDR     r2, =_tx_thread_preempt_disable         // Build address of preempt disable flag
 80003c4:	4ace      	ldr	r2, [pc, #824]	; (8000700 <_tx_vfp_access+0x4>)
    STR     r0, [r2, #0]                            // Clear preempt disable flag
 80003c6:	6010      	str	r0, [r2, #0]

#ifdef __ARM_FP
    /* Clear CONTROL.FPCA bit so VFP registers aren't unnecessarily stacked.  */
    MRS     r0, CONTROL                             // Pickup current CONTROL register
 80003c8:	f3ef 8014 	mrs	r0, CONTROL
    BIC     r0, r0, #4                              // Clear the FPCA bit
 80003cc:	f020 0004 	bic.w	r0, r0, #4
    MSR     CONTROL, r0                             // Setup new CONTROL register
 80003d0:	f380 8814 	msr	CONTROL, r0
#endif

    /* Enable memory fault registers.  */
    LDR     r0, =0xE000ED24                         // Build SHCSR address
 80003d4:	48cb      	ldr	r0, [pc, #812]	; (8000704 <_tx_vfp_access+0x8>)
    LDR     r1, =0x70000                            // Enable Usage, Bus, and MemManage faults
 80003d6:	f44f 21e0 	mov.w	r1, #458752	; 0x70000
    STR     r1, [r0]                                //
 80003da:	6001      	str	r1, [r0, #0]

    /* Enable interrupts */
    CPSIE   i
 80003dc:	b662      	cpsie	i

    /* Enter the scheduler for the first time.  */
    MOV     r0, #0x10000000                         // Load PENDSVSET bit
 80003de:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    MOV     r1, #0xE000E000                         // Load NVIC base
 80003e2:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
    STR     r0, [r1, #0xD04]                        // Set PENDSVBIT in ICSR
 80003e6:	f8c1 0d04 	str.w	r0, [r1, #3332]	; 0xd04
    DSB                                             // Complete all memory accesses
 80003ea:	f3bf 8f4f 	dsb	sy
    ISB                                             // Flush pipeline
 80003ee:	f3bf 8f6f 	isb	sy

080003f2 <__tx_wait_here>:

    /* Wait here for the PendSV to take place.  */

__tx_wait_here:
    B       __tx_wait_here                          // Wait for the PendSV to happen
 80003f2:	e7fe      	b.n	80003f2 <__tx_wait_here>

080003f4 <BusFault_Handler>:

#ifdef TX_PORT_USE_BASEPRI
    LDR     r1, =TX_PORT_BASEPRI                    // Mask interrupt priorities =< TX_PORT_BASEPRI
    MSR     BASEPRI, r1
#else
    CPSID   i                                       // Disable interrupts
 80003f4:	b672      	cpsid	i
#endif  /* TX_PORT_USE_BASEPRI */

    /* Now pickup and store all the fault related information.  */

    LDR     r12,=_txm_module_manager_memory_fault_info  // Pickup fault info struct
 80003f6:	f8df c310 	ldr.w	ip, [pc, #784]	; 8000708 <_tx_vfp_access+0xc>
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
 80003fa:	48c4      	ldr	r0, [pc, #784]	; (800070c <_tx_vfp_access+0x10>)
    LDR     r1, [r0]                                // Pickup the current thread pointer
 80003fc:	6801      	ldr	r1, [r0, #0]
    STR     r1, [r12, #0]                           // Save current thread pointer in fault info structure
 80003fe:	f8cc 1000 	str.w	r1, [ip]
    LDR     r0, =0xE000ED24                         // Build SHCSR address
 8000402:	48c0      	ldr	r0, [pc, #768]	; (8000704 <_tx_vfp_access+0x8>)
    LDR     r1, [r0]                                // Pickup SHCSR
 8000404:	6801      	ldr	r1, [r0, #0]
    STR     r1, [r12, #8]                           // Save SHCSR
 8000406:	f8cc 1008 	str.w	r1, [ip, #8]
    LDR     r0, =0xE000ED28                         // Build CFSR address
 800040a:	48c1      	ldr	r0, [pc, #772]	; (8000710 <_tx_vfp_access+0x14>)
    LDR     r1, [r0]                                // Pickup CFSR
 800040c:	6801      	ldr	r1, [r0, #0]
    STR     r1, [r12, #12]                          // Save CFSR
 800040e:	f8cc 100c 	str.w	r1, [ip, #12]
    LDR     r0, =0xE000ED34                         // Build MMFAR address
 8000412:	48c0      	ldr	r0, [pc, #768]	; (8000714 <_tx_vfp_access+0x18>)
    LDR     r1, [r0]                                // Pickup MMFAR
 8000414:	6801      	ldr	r1, [r0, #0]
    STR     r1, [r12, #16]                          // Save MMFAR
 8000416:	f8cc 1010 	str.w	r1, [ip, #16]
    LDR     r0, =0xE000ED38                         // Build BFAR address
 800041a:	48bf      	ldr	r0, [pc, #764]	; (8000718 <_tx_vfp_access+0x1c>)
    LDR     r1, [r0]                                // Pickup BFAR
 800041c:	6801      	ldr	r1, [r0, #0]
    STR     r1, [r12, #20]                          // Save BFAR
 800041e:	f8cc 1014 	str.w	r1, [ip, #20]
    MRS     r0, CONTROL                             // Pickup current CONTROL register
 8000422:	f3ef 8014 	mrs	r0, CONTROL
    STR     r0, [r12, #24]                          // Save CONTROL
 8000426:	f8cc 0018 	str.w	r0, [ip, #24]
    MRS     r1, PSP                                 // Pickup thread stack pointer
 800042a:	f3ef 8109 	mrs	r1, PSP
    STR     r1, [r12, #28]                          // Save thread stack pointer
 800042e:	f8cc 101c 	str.w	r1, [ip, #28]
    LDR     r0, [r1]                                // Pickup saved r0
 8000432:	6808      	ldr	r0, [r1, #0]
    STR     r0, [r12, #32]                          // Save r0
 8000434:	f8cc 0020 	str.w	r0, [ip, #32]
    LDR     r0, [r1, #4]                            // Pickup saved r1
 8000438:	6848      	ldr	r0, [r1, #4]
    STR     r0, [r12, #36]                          // Save r1
 800043a:	f8cc 0024 	str.w	r0, [ip, #36]	; 0x24
    STR     r2, [r12, #40]                          // Save r2
 800043e:	f8cc 2028 	str.w	r2, [ip, #40]	; 0x28
    STR     r3, [r12, #44]                          // Save r3
 8000442:	f8cc 302c 	str.w	r3, [ip, #44]	; 0x2c
    STR     r4, [r12, #48]                          // Save r4
 8000446:	f8cc 4030 	str.w	r4, [ip, #48]	; 0x30
    STR     r5, [r12, #52]                          // Save r5
 800044a:	f8cc 5034 	str.w	r5, [ip, #52]	; 0x34
    STR     r6, [r12, #56]                          // Save r6
 800044e:	f8cc 6038 	str.w	r6, [ip, #56]	; 0x38
    STR     r7, [r12, #60]                          // Save r7
 8000452:	f8cc 703c 	str.w	r7, [ip, #60]	; 0x3c
    STR     r8, [r12, #64]                          // Save r8
 8000456:	f8cc 8040 	str.w	r8, [ip, #64]	; 0x40
    STR     r9, [r12, #68]                          // Save r9
 800045a:	f8cc 9044 	str.w	r9, [ip, #68]	; 0x44
    STR     r10,[r12, #72]                          // Save r10
 800045e:	f8cc a048 	str.w	sl, [ip, #72]	; 0x48
    STR     r11,[r12, #76]                          // Save r11
 8000462:	f8cc b04c 	str.w	fp, [ip, #76]	; 0x4c
    LDR     r0, [r1, #16]                           // Pickup saved r12
 8000466:	6908      	ldr	r0, [r1, #16]
    STR     r0, [r12, #80]                          // Save r12
 8000468:	f8cc 0050 	str.w	r0, [ip, #80]	; 0x50
    LDR     r0, [r1, #20]                           // Pickup saved lr
 800046c:	6948      	ldr	r0, [r1, #20]
    STR     r0, [r12, #84]                          // Save lr
 800046e:	f8cc 0054 	str.w	r0, [ip, #84]	; 0x54
    LDR     r0, [r1, #24]                           // Pickup instruction address at point of fault
 8000472:	6988      	ldr	r0, [r1, #24]
    STR     r0, [r12, #4]                           // Save point of fault
 8000474:	f8cc 0004 	str.w	r0, [ip, #4]
    LDR     r0, [r1, #28]                           // Pickup xPSR
 8000478:	69c8      	ldr	r0, [r1, #28]
    STR     r0, [r12, #88]                          // Save xPSR
 800047a:	f8cc 0058 	str.w	r0, [ip, #88]	; 0x58

    MRS     r0, CONTROL                             // Pickup current CONTROL register
 800047e:	f3ef 8014 	mrs	r0, CONTROL
    BIC     r0, r0, #1                              // Clear the UNPRIV bit
 8000482:	f020 0001 	bic.w	r0, r0, #1
    MSR     CONTROL, r0                             // Setup new CONTROL register
 8000486:	f380 8814 	msr	CONTROL, r0

    LDR     r0, =0xE000ED28                         // Build the Memory Management Fault Status Register (MMFSR)
 800048a:	48a1      	ldr	r0, [pc, #644]	; (8000710 <_tx_vfp_access+0x14>)
    LDRB    r1, [r0]                                // Pickup the MMFSR, with the following bit definitions:
 800048c:	7801      	ldrb	r1, [r0, #0]
                                                    //     Bit 0 = 1 -> Instruction address violation
                                                    //     Bit 1 = 1 -> Load/store address violation
                                                    //     Bit 7 = 1 -> MMFAR is valid
    STRB    r1, [r0]                                // Clear the MMFSR
 800048e:	7001      	strb	r1, [r0, #0]

#ifdef __ARM_FP
    LDR     r0, =0xE000EF34                         // Cleanup FPU context: Load FPCCR address
 8000490:	48a2      	ldr	r0, [pc, #648]	; (800071c <_tx_vfp_access+0x20>)
    LDR     r1, [r0]                                // Load FPCCR
 8000492:	6801      	ldr	r1, [r0, #0]
    BIC     r1, r1, #1                              // Clear the lazy preservation active bit
 8000494:	f021 0101 	bic.w	r1, r1, #1
    STR     r1, [r0]                                // Store the value
 8000498:	6001      	str	r1, [r0, #0]
#endif

    BL      _txm_module_manager_memory_fault_handler    // Call memory manager fault handler
 800049a:	f014 fc39 	bl	8014d10 <_txm_module_manager_memory_fault_handler>
    CPSID   i                                       // Disable interrupts
    BL      _tx_execution_thread_exit               // Call the thread exit function
    CPSIE   i                                       // Enable interrupts
#endif

    MOV     r1, #0                                  // Build NULL value
 800049e:	f04f 0100 	mov.w	r1, #0
    LDR     r0, =_tx_thread_current_ptr             // Pickup address of current thread pointer
 80004a2:	489a      	ldr	r0, [pc, #616]	; (800070c <_tx_vfp_access+0x10>)
    STR     r1, [r0]                                // Clear current thread pointer
 80004a4:	6001      	str	r1, [r0, #0]

    // Return from MemManage_Handler exception
    LDR     r0, =0xE000ED04                         // Load ICSR
 80004a6:	489e      	ldr	r0, [pc, #632]	; (8000720 <_tx_vfp_access+0x24>)
    LDR     r1, =0x10000000                         // Set PENDSVSET bit
 80004a8:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
    STR     r1, [r0]                                // Store ICSR
 80004ac:	6001      	str	r1, [r0, #0]
    DSB                                             // Wait for memory access to complete
 80004ae:	f3bf 8f4f 	dsb	sy
#ifdef TX_PORT_USE_BASEPRI
    MOV     r0, 0                                   // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r0
#else
    CPSIE   i                                       // Enable interrupts
 80004b2:	b662      	cpsie	i
#endif
#ifdef TX_SINGLE_MODE_SECURE
    LDR     lr, =0xFFFFFFFD                         // Exception return to secure
#else
    LDR     lr, =0xFFFFFFBC                         // Exception return to non-secure
 80004b4:	f06f 0e43 	mvn.w	lr, #67	; 0x43
#endif
    BX      lr                                      // Return from exception
 80004b8:	4770      	bx	lr
 80004ba:	bf00      	nop

080004bc <PendSV_Handler>:
#else
    CPSIE   i                                       // Enable interrupts
#endif  /* TX_PORT_USE_BASEPRI */
#endif  /* EXECUTION PROFILE */

    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
 80004bc:	4893      	ldr	r0, [pc, #588]	; (800070c <_tx_vfp_access+0x10>)
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
 80004be:	4a99      	ldr	r2, [pc, #612]	; (8000724 <_tx_vfp_access+0x28>)
    MOV     r3, #0                                  // Build NULL value
 80004c0:	f04f 0300 	mov.w	r3, #0
    LDR     r1, [r0]                                // Pickup current thread pointer
 80004c4:	6801      	ldr	r1, [r0, #0]

    /* Determine if there is a current thread to finish preserving.  */

    CBZ     r1, __tx_ts_new                         // If NULL, skip preservation
 80004c6:	b191      	cbz	r1, 80004ee <__tx_ts_new>

    /* Recover PSP and preserve current thread context.  */

    STR     r3, [r0]                                // Set _tx_thread_current_ptr to NULL
 80004c8:	6003      	str	r3, [r0, #0]
    MRS     r12, PSP                                // Pickup PSP pointer (thread's stack pointer)
 80004ca:	f3ef 8c09 	mrs	ip, PSP
    STMDB   r12!, {r4-r11}                          // Save its remaining registers
 80004ce:	e92c 0ff0 	stmdb	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
#ifdef __ARM_FP
    TST     LR, #0x10                               // Determine if the VFP extended frame is present
 80004d2:	f01e 0f10 	tst.w	lr, #16
    BNE     _skip_vfp_save
 80004d6:	d101      	bne.n	80004dc <_skip_vfp_save>
    VSTMDB  r12!,{s16-s31}                          // Yes, save additional VFP registers
 80004d8:	ed2c 8a10 	vstmdb	ip!, {s16-s31}

080004dc <_skip_vfp_save>:
_skip_vfp_save:
#endif
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
 80004dc:	4c92      	ldr	r4, [pc, #584]	; (8000728 <_tx_vfp_access+0x2c>)
    STMDB   r12!, {LR}                              // Save LR on the stack
 80004de:	f84c ed04 	str.w	lr, [ip, #-4]!
    STR     r12, [r1, #8]                           // Save the thread stack pointer
 80004e2:	f8c1 c008 	str.w	ip, [r1, #8]
_skip_secure_save:
#endif

    /* Determine if time-slice is active. If it isn't, skip time handling processing.  */

    LDR     r5, [r4]                                // Pickup current time-slice
 80004e6:	6825      	ldr	r5, [r4, #0]
    CBZ     r5, __tx_ts_new                         // If not active, skip processing
 80004e8:	b10d      	cbz	r5, 80004ee <__tx_ts_new>

    /* Time-slice is active, save the current thread's time-slice and clear the global time-slice variable.  */

    STR     r5, [r1, #24]                           // Save current time-slice
 80004ea:	618d      	str	r5, [r1, #24]

    /* Clear the global time-slice.  */

    STR     r3, [r4]                                // Clear time-slice
 80004ec:	6023      	str	r3, [r4, #0]

080004ee <__tx_ts_new>:

#ifdef TX_PORT_USE_BASEPRI
    LDR     r1, =TX_PORT_BASEPRI                    // Mask interrupt priorities =< TX_PORT_BASEPRI
    MSR     BASEPRI, r1
#else
    CPSID   i                                       // Disable interrupts
 80004ee:	b672      	cpsid	i
#endif
    LDR     r1, [r2]                                // Is there another thread ready to execute?
 80004f0:	6811      	ldr	r1, [r2, #0]
    CBNZ    r1, __tx_ts_restore                     // Yes, schedule it
 80004f2:	b951      	cbnz	r1, 800050a <__tx_ts_restore>

080004f4 <__tx_ts_wait>:
__tx_ts_wait:
#ifdef TX_PORT_USE_BASEPRI
    LDR     r1, =TX_PORT_BASEPRI                    // Mask interrupt priorities =< TX_PORT_BASEPRI
    MSR     BASEPRI, r1
#else
    CPSID   i                                       // Disable interrupts
 80004f4:	b672      	cpsid	i
#endif
    LDR     r1, [r2]                                // Pickup the next thread to execute pointer
 80004f6:	6811      	ldr	r1, [r2, #0]
    CBNZ    r1, __tx_ts_ready                       // If non-NULL, a new thread is ready!
 80004f8:	b909      	cbnz	r1, 80004fe <__tx_ts_ready>

#ifdef TX_PORT_USE_BASEPRI
    MOV     r4, #0                                  // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r4
#else
    CPSIE   i                                       // Enable interrupts
 80004fa:	b662      	cpsie	i
#endif
    B       __tx_ts_wait                            // Loop to continue waiting
 80004fc:	e7fa      	b.n	80004f4 <__tx_ts_wait>

080004fe <__tx_ts_ready>:

    /* At this point, we have a new thread ready to go. Clear any newly pended PendSV - since we are
       already in the handler!  */

__tx_ts_ready:
    MOV     r7, #0x08000000                         // Build clear PendSV value
 80004fe:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
    MOV     r8, #0xE000E000                         // Build base NVIC address
 8000502:	f04f 28e0 	mov.w	r8, #3758153728	; 0xe000e000
    STR     r7, [r8, #0xD04]                        // Clear any PendSV
 8000506:	f8c8 7d04 	str.w	r7, [r8, #3332]	; 0xd04

0800050a <__tx_ts_restore>:
__tx_ts_restore:

    /* A thread is ready, make the current thread the new thread
       and enable interrupts.  */

    STR     r1, [r0]                                // Setup the current thread pointer to the new thread
 800050a:	6001      	str	r1, [r0, #0]
#ifdef TX_PORT_USE_BASEPRI
    MOV     r4, #0                                  // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r4
#else
    CPSIE   i                                       // Enable interrupts
 800050c:	b662      	cpsie	i
#endif

    /* Increment the thread run count.  */

    LDR     r7, [r1, #4]                            // Pickup the current thread run count
 800050e:	684f      	ldr	r7, [r1, #4]
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
 8000510:	4c85      	ldr	r4, [pc, #532]	; (8000728 <_tx_vfp_access+0x2c>)
    LDR     r5, [r1, #24]                           // Pickup thread's current time-slice
 8000512:	698d      	ldr	r5, [r1, #24]
    ADD     r7, r7, #1                              // Increment the thread run count
 8000514:	f107 0701 	add.w	r7, r7, #1
    STR     r7, [r1, #4]                            // Store the new run count
 8000518:	604f      	str	r7, [r1, #4]

    /* Setup global time-slice with thread's current time-slice.  */

    STR     r5, [r4]                                // Setup global time-slice
 800051a:	6025      	str	r5, [r4, #0]
    POP     {r0,r1}                                 // Restore r1 (and dummy r0)
_skip_secure_restore:
#endif

    /* Restore the thread context and PSP.  */
    LDR     r12, [r1, #12]                          // Get stack start
 800051c:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    MSR     PSPLIM, r12                             // Set stack limit
 8000520:	f38c 880b 	msr	PSPLIM, ip
    LDR     r12, [r1, #8]                           // Pickup thread's stack pointer
 8000524:	f8d1 c008 	ldr.w	ip, [r1, #8]

    MRS     r5, CONTROL                             // Pickup current CONTROL register
 8000528:	f3ef 8514 	mrs	r5, CONTROL
    LDR     r4, [r1, #0x98]                         // Pickup current user mode flag
 800052c:	f8d1 4098 	ldr.w	r4, [r1, #152]	; 0x98
    BIC     r5, r5, #1                              // Clear the UNPRIV bit
 8000530:	f025 0501 	bic.w	r5, r5, #1
    ORR     r4, r4, r5                              // Build new CONTROL register
 8000534:	ea44 0405 	orr.w	r4, r4, r5
    MSR     CONTROL, r4                             // Setup new CONTROL register
 8000538:	f384 8814 	msr	CONTROL, r4

    LDR     r0, =0xE000ED94                         // Build MPU control reg address
 800053c:	487b      	ldr	r0, [pc, #492]	; (800072c <_tx_vfp_access+0x30>)
    MOV     r3, #0                                  // Build disable value
 800053e:	f04f 0300 	mov.w	r3, #0
    STR     r3, [r0]                                // Disable MPU
 8000542:	6003      	str	r3, [r0, #0]
    LDR     r0, [r1, #0x90]                         // Pickup the module instance pointer
 8000544:	f8d1 0090 	ldr.w	r0, [r1, #144]	; 0x90
    CBZ     r0, skip_mpu_setup                      // Is this thread owned by a module? No, skip MPU setup
 8000548:	b1b0      	cbz	r0, 8000578 <skip_mpu_setup>
    LDR     r2, [r0, #0x74]                         // Pickup MPU address of data region
 800054a:	6f42      	ldr	r2, [r0, #116]	; 0x74
    CBZ     r2, skip_mpu_setup                      // Is protection required for this module? No, skip MPU setup
 800054c:	b1a2      	cbz	r2, 8000578 <skip_mpu_setup>

    LDR     r1, =0xE000ED9C                         // MPU_RBAR register address
 800054e:	4978      	ldr	r1, [pc, #480]	; (8000730 <_tx_vfp_access+0x34>)

    // Use alias registers to quickly load MPU
    LDR     r2, =0xE000ED98                         // Get region register
 8000550:	4a78      	ldr	r2, [pc, #480]	; (8000734 <_tx_vfp_access+0x38>)
    STR     r3, [r2]                                // Set region to 0
 8000552:	6013      	str	r3, [r2, #0]
    ADD     r0, r0, #0x64                           // Build address of MPU register start in thread control block
 8000554:	f100 0064 	add.w	r0, r0, #100	; 0x64
    LDM     r0!, {r2-r9}                            // Load first four MPU regions
 8000558:	e8b0 03fc 	ldmia.w	r0!, {r2, r3, r4, r5, r6, r7, r8, r9}
    STM     r1, {r2-r9}                             // Store first four MPU regions
 800055c:	e881 03fc 	stmia.w	r1, {r2, r3, r4, r5, r6, r7, r8, r9}
    MOV     r2, #4                                  // Select region 4
 8000560:	f04f 0204 	mov.w	r2, #4
    LDR     r3, =0xE000ED98                         // Get region register
 8000564:	4b73      	ldr	r3, [pc, #460]	; (8000734 <_tx_vfp_access+0x38>)
    STR     r2, [r3]                                // Set region to 4
 8000566:	601a      	str	r2, [r3, #0]
    LDM     r0, {r2-r9}                             // Load second four MPU regions
 8000568:	e890 03fc 	ldmia.w	r0, {r2, r3, r4, r5, r6, r7, r8, r9}
    STM     r1, {r2-r9}                             // Store second four MPU regions
 800056c:	e881 03fc 	stmia.w	r1, {r2, r3, r4, r5, r6, r7, r8, r9}

08000570 <_tx_enable_mpu>:
_tx_enable_mpu:
    LDR     r0, =0xE000ED94                         // Build MPU control reg address
 8000570:	486e      	ldr	r0, [pc, #440]	; (800072c <_tx_vfp_access+0x30>)
    MOV     r1, #5                                  // Build enable value with background region enabled
 8000572:	f04f 0105 	mov.w	r1, #5
    STR     r1, [r0]                                // Enable MPU
 8000576:	6001      	str	r1, [r0, #0]

08000578 <skip_mpu_setup>:
skip_mpu_setup:
    LDMIA   r12!, {LR}                              // Pickup LR
 8000578:	f85c eb04 	ldr.w	lr, [ip], #4
#ifdef __ARM_FP
    TST     LR, #0x10                               // Determine if the VFP extended frame is present
 800057c:	f01e 0f10 	tst.w	lr, #16
    BNE     _skip_vfp_restore                       // If not, skip VFP restore
 8000580:	d101      	bne.n	8000586 <_skip_vfp_restore>
    VLDMIA  r12!, {s16-s31}                         // Yes, restore additional VFP registers
 8000582:	ecbc 8a10 	vldmia	ip!, {s16-s31}

08000586 <_skip_vfp_restore>:
_skip_vfp_restore:
#endif
    LDMIA   r12!, {r4-r11}                          // Recover thread's registers
 8000586:	e8bc 0ff0 	ldmia.w	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
    MSR     PSP, r12                                // Setup the thread's stack pointer
 800058a:	f38c 8809 	msr	PSP, ip

    BX      lr                                      // Return to thread!
 800058e:	4770      	bx	lr

08000590 <SVC_Handler>:
    .eabi_attribute Tag_ABI_align_preserved, 1
    .global  SVC_Handler
    .thumb_func
.type SVC_Handler, function
SVC_Handler:
    TST     lr, #0x04                               // Determine return stack from EXC_RETURN bit 2
 8000590:	f01e 0f04 	tst.w	lr, #4
    ITE     EQ
 8000594:	bf0c      	ite	eq
    MRSEQ   r0, MSP                                 // Get MSP if return stack is MSP
 8000596:	f3ef 8008 	mrseq	r0, MSP
    MRSNE   r0, PSP                                 // Get PSP if return stack is PSP
 800059a:	f3ef 8009 	mrsne	r0, PSP

    LDR     r1, [r0,#24]                            // Load saved PC from stack
 800059e:	6981      	ldr	r1, [r0, #24]
    LDRB    r2, [r1,#-2]                            // Load SVC number
 80005a0:	f811 2c02 	ldrb.w	r2, [r1, #-2]
    CMP     r2, #2                                  // Is it a secure stack free request?
    BEQ     _tx_svc_secure_free                     // Yes, go there
#endif  // End of ifndef TX_SINGLE_MODE_SECURE, TX_SINGLE_MODE_NON_SECURE


    CMP     r2, #3                                  // Is it the entry into ThreadX?
 80005a4:	2a03      	cmp	r2, #3
    BNE     _tx_thread_user_return                  // No, return to user mode
 80005a6:	d145      	bne.n	8000634 <_tx_thread_user_return>

    /* At this point we have an SVC 3, which means we are entering
       the kernel from a module thread with user mode selected. */

    LDR     r2, =_txm_module_priv                   // Load address of where we should have come from
 80005a8:	4a63      	ldr	r2, [pc, #396]	; (8000738 <_tx_vfp_access+0x3c>)
    CMP     r1, r2                                  // Did we come from user_mode_entry?
 80005aa:	4291      	cmp	r1, r2
    IT      NE                                      // If no (not equal), then...
 80005ac:	bf18      	it	ne
    BXNE    lr                                      // return from where we came.
 80005ae:	4770      	bxne	lr

    LDR     r3, [r0, #20]                           // This is the saved LR
 80005b0:	6943      	ldr	r3, [r0, #20]
    LDR     r1, =_tx_thread_current_ptr             // Build current thread pointer address
 80005b2:	4956      	ldr	r1, [pc, #344]	; (800070c <_tx_vfp_access+0x10>)
    LDR     r2, [r1]                                // Pickup current thread pointer
 80005b4:	680a      	ldr	r2, [r1, #0]
    MOV     r1, #0                                  // Build clear value
 80005b6:	f04f 0100 	mov.w	r1, #0
    STR     r1, [r2, #0x98]                         // Clear the current user mode selection for thread
 80005ba:	f8c2 1098 	str.w	r1, [r2, #152]	; 0x98
    STR     r3, [r2, #0xA0]                         // Save the original LR in thread control block
 80005be:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0

    /* If there is memory protection, use kernel stack */
    LDR     r0, [r2, #0x90]                         // Load the module instance ptr
 80005c2:	f8d2 0090 	ldr.w	r0, [r2, #144]	; 0x90
    LDR     r0, [r0, #0x0C]                         // Load the module property flags
 80005c6:	68c0      	ldr	r0, [r0, #12]
    TST     r0, #2                                  // Check if memory protected
 80005c8:	f010 0f02 	tst.w	r0, #2
    BEQ     _tx_skip_kernel_stack_enter
 80005cc:	d02b      	beq.n	8000626 <_tx_skip_kernel_stack_enter>

    /* Switch to the module thread's kernel stack */
    LDR     r0, [r2, #0xA8]                         // Load the module kernel stack end
 80005ce:	f8d2 00a8 	ldr.w	r0, [r2, #168]	; 0xa8
    LDR     r1, [r2, #0xA4]                         // Load the module kernel stack start
 80005d2:	f8d2 10a4 	ldr.w	r1, [r2, #164]	; 0xa4
    MSR     PSPLIM, r1                              // Set stack limit
 80005d6:	f381 880b 	msr	PSPLIM, r1
#ifndef TXM_MODULE_KERNEL_STACK_MAINTENANCE_DISABLE
    LDR     r3, [r2, #0xAC]                         // Load the module kernel stack size
 80005da:	f8d2 30ac 	ldr.w	r3, [r2, #172]	; 0xac
    STR     r1, [r2, #12]                           // Set stack start
 80005de:	60d1      	str	r1, [r2, #12]
    STR     r0, [r2, #16]                           // Set stack end
 80005e0:	6110      	str	r0, [r2, #16]
    STR     r3, [r2, #20]                           // Set stack size
 80005e2:	6153      	str	r3, [r2, #20]
#endif
    MRS     r3, PSP                                 // Pickup thread stack pointer
 80005e4:	f3ef 8309 	mrs	r3, PSP
    TST     lr, #0x10                               // Test for extended module stack
 80005e8:	f01e 0f10 	tst.w	lr, #16
    ITT     EQ
 80005ec:	bf04      	itt	eq
    ORREQ   r3, r3, #1                              // If so, set LSB in thread stack pointer to indicate extended frame
 80005ee:	f043 0301 	orreq.w	r3, r3, #1
    ORREQ   lr, lr, #0x10                           // Set bit, return with standard frame
 80005f2:	f04e 0e10 	orreq.w	lr, lr, #16
    STR     r3, [r2, #0xB0]                         // Save thread stack pointer
 80005f6:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
    BIC     r3, #1                                  // Clear possibly OR'd bit
 80005fa:	f023 0301 	bic.w	r3, r3, #1
    
    /* Build kernel stack by copying thread stack two registers at a time */
    ADD     r3, r3, #32                             // Start at bottom of hardware stack
 80005fe:	f103 0320 	add.w	r3, r3, #32
    LDMDB   r3!, {r1-r2}
 8000602:	e933 0006 	ldmdb	r3!, {r1, r2}
    STMDB   r0!, {r1-r2}
 8000606:	e920 0006 	stmdb	r0!, {r1, r2}
    LDMDB   r3!, {r1-r2}
 800060a:	e933 0006 	ldmdb	r3!, {r1, r2}
    STMDB   r0!, {r1-r2}
 800060e:	e920 0006 	stmdb	r0!, {r1, r2}
    LDMDB   r3!, {r1-r2}
 8000612:	e933 0006 	ldmdb	r3!, {r1, r2}
    STMDB   r0!, {r1-r2}
 8000616:	e920 0006 	stmdb	r0!, {r1, r2}
    LDMDB   r3!, {r1-r2}
 800061a:	e933 0006 	ldmdb	r3!, {r1, r2}
    STMDB   r0!, {r1-r2}
 800061e:	e920 0006 	stmdb	r0!, {r1, r2}

    MSR     PSP, r0                                 // Set kernel stack pointer
 8000622:	f380 8809 	msr	PSP, r0

08000626 <_tx_skip_kernel_stack_enter>:

_tx_skip_kernel_stack_enter:
    MRS     r0, CONTROL                             // Pickup current CONTROL register
 8000626:	f3ef 8014 	mrs	r0, CONTROL
    BIC     r0, r0, #1                              // Clear the UNPRIV bit
 800062a:	f020 0001 	bic.w	r0, r0, #1
    MSR     CONTROL, r0                             // Setup new CONTROL register
 800062e:	f380 8814 	msr	CONTROL, r0
    BX      lr                                      // Return to thread
 8000632:	4770      	bx	lr

08000634 <_tx_thread_user_return>:


_tx_thread_user_return:
    LDR     r2, =_txm_module_user_mode_exit         // Load address of where we should have come from
 8000634:	4a41      	ldr	r2, [pc, #260]	; (800073c <_tx_vfp_access+0x40>)
    CMP     r1, r2                                  // Did we come from user_mode_exit?
 8000636:	4291      	cmp	r1, r2
    IT      NE                                      // If no (not equal), then...
 8000638:	bf18      	it	ne
    BXNE    lr                                      // return from where we came
 800063a:	4770      	bxne	lr

    LDR     r1, =_tx_thread_current_ptr             // Build current thread pointer address
 800063c:	4933      	ldr	r1, [pc, #204]	; (800070c <_tx_vfp_access+0x10>)
    LDR     r2, [r1]                                // Pickup current thread pointer
 800063e:	680a      	ldr	r2, [r1, #0]
    LDR     r1, [r2, #0x9C]                         // Pick up user mode
 8000640:	f8d2 109c 	ldr.w	r1, [r2, #156]	; 0x9c
    STR     r1, [r2, #0x98]                         // Set the current user mode selection for thread
 8000644:	f8c2 1098 	str.w	r1, [r2, #152]	; 0x98

    /* If there is memory protection, use kernel stack */
    LDR     r0, [r2, #0x90]                         // Load the module instance ptr
 8000648:	f8d2 0090 	ldr.w	r0, [r2, #144]	; 0x90
    LDR     r0, [r0, #0x0C]                         // Load the module property flags
 800064c:	68c0      	ldr	r0, [r0, #12]
    TST     r0, #2                                  // Check if memory protected
 800064e:	f010 0f02 	tst.w	r0, #2
    BEQ     _tx_skip_kernel_stack_exit
 8000652:	d03a      	beq.n	80006ca <_tx_skip_kernel_stack_exit>


    LDR     r0, [r2, #0xB4]                         // Load the module thread stack start
 8000654:	f8d2 00b4 	ldr.w	r0, [r2, #180]	; 0xb4
    MSR     PSPLIM, r0                              // Set stack limit
 8000658:	f380 880b 	msr	PSPLIM, r0
#ifndef TXM_MODULE_KERNEL_STACK_MAINTENANCE_DISABLE
    LDR     r1, [r2, #0xB8]                         // Load the module thread stack end
 800065c:	f8d2 10b8 	ldr.w	r1, [r2, #184]	; 0xb8
    LDR     r3, [r2, #0xBC]                         // Load the module thread stack size
 8000660:	f8d2 30bc 	ldr.w	r3, [r2, #188]	; 0xbc
    STR     r0, [r2, #12]                           // Set stack start
 8000664:	60d0      	str	r0, [r2, #12]
    STR     r1, [r2, #16]                           // Set stack end
 8000666:	6111      	str	r1, [r2, #16]
    STR     r3, [r2, #20]                           // Set stack size
 8000668:	6153      	str	r3, [r2, #20]
#endif

    /* If lazy stacking is pending, check if it can be cleared.
       if(LSPACT && tx_thread_module_stack_start < FPCAR && FPCAR < tx_thread_module_stack_end)
       then clear LSPACT. */
    LDR     r3, =0xE000EF34                         // Address of FPCCR
 800066a:	4b2c      	ldr	r3, [pc, #176]	; (800071c <_tx_vfp_access+0x20>)
    LDR     r3, [r3]                                // Load FPCCR
 800066c:	681b      	ldr	r3, [r3, #0]
    TST     r3, #1                                  // Check if LSPACT is set
 800066e:	f013 0f01 	tst.w	r3, #1
    BEQ     _tx_no_lazy_clear                       // if clear, move on
 8000672:	d00d      	beq.n	8000690 <_tx_no_lazy_clear>
    LDR     r1, =0xE000EF38                         // Address of FPCAR
 8000674:	4932      	ldr	r1, [pc, #200]	; (8000740 <_tx_vfp_access+0x44>)
    LDR     r1, [r1]                                // Load FPCAR
 8000676:	6809      	ldr	r1, [r1, #0]
    LDR     r0, [r2, #0xA4]                         // Load kernel stack start
 8000678:	f8d2 00a4 	ldr.w	r0, [r2, #164]	; 0xa4
    CMP     r1, r0                                  // If FPCAR < start, move on
 800067c:	4281      	cmp	r1, r0
    BLO     _tx_no_lazy_clear
 800067e:	d307      	bcc.n	8000690 <_tx_no_lazy_clear>
    LDR     r0, [r2, #0xA8]                         // Load kernel stack end
 8000680:	f8d2 00a8 	ldr.w	r0, [r2, #168]	; 0xa8
    CMP     r0, r1                                  // If end < FPCAR, move on
 8000684:	4288      	cmp	r0, r1
    BLO     _tx_no_lazy_clear
 8000686:	d303      	bcc.n	8000690 <_tx_no_lazy_clear>
    BIC     r3, #1                                  // Clear LSPACT
 8000688:	f023 0301 	bic.w	r3, r3, #1
    LDR     r1, =0xE000EF34                         // Address of FPCCR
 800068c:	4923      	ldr	r1, [pc, #140]	; (800071c <_tx_vfp_access+0x20>)
    STR     r3, [r1]                                // Save updated FPCCR
 800068e:	600b      	str	r3, [r1, #0]

08000690 <_tx_no_lazy_clear>:
_tx_no_lazy_clear:

    LDR     r0, [r2, #0xB0]                         // Load the module thread stack pointer
 8000690:	f8d2 00b0 	ldr.w	r0, [r2, #176]	; 0xb0
    MRS     r3, PSP                                 // Pickup kernel stack pointer
 8000694:	f3ef 8309 	mrs	r3, PSP
    TST     r0, #1                                  // Is module stack extended?
 8000698:	f010 0f01 	tst.w	r0, #1
    ITTE    NE                                      // If so...
 800069c:	bf1a      	itte	ne
    BICNE   lr, #0x10                               // Clear bit, return with extended frame
 800069e:	f02e 0e10 	bicne.w	lr, lr, #16
    BICNE   r0, #1                                  // Clear bit that indicates extended module frame
 80006a2:	f020 0001 	bicne.w	r0, r0, #1
    ORREQ   lr, lr, #0x10                           // Else set bit, return with standard frame
 80006a6:	f04e 0e10 	orreq.w	lr, lr, #16

    /* Copy kernel hardware stack to module thread stack. */
    LDM     r3!, {r1-r2}                            // Get r0, r1 from kernel stack
 80006aa:	cb06      	ldmia	r3!, {r1, r2}
    STM     r0!, {r1-r2}                            // Insert r0, r1 into thread stack
 80006ac:	c006      	stmia	r0!, {r1, r2}
    LDM     r3!, {r1-r2}                            // Get r2, r3 from kernel stack
 80006ae:	cb06      	ldmia	r3!, {r1, r2}
    STM     r0!, {r1-r2}                            // Insert r2, r3 into thread stack
 80006b0:	c006      	stmia	r0!, {r1, r2}
    LDM     r3!, {r1-r2}                            // Get r12, lr from kernel stack
 80006b2:	cb06      	ldmia	r3!, {r1, r2}
    STM     r0!, {r1-r2}                            // Insert r12, lr into thread stack
 80006b4:	c006      	stmia	r0!, {r1, r2}
    LDM     r3!, {r1-r2}                            // Get pc, xpsr from kernel stack
 80006b6:	cb06      	ldmia	r3!, {r1, r2}
    STM     r0!, {r1-r2}                            // Insert pc, xpsr into thread stack
 80006b8:	c006      	stmia	r0!, {r1, r2}
    SUB     r0, r0, #32                             // Subtract 32 to get back to top of stack
 80006ba:	f1a0 0020 	sub.w	r0, r0, #32
    MSR     PSP, r0                                 // Set thread stack pointer
 80006be:	f380 8809 	msr	PSP, r0

    LDR     r1, =_tx_thread_current_ptr             // Build current thread pointer address
 80006c2:	4912      	ldr	r1, [pc, #72]	; (800070c <_tx_vfp_access+0x10>)
    LDR     r2, [r1]                                // Pickup current thread pointer
 80006c4:	680a      	ldr	r2, [r1, #0]
    LDR     r1, [r2, #0x9C]                         // Pick up user mode
 80006c6:	f8d2 109c 	ldr.w	r1, [r2, #156]	; 0x9c

080006ca <_tx_skip_kernel_stack_exit>:

_tx_skip_kernel_stack_exit:
    MRS     r0, CONTROL                             // Pickup current CONTROL register
 80006ca:	f3ef 8014 	mrs	r0, CONTROL
    ORR     r0, r0, r1                              // OR in the user mode bit
 80006ce:	ea40 0001 	orr.w	r0, r0, r1
    MSR     CONTROL, r0                             // Setup new CONTROL register
 80006d2:	f380 8814 	msr	CONTROL, r0
    BX      lr                                      // Return to thread
 80006d6:	4770      	bx	lr
 80006d8:	f3af 8000 	nop.w
 80006dc:	f3af 8000 	nop.w

080006e0 <_txm_module_manager_user_mode_entry>:
// VOID   _txm_module_manager_user_mode_entry(VOID)
// {
    .global  _txm_module_manager_user_mode_entry
    .thumb_func
_txm_module_manager_user_mode_entry:
    SVC     3                                       // Enter kernel
 80006e0:	df03      	svc	3

080006e2 <_txm_module_priv>:
_txm_module_priv:
    /* At this point, we are out of user mode. The original LR has been saved in the
       thread control block. Simply call the kernel dispatch function. */
    BL      _txm_module_manager_kernel_dispatch
 80006e2:	f013 ff65 	bl	80145b0 <_txm_module_manager_kernel_dispatch>

    /* Pickup the original LR value while still in privileged mode */
    LDR     r2, =_tx_thread_current_ptr             // Build current thread pointer address
 80006e6:	4a09      	ldr	r2, [pc, #36]	; (800070c <_tx_vfp_access+0x10>)
    LDR     r3, [r2]                                // Pickup current thread pointer
 80006e8:	6813      	ldr	r3, [r2, #0]
    LDR     lr, [r3, #0xA0]                         // Pickup saved LR from original call
 80006ea:	f8d3 e0a0 	ldr.w	lr, [r3, #160]	; 0xa0

    SVC     4                                       // Exit kernel and return to user mode
 80006ee:	df04      	svc	4

080006f0 <_txm_module_user_mode_exit>:
_txm_module_user_mode_exit:
    BX      lr                                      // Return to the caller
 80006f0:	4770      	bx	lr
    NOP
 80006f2:	bf00      	nop
    NOP
 80006f4:	bf00      	nop
    NOP
 80006f6:	bf00      	nop
    NOP
 80006f8:	bf00      	nop
 80006fa:	bf00      	nop

080006fc <_tx_vfp_access>:
.type _tx_vfp_access, function
_tx_vfp_access:
#if TX_ENABLE_FPU_SUPPORT
    VMOV.F32 s0, s0                                 // Simply access the VFP
#endif
    BX       lr                                     // Return to caller
 80006fc:	4770      	bx	lr
 80006fe:	0000      	.short	0x0000
    LDR     r2, =_tx_thread_preempt_disable         // Build address of preempt disable flag
 8000700:	2000f054 	.word	0x2000f054
    LDR     r0, =0xE000ED24                         // Build SHCSR address
 8000704:	e000ed24 	.word	0xe000ed24
    LDR     r12,=_txm_module_manager_memory_fault_info  // Pickup fault info struct
 8000708:	2000f6c0 	.word	0x2000f6c0
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
 800070c:	2000efb8 	.word	0x2000efb8
    LDR     r0, =0xE000ED28                         // Build CFSR address
 8000710:	e000ed28 	.word	0xe000ed28
    LDR     r0, =0xE000ED34                         // Build MMFAR address
 8000714:	e000ed34 	.word	0xe000ed34
    LDR     r0, =0xE000ED38                         // Build BFAR address
 8000718:	e000ed38 	.word	0xe000ed38
    LDR     r0, =0xE000EF34                         // Cleanup FPU context: Load FPCCR address
 800071c:	e000ef34 	.word	0xe000ef34
    LDR     r0, =0xE000ED04                         // Load ICSR
 8000720:	e000ed04 	.word	0xe000ed04
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
 8000724:	2000efbc 	.word	0x2000efbc
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
 8000728:	2000f5fc 	.word	0x2000f5fc
    LDR     r0, =0xE000ED94                         // Build MPU control reg address
 800072c:	e000ed94 	.word	0xe000ed94
    LDR     r1, =0xE000ED9C                         // MPU_RBAR register address
 8000730:	e000ed9c 	.word	0xe000ed9c
    LDR     r2, =0xE000ED98                         // Get region register
 8000734:	e000ed98 	.word	0xe000ed98
    LDR     r2, =_txm_module_priv                   // Load address of where we should have come from
 8000738:	080006e2 	.word	0x080006e2
    LDR     r2, =_txm_module_user_mode_exit         // Load address of where we should have come from
 800073c:	080006f0 	.word	0x080006f0
    LDR     r1, =0xE000EF38                         // Address of FPCAR
 8000740:	e000ef38 	.word	0xe000ef38

08000744 <_tx_thread_stack_build>:
                       pc          Initial value for pc
                       xPSR        Initial value for xPSR

    Stack Bottom: (higher memory address)  */

    LDR     r2, [r0, #16]                           // Pickup end of stack area
 8000744:	6902      	ldr	r2, [r0, #16]
    BIC     r2, r2, #0x7                            // Align frame for 8-byte alignment
 8000746:	f022 0207 	bic.w	r2, r2, #7
    SUB     r2, r2, #68                             // Subtract frame size
 800074a:	f1a2 0244 	sub.w	r2, r2, #68	; 0x44
#ifdef TX_SINGLE_MODE_SECURE
    LDR     r3, =0xFFFFFFFD                         // Build initial LR value for secure mode
#else
    LDR     r3, =0xFFFFFFBC                         // Build initial LR value to return to non-secure PSP
 800074e:	f06f 0343 	mvn.w	r3, #67	; 0x43
#endif
    STR     r3, [r2, #0]                            // Save on the stack
 8000752:	6013      	str	r3, [r2, #0]

    /* Actually build the stack frame.  */

    MOV     r3, #0                                  // Build initial register value
 8000754:	f04f 0300 	mov.w	r3, #0
    STR     r3, [r2, #4]                            // Store initial r4
 8000758:	6053      	str	r3, [r2, #4]
    STR     r3, [r2, #8]                            // Store initial r5
 800075a:	6093      	str	r3, [r2, #8]
    STR     r3, [r2, #12]                           // Store initial r6
 800075c:	60d3      	str	r3, [r2, #12]
    STR     r3, [r2, #16]                           // Store initial r7
 800075e:	6113      	str	r3, [r2, #16]
    STR     r3, [r2, #20]                           // Store initial r8
 8000760:	6153      	str	r3, [r2, #20]
    STR     r3, [r2, #24]                           // Store initial r9
 8000762:	6193      	str	r3, [r2, #24]
    STR     r3, [r2, #28]                           // Store initial r10
 8000764:	61d3      	str	r3, [r2, #28]
    STR     r3, [r2, #32]                           // Store initial r11
 8000766:	6213      	str	r3, [r2, #32]

    /* Hardware stack follows.  */

    STR     r3, [r2, #36]                           // Store initial r0
 8000768:	6253      	str	r3, [r2, #36]	; 0x24
    STR     r3, [r2, #40]                           // Store initial r1
 800076a:	6293      	str	r3, [r2, #40]	; 0x28
    STR     r3, [r2, #44]                           // Store initial r2
 800076c:	62d3      	str	r3, [r2, #44]	; 0x2c
    STR     r3, [r2, #48]                           // Store initial r3
 800076e:	6313      	str	r3, [r2, #48]	; 0x30
    STR     r3, [r2, #52]                           // Store initial r12
 8000770:	6353      	str	r3, [r2, #52]	; 0x34
    MOV     r3, #0xFFFFFFFF                         // Poison EXC_RETURN value
 8000772:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    STR     r3, [r2, #56]                           // Store initial lr
 8000776:	6393      	str	r3, [r2, #56]	; 0x38
    STR     r1, [r2, #60]                           // Store initial pc
 8000778:	63d1      	str	r1, [r2, #60]	; 0x3c
    MOV     r3, #0x01000000                         // Only T-bit need be set
 800077a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    STR     r3, [r2, #64]                           // Store initial xPSR
 800077e:	6413      	str	r3, [r2, #64]	; 0x40

    /* Setup stack pointer.  */
    // thread_ptr -> tx_thread_stack_ptr =  r2;

    STR     r2, [r0, #8]                            // Save stack pointer in thread's
 8000780:	6082      	str	r2, [r0, #8]
                                                    //   control block
    BX      lr                                      // Return to caller
 8000782:	4770      	bx	lr
	...

08000790 <_txm_module_manager_thread_stack_build>:
                    pc          Initial value for pc
                    xPSR        Initial value for xPSR

    Stack Bottom: (higher memory address)  */

    LDR     r2, [r0, #16]                       // Pickup end of stack area
 8000790:	6902      	ldr	r2, [r0, #16]
    BIC     r2, r2, #0x7                        // Align frame
 8000792:	f022 0207 	bic.w	r2, r2, #7
    SUB     r2, r2, #68                         // Subtract frame size
 8000796:	f1a2 0244 	sub.w	r2, r2, #68	; 0x44
#ifdef TX_SINGLE_MODE_SECURE
    LDR     r3, =0xFFFFFFFD                     // Build initial LR value for secure mode
#else
    LDR     r3, =0xFFFFFFBC                     // Build initial LR value to return to non-secure PSP
 800079a:	f06f 0343 	mvn.w	r3, #67	; 0x43
#endif
    STR     r3, [r2, #0]                        // Save on the stack
 800079e:	6013      	str	r3, [r2, #0]

    /* Actually build the stack frame.  */

    MOV     r3, #0                              // Build initial register value
 80007a0:	f04f 0300 	mov.w	r3, #0
    STR     r3, [r2, #4]                        // Store initial r4
 80007a4:	6053      	str	r3, [r2, #4]
    STR     r3, [r2, #8]                        // Store initial r5
 80007a6:	6093      	str	r3, [r2, #8]
    STR     r3, [r2, #12]                       // Store initial r6
 80007a8:	60d3      	str	r3, [r2, #12]
    STR     r3, [r2, #16]                       // Store initial r7
 80007aa:	6113      	str	r3, [r2, #16]
    STR     r3, [r2, #20]                       // Store initial r8
 80007ac:	6153      	str	r3, [r2, #20]
    STR     r3, [r2, #28]                       // Store initial r10
 80007ae:	61d3      	str	r3, [r2, #28]
    STR     r3, [r2, #32]                       // Store initial r11
 80007b0:	6213      	str	r3, [r2, #32]

    /* Hardware stack follows.  */

    STR     r0, [r2, #36]                       // Store initial r0, which is the thread control block
 80007b2:	6250      	str	r0, [r2, #36]	; 0x24

    LDR     r3, [r0, #8]                        // Pickup thread entry info pointer,which is in the stack pointer position of the thread control block.
 80007b4:	6883      	ldr	r3, [r0, #8]
                                                //   It was setup in the txm_module_manager_thread_create function. It will be overwritten later in this
                                                //   function with the actual, initial stack pointer.
    STR     r3, [r2, #40]                       // Store initial r1, which is the module entry information.
 80007b6:	6293      	str	r3, [r2, #40]	; 0x28
    LDR     r3, [r3, #8]                        // Pickup data base register from the module information
 80007b8:	689b      	ldr	r3, [r3, #8]
    STR     r3, [r2, #24]                       // Store initial r9 (data base register)
 80007ba:	6193      	str	r3, [r2, #24]
    MOV     r3, #0                              // Clear r3 again
 80007bc:	f04f 0300 	mov.w	r3, #0

    STR     r3, [r2, #44]                       // Store initial r2
 80007c0:	62d3      	str	r3, [r2, #44]	; 0x2c
    STR     r3, [r2, #48]                       // Store initial r3
 80007c2:	6313      	str	r3, [r2, #48]	; 0x30
    STR     r3, [r2, #52]                       // Store initial r12
 80007c4:	6353      	str	r3, [r2, #52]	; 0x34
    MOV     r3, #0xFFFFFFFF                     // Poison EXC_RETURN value
 80007c6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    STR     r3, [r2, #56]                       // Store initial lr
 80007ca:	6393      	str	r3, [r2, #56]	; 0x38
    STR     r1, [r2, #60]                       // Store initial pc
 80007cc:	63d1      	str	r1, [r2, #60]	; 0x3c
    MOV     r3, #0x01000000                     // Only T-bit need be set
 80007ce:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    STR     r3, [r2, #64]                       // Store initial xPSR
 80007d2:	6413      	str	r3, [r2, #64]	; 0x40

    /* Setup stack pointer.  */
    // thread_ptr -> tx_thread_stack_ptr =  r2;

    STR     r2, [r0, #8]                        // Save stack pointer in thread's control block
 80007d4:	6082      	str	r2, [r0, #8]
    BX      lr                                  // Return to caller
 80007d6:	4770      	bx	lr

080007d8 <__aeabi_uldivmod>:
 80007d8:	b953      	cbnz	r3, 80007f0 <__aeabi_uldivmod+0x18>
 80007da:	b94a      	cbnz	r2, 80007f0 <__aeabi_uldivmod+0x18>
 80007dc:	2900      	cmp	r1, #0
 80007de:	bf08      	it	eq
 80007e0:	2800      	cmpeq	r0, #0
 80007e2:	bf1c      	itt	ne
 80007e4:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 80007e8:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 80007ec:	f000 b982 	b.w	8000af4 <__aeabi_idiv0>
 80007f0:	f1ad 0c08 	sub.w	ip, sp, #8
 80007f4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80007f8:	f000 f806 	bl	8000808 <__udivmoddi4>
 80007fc:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000800:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000804:	b004      	add	sp, #16
 8000806:	4770      	bx	lr

08000808 <__udivmoddi4>:
 8000808:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800080c:	9e09      	ldr	r6, [sp, #36]	; 0x24
 800080e:	460d      	mov	r5, r1
 8000810:	4604      	mov	r4, r0
 8000812:	460f      	mov	r7, r1
 8000814:	2b00      	cmp	r3, #0
 8000816:	d146      	bne.n	80008a6 <__udivmoddi4+0x9e>
 8000818:	428a      	cmp	r2, r1
 800081a:	4694      	mov	ip, r2
 800081c:	d95e      	bls.n	80008dc <__udivmoddi4+0xd4>
 800081e:	fab2 f382 	clz	r3, r2
 8000822:	b143      	cbz	r3, 8000836 <__udivmoddi4+0x2e>
 8000824:	fa02 fc03 	lsl.w	ip, r2, r3
 8000828:	f1c3 0220 	rsb	r2, r3, #32
 800082c:	409f      	lsls	r7, r3
 800082e:	409c      	lsls	r4, r3
 8000830:	fa20 f202 	lsr.w	r2, r0, r2
 8000834:	4317      	orrs	r7, r2
 8000836:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
 800083a:	fa1f f58c 	uxth.w	r5, ip
 800083e:	0c22      	lsrs	r2, r4, #16
 8000840:	fbb7 f1fe 	udiv	r1, r7, lr
 8000844:	fb0e 7711 	mls	r7, lr, r1, r7
 8000848:	fb01 f005 	mul.w	r0, r1, r5
 800084c:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 8000850:	4290      	cmp	r0, r2
 8000852:	d908      	bls.n	8000866 <__udivmoddi4+0x5e>
 8000854:	eb1c 0202 	adds.w	r2, ip, r2
 8000858:	f101 37ff 	add.w	r7, r1, #4294967295	; 0xffffffff
 800085c:	d202      	bcs.n	8000864 <__udivmoddi4+0x5c>
 800085e:	4290      	cmp	r0, r2
 8000860:	f200 8134 	bhi.w	8000acc <__udivmoddi4+0x2c4>
 8000864:	4639      	mov	r1, r7
 8000866:	1a12      	subs	r2, r2, r0
 8000868:	b2a4      	uxth	r4, r4
 800086a:	fbb2 f0fe 	udiv	r0, r2, lr
 800086e:	fb0e 2210 	mls	r2, lr, r0, r2
 8000872:	fb00 f505 	mul.w	r5, r0, r5
 8000876:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 800087a:	42a5      	cmp	r5, r4
 800087c:	d908      	bls.n	8000890 <__udivmoddi4+0x88>
 800087e:	eb1c 0404 	adds.w	r4, ip, r4
 8000882:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
 8000886:	d202      	bcs.n	800088e <__udivmoddi4+0x86>
 8000888:	42a5      	cmp	r5, r4
 800088a:	f200 8119 	bhi.w	8000ac0 <__udivmoddi4+0x2b8>
 800088e:	4610      	mov	r0, r2
 8000890:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8000894:	1b64      	subs	r4, r4, r5
 8000896:	2100      	movs	r1, #0
 8000898:	b11e      	cbz	r6, 80008a2 <__udivmoddi4+0x9a>
 800089a:	40dc      	lsrs	r4, r3
 800089c:	2300      	movs	r3, #0
 800089e:	e9c6 4300 	strd	r4, r3, [r6]
 80008a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80008a6:	428b      	cmp	r3, r1
 80008a8:	d908      	bls.n	80008bc <__udivmoddi4+0xb4>
 80008aa:	2e00      	cmp	r6, #0
 80008ac:	f000 80fc 	beq.w	8000aa8 <__udivmoddi4+0x2a0>
 80008b0:	2100      	movs	r1, #0
 80008b2:	e9c6 0500 	strd	r0, r5, [r6]
 80008b6:	4608      	mov	r0, r1
 80008b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80008bc:	fab3 f183 	clz	r1, r3
 80008c0:	2900      	cmp	r1, #0
 80008c2:	d14c      	bne.n	800095e <__udivmoddi4+0x156>
 80008c4:	42ab      	cmp	r3, r5
 80008c6:	f0c0 80f2 	bcc.w	8000aae <__udivmoddi4+0x2a6>
 80008ca:	4282      	cmp	r2, r0
 80008cc:	f240 80ef 	bls.w	8000aae <__udivmoddi4+0x2a6>
 80008d0:	4608      	mov	r0, r1
 80008d2:	2e00      	cmp	r6, #0
 80008d4:	d0e5      	beq.n	80008a2 <__udivmoddi4+0x9a>
 80008d6:	e9c6 4700 	strd	r4, r7, [r6]
 80008da:	e7e2      	b.n	80008a2 <__udivmoddi4+0x9a>
 80008dc:	b902      	cbnz	r2, 80008e0 <__udivmoddi4+0xd8>
 80008de:	deff      	udf	#255	; 0xff
 80008e0:	fab2 f382 	clz	r3, r2
 80008e4:	2b00      	cmp	r3, #0
 80008e6:	f040 809f 	bne.w	8000a28 <__udivmoddi4+0x220>
 80008ea:	1a8a      	subs	r2, r1, r2
 80008ec:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
 80008f0:	fa1f f78c 	uxth.w	r7, ip
 80008f4:	2101      	movs	r1, #1
 80008f6:	fbb2 f5fe 	udiv	r5, r2, lr
 80008fa:	fb0e 2015 	mls	r0, lr, r5, r2
 80008fe:	0c22      	lsrs	r2, r4, #16
 8000900:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8000904:	fb07 f005 	mul.w	r0, r7, r5
 8000908:	4290      	cmp	r0, r2
 800090a:	d90f      	bls.n	800092c <__udivmoddi4+0x124>
 800090c:	eb1c 0202 	adds.w	r2, ip, r2
 8000910:	f105 38ff 	add.w	r8, r5, #4294967295	; 0xffffffff
 8000914:	bf2c      	ite	cs
 8000916:	f04f 0901 	movcs.w	r9, #1
 800091a:	f04f 0900 	movcc.w	r9, #0
 800091e:	4290      	cmp	r0, r2
 8000920:	d903      	bls.n	800092a <__udivmoddi4+0x122>
 8000922:	f1b9 0f00 	cmp.w	r9, #0
 8000926:	f000 80ce 	beq.w	8000ac6 <__udivmoddi4+0x2be>
 800092a:	4645      	mov	r5, r8
 800092c:	1a12      	subs	r2, r2, r0
 800092e:	b2a4      	uxth	r4, r4
 8000930:	fbb2 f0fe 	udiv	r0, r2, lr
 8000934:	fb0e 2210 	mls	r2, lr, r0, r2
 8000938:	fb00 f707 	mul.w	r7, r0, r7
 800093c:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8000940:	42a7      	cmp	r7, r4
 8000942:	d908      	bls.n	8000956 <__udivmoddi4+0x14e>
 8000944:	eb1c 0404 	adds.w	r4, ip, r4
 8000948:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
 800094c:	d202      	bcs.n	8000954 <__udivmoddi4+0x14c>
 800094e:	42a7      	cmp	r7, r4
 8000950:	f200 80b3 	bhi.w	8000aba <__udivmoddi4+0x2b2>
 8000954:	4610      	mov	r0, r2
 8000956:	1be4      	subs	r4, r4, r7
 8000958:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 800095c:	e79c      	b.n	8000898 <__udivmoddi4+0x90>
 800095e:	f1c1 0420 	rsb	r4, r1, #32
 8000962:	408b      	lsls	r3, r1
 8000964:	fa05 fc01 	lsl.w	ip, r5, r1
 8000968:	fa22 f704 	lsr.w	r7, r2, r4
 800096c:	40e5      	lsrs	r5, r4
 800096e:	408a      	lsls	r2, r1
 8000970:	431f      	orrs	r7, r3
 8000972:	fa20 f304 	lsr.w	r3, r0, r4
 8000976:	4088      	lsls	r0, r1
 8000978:	ea4f 4817 	mov.w	r8, r7, lsr #16
 800097c:	ea43 030c 	orr.w	r3, r3, ip
 8000980:	fa1f fc87 	uxth.w	ip, r7
 8000984:	ea4f 4913 	mov.w	r9, r3, lsr #16
 8000988:	fbb5 fef8 	udiv	lr, r5, r8
 800098c:	fb08 551e 	mls	r5, r8, lr, r5
 8000990:	ea49 4505 	orr.w	r5, r9, r5, lsl #16
 8000994:	fb0e f90c 	mul.w	r9, lr, ip
 8000998:	45a9      	cmp	r9, r5
 800099a:	d90e      	bls.n	80009ba <__udivmoddi4+0x1b2>
 800099c:	197d      	adds	r5, r7, r5
 800099e:	f10e 3aff 	add.w	sl, lr, #4294967295	; 0xffffffff
 80009a2:	bf2c      	ite	cs
 80009a4:	f04f 0b01 	movcs.w	fp, #1
 80009a8:	f04f 0b00 	movcc.w	fp, #0
 80009ac:	45a9      	cmp	r9, r5
 80009ae:	d903      	bls.n	80009b8 <__udivmoddi4+0x1b0>
 80009b0:	f1bb 0f00 	cmp.w	fp, #0
 80009b4:	f000 808d 	beq.w	8000ad2 <__udivmoddi4+0x2ca>
 80009b8:	46d6      	mov	lr, sl
 80009ba:	eba5 0509 	sub.w	r5, r5, r9
 80009be:	fa1f f983 	uxth.w	r9, r3
 80009c2:	fbb5 f3f8 	udiv	r3, r5, r8
 80009c6:	fb08 5513 	mls	r5, r8, r3, r5
 80009ca:	fb03 fc0c 	mul.w	ip, r3, ip
 80009ce:	ea49 4505 	orr.w	r5, r9, r5, lsl #16
 80009d2:	45ac      	cmp	ip, r5
 80009d4:	d906      	bls.n	80009e4 <__udivmoddi4+0x1dc>
 80009d6:	197d      	adds	r5, r7, r5
 80009d8:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 80009dc:	d201      	bcs.n	80009e2 <__udivmoddi4+0x1da>
 80009de:	45ac      	cmp	ip, r5
 80009e0:	d87e      	bhi.n	8000ae0 <__udivmoddi4+0x2d8>
 80009e2:	4643      	mov	r3, r8
 80009e4:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 80009e8:	eba5 050c 	sub.w	r5, r5, ip
 80009ec:	fba3 9802 	umull	r9, r8, r3, r2
 80009f0:	4545      	cmp	r5, r8
 80009f2:	46ce      	mov	lr, r9
 80009f4:	46c4      	mov	ip, r8
 80009f6:	d302      	bcc.n	80009fe <__udivmoddi4+0x1f6>
 80009f8:	d106      	bne.n	8000a08 <__udivmoddi4+0x200>
 80009fa:	4548      	cmp	r0, r9
 80009fc:	d204      	bcs.n	8000a08 <__udivmoddi4+0x200>
 80009fe:	3b01      	subs	r3, #1
 8000a00:	ebb9 0e02 	subs.w	lr, r9, r2
 8000a04:	eb68 0c07 	sbc.w	ip, r8, r7
 8000a08:	2e00      	cmp	r6, #0
 8000a0a:	d06f      	beq.n	8000aec <__udivmoddi4+0x2e4>
 8000a0c:	ebb0 020e 	subs.w	r2, r0, lr
 8000a10:	eb65 050c 	sbc.w	r5, r5, ip
 8000a14:	40ca      	lsrs	r2, r1
 8000a16:	fa05 f404 	lsl.w	r4, r5, r4
 8000a1a:	40cd      	lsrs	r5, r1
 8000a1c:	4618      	mov	r0, r3
 8000a1e:	4314      	orrs	r4, r2
 8000a20:	2100      	movs	r1, #0
 8000a22:	e9c6 4500 	strd	r4, r5, [r6]
 8000a26:	e73c      	b.n	80008a2 <__udivmoddi4+0x9a>
 8000a28:	fa02 fc03 	lsl.w	ip, r2, r3
 8000a2c:	f1c3 0220 	rsb	r2, r3, #32
 8000a30:	4099      	lsls	r1, r3
 8000a32:	409c      	lsls	r4, r3
 8000a34:	40d5      	lsrs	r5, r2
 8000a36:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
 8000a3a:	fa20 f202 	lsr.w	r2, r0, r2
 8000a3e:	fa1f f78c 	uxth.w	r7, ip
 8000a42:	fbb5 f0fe 	udiv	r0, r5, lr
 8000a46:	430a      	orrs	r2, r1
 8000a48:	fb0e 5510 	mls	r5, lr, r0, r5
 8000a4c:	0c11      	lsrs	r1, r2, #16
 8000a4e:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
 8000a52:	fb00 f507 	mul.w	r5, r0, r7
 8000a56:	428d      	cmp	r5, r1
 8000a58:	d90e      	bls.n	8000a78 <__udivmoddi4+0x270>
 8000a5a:	eb1c 0101 	adds.w	r1, ip, r1
 8000a5e:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
 8000a62:	bf2c      	ite	cs
 8000a64:	f04f 0901 	movcs.w	r9, #1
 8000a68:	f04f 0900 	movcc.w	r9, #0
 8000a6c:	428d      	cmp	r5, r1
 8000a6e:	d902      	bls.n	8000a76 <__udivmoddi4+0x26e>
 8000a70:	f1b9 0f00 	cmp.w	r9, #0
 8000a74:	d031      	beq.n	8000ada <__udivmoddi4+0x2d2>
 8000a76:	4640      	mov	r0, r8
 8000a78:	1b49      	subs	r1, r1, r5
 8000a7a:	b292      	uxth	r2, r2
 8000a7c:	fbb1 f5fe 	udiv	r5, r1, lr
 8000a80:	fb0e 1115 	mls	r1, lr, r5, r1
 8000a84:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8000a88:	fb05 f107 	mul.w	r1, r5, r7
 8000a8c:	4291      	cmp	r1, r2
 8000a8e:	d907      	bls.n	8000aa0 <__udivmoddi4+0x298>
 8000a90:	eb1c 0202 	adds.w	r2, ip, r2
 8000a94:	f105 38ff 	add.w	r8, r5, #4294967295	; 0xffffffff
 8000a98:	d201      	bcs.n	8000a9e <__udivmoddi4+0x296>
 8000a9a:	4291      	cmp	r1, r2
 8000a9c:	d823      	bhi.n	8000ae6 <__udivmoddi4+0x2de>
 8000a9e:	4645      	mov	r5, r8
 8000aa0:	1a52      	subs	r2, r2, r1
 8000aa2:	ea45 4100 	orr.w	r1, r5, r0, lsl #16
 8000aa6:	e726      	b.n	80008f6 <__udivmoddi4+0xee>
 8000aa8:	4631      	mov	r1, r6
 8000aaa:	4630      	mov	r0, r6
 8000aac:	e6f9      	b.n	80008a2 <__udivmoddi4+0x9a>
 8000aae:	1a84      	subs	r4, r0, r2
 8000ab0:	eb65 0203 	sbc.w	r2, r5, r3
 8000ab4:	2001      	movs	r0, #1
 8000ab6:	4617      	mov	r7, r2
 8000ab8:	e70b      	b.n	80008d2 <__udivmoddi4+0xca>
 8000aba:	4464      	add	r4, ip
 8000abc:	3802      	subs	r0, #2
 8000abe:	e74a      	b.n	8000956 <__udivmoddi4+0x14e>
 8000ac0:	4464      	add	r4, ip
 8000ac2:	3802      	subs	r0, #2
 8000ac4:	e6e4      	b.n	8000890 <__udivmoddi4+0x88>
 8000ac6:	3d02      	subs	r5, #2
 8000ac8:	4462      	add	r2, ip
 8000aca:	e72f      	b.n	800092c <__udivmoddi4+0x124>
 8000acc:	3902      	subs	r1, #2
 8000ace:	4462      	add	r2, ip
 8000ad0:	e6c9      	b.n	8000866 <__udivmoddi4+0x5e>
 8000ad2:	f1ae 0e02 	sub.w	lr, lr, #2
 8000ad6:	443d      	add	r5, r7
 8000ad8:	e76f      	b.n	80009ba <__udivmoddi4+0x1b2>
 8000ada:	3802      	subs	r0, #2
 8000adc:	4461      	add	r1, ip
 8000ade:	e7cb      	b.n	8000a78 <__udivmoddi4+0x270>
 8000ae0:	3b02      	subs	r3, #2
 8000ae2:	443d      	add	r5, r7
 8000ae4:	e77e      	b.n	80009e4 <__udivmoddi4+0x1dc>
 8000ae6:	3d02      	subs	r5, #2
 8000ae8:	4462      	add	r2, ip
 8000aea:	e7d9      	b.n	8000aa0 <__udivmoddi4+0x298>
 8000aec:	4618      	mov	r0, r3
 8000aee:	4631      	mov	r1, r6
 8000af0:	e6d7      	b.n	80008a2 <__udivmoddi4+0x9a>
 8000af2:	bf00      	nop

08000af4 <__aeabi_idiv0>:
 8000af4:	4770      	bx	lr
 8000af6:	bf00      	nop

08000af8 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* set stack pointer */
 8000af8:	f8df d034 	ldr.w	sp, [pc, #52]	; 8000b30 <LoopForever+0x2>
/* Call the clock system initialization function.*/
  bl  SystemInit
 8000afc:	f000 fd50 	bl	80015a0 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8000b00:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8000b02:	e003      	b.n	8000b0c <LoopCopyDataInit>

08000b04 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8000b04:	4b0b      	ldr	r3, [pc, #44]	; (8000b34 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 8000b06:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8000b08:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 8000b0a:	3104      	adds	r1, #4

08000b0c <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 8000b0c:	480a      	ldr	r0, [pc, #40]	; (8000b38 <LoopForever+0xa>)
	ldr	r3, =_edata
 8000b0e:	4b0b      	ldr	r3, [pc, #44]	; (8000b3c <LoopForever+0xe>)
	adds	r2, r0, r1
 8000b10:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8000b12:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8000b14:	d3f6      	bcc.n	8000b04 <CopyDataInit>
	ldr	r2, =_sbss
 8000b16:	4a0a      	ldr	r2, [pc, #40]	; (8000b40 <LoopForever+0x12>)
	b	LoopFillZerobss
 8000b18:	e002      	b.n	8000b20 <LoopFillZerobss>

08000b1a <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 8000b1a:	2300      	movs	r3, #0
	str	r3, [r2], #4
 8000b1c:	f842 3b04 	str.w	r3, [r2], #4

08000b20 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 8000b20:	4b08      	ldr	r3, [pc, #32]	; (8000b44 <LoopForever+0x16>)
	cmp	r2, r3
 8000b22:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8000b24:	d3f9      	bcc.n	8000b1a <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 8000b26:	f015 ff6b 	bl	8016a00 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 8000b2a:	f000 fa09 	bl	8000f40 <main>

08000b2e <LoopForever>:

LoopForever:
    b LoopForever
 8000b2e:	e7fe      	b.n	8000b2e <LoopForever>
  ldr   sp, =_estack    /* set stack pointer */
 8000b30:	20020000 	.word	0x20020000
	ldr	r3, =_sidata
 8000b34:	08017bd8 	.word	0x08017bd8
	ldr	r0, =_sdata
 8000b38:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8000b3c:	2000006c 	.word	0x2000006c
	ldr	r2, =_sbss
 8000b40:	2000006c 	.word	0x2000006c
	ldr	r3, = _ebss
 8000b44:	2000f868 	.word	0x2000f868

08000b48 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8000b48:	e7fe      	b.n	8000b48 <ADC1_IRQHandler>
	...

08000b4c <tx_application_define>:
  * @brief  Define the initial system.
  * @param  first_unused_memory : Pointer to the first unused memory
  * @retval None
  */
VOID tx_application_define(VOID *first_unused_memory)
{
 8000b4c:	b580      	push	{r7, lr}
 8000b4e:	b08c      	sub	sp, #48	; 0x30
 8000b50:	af08      	add	r7, sp, #32
 8000b52:	6078      	str	r0, [r7, #4]
  CHAR *pointer;
  
  if (tx_byte_pool_create(&ModuleManagerBytePool, "Module Manager Byte Pool", tx_byte_pool_buffer, TX_APP_MEM_POOL_SIZE) != TX_SUCCESS)
 8000b54:	2334      	movs	r3, #52	; 0x34
 8000b56:	9300      	str	r3, [sp, #0]
 8000b58:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8000b5c:	4a28      	ldr	r2, [pc, #160]	; (8000c00 <tx_application_define+0xb4>)
 8000b5e:	4929      	ldr	r1, [pc, #164]	; (8000c04 <tx_application_define+0xb8>)
 8000b60:	4829      	ldr	r0, [pc, #164]	; (8000c08 <tx_application_define+0xbc>)
 8000b62:	f00d f9e3 	bl	800df2c <_txe_byte_pool_create>
 8000b66:	4603      	mov	r3, r0
 8000b68:	2b00      	cmp	r3, #0
 8000b6a:	d002      	beq.n	8000b72 <tx_application_define+0x26>
  {
    /* USER CODE BEGIN TX_Byte_Pool_Error */
    Error_Handler();
 8000b6c:	f000 fb4e 	bl	800120c <Error_Handler>
                        pointer, 16 * sizeof(ULONG)) != TX_SUCCESS)
    {
      Error_Handler();
    }
  }
}
 8000b70:	e041      	b.n	8000bf6 <tx_application_define+0xaa>
    if (tx_byte_allocate(&ModuleManagerBytePool, (VOID **) &pointer,
 8000b72:	f107 010c 	add.w	r1, r7, #12
 8000b76:	2300      	movs	r3, #0
 8000b78:	f44f 6240 	mov.w	r2, #3072	; 0xc00
 8000b7c:	4822      	ldr	r0, [pc, #136]	; (8000c08 <tx_application_define+0xbc>)
 8000b7e:	f00d f961 	bl	800de44 <_txe_byte_allocate>
 8000b82:	4603      	mov	r3, r0
 8000b84:	2b00      	cmp	r3, #0
 8000b86:	d001      	beq.n	8000b8c <tx_application_define+0x40>
      Error_Handler();
 8000b88:	f000 fb40 	bl	800120c <Error_Handler>
    if (tx_thread_create(&ModuleManager, "Module Manager Thread", ModuleManager_Entry, 0,
 8000b8c:	68fb      	ldr	r3, [r7, #12]
 8000b8e:	22e8      	movs	r2, #232	; 0xe8
 8000b90:	9206      	str	r2, [sp, #24]
 8000b92:	2201      	movs	r2, #1
 8000b94:	9205      	str	r2, [sp, #20]
 8000b96:	2200      	movs	r2, #0
 8000b98:	9204      	str	r2, [sp, #16]
 8000b9a:	2204      	movs	r2, #4
 8000b9c:	9203      	str	r2, [sp, #12]
 8000b9e:	2204      	movs	r2, #4
 8000ba0:	9202      	str	r2, [sp, #8]
 8000ba2:	f44f 6240 	mov.w	r2, #3072	; 0xc00
 8000ba6:	9201      	str	r2, [sp, #4]
 8000ba8:	9300      	str	r3, [sp, #0]
 8000baa:	2300      	movs	r3, #0
 8000bac:	4a17      	ldr	r2, [pc, #92]	; (8000c0c <tx_application_define+0xc0>)
 8000bae:	4918      	ldr	r1, [pc, #96]	; (8000c10 <tx_application_define+0xc4>)
 8000bb0:	4818      	ldr	r0, [pc, #96]	; (8000c14 <tx_application_define+0xc8>)
 8000bb2:	f00e fa83 	bl	800f0bc <_txe_thread_create>
 8000bb6:	4603      	mov	r3, r0
 8000bb8:	2b00      	cmp	r3, #0
 8000bba:	d001      	beq.n	8000bc0 <tx_application_define+0x74>
      Error_Handler();
 8000bbc:	f000 fb26 	bl	800120c <Error_Handler>
    if (tx_byte_allocate(&ModuleManagerBytePool, (VOID **) &pointer,
 8000bc0:	f107 010c 	add.w	r1, r7, #12
 8000bc4:	2300      	movs	r3, #0
 8000bc6:	2240      	movs	r2, #64	; 0x40
 8000bc8:	480f      	ldr	r0, [pc, #60]	; (8000c08 <tx_application_define+0xbc>)
 8000bca:	f00d f93b 	bl	800de44 <_txe_byte_allocate>
 8000bce:	4603      	mov	r3, r0
 8000bd0:	2b00      	cmp	r3, #0
 8000bd2:	d001      	beq.n	8000bd8 <tx_application_define+0x8c>
      Error_Handler();
 8000bd4:	f000 fb1a 	bl	800120c <Error_Handler>
    if (tx_queue_create(&ResidentQueue, "Resident Queue",TX_1_ULONG,
 8000bd8:	68fb      	ldr	r3, [r7, #12]
 8000bda:	2244      	movs	r2, #68	; 0x44
 8000bdc:	9201      	str	r2, [sp, #4]
 8000bde:	2240      	movs	r2, #64	; 0x40
 8000be0:	9200      	str	r2, [sp, #0]
 8000be2:	2201      	movs	r2, #1
 8000be4:	490c      	ldr	r1, [pc, #48]	; (8000c18 <tx_application_define+0xcc>)
 8000be6:	480d      	ldr	r0, [pc, #52]	; (8000c1c <tx_application_define+0xd0>)
 8000be8:	f00d fe56 	bl	800e898 <_txe_queue_create>
 8000bec:	4603      	mov	r3, r0
 8000bee:	2b00      	cmp	r3, #0
 8000bf0:	d001      	beq.n	8000bf6 <tx_application_define+0xaa>
      Error_Handler();
 8000bf2:	f000 fb0b 	bl	800120c <Error_Handler>
}
 8000bf6:	bf00      	nop
 8000bf8:	3710      	adds	r7, #16
 8000bfa:	46bd      	mov	sp, r7
 8000bfc:	bd80      	pop	{r7, pc}
 8000bfe:	bf00      	nop
 8000c00:	2000c664 	.word	0x2000c664
 8000c04:	080176f0 	.word	0x080176f0
 8000c08:	2000ee64 	.word	0x2000ee64
 8000c0c:	08000c2d 	.word	0x08000c2d
 8000c10:	0801770c 	.word	0x0801770c
 8000c14:	20000088 	.word	0x20000088
 8000c18:	08017724 	.word	0x08017724
 8000c1c:	2000061c 	.word	0x2000061c

08000c20 <MX_ThreadX_Init>:
  * @brief  MX_ThreadX_Init
  * @param  None
  * @retval None
  */
void MX_ThreadX_Init(void)
{
 8000c20:	b580      	push	{r7, lr}
 8000c22:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN  Before_Kernel_Start */

  /* USER CODE END  Before_Kernel_Start */

  tx_kernel_enter();
 8000c24:	f008 f9f2 	bl	800900c <_tx_initialize_kernel_enter>

  /* USER CODE BEGIN  Kernel_Start_Error */

  /* USER CODE END  Kernel_Start_Error */
}
 8000c28:	bf00      	nop
 8000c2a:	bd80      	pop	{r7, pc}

08000c2c <ModuleManager_Entry>:
  * @brief  Module Manager main thread.
  * @param  thread_input: thread id
  * @retval none
  */
VOID ModuleManager_Entry(ULONG thread_input)
{
 8000c2c:	b580      	push	{r7, lr}
 8000c2e:	b096      	sub	sp, #88	; 0x58
 8000c30:	af00      	add	r7, sp, #0
 8000c32:	6078      	str	r0, [r7, #4]
  UINT   status;
  CHAR   p_msg[64];
  ULONG  r_msg = PROCESSING_NOT_STARTED;
 8000c34:	2363      	movs	r3, #99	; 0x63
 8000c36:	613b      	str	r3, [r7, #16]
  ULONG  module_properties;

  /* Initialize the module manager. */
  status = txm_module_manager_initialize((VOID *) module_data_area, MODULE_DATA_SIZE);
 8000c38:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000c3c:	486f      	ldr	r0, [pc, #444]	; (8000dfc <ModuleManager_Entry+0x1d0>)
 8000c3e:	f00f f8b1 	bl	800fda4 <_txm_module_manager_initialize>
 8000c42:	6578      	str	r0, [r7, #84]	; 0x54

  if(status != TX_SUCCESS)
 8000c44:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8000c46:	2b00      	cmp	r3, #0
 8000c48:	d001      	beq.n	8000c4e <ModuleManager_Entry+0x22>
  {
    Error_Handler();
 8000c4a:	f000 fadf 	bl	800120c <Error_Handler>
  }

  /* Create a pool for module objects. */
  status = txm_module_manager_object_pool_create(object_memory, OBJECT_MEM_SIZE);
 8000c4e:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8000c52:	486b      	ldr	r0, [pc, #428]	; (8000e00 <ModuleManager_Entry+0x1d4>)
 8000c54:	f014 fbea 	bl	801542c <_txm_module_manager_object_pool_create>
 8000c58:	6578      	str	r0, [r7, #84]	; 0x54

  if(status != TX_SUCCESS)
 8000c5a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8000c5c:	2b00      	cmp	r3, #0
 8000c5e:	d001      	beq.n	8000c64 <ModuleManager_Entry+0x38>
  {
    Error_Handler();
 8000c60:	f000 fad4 	bl	800120c <Error_Handler>
  }

  /* Register a fault handler. */
  status = txm_module_manager_memory_fault_notify(module_fault_handler);
 8000c64:	4867      	ldr	r0, [pc, #412]	; (8000e04 <ModuleManager_Entry+0x1d8>)
 8000c66:	f014 f879 	bl	8014d5c <_txm_module_manager_memory_fault_notify>
 8000c6a:	6578      	str	r0, [r7, #84]	; 0x54

  if(status != TX_SUCCESS)
 8000c6c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8000c6e:	2b00      	cmp	r3, #0
 8000c70:	d001      	beq.n	8000c76 <ModuleManager_Entry+0x4a>
  {
    Error_Handler();
 8000c72:	f000 facb 	bl	800120c <Error_Handler>
  }

  /* Load the module from the specified address */
  status = txm_module_manager_in_place_load(&ModuleOne, "Module One", (VOID *) MODULE_FLASH_ADDRESS);
 8000c76:	4a64      	ldr	r2, [pc, #400]	; (8000e08 <ModuleManager_Entry+0x1dc>)
 8000c78:	4964      	ldr	r1, [pc, #400]	; (8000e0c <ModuleManager_Entry+0x1e0>)
 8000c7a:	4865      	ldr	r0, [pc, #404]	; (8000e10 <ModuleManager_Entry+0x1e4>)
 8000c7c:	f00f f852 	bl	800fd24 <_txm_module_manager_in_place_load>
 8000c80:	6578      	str	r0, [r7, #84]	; 0x54

  if(status != TX_SUCCESS)
 8000c82:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8000c84:	2b00      	cmp	r3, #0
 8000c86:	d001      	beq.n	8000c8c <ModuleManager_Entry+0x60>
  {
    Error_Handler();
 8000c88:	f000 fac0 	bl	800120c <Error_Handler>
  }

  /* Enable shared memory region for module with read-only access permission. */
  status = txm_module_manager_external_memory_enable(&ModuleOne, (void*)READONLY_REGION, SHARED_MEM_SIZE, TXM_MODULE_ATTRIBUTE_READ_ONLY);
 8000c8c:	2306      	movs	r3, #6
 8000c8e:	22ff      	movs	r2, #255	; 0xff
 8000c90:	4960      	ldr	r1, [pc, #384]	; (8000e14 <ModuleManager_Entry+0x1e8>)
 8000c92:	485f      	ldr	r0, [pc, #380]	; (8000e10 <ModuleManager_Entry+0x1e4>)
 8000c94:	f00e ffc0 	bl	800fc18 <_txm_module_manager_external_memory_enable>
 8000c98:	6578      	str	r0, [r7, #84]	; 0x54

  if(status != TX_SUCCESS)
 8000c9a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8000c9c:	2b00      	cmp	r3, #0
 8000c9e:	d001      	beq.n	8000ca4 <ModuleManager_Entry+0x78>
  {
    Error_Handler();
 8000ca0:	f000 fab4 	bl	800120c <Error_Handler>
  }

  /* Enable shared memory region for module with read and write access permission. */
  status = txm_module_manager_external_memory_enable(&ModuleOne, (void*)READWRITE_REGION, SHARED_MEM_SIZE, TXM_MODULE_ATTRIBUTE_READ_WRITE);
 8000ca4:	2302      	movs	r3, #2
 8000ca6:	22ff      	movs	r2, #255	; 0xff
 8000ca8:	495b      	ldr	r1, [pc, #364]	; (8000e18 <ModuleManager_Entry+0x1ec>)
 8000caa:	4859      	ldr	r0, [pc, #356]	; (8000e10 <ModuleManager_Entry+0x1e4>)
 8000cac:	f00e ffb4 	bl	800fc18 <_txm_module_manager_external_memory_enable>
 8000cb0:	6578      	str	r0, [r7, #84]	; 0x54

  if(status != TX_SUCCESS)
 8000cb2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8000cb4:	2b00      	cmp	r3, #0
 8000cb6:	d001      	beq.n	8000cbc <ModuleManager_Entry+0x90>
  {
    Error_Handler();
 8000cb8:	f000 faa8 	bl	800120c <Error_Handler>
  }

  /* Get module properties. */
  status = txm_module_manager_properties_get(&ModuleOne, &module_properties);
 8000cbc:	f107 030c 	add.w	r3, r7, #12
 8000cc0:	4619      	mov	r1, r3
 8000cc2:	4853      	ldr	r0, [pc, #332]	; (8000e10 <ModuleManager_Entry+0x1e4>)
 8000cc4:	f014 fc3c 	bl	8015540 <_txm_module_manager_properties_get>
 8000cc8:	6578      	str	r0, [r7, #84]	; 0x54

  if(status != TX_SUCCESS)
 8000cca:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8000ccc:	2b00      	cmp	r3, #0
 8000cce:	d001      	beq.n	8000cd4 <ModuleManager_Entry+0xa8>
  {
    Error_Handler();
 8000cd0:	f000 fa9c 	bl	800120c <Error_Handler>
  }

  /* Print loaded module info */
  printf("Module <%s> is loaded from address 0x%08X\n", ModuleOne.txm_module_instance_name, MODULE_FLASH_ADDRESS);
 8000cd4:	4b4e      	ldr	r3, [pc, #312]	; (8000e10 <ModuleManager_Entry+0x1e4>)
 8000cd6:	685b      	ldr	r3, [r3, #4]
 8000cd8:	4a4b      	ldr	r2, [pc, #300]	; (8000e08 <ModuleManager_Entry+0x1dc>)
 8000cda:	4619      	mov	r1, r3
 8000cdc:	484f      	ldr	r0, [pc, #316]	; (8000e1c <ModuleManager_Entry+0x1f0>)
 8000cde:	f015 fe13 	bl	8016908 <iprintf>
  printf("Module code section size: %i bytes, data section size: %i\n", (int)ModuleOne.txm_module_instance_code_size, (int)ModuleOne.txm_module_instance_data_size);
 8000ce2:	4b4b      	ldr	r3, [pc, #300]	; (8000e10 <ModuleManager_Entry+0x1e4>)
 8000ce4:	6a1b      	ldr	r3, [r3, #32]
 8000ce6:	4619      	mov	r1, r3
 8000ce8:	4b49      	ldr	r3, [pc, #292]	; (8000e10 <ModuleManager_Entry+0x1e4>)
 8000cea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000cec:	461a      	mov	r2, r3
 8000cee:	484c      	ldr	r0, [pc, #304]	; (8000e20 <ModuleManager_Entry+0x1f4>)
 8000cf0:	f015 fe0a 	bl	8016908 <iprintf>
  printf("Module Attributes:\n");
 8000cf4:	484b      	ldr	r0, [pc, #300]	; (8000e24 <ModuleManager_Entry+0x1f8>)
 8000cf6:	f015 fe6d 	bl	80169d4 <puts>
  printf("  - Compiled for %s compiler\n", ((module_properties >> 25) == 1)? "STM32CubeIDE (GNU)" : ((module_properties >> 24) == 1)? "ARM KEIL" : "IAR EW");
 8000cfa:	68fb      	ldr	r3, [r7, #12]
 8000cfc:	0e5b      	lsrs	r3, r3, #25
 8000cfe:	2b01      	cmp	r3, #1
 8000d00:	d007      	beq.n	8000d12 <ModuleManager_Entry+0xe6>
 8000d02:	68fb      	ldr	r3, [r7, #12]
 8000d04:	0e1b      	lsrs	r3, r3, #24
 8000d06:	2b01      	cmp	r3, #1
 8000d08:	d101      	bne.n	8000d0e <ModuleManager_Entry+0xe2>
 8000d0a:	4b47      	ldr	r3, [pc, #284]	; (8000e28 <ModuleManager_Entry+0x1fc>)
 8000d0c:	e002      	b.n	8000d14 <ModuleManager_Entry+0xe8>
 8000d0e:	4b47      	ldr	r3, [pc, #284]	; (8000e2c <ModuleManager_Entry+0x200>)
 8000d10:	e000      	b.n	8000d14 <ModuleManager_Entry+0xe8>
 8000d12:	4b47      	ldr	r3, [pc, #284]	; (8000e30 <ModuleManager_Entry+0x204>)
 8000d14:	4619      	mov	r1, r3
 8000d16:	4847      	ldr	r0, [pc, #284]	; (8000e34 <ModuleManager_Entry+0x208>)
 8000d18:	f015 fdf6 	bl	8016908 <iprintf>
  printf("  - Shared/external memory access is %s\n", ((module_properties & 0x04) == 0)? "Disabled" : "Enabled");
 8000d1c:	68fb      	ldr	r3, [r7, #12]
 8000d1e:	f003 0304 	and.w	r3, r3, #4
 8000d22:	2b00      	cmp	r3, #0
 8000d24:	d101      	bne.n	8000d2a <ModuleManager_Entry+0xfe>
 8000d26:	4b44      	ldr	r3, [pc, #272]	; (8000e38 <ModuleManager_Entry+0x20c>)
 8000d28:	e000      	b.n	8000d2c <ModuleManager_Entry+0x100>
 8000d2a:	4b44      	ldr	r3, [pc, #272]	; (8000e3c <ModuleManager_Entry+0x210>)
 8000d2c:	4619      	mov	r1, r3
 8000d2e:	4844      	ldr	r0, [pc, #272]	; (8000e40 <ModuleManager_Entry+0x214>)
 8000d30:	f015 fdea 	bl	8016908 <iprintf>
  printf("  - MPU protection is %s\n", ((module_properties & 0x02) == 0)? "Disabled" : "Enabled");
 8000d34:	68fb      	ldr	r3, [r7, #12]
 8000d36:	f003 0302 	and.w	r3, r3, #2
 8000d3a:	2b00      	cmp	r3, #0
 8000d3c:	d101      	bne.n	8000d42 <ModuleManager_Entry+0x116>
 8000d3e:	4b3e      	ldr	r3, [pc, #248]	; (8000e38 <ModuleManager_Entry+0x20c>)
 8000d40:	e000      	b.n	8000d44 <ModuleManager_Entry+0x118>
 8000d42:	4b3e      	ldr	r3, [pc, #248]	; (8000e3c <ModuleManager_Entry+0x210>)
 8000d44:	4619      	mov	r1, r3
 8000d46:	483f      	ldr	r0, [pc, #252]	; (8000e44 <ModuleManager_Entry+0x218>)
 8000d48:	f015 fdde 	bl	8016908 <iprintf>
  printf("  - %s mode execution is enabled for the module\n\n", ((module_properties & 0x01) == 0)? "Privileged" : "User");
 8000d4c:	68fb      	ldr	r3, [r7, #12]
 8000d4e:	f003 0301 	and.w	r3, r3, #1
 8000d52:	2b00      	cmp	r3, #0
 8000d54:	d101      	bne.n	8000d5a <ModuleManager_Entry+0x12e>
 8000d56:	4b3c      	ldr	r3, [pc, #240]	; (8000e48 <ModuleManager_Entry+0x21c>)
 8000d58:	e000      	b.n	8000d5c <ModuleManager_Entry+0x130>
 8000d5a:	4b3c      	ldr	r3, [pc, #240]	; (8000e4c <ModuleManager_Entry+0x220>)
 8000d5c:	4619      	mov	r1, r3
 8000d5e:	483c      	ldr	r0, [pc, #240]	; (8000e50 <ModuleManager_Entry+0x224>)
 8000d60:	f015 fdd2 	bl	8016908 <iprintf>


  /* Start the modules. */
  status = txm_module_manager_start(&ModuleOne);
 8000d64:	482a      	ldr	r0, [pc, #168]	; (8000e10 <ModuleManager_Entry+0x1e4>)
 8000d66:	f014 fccb 	bl	8015700 <_txm_module_manager_start>
 8000d6a:	6578      	str	r0, [r7, #84]	; 0x54

  if(status != TX_SUCCESS)
 8000d6c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8000d6e:	2b00      	cmp	r3, #0
 8000d70:	d001      	beq.n	8000d76 <ModuleManager_Entry+0x14a>
  {
    Error_Handler();
 8000d72:	f000 fa4b 	bl	800120c <Error_Handler>
  }

  printf("Module execution is started\n");
 8000d76:	4837      	ldr	r0, [pc, #220]	; (8000e54 <ModuleManager_Entry+0x228>)
 8000d78:	f015 fe2c 	bl	80169d4 <puts>

  /* Get Module's progress messages */
  while(r_msg != PROCESSING_FINISHED)
 8000d7c:	e021      	b.n	8000dc2 <ModuleManager_Entry+0x196>
  {
    if(tx_queue_receive(&ResidentQueue, &r_msg, 10) == TX_SUCCESS)
 8000d7e:	f107 0310 	add.w	r3, r7, #16
 8000d82:	220a      	movs	r2, #10
 8000d84:	4619      	mov	r1, r3
 8000d86:	4834      	ldr	r0, [pc, #208]	; (8000e58 <ModuleManager_Entry+0x22c>)
 8000d88:	f00d ff24 	bl	800ebd4 <_txe_queue_receive>
 8000d8c:	4603      	mov	r3, r0
 8000d8e:	2b00      	cmp	r3, #0
 8000d90:	d117      	bne.n	8000dc2 <ModuleManager_Entry+0x196>
    {
      /* Convert the message to a user friendly string */
      pretty_msg(p_msg, r_msg);
 8000d92:	693a      	ldr	r2, [r7, #16]
 8000d94:	f107 0314 	add.w	r3, r7, #20
 8000d98:	4611      	mov	r1, r2
 8000d9a:	4618      	mov	r0, r3
 8000d9c:	f000 f878 	bl	8000e90 <pretty_msg>

      printf("Module is executing: %s\n", p_msg);
 8000da0:	f107 0314 	add.w	r3, r7, #20
 8000da4:	4619      	mov	r1, r3
 8000da6:	482d      	ldr	r0, [pc, #180]	; (8000e5c <ModuleManager_Entry+0x230>)
 8000da8:	f015 fdae 	bl	8016908 <iprintf>

      /* Check if the last executed operation resulted in memory violation */
      if(memory_faults)
 8000dac:	4b2c      	ldr	r3, [pc, #176]	; (8000e60 <ModuleManager_Entry+0x234>)
 8000dae:	681b      	ldr	r3, [r3, #0]
 8000db0:	2b00      	cmp	r3, #0
 8000db2:	d006      	beq.n	8000dc2 <ModuleManager_Entry+0x196>
      {
        /* A memory access fault just occurred */
        printf("A memory fault occurred while module executed: %s\n", p_msg);
 8000db4:	f107 0314 	add.w	r3, r7, #20
 8000db8:	4619      	mov	r1, r3
 8000dba:	482a      	ldr	r0, [pc, #168]	; (8000e64 <ModuleManager_Entry+0x238>)
 8000dbc:	f015 fda4 	bl	8016908 <iprintf>
        break;
 8000dc0:	e002      	b.n	8000dc8 <ModuleManager_Entry+0x19c>
  while(r_msg != PROCESSING_FINISHED)
 8000dc2:	693b      	ldr	r3, [r7, #16]
 8000dc4:	2b2c      	cmp	r3, #44	; 0x2c
 8000dc6:	d1da      	bne.n	8000d7e <ModuleManager_Entry+0x152>
      }
    }
  }

  /* Stop the modules. */
  status = txm_module_manager_stop(&ModuleOne);
 8000dc8:	4811      	ldr	r0, [pc, #68]	; (8000e10 <ModuleManager_Entry+0x1e4>)
 8000dca:	f014 fd87 	bl	80158dc <_txm_module_manager_stop>
 8000dce:	6578      	str	r0, [r7, #84]	; 0x54

  if(status != TX_SUCCESS)
 8000dd0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8000dd2:	2b00      	cmp	r3, #0
 8000dd4:	d001      	beq.n	8000dda <ModuleManager_Entry+0x1ae>
  {
    Error_Handler();
 8000dd6:	f000 fa19 	bl	800120c <Error_Handler>
  }

  /* Unload the modules. */
  status = txm_module_manager_unload(&ModuleOne);
 8000dda:	480d      	ldr	r0, [pc, #52]	; (8000e10 <ModuleManager_Entry+0x1e4>)
 8000ddc:	f015 fb84 	bl	80164e8 <_txm_module_manager_unload>
 8000de0:	6578      	str	r0, [r7, #84]	; 0x54

  if(status != TX_SUCCESS)
 8000de2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8000de4:	2b00      	cmp	r3, #0
 8000de6:	d001      	beq.n	8000dec <ModuleManager_Entry+0x1c0>
  {
    Error_Handler();
 8000de8:	f000 fa10 	bl	800120c <Error_Handler>
  }

  /* Toggle green LED to indicated success of operations */
  while(1) {
    HAL_GPIO_TogglePin(LED_GREEN_Port, LED_GREEN);
 8000dec:	2180      	movs	r1, #128	; 0x80
 8000dee:	481e      	ldr	r0, [pc, #120]	; (8000e68 <ModuleManager_Entry+0x23c>)
 8000df0:	f000 ff50 	bl	8001c94 <HAL_GPIO_TogglePin>
    tx_thread_sleep(50);
 8000df4:	2032      	movs	r0, #50	; 0x32
 8000df6:	f00b f9ef 	bl	800c1d8 <_tx_thread_sleep>
    HAL_GPIO_TogglePin(LED_GREEN_Port, LED_GREEN);
 8000dfa:	e7f7      	b.n	8000dec <ModuleManager_Entry+0x1c0>
 8000dfc:	20000660 	.word	0x20000660
 8000e00:	20008660 	.word	0x20008660
 8000e04:	08000e6d 	.word	0x08000e6d
 8000e08:	08020000 	.word	0x08020000
 8000e0c:	08017734 	.word	0x08017734
 8000e10:	20000170 	.word	0x20000170
 8000e14:	20010000 	.word	0x20010000
 8000e18:	20010100 	.word	0x20010100
 8000e1c:	08017740 	.word	0x08017740
 8000e20:	0801776c 	.word	0x0801776c
 8000e24:	080177a8 	.word	0x080177a8
 8000e28:	080177bc 	.word	0x080177bc
 8000e2c:	080177c8 	.word	0x080177c8
 8000e30:	080177d0 	.word	0x080177d0
 8000e34:	080177e4 	.word	0x080177e4
 8000e38:	08017804 	.word	0x08017804
 8000e3c:	08017810 	.word	0x08017810
 8000e40:	08017818 	.word	0x08017818
 8000e44:	08017844 	.word	0x08017844
 8000e48:	08017860 	.word	0x08017860
 8000e4c:	0801786c 	.word	0x0801786c
 8000e50:	08017874 	.word	0x08017874
 8000e54:	080178a8 	.word	0x080178a8
 8000e58:	2000061c 	.word	0x2000061c
 8000e5c:	080178c4 	.word	0x080178c4
 8000e60:	2000c660 	.word	0x2000c660
 8000e64:	080178e0 	.word	0x080178e0
 8000e68:	42020800 	.word	0x42020800

08000e6c <module_fault_handler>:
  }
}

VOID module_fault_handler(TX_THREAD *thread, TXM_MODULE_INSTANCE *module)
{
 8000e6c:	b480      	push	{r7}
 8000e6e:	b083      	sub	sp, #12
 8000e70:	af00      	add	r7, sp, #0
 8000e72:	6078      	str	r0, [r7, #4]
 8000e74:	6039      	str	r1, [r7, #0]
    /* Just increment the fault counter.   */
    memory_faults++;
 8000e76:	4b05      	ldr	r3, [pc, #20]	; (8000e8c <module_fault_handler+0x20>)
 8000e78:	681b      	ldr	r3, [r3, #0]
 8000e7a:	3301      	adds	r3, #1
 8000e7c:	4a03      	ldr	r2, [pc, #12]	; (8000e8c <module_fault_handler+0x20>)
 8000e7e:	6013      	str	r3, [r2, #0]
}
 8000e80:	bf00      	nop
 8000e82:	370c      	adds	r7, #12
 8000e84:	46bd      	mov	sp, r7
 8000e86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000e8a:	4770      	bx	lr
 8000e8c:	2000c660 	.word	0x2000c660

08000e90 <pretty_msg>:

VOID pretty_msg(char *p_msg, ULONG r_msg)
{
 8000e90:	b580      	push	{r7, lr}
 8000e92:	b082      	sub	sp, #8
 8000e94:	af00      	add	r7, sp, #0
 8000e96:	6078      	str	r0, [r7, #4]
 8000e98:	6039      	str	r1, [r7, #0]
  memset(p_msg, 0, 64);
 8000e9a:	2240      	movs	r2, #64	; 0x40
 8000e9c:	2100      	movs	r1, #0
 8000e9e:	6878      	ldr	r0, [r7, #4]
 8000ea0:	f015 fda0 	bl	80169e4 <memset>

  switch(r_msg)
 8000ea4:	683b      	ldr	r3, [r7, #0]
 8000ea6:	2b58      	cmp	r3, #88	; 0x58
 8000ea8:	d015      	beq.n	8000ed6 <pretty_msg+0x46>
 8000eaa:	683b      	ldr	r3, [r7, #0]
 8000eac:	2b58      	cmp	r3, #88	; 0x58
 8000eae:	d830      	bhi.n	8000f12 <pretty_msg+0x82>
 8000eb0:	683b      	ldr	r3, [r7, #0]
 8000eb2:	2b4d      	cmp	r3, #77	; 0x4d
 8000eb4:	d015      	beq.n	8000ee2 <pretty_msg+0x52>
 8000eb6:	683b      	ldr	r3, [r7, #0]
 8000eb8:	2b4d      	cmp	r3, #77	; 0x4d
 8000eba:	d82a      	bhi.n	8000f12 <pretty_msg+0x82>
 8000ebc:	683b      	ldr	r3, [r7, #0]
 8000ebe:	2b42      	cmp	r3, #66	; 0x42
 8000ec0:	d015      	beq.n	8000eee <pretty_msg+0x5e>
 8000ec2:	683b      	ldr	r3, [r7, #0]
 8000ec4:	2b42      	cmp	r3, #66	; 0x42
 8000ec6:	d824      	bhi.n	8000f12 <pretty_msg+0x82>
 8000ec8:	683b      	ldr	r3, [r7, #0]
 8000eca:	2b2c      	cmp	r3, #44	; 0x2c
 8000ecc:	d01b      	beq.n	8000f06 <pretty_msg+0x76>
 8000ece:	683b      	ldr	r3, [r7, #0]
 8000ed0:	2b37      	cmp	r3, #55	; 0x37
 8000ed2:	d012      	beq.n	8000efa <pretty_msg+0x6a>
 8000ed4:	e01d      	b.n	8000f12 <pretty_msg+0x82>
  {
  case WRITING_TO_READWRITE:
    memcpy(p_msg, "Writing to ReadWrite Region", 27);
 8000ed6:	221b      	movs	r2, #27
 8000ed8:	4913      	ldr	r1, [pc, #76]	; (8000f28 <pretty_msg+0x98>)
 8000eda:	6878      	ldr	r0, [r7, #4]
 8000edc:	f015 fdb6 	bl	8016a4c <memcpy>
    break;
 8000ee0:	e01d      	b.n	8000f1e <pretty_msg+0x8e>
  case WRITING_TO_READONLY:
    memcpy(p_msg, "Writing to ReadOnly Region", 26);
 8000ee2:	221a      	movs	r2, #26
 8000ee4:	4911      	ldr	r1, [pc, #68]	; (8000f2c <pretty_msg+0x9c>)
 8000ee6:	6878      	ldr	r0, [r7, #4]
 8000ee8:	f015 fdb0 	bl	8016a4c <memcpy>
    break;
 8000eec:	e017      	b.n	8000f1e <pretty_msg+0x8e>
  case READING_FROM_READWRITE:
    memcpy(p_msg, "Reading from ReadWrite Region", 29);
 8000eee:	221d      	movs	r2, #29
 8000ef0:	490f      	ldr	r1, [pc, #60]	; (8000f30 <pretty_msg+0xa0>)
 8000ef2:	6878      	ldr	r0, [r7, #4]
 8000ef4:	f015 fdaa 	bl	8016a4c <memcpy>
    break;
 8000ef8:	e011      	b.n	8000f1e <pretty_msg+0x8e>
  case READING_FROM_READONLY:
    memcpy(p_msg, "Reading from ReadOnly Region", 28);
 8000efa:	221c      	movs	r2, #28
 8000efc:	490d      	ldr	r1, [pc, #52]	; (8000f34 <pretty_msg+0xa4>)
 8000efe:	6878      	ldr	r0, [r7, #4]
 8000f00:	f015 fda4 	bl	8016a4c <memcpy>
    break;
 8000f04:	e00b      	b.n	8000f1e <pretty_msg+0x8e>
  case PROCESSING_FINISHED:
    memcpy(p_msg, "All operations were done", 24);
 8000f06:	2218      	movs	r2, #24
 8000f08:	490b      	ldr	r1, [pc, #44]	; (8000f38 <pretty_msg+0xa8>)
 8000f0a:	6878      	ldr	r0, [r7, #4]
 8000f0c:	f015 fd9e 	bl	8016a4c <memcpy>
    break;
 8000f10:	e005      	b.n	8000f1e <pretty_msg+0x8e>
  default:
    memcpy(p_msg, "Invalid option", 14);
 8000f12:	220e      	movs	r2, #14
 8000f14:	4909      	ldr	r1, [pc, #36]	; (8000f3c <pretty_msg+0xac>)
 8000f16:	6878      	ldr	r0, [r7, #4]
 8000f18:	f015 fd98 	bl	8016a4c <memcpy>
    break;
 8000f1c:	bf00      	nop
  }
}
 8000f1e:	bf00      	nop
 8000f20:	3708      	adds	r7, #8
 8000f22:	46bd      	mov	sp, r7
 8000f24:	bd80      	pop	{r7, pc}
 8000f26:	bf00      	nop
 8000f28:	08017914 	.word	0x08017914
 8000f2c:	08017930 	.word	0x08017930
 8000f30:	0801794c 	.word	0x0801794c
 8000f34:	0801796c 	.word	0x0801796c
 8000f38:	0801798c 	.word	0x0801798c
 8000f3c:	080179a8 	.word	0x080179a8

08000f40 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8000f40:	b580      	push	{r7, lr}
 8000f42:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8000f44:	f000 fb64 	bl	8001610 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 8000f48:	f000 f80b 	bl	8000f62 <SystemClock_Config>

  /* Configure the System Power */
  SystemPower_Config();
 8000f4c:	f000 f865 	bl	800101a <SystemPower_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8000f50:	f000 f8d0 	bl	80010f4 <MX_GPIO_Init>
  MX_ICACHE_Init();
 8000f54:	f000 f86f 	bl	8001036 <MX_ICACHE_Init>
  MX_USART1_UART_Init();
 8000f58:	f000 f880 	bl	800105c <MX_USART1_UART_Init>
  /* USER CODE BEGIN 2 */

  /* USER CODE END 2 */

  MX_ThreadX_Init();
 8000f5c:	f7ff fe60 	bl	8000c20 <MX_ThreadX_Init>
  /* We should never get here as control is now taken by the scheduler */
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 8000f60:	e7fe      	b.n	8000f60 <main+0x20>

08000f62 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8000f62:	b580      	push	{r7, lr}
 8000f64:	b09e      	sub	sp, #120	; 0x78
 8000f66:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8000f68:	f107 0318 	add.w	r3, r7, #24
 8000f6c:	2260      	movs	r2, #96	; 0x60
 8000f6e:	2100      	movs	r1, #0
 8000f70:	4618      	mov	r0, r3
 8000f72:	f015 fd37 	bl	80169e4 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000f76:	463b      	mov	r3, r7
 8000f78:	2200      	movs	r2, #0
 8000f7a:	601a      	str	r2, [r3, #0]
 8000f7c:	605a      	str	r2, [r3, #4]
 8000f7e:	609a      	str	r2, [r3, #8]
 8000f80:	60da      	str	r2, [r3, #12]
 8000f82:	611a      	str	r2, [r3, #16]
 8000f84:	615a      	str	r2, [r3, #20]

  /** Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
 8000f86:	f44f 3040 	mov.w	r0, #196608	; 0x30000
 8000f8a:	f000 fecd 	bl	8001d28 <HAL_PWREx_ControlVoltageScaling>
 8000f8e:	4603      	mov	r3, r0
 8000f90:	2b00      	cmp	r3, #0
 8000f92:	d001      	beq.n	8000f98 <SystemClock_Config+0x36>
  {
    Error_Handler();
 8000f94:	f000 f93a 	bl	800120c <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
 8000f98:	2310      	movs	r3, #16
 8000f9a:	61bb      	str	r3, [r7, #24]
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 8000f9c:	2301      	movs	r3, #1
 8000f9e:	637b      	str	r3, [r7, #52]	; 0x34
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 8000fa0:	2310      	movs	r3, #16
 8000fa2:	63bb      	str	r3, [r7, #56]	; 0x38
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_4;
 8000fa4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000fa8:	63fb      	str	r3, [r7, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000faa:	2302      	movs	r3, #2
 8000fac:	653b      	str	r3, [r7, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
 8000fae:	2301      	movs	r3, #1
 8000fb0:	657b      	str	r3, [r7, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLMBOOST = RCC_PLLMBOOST_DIV1;
 8000fb2:	2300      	movs	r3, #0
 8000fb4:	65fb      	str	r3, [r7, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLM = 1;
 8000fb6:	2301      	movs	r3, #1
 8000fb8:	65bb      	str	r3, [r7, #88]	; 0x58
  RCC_OscInitStruct.PLL.PLLN = 80;
 8000fba:	2350      	movs	r3, #80	; 0x50
 8000fbc:	663b      	str	r3, [r7, #96]	; 0x60
  RCC_OscInitStruct.PLL.PLLP = 2;
 8000fbe:	2302      	movs	r3, #2
 8000fc0:	667b      	str	r3, [r7, #100]	; 0x64
  RCC_OscInitStruct.PLL.PLLQ = 2;
 8000fc2:	2302      	movs	r3, #2
 8000fc4:	66bb      	str	r3, [r7, #104]	; 0x68
  RCC_OscInitStruct.PLL.PLLR = 2;
 8000fc6:	2302      	movs	r3, #2
 8000fc8:	66fb      	str	r3, [r7, #108]	; 0x6c
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLLVCIRANGE_0;
 8000fca:	2300      	movs	r3, #0
 8000fcc:	673b      	str	r3, [r7, #112]	; 0x70
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
 8000fce:	2300      	movs	r3, #0
 8000fd0:	677b      	str	r3, [r7, #116]	; 0x74
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000fd2:	f107 0318 	add.w	r3, r7, #24
 8000fd6:	4618      	mov	r0, r3
 8000fd8:	f000 ff92 	bl	8001f00 <HAL_RCC_OscConfig>
 8000fdc:	4603      	mov	r3, r0
 8000fde:	2b00      	cmp	r3, #0
 8000fe0:	d001      	beq.n	8000fe6 <SystemClock_Config+0x84>
  {
    Error_Handler();
 8000fe2:	f000 f913 	bl	800120c <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000fe6:	231f      	movs	r3, #31
 8000fe8:	603b      	str	r3, [r7, #0]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_PCLK3;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000fea:	2303      	movs	r3, #3
 8000fec:	607b      	str	r3, [r7, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000fee:	2300      	movs	r3, #0
 8000ff0:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8000ff2:	2300      	movs	r3, #0
 8000ff4:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000ff6:	2300      	movs	r3, #0
 8000ff8:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB3CLKDivider = RCC_HCLK_DIV1;
 8000ffa:	2300      	movs	r3, #0
 8000ffc:	617b      	str	r3, [r7, #20]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8000ffe:	463b      	mov	r3, r7
 8001000:	2104      	movs	r1, #4
 8001002:	4618      	mov	r0, r3
 8001004:	f001 fe58 	bl	8002cb8 <HAL_RCC_ClockConfig>
 8001008:	4603      	mov	r3, r0
 800100a:	2b00      	cmp	r3, #0
 800100c:	d001      	beq.n	8001012 <SystemClock_Config+0xb0>
  {
    Error_Handler();
 800100e:	f000 f8fd 	bl	800120c <Error_Handler>
  }
}
 8001012:	bf00      	nop
 8001014:	3778      	adds	r7, #120	; 0x78
 8001016:	46bd      	mov	sp, r7
 8001018:	bd80      	pop	{r7, pc}

0800101a <SystemPower_Config>:
  * @brief Power Configuration
  * @retval None
  */

void SystemPower_Config(void)
{
 800101a:	b580      	push	{r7, lr}
 800101c:	af00      	add	r7, sp, #0
  /** Disable the internal Pull-Up in Dead Battery pins of UCPD peripheral
  */
  HAL_PWREx_DisableUCPDDeadBattery();
 800101e:	f000 ff5f 	bl	8001ee0 <HAL_PWREx_DisableUCPDDeadBattery>

  /** Switch to SMPS regulator instead of LDO
  */
  if (HAL_PWREx_ConfigSupply(PWR_SMPS_SUPPLY) != HAL_OK)
 8001022:	2002      	movs	r0, #2
 8001024:	f000 ff0c 	bl	8001e40 <HAL_PWREx_ConfigSupply>
 8001028:	4603      	mov	r3, r0
 800102a:	2b00      	cmp	r3, #0
 800102c:	d001      	beq.n	8001032 <SystemPower_Config+0x18>
  {
    Error_Handler();
 800102e:	f000 f8ed 	bl	800120c <Error_Handler>
  }
}
 8001032:	bf00      	nop
 8001034:	bd80      	pop	{r7, pc}

08001036 <MX_ICACHE_Init>:
  * @brief ICACHE Initialization Function
  * @param None
  * @retval None
  */
static void MX_ICACHE_Init(void)
{
 8001036:	b580      	push	{r7, lr}
 8001038:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN ICACHE_Init 1 */

  /* USER CODE END ICACHE_Init 1 */
  /** Enable instruction cache in 1-way (direct mapped cache)
  */
  if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
 800103a:	2000      	movs	r0, #0
 800103c:	f000 fe44 	bl	8001cc8 <HAL_ICACHE_ConfigAssociativityMode>
 8001040:	4603      	mov	r3, r0
 8001042:	2b00      	cmp	r3, #0
 8001044:	d001      	beq.n	800104a <MX_ICACHE_Init+0x14>
  {
    Error_Handler();
 8001046:	f000 f8e1 	bl	800120c <Error_Handler>
  }
  if (HAL_ICACHE_Enable() != HAL_OK)
 800104a:	f000 fe5d 	bl	8001d08 <HAL_ICACHE_Enable>
 800104e:	4603      	mov	r3, r0
 8001050:	2b00      	cmp	r3, #0
 8001052:	d001      	beq.n	8001058 <MX_ICACHE_Init+0x22>
  {
    Error_Handler();
 8001054:	f000 f8da 	bl	800120c <Error_Handler>
  }
  /* USER CODE BEGIN ICACHE_Init 2 */

  /* USER CODE END ICACHE_Init 2 */

}
 8001058:	bf00      	nop
 800105a:	bd80      	pop	{r7, pc}

0800105c <MX_USART1_UART_Init>:
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{
 800105c:	b580      	push	{r7, lr}
 800105e:	af00      	add	r7, sp, #0
  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
 8001060:	4b22      	ldr	r3, [pc, #136]	; (80010ec <MX_USART1_UART_Init+0x90>)
 8001062:	4a23      	ldr	r2, [pc, #140]	; (80010f0 <MX_USART1_UART_Init+0x94>)
 8001064:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
 8001066:	4b21      	ldr	r3, [pc, #132]	; (80010ec <MX_USART1_UART_Init+0x90>)
 8001068:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 800106c:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 800106e:	4b1f      	ldr	r3, [pc, #124]	; (80010ec <MX_USART1_UART_Init+0x90>)
 8001070:	2200      	movs	r2, #0
 8001072:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 8001074:	4b1d      	ldr	r3, [pc, #116]	; (80010ec <MX_USART1_UART_Init+0x90>)
 8001076:	2200      	movs	r2, #0
 8001078:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 800107a:	4b1c      	ldr	r3, [pc, #112]	; (80010ec <MX_USART1_UART_Init+0x90>)
 800107c:	2200      	movs	r2, #0
 800107e:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 8001080:	4b1a      	ldr	r3, [pc, #104]	; (80010ec <MX_USART1_UART_Init+0x90>)
 8001082:	220c      	movs	r2, #12
 8001084:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8001086:	4b19      	ldr	r3, [pc, #100]	; (80010ec <MX_USART1_UART_Init+0x90>)
 8001088:	2200      	movs	r2, #0
 800108a:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 800108c:	4b17      	ldr	r3, [pc, #92]	; (80010ec <MX_USART1_UART_Init+0x90>)
 800108e:	2200      	movs	r2, #0
 8001090:	61da      	str	r2, [r3, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8001092:	4b16      	ldr	r3, [pc, #88]	; (80010ec <MX_USART1_UART_Init+0x90>)
 8001094:	2200      	movs	r2, #0
 8001096:	621a      	str	r2, [r3, #32]
  huart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 8001098:	4b14      	ldr	r3, [pc, #80]	; (80010ec <MX_USART1_UART_Init+0x90>)
 800109a:	2200      	movs	r2, #0
 800109c:	625a      	str	r2, [r3, #36]	; 0x24
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800109e:	4b13      	ldr	r3, [pc, #76]	; (80010ec <MX_USART1_UART_Init+0x90>)
 80010a0:	2200      	movs	r2, #0
 80010a2:	629a      	str	r2, [r3, #40]	; 0x28
  if (HAL_UART_Init(&huart1) != HAL_OK)
 80010a4:	4811      	ldr	r0, [pc, #68]	; (80010ec <MX_USART1_UART_Init+0x90>)
 80010a6:	f005 fa61 	bl	800656c <HAL_UART_Init>
 80010aa:	4603      	mov	r3, r0
 80010ac:	2b00      	cmp	r3, #0
 80010ae:	d001      	beq.n	80010b4 <MX_USART1_UART_Init+0x58>
  {
    Error_Handler();
 80010b0:	f000 f8ac 	bl	800120c <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 80010b4:	2100      	movs	r1, #0
 80010b6:	480d      	ldr	r0, [pc, #52]	; (80010ec <MX_USART1_UART_Init+0x90>)
 80010b8:	f005 ff3a 	bl	8006f30 <HAL_UARTEx_SetTxFifoThreshold>
 80010bc:	4603      	mov	r3, r0
 80010be:	2b00      	cmp	r3, #0
 80010c0:	d001      	beq.n	80010c6 <MX_USART1_UART_Init+0x6a>
  {
    Error_Handler();
 80010c2:	f000 f8a3 	bl	800120c <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 80010c6:	2100      	movs	r1, #0
 80010c8:	4808      	ldr	r0, [pc, #32]	; (80010ec <MX_USART1_UART_Init+0x90>)
 80010ca:	f005 ff6f 	bl	8006fac <HAL_UARTEx_SetRxFifoThreshold>
 80010ce:	4603      	mov	r3, r0
 80010d0:	2b00      	cmp	r3, #0
 80010d2:	d001      	beq.n	80010d8 <MX_USART1_UART_Init+0x7c>
  {
    Error_Handler();
 80010d4:	f000 f89a 	bl	800120c <Error_Handler>
  }
  if (HAL_UARTEx_DisableFifoMode(&huart1) != HAL_OK)
 80010d8:	4804      	ldr	r0, [pc, #16]	; (80010ec <MX_USART1_UART_Init+0x90>)
 80010da:	f005 fef0 	bl	8006ebe <HAL_UARTEx_DisableFifoMode>
 80010de:	4603      	mov	r3, r0
 80010e0:	2b00      	cmp	r3, #0
 80010e2:	d001      	beq.n	80010e8 <MX_USART1_UART_Init+0x8c>
  {
    Error_Handler();
 80010e4:	f000 f892 	bl	800120c <Error_Handler>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
 80010e8:	bf00      	nop
 80010ea:	bd80      	pop	{r7, pc}
 80010ec:	2000ee98 	.word	0x2000ee98
 80010f0:	40013800 	.word	0x40013800

080010f4 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 80010f4:	b580      	push	{r7, lr}
 80010f6:	b088      	sub	sp, #32
 80010f8:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80010fa:	f107 030c 	add.w	r3, r7, #12
 80010fe:	2200      	movs	r2, #0
 8001100:	601a      	str	r2, [r3, #0]
 8001102:	605a      	str	r2, [r3, #4]
 8001104:	609a      	str	r2, [r3, #8]
 8001106:	60da      	str	r2, [r3, #12]
 8001108:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800110a:	4b2b      	ldr	r3, [pc, #172]	; (80011b8 <MX_GPIO_Init+0xc4>)
 800110c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8001110:	4a29      	ldr	r2, [pc, #164]	; (80011b8 <MX_GPIO_Init+0xc4>)
 8001112:	f043 0301 	orr.w	r3, r3, #1
 8001116:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 800111a:	4b27      	ldr	r3, [pc, #156]	; (80011b8 <MX_GPIO_Init+0xc4>)
 800111c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8001120:	f003 0301 	and.w	r3, r3, #1
 8001124:	60bb      	str	r3, [r7, #8]
 8001126:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 8001128:	4b23      	ldr	r3, [pc, #140]	; (80011b8 <MX_GPIO_Init+0xc4>)
 800112a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800112e:	4a22      	ldr	r2, [pc, #136]	; (80011b8 <MX_GPIO_Init+0xc4>)
 8001130:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001134:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 8001138:	4b1f      	ldr	r3, [pc, #124]	; (80011b8 <MX_GPIO_Init+0xc4>)
 800113a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800113e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8001142:	607b      	str	r3, [r7, #4]
 8001144:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8001146:	4b1c      	ldr	r3, [pc, #112]	; (80011b8 <MX_GPIO_Init+0xc4>)
 8001148:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800114c:	4a1a      	ldr	r2, [pc, #104]	; (80011b8 <MX_GPIO_Init+0xc4>)
 800114e:	f043 0304 	orr.w	r3, r3, #4
 8001152:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 8001156:	4b18      	ldr	r3, [pc, #96]	; (80011b8 <MX_GPIO_Init+0xc4>)
 8001158:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800115c:	f003 0304 	and.w	r3, r3, #4
 8001160:	603b      	str	r3, [r7, #0]
 8001162:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED_GREEN_Port, LED_GREEN, GPIO_PIN_RESET);
 8001164:	2200      	movs	r2, #0
 8001166:	2180      	movs	r1, #128	; 0x80
 8001168:	4814      	ldr	r0, [pc, #80]	; (80011bc <MX_GPIO_Init+0xc8>)
 800116a:	f000 fd7b 	bl	8001c64 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED_RED_Port, LED_RED, GPIO_PIN_RESET);
 800116e:	2200      	movs	r2, #0
 8001170:	2104      	movs	r1, #4
 8001172:	4813      	ldr	r0, [pc, #76]	; (80011c0 <MX_GPIO_Init+0xcc>)
 8001174:	f000 fd76 	bl	8001c64 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : LED_GREEN */
  GPIO_InitStruct.Pin = LED_GREEN;
 8001178:	2380      	movs	r3, #128	; 0x80
 800117a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800117c:	2301      	movs	r3, #1
 800117e:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001180:	2300      	movs	r3, #0
 8001182:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001184:	2300      	movs	r3, #0
 8001186:	61bb      	str	r3, [r7, #24]
  HAL_GPIO_Init(LED_GREEN_Port, &GPIO_InitStruct);
 8001188:	f107 030c 	add.w	r3, r7, #12
 800118c:	4619      	mov	r1, r3
 800118e:	480b      	ldr	r0, [pc, #44]	; (80011bc <MX_GPIO_Init+0xc8>)
 8001190:	f000 fb90 	bl	80018b4 <HAL_GPIO_Init>

  /*Configure GPIO pin : LED_RED */
  GPIO_InitStruct.Pin = LED_RED;
 8001194:	2304      	movs	r3, #4
 8001196:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001198:	2301      	movs	r3, #1
 800119a:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800119c:	2300      	movs	r3, #0
 800119e:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80011a0:	2300      	movs	r3, #0
 80011a2:	61bb      	str	r3, [r7, #24]
  HAL_GPIO_Init(LED_RED_Port, &GPIO_InitStruct);
 80011a4:	f107 030c 	add.w	r3, r7, #12
 80011a8:	4619      	mov	r1, r3
 80011aa:	4805      	ldr	r0, [pc, #20]	; (80011c0 <MX_GPIO_Init+0xcc>)
 80011ac:	f000 fb82 	bl	80018b4 <HAL_GPIO_Init>

}
 80011b0:	bf00      	nop
 80011b2:	3720      	adds	r7, #32
 80011b4:	46bd      	mov	sp, r7
 80011b6:	bd80      	pop	{r7, pc}
 80011b8:	46020c00 	.word	0x46020c00
 80011bc:	42020800 	.word	0x42020800
 80011c0:	42021800 	.word	0x42021800

080011c4 <__io_putchar>:
  * @brief  Retargets the C library printf function to the USART.
  * @param  None
  * @retval None
  */
PUTCHAR_PROTOTYPE
{
 80011c4:	b580      	push	{r7, lr}
 80011c6:	b082      	sub	sp, #8
 80011c8:	af00      	add	r7, sp, #0
 80011ca:	6078      	str	r0, [r7, #4]
  /* Place your implementation of fputc here */
  /* e.g. write a character to the USART and Loop until the end of transmission */
  HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF);
 80011cc:	1d39      	adds	r1, r7, #4
 80011ce:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80011d2:	2201      	movs	r2, #1
 80011d4:	4803      	ldr	r0, [pc, #12]	; (80011e4 <__io_putchar+0x20>)
 80011d6:	f005 fa19 	bl	800660c <HAL_UART_Transmit>

  return ch;
 80011da:	687b      	ldr	r3, [r7, #4]
}
 80011dc:	4618      	mov	r0, r3
 80011de:	3708      	adds	r7, #8
 80011e0:	46bd      	mov	sp, r7
 80011e2:	bd80      	pop	{r7, pc}
 80011e4:	2000ee98 	.word	0x2000ee98

080011e8 <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 80011e8:	b580      	push	{r7, lr}
 80011ea:	b082      	sub	sp, #8
 80011ec:	af00      	add	r7, sp, #0
 80011ee:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM6) {
 80011f0:	687b      	ldr	r3, [r7, #4]
 80011f2:	681b      	ldr	r3, [r3, #0]
 80011f4:	4a04      	ldr	r2, [pc, #16]	; (8001208 <HAL_TIM_PeriodElapsedCallback+0x20>)
 80011f6:	4293      	cmp	r3, r2
 80011f8:	d101      	bne.n	80011fe <HAL_TIM_PeriodElapsedCallback+0x16>
    HAL_IncTick();
 80011fa:	f000 fa37 	bl	800166c <HAL_IncTick>
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 80011fe:	bf00      	nop
 8001200:	3708      	adds	r7, #8
 8001202:	46bd      	mov	sp, r7
 8001204:	bd80      	pop	{r7, pc}
 8001206:	bf00      	nop
 8001208:	40001000 	.word	0x40001000

0800120c <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 800120c:	b580      	push	{r7, lr}
 800120e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN Error_Handler_Debug */
  printf(" Error \n");
 8001210:	4808      	ldr	r0, [pc, #32]	; (8001234 <Error_Handler+0x28>)
 8001212:	f015 fbdf 	bl	80169d4 <puts>
  HAL_GPIO_WritePin(LED_GREEN_Port, LED_GREEN, GPIO_PIN_RESET);
 8001216:	2200      	movs	r2, #0
 8001218:	2180      	movs	r1, #128	; 0x80
 800121a:	4807      	ldr	r0, [pc, #28]	; (8001238 <Error_Handler+0x2c>)
 800121c:	f000 fd22 	bl	8001c64 <HAL_GPIO_WritePin>
  while(1)
  {
    /* Toggle LED_RED: Error */
    HAL_GPIO_TogglePin(LED_RED_Port, LED_RED);
 8001220:	2104      	movs	r1, #4
 8001222:	4806      	ldr	r0, [pc, #24]	; (800123c <Error_Handler+0x30>)
 8001224:	f000 fd36 	bl	8001c94 <HAL_GPIO_TogglePin>
    HAL_Delay(1000);
 8001228:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800122c:	f000 fa3e 	bl	80016ac <HAL_Delay>
    HAL_GPIO_TogglePin(LED_RED_Port, LED_RED);
 8001230:	e7f6      	b.n	8001220 <Error_Handler+0x14>
 8001232:	bf00      	nop
 8001234:	080179b8 	.word	0x080179b8
 8001238:	42020800 	.word	0x42020800
 800123c:	42021800 	.word	0x42021800

08001240 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MCU Support Package.
  */
void HAL_MspInit(void)
{
 8001240:	b480      	push	{r7}
 8001242:	b083      	sub	sp, #12
 8001244:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_PWR_CLK_ENABLE();
 8001246:	4b0a      	ldr	r3, [pc, #40]	; (8001270 <HAL_MspInit+0x30>)
 8001248:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800124c:	4a08      	ldr	r2, [pc, #32]	; (8001270 <HAL_MspInit+0x30>)
 800124e:	f043 0304 	orr.w	r3, r3, #4
 8001252:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 8001256:	4b06      	ldr	r3, [pc, #24]	; (8001270 <HAL_MspInit+0x30>)
 8001258:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800125c:	f003 0304 	and.w	r3, r3, #4
 8001260:	607b      	str	r3, [r7, #4]
 8001262:	687b      	ldr	r3, [r7, #4]


  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8001264:	bf00      	nop
 8001266:	370c      	adds	r7, #12
 8001268:	46bd      	mov	sp, r7
 800126a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800126e:	4770      	bx	lr
 8001270:	46020c00 	.word	0x46020c00

08001274 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8001274:	b580      	push	{r7, lr}
 8001276:	b0ba      	sub	sp, #232	; 0xe8
 8001278:	af00      	add	r7, sp, #0
 800127a:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800127c:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
 8001280:	2200      	movs	r2, #0
 8001282:	601a      	str	r2, [r3, #0]
 8001284:	605a      	str	r2, [r3, #4]
 8001286:	609a      	str	r2, [r3, #8]
 8001288:	60da      	str	r2, [r3, #12]
 800128a:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 800128c:	f107 0310 	add.w	r3, r7, #16
 8001290:	22c0      	movs	r2, #192	; 0xc0
 8001292:	2100      	movs	r1, #0
 8001294:	4618      	mov	r0, r3
 8001296:	f015 fba5 	bl	80169e4 <memset>
  if(huart->Instance==USART1)
 800129a:	687b      	ldr	r3, [r7, #4]
 800129c:	681b      	ldr	r3, [r3, #0]
 800129e:	4a26      	ldr	r2, [pc, #152]	; (8001338 <HAL_UART_MspInit+0xc4>)
 80012a0:	4293      	cmp	r3, r2
 80012a2:	d145      	bne.n	8001330 <HAL_UART_MspInit+0xbc>
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;
 80012a4:	f04f 0201 	mov.w	r2, #1
 80012a8:	f04f 0300 	mov.w	r3, #0
 80012ac:	e9c7 2304 	strd	r2, r3, [r7, #16]
    PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
 80012b0:	2300      	movs	r3, #0
 80012b2:	663b      	str	r3, [r7, #96]	; 0x60
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 80012b4:	f107 0310 	add.w	r3, r7, #16
 80012b8:	4618      	mov	r0, r3
 80012ba:	f002 f905 	bl	80034c8 <HAL_RCCEx_PeriphCLKConfig>
 80012be:	4603      	mov	r3, r0
 80012c0:	2b00      	cmp	r3, #0
 80012c2:	d001      	beq.n	80012c8 <HAL_UART_MspInit+0x54>
    {
      Error_Handler();
 80012c4:	f7ff ffa2 	bl	800120c <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 80012c8:	4b1c      	ldr	r3, [pc, #112]	; (800133c <HAL_UART_MspInit+0xc8>)
 80012ca:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 80012ce:	4a1b      	ldr	r2, [pc, #108]	; (800133c <HAL_UART_MspInit+0xc8>)
 80012d0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80012d4:	f8c2 30a4 	str.w	r3, [r2, #164]	; 0xa4
 80012d8:	4b18      	ldr	r3, [pc, #96]	; (800133c <HAL_UART_MspInit+0xc8>)
 80012da:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 80012de:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80012e2:	60fb      	str	r3, [r7, #12]
 80012e4:	68fb      	ldr	r3, [r7, #12]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 80012e6:	4b15      	ldr	r3, [pc, #84]	; (800133c <HAL_UART_MspInit+0xc8>)
 80012e8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80012ec:	4a13      	ldr	r2, [pc, #76]	; (800133c <HAL_UART_MspInit+0xc8>)
 80012ee:	f043 0301 	orr.w	r3, r3, #1
 80012f2:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 80012f6:	4b11      	ldr	r3, [pc, #68]	; (800133c <HAL_UART_MspInit+0xc8>)
 80012f8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80012fc:	f003 0301 	and.w	r3, r3, #1
 8001300:	60bb      	str	r3, [r7, #8]
 8001302:	68bb      	ldr	r3, [r7, #8]
    /**USART1 GPIO Configuration
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 8001304:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8001308:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800130c:	2302      	movs	r3, #2
 800130e:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001312:	2300      	movs	r3, #0
 8001314:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001318:	2300      	movs	r3, #0
 800131a:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 800131e:	2307      	movs	r3, #7
 8001320:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001324:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
 8001328:	4619      	mov	r1, r3
 800132a:	4805      	ldr	r0, [pc, #20]	; (8001340 <HAL_UART_MspInit+0xcc>)
 800132c:	f000 fac2 	bl	80018b4 <HAL_GPIO_Init>
  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }

}
 8001330:	bf00      	nop
 8001332:	37e8      	adds	r7, #232	; 0xe8
 8001334:	46bd      	mov	sp, r7
 8001336:	bd80      	pop	{r7, pc}
 8001338:	40013800 	.word	0x40013800
 800133c:	46020c00 	.word	0x46020c00
 8001340:	42020000 	.word	0x42020000

08001344 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001344:	b580      	push	{r7, lr}
 8001346:	b08e      	sub	sp, #56	; 0x38
 8001348:	af00      	add	r7, sp, #0
 800134a:	6078      	str	r0, [r7, #4]
  RCC_ClkInitTypeDef    clkconfig;
  uint32_t              uwTimclock = 0;
 800134c:	2300      	movs	r3, #0
 800134e:	633b      	str	r3, [r7, #48]	; 0x30
  uint32_t              uwPrescalerValue = 0;
 8001350:	2300      	movs	r3, #0
 8001352:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint32_t              pFLatency;
  HAL_StatusTypeDef     status;

  /* Enable TIM6 clock */
  __HAL_RCC_TIM6_CLK_ENABLE();
 8001354:	4b2e      	ldr	r3, [pc, #184]	; (8001410 <HAL_InitTick+0xcc>)
 8001356:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800135a:	4a2d      	ldr	r2, [pc, #180]	; (8001410 <HAL_InitTick+0xcc>)
 800135c:	f043 0310 	orr.w	r3, r3, #16
 8001360:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
 8001364:	4b2a      	ldr	r3, [pc, #168]	; (8001410 <HAL_InitTick+0xcc>)
 8001366:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800136a:	f003 0310 	and.w	r3, r3, #16
 800136e:	60fb      	str	r3, [r7, #12]
 8001370:	68fb      	ldr	r3, [r7, #12]

  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8001372:	f107 0210 	add.w	r2, r7, #16
 8001376:	f107 0314 	add.w	r3, r7, #20
 800137a:	4611      	mov	r1, r2
 800137c:	4618      	mov	r0, r3
 800137e:	f001 ffe5 	bl	800334c <HAL_RCC_GetClockConfig>

  /* Compute TIM6 clock */
  uwTimclock = HAL_RCC_GetPCLK1Freq();
 8001382:	f001 ffa7 	bl	80032d4 <HAL_RCC_GetPCLK1Freq>
 8001386:	6338      	str	r0, [r7, #48]	; 0x30
  /* Compute the prescaler value to have TIM6 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8001388:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800138a:	4a22      	ldr	r2, [pc, #136]	; (8001414 <HAL_InitTick+0xd0>)
 800138c:	fba2 2303 	umull	r2, r3, r2, r3
 8001390:	0c9b      	lsrs	r3, r3, #18
 8001392:	3b01      	subs	r3, #1
 8001394:	62fb      	str	r3, [r7, #44]	; 0x2c

  /* Initialize TIM6 */
  htim6.Instance = TIM6;
 8001396:	4b20      	ldr	r3, [pc, #128]	; (8001418 <HAL_InitTick+0xd4>)
 8001398:	4a20      	ldr	r2, [pc, #128]	; (800141c <HAL_InitTick+0xd8>)
 800139a:	601a      	str	r2, [r3, #0]
  + Period = [(TIM6CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim6.Init.Period = (1000000U / 1000U) - 1U;
 800139c:	4b1e      	ldr	r3, [pc, #120]	; (8001418 <HAL_InitTick+0xd4>)
 800139e:	f240 32e7 	movw	r2, #999	; 0x3e7
 80013a2:	60da      	str	r2, [r3, #12]
  htim6.Init.Prescaler = uwPrescalerValue;
 80013a4:	4a1c      	ldr	r2, [pc, #112]	; (8001418 <HAL_InitTick+0xd4>)
 80013a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80013a8:	6053      	str	r3, [r2, #4]
  htim6.Init.ClockDivision = 0;
 80013aa:	4b1b      	ldr	r3, [pc, #108]	; (8001418 <HAL_InitTick+0xd4>)
 80013ac:	2200      	movs	r2, #0
 80013ae:	611a      	str	r2, [r3, #16]
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
 80013b0:	4b19      	ldr	r3, [pc, #100]	; (8001418 <HAL_InitTick+0xd4>)
 80013b2:	2200      	movs	r2, #0
 80013b4:	609a      	str	r2, [r3, #8]

  status = HAL_TIM_Base_Init(&htim6);
 80013b6:	4818      	ldr	r0, [pc, #96]	; (8001418 <HAL_InitTick+0xd4>)
 80013b8:	f004 fd1e 	bl	8005df8 <HAL_TIM_Base_Init>
 80013bc:	4603      	mov	r3, r0
 80013be:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
  if (status == HAL_OK)
 80013c2:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80013c6:	2b00      	cmp	r3, #0
 80013c8:	d118      	bne.n	80013fc <HAL_InitTick+0xb8>
  {
    /* Start the TIM time Base generation in interrupt mode */
    status = HAL_TIM_Base_Start_IT(&htim6);
 80013ca:	4813      	ldr	r0, [pc, #76]	; (8001418 <HAL_InitTick+0xd4>)
 80013cc:	f004 fd76 	bl	8005ebc <HAL_TIM_Base_Start_IT>
 80013d0:	4603      	mov	r3, r0
 80013d2:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    if (status == HAL_OK)
 80013d6:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80013da:	2b00      	cmp	r3, #0
 80013dc:	d10e      	bne.n	80013fc <HAL_InitTick+0xb8>
    {
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 80013de:	687b      	ldr	r3, [r7, #4]
 80013e0:	2b0f      	cmp	r3, #15
 80013e2:	d808      	bhi.n	80013f6 <HAL_InitTick+0xb2>
      {
        /* Enable the TIM6 global Interrupt */
        HAL_NVIC_SetPriority(TIM6_IRQn, TickPriority, 0U);
 80013e4:	2200      	movs	r2, #0
 80013e6:	6879      	ldr	r1, [r7, #4]
 80013e8:	2031      	movs	r0, #49	; 0x31
 80013ea:	f000 fa3b 	bl	8001864 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 80013ee:	4a0c      	ldr	r2, [pc, #48]	; (8001420 <HAL_InitTick+0xdc>)
 80013f0:	687b      	ldr	r3, [r7, #4]
 80013f2:	6013      	str	r3, [r2, #0]
 80013f4:	e002      	b.n	80013fc <HAL_InitTick+0xb8>
      }
      else
      {
        status = HAL_ERROR;
 80013f6:	2301      	movs	r3, #1
 80013f8:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
      }
    }
  }
  /* Enable the TIM6 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM6_IRQn);
 80013fc:	2031      	movs	r0, #49	; 0x31
 80013fe:	f000 fa4b 	bl	8001898 <HAL_NVIC_EnableIRQ>

 /* Return function status */
  return status;
 8001402:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
}
 8001406:	4618      	mov	r0, r3
 8001408:	3738      	adds	r7, #56	; 0x38
 800140a:	46bd      	mov	sp, r7
 800140c:	bd80      	pop	{r7, pc}
 800140e:	bf00      	nop
 8001410:	46020c00 	.word	0x46020c00
 8001414:	431bde83 	.word	0x431bde83
 8001418:	2000ef2c 	.word	0x2000ef2c
 800141c:	40001000 	.word	0x40001000
 8001420:	20000004 	.word	0x20000004

08001424 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8001424:	b480      	push	{r7}
 8001426:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8001428:	e7fe      	b.n	8001428 <NMI_Handler+0x4>

0800142a <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 800142a:	b480      	push	{r7}
 800142c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800142e:	e7fe      	b.n	800142e <HardFault_Handler+0x4>

08001430 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8001430:	b480      	push	{r7}
 8001432:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8001434:	e7fe      	b.n	8001434 <UsageFault_Handler+0x4>

08001436 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8001436:	b480      	push	{r7}
 8001438:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800143a:	bf00      	nop
 800143c:	46bd      	mov	sp, r7
 800143e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001442:	4770      	bx	lr

08001444 <TIM6_IRQHandler>:

/**
  * @brief This function handles TIM6 global interrupt.
  */
void TIM6_IRQHandler(void)
{
 8001444:	b580      	push	{r7, lr}
 8001446:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM6_IRQn 0 */

  /* USER CODE END TIM6_IRQn 0 */
  HAL_TIM_IRQHandler(&htim6);
 8001448:	4802      	ldr	r0, [pc, #8]	; (8001454 <TIM6_IRQHandler+0x10>)
 800144a:	f004 fdd7 	bl	8005ffc <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM6_IRQn 1 */

  /* USER CODE END TIM6_IRQn 1 */
}
 800144e:	bf00      	nop
 8001450:	bd80      	pop	{r7, pc}
 8001452:	bf00      	nop
 8001454:	2000ef2c 	.word	0x2000ef2c

08001458 <_read>:
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8001458:	b580      	push	{r7, lr}
 800145a:	b086      	sub	sp, #24
 800145c:	af00      	add	r7, sp, #0
 800145e:	60f8      	str	r0, [r7, #12]
 8001460:	60b9      	str	r1, [r7, #8]
 8001462:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001464:	2300      	movs	r3, #0
 8001466:	617b      	str	r3, [r7, #20]
 8001468:	e00a      	b.n	8001480 <_read+0x28>
	{
		*ptr++ = __io_getchar();
 800146a:	f3af 8000 	nop.w
 800146e:	4601      	mov	r1, r0
 8001470:	68bb      	ldr	r3, [r7, #8]
 8001472:	1c5a      	adds	r2, r3, #1
 8001474:	60ba      	str	r2, [r7, #8]
 8001476:	b2ca      	uxtb	r2, r1
 8001478:	701a      	strb	r2, [r3, #0]
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800147a:	697b      	ldr	r3, [r7, #20]
 800147c:	3301      	adds	r3, #1
 800147e:	617b      	str	r3, [r7, #20]
 8001480:	697a      	ldr	r2, [r7, #20]
 8001482:	687b      	ldr	r3, [r7, #4]
 8001484:	429a      	cmp	r2, r3
 8001486:	dbf0      	blt.n	800146a <_read+0x12>
	}

return len;
 8001488:	687b      	ldr	r3, [r7, #4]
}
 800148a:	4618      	mov	r0, r3
 800148c:	3718      	adds	r7, #24
 800148e:	46bd      	mov	sp, r7
 8001490:	bd80      	pop	{r7, pc}

08001492 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8001492:	b580      	push	{r7, lr}
 8001494:	b086      	sub	sp, #24
 8001496:	af00      	add	r7, sp, #0
 8001498:	60f8      	str	r0, [r7, #12]
 800149a:	60b9      	str	r1, [r7, #8]
 800149c:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800149e:	2300      	movs	r3, #0
 80014a0:	617b      	str	r3, [r7, #20]
 80014a2:	e009      	b.n	80014b8 <_write+0x26>
	{
		__io_putchar(*ptr++);
 80014a4:	68bb      	ldr	r3, [r7, #8]
 80014a6:	1c5a      	adds	r2, r3, #1
 80014a8:	60ba      	str	r2, [r7, #8]
 80014aa:	781b      	ldrb	r3, [r3, #0]
 80014ac:	4618      	mov	r0, r3
 80014ae:	f7ff fe89 	bl	80011c4 <__io_putchar>
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80014b2:	697b      	ldr	r3, [r7, #20]
 80014b4:	3301      	adds	r3, #1
 80014b6:	617b      	str	r3, [r7, #20]
 80014b8:	697a      	ldr	r2, [r7, #20]
 80014ba:	687b      	ldr	r3, [r7, #4]
 80014bc:	429a      	cmp	r2, r3
 80014be:	dbf1      	blt.n	80014a4 <_write+0x12>
	}
	return len;
 80014c0:	687b      	ldr	r3, [r7, #4]
}
 80014c2:	4618      	mov	r0, r3
 80014c4:	3718      	adds	r7, #24
 80014c6:	46bd      	mov	sp, r7
 80014c8:	bd80      	pop	{r7, pc}

080014ca <_close>:

int _close(int file)
{
 80014ca:	b480      	push	{r7}
 80014cc:	b083      	sub	sp, #12
 80014ce:	af00      	add	r7, sp, #0
 80014d0:	6078      	str	r0, [r7, #4]
	return -1;
 80014d2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
 80014d6:	4618      	mov	r0, r3
 80014d8:	370c      	adds	r7, #12
 80014da:	46bd      	mov	sp, r7
 80014dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80014e0:	4770      	bx	lr

080014e2 <_fstat>:


int _fstat(int file, struct stat *st)
{
 80014e2:	b480      	push	{r7}
 80014e4:	b083      	sub	sp, #12
 80014e6:	af00      	add	r7, sp, #0
 80014e8:	6078      	str	r0, [r7, #4]
 80014ea:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
 80014ec:	683b      	ldr	r3, [r7, #0]
 80014ee:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80014f2:	605a      	str	r2, [r3, #4]
	return 0;
 80014f4:	2300      	movs	r3, #0
}
 80014f6:	4618      	mov	r0, r3
 80014f8:	370c      	adds	r7, #12
 80014fa:	46bd      	mov	sp, r7
 80014fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001500:	4770      	bx	lr

08001502 <_isatty>:

int _isatty(int file)
{
 8001502:	b480      	push	{r7}
 8001504:	b083      	sub	sp, #12
 8001506:	af00      	add	r7, sp, #0
 8001508:	6078      	str	r0, [r7, #4]
	return 1;
 800150a:	2301      	movs	r3, #1
}
 800150c:	4618      	mov	r0, r3
 800150e:	370c      	adds	r7, #12
 8001510:	46bd      	mov	sp, r7
 8001512:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001516:	4770      	bx	lr

08001518 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 8001518:	b480      	push	{r7}
 800151a:	b085      	sub	sp, #20
 800151c:	af00      	add	r7, sp, #0
 800151e:	60f8      	str	r0, [r7, #12]
 8001520:	60b9      	str	r1, [r7, #8]
 8001522:	607a      	str	r2, [r7, #4]
	return 0;
 8001524:	2300      	movs	r3, #0
}
 8001526:	4618      	mov	r0, r3
 8001528:	3714      	adds	r7, #20
 800152a:	46bd      	mov	sp, r7
 800152c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001530:	4770      	bx	lr
	...

08001534 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8001534:	b580      	push	{r7, lr}
 8001536:	b086      	sub	sp, #24
 8001538:	af00      	add	r7, sp, #0
 800153a:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 800153c:	4a14      	ldr	r2, [pc, #80]	; (8001590 <_sbrk+0x5c>)
 800153e:	4b15      	ldr	r3, [pc, #84]	; (8001594 <_sbrk+0x60>)
 8001540:	1ad3      	subs	r3, r2, r3
 8001542:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 8001544:	697b      	ldr	r3, [r7, #20]
 8001546:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8001548:	4b13      	ldr	r3, [pc, #76]	; (8001598 <_sbrk+0x64>)
 800154a:	681b      	ldr	r3, [r3, #0]
 800154c:	2b00      	cmp	r3, #0
 800154e:	d102      	bne.n	8001556 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8001550:	4b11      	ldr	r3, [pc, #68]	; (8001598 <_sbrk+0x64>)
 8001552:	4a12      	ldr	r2, [pc, #72]	; (800159c <_sbrk+0x68>)
 8001554:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8001556:	4b10      	ldr	r3, [pc, #64]	; (8001598 <_sbrk+0x64>)
 8001558:	681a      	ldr	r2, [r3, #0]
 800155a:	687b      	ldr	r3, [r7, #4]
 800155c:	4413      	add	r3, r2
 800155e:	693a      	ldr	r2, [r7, #16]
 8001560:	429a      	cmp	r2, r3
 8001562:	d207      	bcs.n	8001574 <_sbrk+0x40>
  {
    errno = ENOMEM;
 8001564:	f015 fa46 	bl	80169f4 <__errno>
 8001568:	4603      	mov	r3, r0
 800156a:	220c      	movs	r2, #12
 800156c:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 800156e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001572:	e009      	b.n	8001588 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 8001574:	4b08      	ldr	r3, [pc, #32]	; (8001598 <_sbrk+0x64>)
 8001576:	681b      	ldr	r3, [r3, #0]
 8001578:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 800157a:	4b07      	ldr	r3, [pc, #28]	; (8001598 <_sbrk+0x64>)
 800157c:	681a      	ldr	r2, [r3, #0]
 800157e:	687b      	ldr	r3, [r7, #4]
 8001580:	4413      	add	r3, r2
 8001582:	4a05      	ldr	r2, [pc, #20]	; (8001598 <_sbrk+0x64>)
 8001584:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 8001586:	68fb      	ldr	r3, [r7, #12]
}
 8001588:	4618      	mov	r0, r3
 800158a:	3718      	adds	r7, #24
 800158c:	46bd      	mov	sp, r7
 800158e:	bd80      	pop	{r7, pc}
 8001590:	20020000 	.word	0x20020000
 8001594:	00000800 	.word	0x00000800
 8001598:	2000ef78 	.word	0x2000ef78
 800159c:	2000f868 	.word	0x2000f868

080015a0 <SystemInit>:
  * @param  None
  * @retval None
  */

void SystemInit(void)
{
 80015a0:	b480      	push	{r7}
 80015a2:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
   SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 80015a4:	4b18      	ldr	r3, [pc, #96]	; (8001608 <SystemInit+0x68>)
 80015a6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80015aa:	4a17      	ldr	r2, [pc, #92]	; (8001608 <SystemInit+0x68>)
 80015ac:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 80015b0:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR = RCC_CR_MSISON;
 80015b4:	4b15      	ldr	r3, [pc, #84]	; (800160c <SystemInit+0x6c>)
 80015b6:	2201      	movs	r2, #1
 80015b8:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR1 = 0U;
 80015ba:	4b14      	ldr	r3, [pc, #80]	; (800160c <SystemInit+0x6c>)
 80015bc:	2200      	movs	r2, #0
 80015be:	61da      	str	r2, [r3, #28]
  RCC->CFGR2 = 0U;
 80015c0:	4b12      	ldr	r3, [pc, #72]	; (800160c <SystemInit+0x6c>)
 80015c2:	2200      	movs	r2, #0
 80015c4:	621a      	str	r2, [r3, #32]
  RCC->CFGR3 = 0U;
 80015c6:	4b11      	ldr	r3, [pc, #68]	; (800160c <SystemInit+0x6c>)
 80015c8:	2200      	movs	r2, #0
 80015ca:	625a      	str	r2, [r3, #36]	; 0x24

  /* Reset HSEON, CSSON , HSION, PLLxON bits */
  RCC->CR &= ~(RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLL1ON | RCC_CR_PLL2ON | RCC_CR_PLL3ON);
 80015cc:	4b0f      	ldr	r3, [pc, #60]	; (800160c <SystemInit+0x6c>)
 80015ce:	681b      	ldr	r3, [r3, #0]
 80015d0:	4a0e      	ldr	r2, [pc, #56]	; (800160c <SystemInit+0x6c>)
 80015d2:	f023 53a8 	bic.w	r3, r3, #352321536	; 0x15000000
 80015d6:	f423 2310 	bic.w	r3, r3, #589824	; 0x90000
 80015da:	6013      	str	r3, [r2, #0]

  /* Reset PLLCFGR register */
  RCC->PLL1CFGR = 0U;
 80015dc:	4b0b      	ldr	r3, [pc, #44]	; (800160c <SystemInit+0x6c>)
 80015de:	2200      	movs	r2, #0
 80015e0:	629a      	str	r2, [r3, #40]	; 0x28

  /* Reset HSEBYP bit */
  RCC->CR &= ~(RCC_CR_HSEBYP);
 80015e2:	4b0a      	ldr	r3, [pc, #40]	; (800160c <SystemInit+0x6c>)
 80015e4:	681b      	ldr	r3, [r3, #0]
 80015e6:	4a09      	ldr	r2, [pc, #36]	; (800160c <SystemInit+0x6c>)
 80015e8:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80015ec:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0U;
 80015ee:	4b07      	ldr	r3, [pc, #28]	; (800160c <SystemInit+0x6c>)
 80015f0:	2200      	movs	r2, #0
 80015f2:	651a      	str	r2, [r3, #80]	; 0x50

  /* Configure the Vector Table location add offset address ------------------*/
  #ifdef VECT_TAB_SRAM
    SCB->VTOR = SRAM1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
  #else
    SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80015f4:	4b04      	ldr	r3, [pc, #16]	; (8001608 <SystemInit+0x68>)
 80015f6:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80015fa:	609a      	str	r2, [r3, #8]
  #endif
}
 80015fc:	bf00      	nop
 80015fe:	46bd      	mov	sp, r7
 8001600:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001604:	4770      	bx	lr
 8001606:	bf00      	nop
 8001608:	e000ed00 	.word	0xe000ed00
 800160c:	46020c00 	.word	0x46020c00

08001610 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001610:	b580      	push	{r7, lr}
 8001612:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch */
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8001614:	4b11      	ldr	r3, [pc, #68]	; (800165c <HAL_Init+0x4c>)
 8001616:	681b      	ldr	r3, [r3, #0]
 8001618:	4a10      	ldr	r2, [pc, #64]	; (800165c <HAL_Init+0x4c>)
 800161a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800161e:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001620:	2003      	movs	r0, #3
 8001622:	f000 f914 	bl	800184e <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
 8001626:	f001 fd39 	bl	800309c <HAL_RCC_GetSysClockFreq>
 800162a:	4602      	mov	r2, r0
 800162c:	4b0c      	ldr	r3, [pc, #48]	; (8001660 <HAL_Init+0x50>)
 800162e:	6a1b      	ldr	r3, [r3, #32]
 8001630:	f003 030f 	and.w	r3, r3, #15
 8001634:	490b      	ldr	r1, [pc, #44]	; (8001664 <HAL_Init+0x54>)
 8001636:	5ccb      	ldrb	r3, [r1, r3]
 8001638:	fa22 f303 	lsr.w	r3, r2, r3
 800163c:	4a0a      	ldr	r2, [pc, #40]	; (8001668 <HAL_Init+0x58>)
 800163e:	6013      	str	r3, [r2, #0]

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8001640:	200f      	movs	r0, #15
 8001642:	f7ff fe7f 	bl	8001344 <HAL_InitTick>
 8001646:	4603      	mov	r3, r0
 8001648:	2b00      	cmp	r3, #0
 800164a:	d001      	beq.n	8001650 <HAL_Init+0x40>
  {
    return HAL_ERROR;
 800164c:	2301      	movs	r3, #1
 800164e:	e002      	b.n	8001656 <HAL_Init+0x46>
  }

  /* Init the low level hardware */
  HAL_MspInit();
 8001650:	f7ff fdf6 	bl	8001240 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 8001654:	2300      	movs	r3, #0
}
 8001656:	4618      	mov	r0, r3
 8001658:	bd80      	pop	{r7, pc}
 800165a:	bf00      	nop
 800165c:	40022000 	.word	0x40022000
 8001660:	46020c00 	.word	0x46020c00
 8001664:	08017a94 	.word	0x08017a94
 8001668:	20000000 	.word	0x20000000

0800166c <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 800166c:	b480      	push	{r7}
 800166e:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 8001670:	4b06      	ldr	r3, [pc, #24]	; (800168c <HAL_IncTick+0x20>)
 8001672:	781b      	ldrb	r3, [r3, #0]
 8001674:	461a      	mov	r2, r3
 8001676:	4b06      	ldr	r3, [pc, #24]	; (8001690 <HAL_IncTick+0x24>)
 8001678:	681b      	ldr	r3, [r3, #0]
 800167a:	4413      	add	r3, r2
 800167c:	4a04      	ldr	r2, [pc, #16]	; (8001690 <HAL_IncTick+0x24>)
 800167e:	6013      	str	r3, [r2, #0]
}
 8001680:	bf00      	nop
 8001682:	46bd      	mov	sp, r7
 8001684:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001688:	4770      	bx	lr
 800168a:	bf00      	nop
 800168c:	20000008 	.word	0x20000008
 8001690:	2000ef7c 	.word	0x2000ef7c

08001694 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8001694:	b480      	push	{r7}
 8001696:	af00      	add	r7, sp, #0
  return uwTick;
 8001698:	4b03      	ldr	r3, [pc, #12]	; (80016a8 <HAL_GetTick+0x14>)
 800169a:	681b      	ldr	r3, [r3, #0]
}
 800169c:	4618      	mov	r0, r3
 800169e:	46bd      	mov	sp, r7
 80016a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80016a4:	4770      	bx	lr
 80016a6:	bf00      	nop
 80016a8:	2000ef7c 	.word	0x2000ef7c

080016ac <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 80016ac:	b580      	push	{r7, lr}
 80016ae:	b084      	sub	sp, #16
 80016b0:	af00      	add	r7, sp, #0
 80016b2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 80016b4:	f7ff ffee 	bl	8001694 <HAL_GetTick>
 80016b8:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 80016ba:	687b      	ldr	r3, [r7, #4]
 80016bc:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 80016be:	68fb      	ldr	r3, [r7, #12]
 80016c0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80016c4:	d005      	beq.n	80016d2 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 80016c6:	4b0a      	ldr	r3, [pc, #40]	; (80016f0 <HAL_Delay+0x44>)
 80016c8:	781b      	ldrb	r3, [r3, #0]
 80016ca:	461a      	mov	r2, r3
 80016cc:	68fb      	ldr	r3, [r7, #12]
 80016ce:	4413      	add	r3, r2
 80016d0:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
 80016d2:	bf00      	nop
 80016d4:	f7ff ffde 	bl	8001694 <HAL_GetTick>
 80016d8:	4602      	mov	r2, r0
 80016da:	68bb      	ldr	r3, [r7, #8]
 80016dc:	1ad3      	subs	r3, r2, r3
 80016de:	68fa      	ldr	r2, [r7, #12]
 80016e0:	429a      	cmp	r2, r3
 80016e2:	d8f7      	bhi.n	80016d4 <HAL_Delay+0x28>
  {
  }
}
 80016e4:	bf00      	nop
 80016e6:	bf00      	nop
 80016e8:	3710      	adds	r7, #16
 80016ea:	46bd      	mov	sp, r7
 80016ec:	bd80      	pop	{r7, pc}
 80016ee:	bf00      	nop
 80016f0:	20000008 	.word	0x20000008

080016f4 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80016f4:	b480      	push	{r7}
 80016f6:	b085      	sub	sp, #20
 80016f8:	af00      	add	r7, sp, #0
 80016fa:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80016fc:	687b      	ldr	r3, [r7, #4]
 80016fe:	f003 0307 	and.w	r3, r3, #7
 8001702:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001704:	4b0c      	ldr	r3, [pc, #48]	; (8001738 <__NVIC_SetPriorityGrouping+0x44>)
 8001706:	68db      	ldr	r3, [r3, #12]
 8001708:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800170a:	68ba      	ldr	r2, [r7, #8]
 800170c:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8001710:	4013      	ands	r3, r2
 8001712:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8001714:	68fb      	ldr	r3, [r7, #12]
 8001716:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8001718:	68bb      	ldr	r3, [r7, #8]
 800171a:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800171c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8001720:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001724:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8001726:	4a04      	ldr	r2, [pc, #16]	; (8001738 <__NVIC_SetPriorityGrouping+0x44>)
 8001728:	68bb      	ldr	r3, [r7, #8]
 800172a:	60d3      	str	r3, [r2, #12]
}
 800172c:	bf00      	nop
 800172e:	3714      	adds	r7, #20
 8001730:	46bd      	mov	sp, r7
 8001732:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001736:	4770      	bx	lr
 8001738:	e000ed00 	.word	0xe000ed00

0800173c <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 800173c:	b480      	push	{r7}
 800173e:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001740:	4b04      	ldr	r3, [pc, #16]	; (8001754 <__NVIC_GetPriorityGrouping+0x18>)
 8001742:	68db      	ldr	r3, [r3, #12]
 8001744:	0a1b      	lsrs	r3, r3, #8
 8001746:	f003 0307 	and.w	r3, r3, #7
}
 800174a:	4618      	mov	r0, r3
 800174c:	46bd      	mov	sp, r7
 800174e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001752:	4770      	bx	lr
 8001754:	e000ed00 	.word	0xe000ed00

08001758 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001758:	b480      	push	{r7}
 800175a:	b083      	sub	sp, #12
 800175c:	af00      	add	r7, sp, #0
 800175e:	4603      	mov	r3, r0
 8001760:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8001762:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001766:	2b00      	cmp	r3, #0
 8001768:	db0b      	blt.n	8001782 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800176a:	79fb      	ldrb	r3, [r7, #7]
 800176c:	f003 021f 	and.w	r2, r3, #31
 8001770:	4907      	ldr	r1, [pc, #28]	; (8001790 <__NVIC_EnableIRQ+0x38>)
 8001772:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001776:	095b      	lsrs	r3, r3, #5
 8001778:	2001      	movs	r0, #1
 800177a:	fa00 f202 	lsl.w	r2, r0, r2
 800177e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 8001782:	bf00      	nop
 8001784:	370c      	adds	r7, #12
 8001786:	46bd      	mov	sp, r7
 8001788:	f85d 7b04 	ldr.w	r7, [sp], #4
 800178c:	4770      	bx	lr
 800178e:	bf00      	nop
 8001790:	e000e100 	.word	0xe000e100

08001794 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8001794:	b480      	push	{r7}
 8001796:	b083      	sub	sp, #12
 8001798:	af00      	add	r7, sp, #0
 800179a:	4603      	mov	r3, r0
 800179c:	6039      	str	r1, [r7, #0]
 800179e:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80017a0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80017a4:	2b00      	cmp	r3, #0
 80017a6:	db0a      	blt.n	80017be <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80017a8:	683b      	ldr	r3, [r7, #0]
 80017aa:	b2da      	uxtb	r2, r3
 80017ac:	490c      	ldr	r1, [pc, #48]	; (80017e0 <__NVIC_SetPriority+0x4c>)
 80017ae:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80017b2:	0112      	lsls	r2, r2, #4
 80017b4:	b2d2      	uxtb	r2, r2
 80017b6:	440b      	add	r3, r1
 80017b8:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 80017bc:	e00a      	b.n	80017d4 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80017be:	683b      	ldr	r3, [r7, #0]
 80017c0:	b2da      	uxtb	r2, r3
 80017c2:	4908      	ldr	r1, [pc, #32]	; (80017e4 <__NVIC_SetPriority+0x50>)
 80017c4:	79fb      	ldrb	r3, [r7, #7]
 80017c6:	f003 030f 	and.w	r3, r3, #15
 80017ca:	3b04      	subs	r3, #4
 80017cc:	0112      	lsls	r2, r2, #4
 80017ce:	b2d2      	uxtb	r2, r2
 80017d0:	440b      	add	r3, r1
 80017d2:	761a      	strb	r2, [r3, #24]
}
 80017d4:	bf00      	nop
 80017d6:	370c      	adds	r7, #12
 80017d8:	46bd      	mov	sp, r7
 80017da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80017de:	4770      	bx	lr
 80017e0:	e000e100 	.word	0xe000e100
 80017e4:	e000ed00 	.word	0xe000ed00

080017e8 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80017e8:	b480      	push	{r7}
 80017ea:	b089      	sub	sp, #36	; 0x24
 80017ec:	af00      	add	r7, sp, #0
 80017ee:	60f8      	str	r0, [r7, #12]
 80017f0:	60b9      	str	r1, [r7, #8]
 80017f2:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 80017f4:	68fb      	ldr	r3, [r7, #12]
 80017f6:	f003 0307 	and.w	r3, r3, #7
 80017fa:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80017fc:	69fb      	ldr	r3, [r7, #28]
 80017fe:	f1c3 0307 	rsb	r3, r3, #7
 8001802:	2b04      	cmp	r3, #4
 8001804:	bf28      	it	cs
 8001806:	2304      	movcs	r3, #4
 8001808:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800180a:	69fb      	ldr	r3, [r7, #28]
 800180c:	3304      	adds	r3, #4
 800180e:	2b06      	cmp	r3, #6
 8001810:	d902      	bls.n	8001818 <NVIC_EncodePriority+0x30>
 8001812:	69fb      	ldr	r3, [r7, #28]
 8001814:	3b03      	subs	r3, #3
 8001816:	e000      	b.n	800181a <NVIC_EncodePriority+0x32>
 8001818:	2300      	movs	r3, #0
 800181a:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800181c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001820:	69bb      	ldr	r3, [r7, #24]
 8001822:	fa02 f303 	lsl.w	r3, r2, r3
 8001826:	43da      	mvns	r2, r3
 8001828:	68bb      	ldr	r3, [r7, #8]
 800182a:	401a      	ands	r2, r3
 800182c:	697b      	ldr	r3, [r7, #20]
 800182e:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001830:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8001834:	697b      	ldr	r3, [r7, #20]
 8001836:	fa01 f303 	lsl.w	r3, r1, r3
 800183a:	43d9      	mvns	r1, r3
 800183c:	687b      	ldr	r3, [r7, #4]
 800183e:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001840:	4313      	orrs	r3, r2
         );
}
 8001842:	4618      	mov	r0, r3
 8001844:	3724      	adds	r7, #36	; 0x24
 8001846:	46bd      	mov	sp, r7
 8001848:	f85d 7b04 	ldr.w	r7, [sp], #4
 800184c:	4770      	bx	lr

0800184e <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800184e:	b580      	push	{r7, lr}
 8001850:	b082      	sub	sp, #8
 8001852:	af00      	add	r7, sp, #0
 8001854:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8001856:	6878      	ldr	r0, [r7, #4]
 8001858:	f7ff ff4c 	bl	80016f4 <__NVIC_SetPriorityGrouping>
}
 800185c:	bf00      	nop
 800185e:	3708      	adds	r7, #8
 8001860:	46bd      	mov	sp, r7
 8001862:	bd80      	pop	{r7, pc}

08001864 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8001864:	b580      	push	{r7, lr}
 8001866:	b086      	sub	sp, #24
 8001868:	af00      	add	r7, sp, #0
 800186a:	4603      	mov	r3, r0
 800186c:	60b9      	str	r1, [r7, #8]
 800186e:	607a      	str	r2, [r7, #4]
 8001870:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 8001872:	f7ff ff63 	bl	800173c <__NVIC_GetPriorityGrouping>
 8001876:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8001878:	687a      	ldr	r2, [r7, #4]
 800187a:	68b9      	ldr	r1, [r7, #8]
 800187c:	6978      	ldr	r0, [r7, #20]
 800187e:	f7ff ffb3 	bl	80017e8 <NVIC_EncodePriority>
 8001882:	4602      	mov	r2, r0
 8001884:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8001888:	4611      	mov	r1, r2
 800188a:	4618      	mov	r0, r3
 800188c:	f7ff ff82 	bl	8001794 <__NVIC_SetPriority>
}
 8001890:	bf00      	nop
 8001892:	3718      	adds	r7, #24
 8001894:	46bd      	mov	sp, r7
 8001896:	bd80      	pop	{r7, pc}

08001898 <HAL_NVIC_EnableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate
  *          CMSIS device file (stm32u5xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001898:	b580      	push	{r7, lr}
 800189a:	b082      	sub	sp, #8
 800189c:	af00      	add	r7, sp, #0
 800189e:	4603      	mov	r3, r0
 80018a0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 80018a2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80018a6:	4618      	mov	r0, r3
 80018a8:	f7ff ff56 	bl	8001758 <__NVIC_EnableIRQ>
}
 80018ac:	bf00      	nop
 80018ae:	3708      	adds	r7, #8
 80018b0:	46bd      	mov	sp, r7
 80018b2:	bd80      	pop	{r7, pc}

080018b4 <HAL_GPIO_Init>:
  * @param  pGPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *pGPIO_Init)
{
 80018b4:	b480      	push	{r7}
 80018b6:	b089      	sub	sp, #36	; 0x24
 80018b8:	af00      	add	r7, sp, #0
 80018ba:	6078      	str	r0, [r7, #4]
 80018bc:	6039      	str	r1, [r7, #0]
  uint32_t tmp;
  uint32_t iocurrent;
  uint32_t pin_position;
  uint32_t position = 0U;
 80018be:	2300      	movs	r3, #0
 80018c0:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(pGPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(pGPIO_Init->Mode));

  /* Save GPIO port address */
  p_gpio = GPIOx;
 80018c2:	687b      	ldr	r3, [r7, #4]
 80018c4:	613b      	str	r3, [r7, #16]

  /* Configure the port pins */
  while (((pGPIO_Init->Pin) >> position) != 0U)
 80018c6:	e1ba      	b.n	8001c3e <HAL_GPIO_Init+0x38a>
  {
    /* Get current io position */
    iocurrent = (pGPIO_Init->Pin) & (1UL << position);
 80018c8:	683b      	ldr	r3, [r7, #0]
 80018ca:	681a      	ldr	r2, [r3, #0]
 80018cc:	2101      	movs	r1, #1
 80018ce:	697b      	ldr	r3, [r7, #20]
 80018d0:	fa01 f303 	lsl.w	r3, r1, r3
 80018d4:	4013      	ands	r3, r2
 80018d6:	60fb      	str	r3, [r7, #12]

    /* Save Pin Position */
    pin_position = position;
 80018d8:	697b      	ldr	r3, [r7, #20]
 80018da:	61bb      	str	r3, [r7, #24]

    if (iocurrent != 0U)
 80018dc:	68fb      	ldr	r3, [r7, #12]
 80018de:	2b00      	cmp	r3, #0
 80018e0:	f000 81aa 	beq.w	8001c38 <HAL_GPIO_Init+0x384>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if (GPIOx == LPGPIO1)
 80018e4:	687b      	ldr	r3, [r7, #4]
 80018e6:	4a55      	ldr	r2, [pc, #340]	; (8001a3c <HAL_GPIO_Init+0x188>)
 80018e8:	4293      	cmp	r3, r2
 80018ea:	d15d      	bne.n	80019a8 <HAL_GPIO_Init+0xf4>
      {
        /* MODER configuration */
        tmp = GPIOx->MODER;
 80018ec:	687b      	ldr	r3, [r7, #4]
 80018ee:	681b      	ldr	r3, [r3, #0]
 80018f0:	61fb      	str	r3, [r7, #28]
        tmp &= ~(LPGPIO_MODER_MOD0 << position);
 80018f2:	2201      	movs	r2, #1
 80018f4:	697b      	ldr	r3, [r7, #20]
 80018f6:	fa02 f303 	lsl.w	r3, r2, r3
 80018fa:	43db      	mvns	r3, r3
 80018fc:	69fa      	ldr	r2, [r7, #28]
 80018fe:	4013      	ands	r3, r2
 8001900:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE_OUTPUT_PP) << position);
 8001902:	683b      	ldr	r3, [r7, #0]
 8001904:	685b      	ldr	r3, [r3, #4]
 8001906:	f003 0201 	and.w	r2, r3, #1
 800190a:	697b      	ldr	r3, [r7, #20]
 800190c:	fa02 f303 	lsl.w	r3, r2, r3
 8001910:	69fa      	ldr	r2, [r7, #28]
 8001912:	4313      	orrs	r3, r2
 8001914:	61fb      	str	r3, [r7, #28]
        GPIOx->MODER = tmp;
 8001916:	687b      	ldr	r3, [r7, #4]
 8001918:	69fa      	ldr	r2, [r7, #28]
 800191a:	601a      	str	r2, [r3, #0]

        /* Save GPIO Port and pin index */
        p_gpio = LPGPIO_Map[position].GPIO_PORT;
 800191c:	4a48      	ldr	r2, [pc, #288]	; (8001a40 <HAL_GPIO_Init+0x18c>)
 800191e:	697b      	ldr	r3, [r7, #20]
 8001920:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8001924:	613b      	str	r3, [r7, #16]
        pin_position = LPGPIO_Map[position].Pin_Pos;
 8001926:	4a46      	ldr	r2, [pc, #280]	; (8001a40 <HAL_GPIO_Init+0x18c>)
 8001928:	697b      	ldr	r3, [r7, #20]
 800192a:	00db      	lsls	r3, r3, #3
 800192c:	4413      	add	r3, r2
 800192e:	685b      	ldr	r3, [r3, #4]
 8001930:	61bb      	str	r3, [r7, #24]

        /* Configure Alternate function mapped with the current IO */
        tmp = p_gpio->AFR[(pin_position) >> 3U];
 8001932:	69bb      	ldr	r3, [r7, #24]
 8001934:	08da      	lsrs	r2, r3, #3
 8001936:	693b      	ldr	r3, [r7, #16]
 8001938:	3208      	adds	r2, #8
 800193a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800193e:	61fb      	str	r3, [r7, #28]
        tmp &= ~(0x0FUL << (((pin_position) & 0x07U) * 4U));
 8001940:	69bb      	ldr	r3, [r7, #24]
 8001942:	f003 0307 	and.w	r3, r3, #7
 8001946:	009b      	lsls	r3, r3, #2
 8001948:	220f      	movs	r2, #15
 800194a:	fa02 f303 	lsl.w	r3, r2, r3
 800194e:	43db      	mvns	r3, r3
 8001950:	69fa      	ldr	r2, [r7, #28]
 8001952:	4013      	ands	r3, r2
 8001954:	61fb      	str	r3, [r7, #28]
        tmp |= ((GPIO_AF11_LPGPIO1 & 0x0FUL) << (((pin_position) & 0x07U) * 4U));
 8001956:	69bb      	ldr	r3, [r7, #24]
 8001958:	f003 0307 	and.w	r3, r3, #7
 800195c:	009b      	lsls	r3, r3, #2
 800195e:	220b      	movs	r2, #11
 8001960:	fa02 f303 	lsl.w	r3, r2, r3
 8001964:	69fa      	ldr	r2, [r7, #28]
 8001966:	4313      	orrs	r3, r2
 8001968:	61fb      	str	r3, [r7, #28]
        p_gpio->AFR[(pin_position) >> 3U] = tmp;
 800196a:	69bb      	ldr	r3, [r7, #24]
 800196c:	08da      	lsrs	r2, r3, #3
 800196e:	693b      	ldr	r3, [r7, #16]
 8001970:	3208      	adds	r2, #8
 8001972:	69f9      	ldr	r1, [r7, #28]
 8001974:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

        /* Configure IO Direction mode (Alternate) */
        tmp = p_gpio->MODER;
 8001978:	693b      	ldr	r3, [r7, #16]
 800197a:	681b      	ldr	r3, [r3, #0]
 800197c:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * 2U));
 800197e:	69bb      	ldr	r3, [r7, #24]
 8001980:	005b      	lsls	r3, r3, #1
 8001982:	2203      	movs	r2, #3
 8001984:	fa02 f303 	lsl.w	r3, r2, r3
 8001988:	43db      	mvns	r3, r3
 800198a:	69fa      	ldr	r2, [r7, #28]
 800198c:	4013      	ands	r3, r2
 800198e:	61fb      	str	r3, [r7, #28]
        tmp |= ((GPIO_MODE_AF_PP & 0x0FUL) << (pin_position * 2U));
 8001990:	69bb      	ldr	r3, [r7, #24]
 8001992:	005b      	lsls	r3, r3, #1
 8001994:	2202      	movs	r2, #2
 8001996:	fa02 f303 	lsl.w	r3, r2, r3
 800199a:	69fa      	ldr	r2, [r7, #28]
 800199c:	4313      	orrs	r3, r2
 800199e:	61fb      	str	r3, [r7, #28]
        p_gpio->MODER = tmp;
 80019a0:	693b      	ldr	r3, [r7, #16]
 80019a2:	69fa      	ldr	r2, [r7, #28]
 80019a4:	601a      	str	r2, [r3, #0]
 80019a6:	e067      	b.n	8001a78 <HAL_GPIO_Init+0x1c4>
      }
      else if ((pGPIO_Init->Mode == GPIO_MODE_AF_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 80019a8:	683b      	ldr	r3, [r7, #0]
 80019aa:	685b      	ldr	r3, [r3, #4]
 80019ac:	2b02      	cmp	r3, #2
 80019ae:	d003      	beq.n	80019b8 <HAL_GPIO_Init+0x104>
 80019b0:	683b      	ldr	r3, [r7, #0]
 80019b2:	685b      	ldr	r3, [r3, #4]
 80019b4:	2b12      	cmp	r3, #18
 80019b6:	d145      	bne.n	8001a44 <HAL_GPIO_Init+0x190>
        assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(pGPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        tmp = GPIOx->AFR[position >> 3U];
 80019b8:	697b      	ldr	r3, [r7, #20]
 80019ba:	08da      	lsrs	r2, r3, #3
 80019bc:	687b      	ldr	r3, [r7, #4]
 80019be:	3208      	adds	r2, #8
 80019c0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80019c4:	61fb      	str	r3, [r7, #28]
        tmp &= ~(0x0FUL << ((position & 0x07U) * 4U));
 80019c6:	697b      	ldr	r3, [r7, #20]
 80019c8:	f003 0307 	and.w	r3, r3, #7
 80019cc:	009b      	lsls	r3, r3, #2
 80019ce:	220f      	movs	r2, #15
 80019d0:	fa02 f303 	lsl.w	r3, r2, r3
 80019d4:	43db      	mvns	r3, r3
 80019d6:	69fa      	ldr	r2, [r7, #28]
 80019d8:	4013      	ands	r3, r2
 80019da:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Alternate & 0x0FUL) << ((position & 0x07U) * 4U));
 80019dc:	683b      	ldr	r3, [r7, #0]
 80019de:	691b      	ldr	r3, [r3, #16]
 80019e0:	f003 020f 	and.w	r2, r3, #15
 80019e4:	697b      	ldr	r3, [r7, #20]
 80019e6:	f003 0307 	and.w	r3, r3, #7
 80019ea:	009b      	lsls	r3, r3, #2
 80019ec:	fa02 f303 	lsl.w	r3, r2, r3
 80019f0:	69fa      	ldr	r2, [r7, #28]
 80019f2:	4313      	orrs	r3, r2
 80019f4:	61fb      	str	r3, [r7, #28]
        GPIOx->AFR[position >> 3U] = tmp;
 80019f6:	697b      	ldr	r3, [r7, #20]
 80019f8:	08da      	lsrs	r2, r3, #3
 80019fa:	687b      	ldr	r3, [r7, #4]
 80019fc:	3208      	adds	r2, #8
 80019fe:	69f9      	ldr	r1, [r7, #28]
 8001a00:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

        /* Configure IO Direction mode (Alternate) */
        tmp = p_gpio->MODER;
 8001a04:	693b      	ldr	r3, [r7, #16]
 8001a06:	681b      	ldr	r3, [r3, #0]
 8001a08:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * 2U));
 8001a0a:	69bb      	ldr	r3, [r7, #24]
 8001a0c:	005b      	lsls	r3, r3, #1
 8001a0e:	2203      	movs	r2, #3
 8001a10:	fa02 f303 	lsl.w	r3, r2, r3
 8001a14:	43db      	mvns	r3, r3
 8001a16:	69fa      	ldr	r2, [r7, #28]
 8001a18:	4013      	ands	r3, r2
 8001a1a:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (pin_position * 2U));
 8001a1c:	683b      	ldr	r3, [r7, #0]
 8001a1e:	685b      	ldr	r3, [r3, #4]
 8001a20:	f003 0203 	and.w	r2, r3, #3
 8001a24:	69bb      	ldr	r3, [r7, #24]
 8001a26:	005b      	lsls	r3, r3, #1
 8001a28:	fa02 f303 	lsl.w	r3, r2, r3
 8001a2c:	69fa      	ldr	r2, [r7, #28]
 8001a2e:	4313      	orrs	r3, r2
 8001a30:	61fb      	str	r3, [r7, #28]
        p_gpio->MODER = tmp;
 8001a32:	693b      	ldr	r3, [r7, #16]
 8001a34:	69fa      	ldr	r2, [r7, #28]
 8001a36:	601a      	str	r2, [r3, #0]
 8001a38:	e01e      	b.n	8001a78 <HAL_GPIO_Init+0x1c4>
 8001a3a:	bf00      	nop
 8001a3c:	46020000 	.word	0x46020000
 8001a40:	08017aec 	.word	0x08017aec
      {
        /* Check the parameters */
        assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));

        /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
        tmp = p_gpio->MODER;
 8001a44:	693b      	ldr	r3, [r7, #16]
 8001a46:	681b      	ldr	r3, [r3, #0]
 8001a48:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * 2U));
 8001a4a:	69bb      	ldr	r3, [r7, #24]
 8001a4c:	005b      	lsls	r3, r3, #1
 8001a4e:	2203      	movs	r2, #3
 8001a50:	fa02 f303 	lsl.w	r3, r2, r3
 8001a54:	43db      	mvns	r3, r3
 8001a56:	69fa      	ldr	r2, [r7, #28]
 8001a58:	4013      	ands	r3, r2
 8001a5a:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (pin_position * 2U));
 8001a5c:	683b      	ldr	r3, [r7, #0]
 8001a5e:	685b      	ldr	r3, [r3, #4]
 8001a60:	f003 0203 	and.w	r2, r3, #3
 8001a64:	69bb      	ldr	r3, [r7, #24]
 8001a66:	005b      	lsls	r3, r3, #1
 8001a68:	fa02 f303 	lsl.w	r3, r2, r3
 8001a6c:	69fa      	ldr	r2, [r7, #28]
 8001a6e:	4313      	orrs	r3, r2
 8001a70:	61fb      	str	r3, [r7, #28]
        p_gpio->MODER = tmp;
 8001a72:	693b      	ldr	r3, [r7, #16]
 8001a74:	69fa      	ldr	r2, [r7, #28]
 8001a76:	601a      	str	r2, [r3, #0]
      }

      /* In case of Output or Alternate function mode selection */
      if ((pGPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001a78:	683b      	ldr	r3, [r7, #0]
 8001a7a:	685b      	ldr	r3, [r3, #4]
 8001a7c:	2b01      	cmp	r3, #1
 8001a7e:	d00b      	beq.n	8001a98 <HAL_GPIO_Init+0x1e4>
 8001a80:	683b      	ldr	r3, [r7, #0]
 8001a82:	685b      	ldr	r3, [r3, #4]
 8001a84:	2b02      	cmp	r3, #2
 8001a86:	d007      	beq.n	8001a98 <HAL_GPIO_Init+0x1e4>
          (pGPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001a88:	683b      	ldr	r3, [r7, #0]
 8001a8a:	685b      	ldr	r3, [r3, #4]
      if ((pGPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001a8c:	2b11      	cmp	r3, #17
 8001a8e:	d003      	beq.n	8001a98 <HAL_GPIO_Init+0x1e4>
          (pGPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001a90:	683b      	ldr	r3, [r7, #0]
 8001a92:	685b      	ldr	r3, [r3, #4]
 8001a94:	2b12      	cmp	r3, #18
 8001a96:	d130      	bne.n	8001afa <HAL_GPIO_Init+0x246>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(pGPIO_Init->Speed));

        /* Configure the IO Speed */
        tmp = p_gpio->OSPEEDR;
 8001a98:	693b      	ldr	r3, [r7, #16]
 8001a9a:	689b      	ldr	r3, [r3, #8]
 8001a9c:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_OSPEEDR_OSPEED0 << (pin_position * 2U));
 8001a9e:	69bb      	ldr	r3, [r7, #24]
 8001aa0:	005b      	lsls	r3, r3, #1
 8001aa2:	2203      	movs	r2, #3
 8001aa4:	fa02 f303 	lsl.w	r3, r2, r3
 8001aa8:	43db      	mvns	r3, r3
 8001aaa:	69fa      	ldr	r2, [r7, #28]
 8001aac:	4013      	ands	r3, r2
 8001aae:	61fb      	str	r3, [r7, #28]
        tmp |= (pGPIO_Init->Speed << (pin_position * 2U));
 8001ab0:	683b      	ldr	r3, [r7, #0]
 8001ab2:	68da      	ldr	r2, [r3, #12]
 8001ab4:	69bb      	ldr	r3, [r7, #24]
 8001ab6:	005b      	lsls	r3, r3, #1
 8001ab8:	fa02 f303 	lsl.w	r3, r2, r3
 8001abc:	69fa      	ldr	r2, [r7, #28]
 8001abe:	4313      	orrs	r3, r2
 8001ac0:	61fb      	str	r3, [r7, #28]
        p_gpio->OSPEEDR = tmp;
 8001ac2:	693b      	ldr	r3, [r7, #16]
 8001ac4:	69fa      	ldr	r2, [r7, #28]
 8001ac6:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        tmp = p_gpio->OTYPER;
 8001ac8:	693b      	ldr	r3, [r7, #16]
 8001aca:	685b      	ldr	r3, [r3, #4]
 8001acc:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_OTYPER_OT0 << pin_position);
 8001ace:	2201      	movs	r2, #1
 8001ad0:	69bb      	ldr	r3, [r7, #24]
 8001ad2:	fa02 f303 	lsl.w	r3, r2, r3
 8001ad6:	43db      	mvns	r3, r3
 8001ad8:	69fa      	ldr	r2, [r7, #28]
 8001ada:	4013      	ands	r3, r2
 8001adc:	61fb      	str	r3, [r7, #28]
        tmp |= (((pGPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << pin_position);
 8001ade:	683b      	ldr	r3, [r7, #0]
 8001ae0:	685b      	ldr	r3, [r3, #4]
 8001ae2:	091b      	lsrs	r3, r3, #4
 8001ae4:	f003 0201 	and.w	r2, r3, #1
 8001ae8:	69bb      	ldr	r3, [r7, #24]
 8001aea:	fa02 f303 	lsl.w	r3, r2, r3
 8001aee:	69fa      	ldr	r2, [r7, #28]
 8001af0:	4313      	orrs	r3, r2
 8001af2:	61fb      	str	r3, [r7, #28]
        p_gpio->OTYPER = tmp;
 8001af4:	693b      	ldr	r3, [r7, #16]
 8001af6:	69fa      	ldr	r2, [r7, #28]
 8001af8:	605a      	str	r2, [r3, #4]
      }

      if (pGPIO_Init->Mode != GPIO_MODE_ANALOG)
 8001afa:	683b      	ldr	r3, [r7, #0]
 8001afc:	685b      	ldr	r3, [r3, #4]
 8001afe:	2b03      	cmp	r3, #3
 8001b00:	d017      	beq.n	8001b32 <HAL_GPIO_Init+0x27e>
      {
        /* Check the Pull parameters */
        assert_param(IS_GPIO_PULL(pGPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        tmp = p_gpio->PUPDR;
 8001b02:	693b      	ldr	r3, [r7, #16]
 8001b04:	68db      	ldr	r3, [r3, #12]
 8001b06:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_PUPDR_PUPD0 << (pin_position * 2U));
 8001b08:	69bb      	ldr	r3, [r7, #24]
 8001b0a:	005b      	lsls	r3, r3, #1
 8001b0c:	2203      	movs	r2, #3
 8001b0e:	fa02 f303 	lsl.w	r3, r2, r3
 8001b12:	43db      	mvns	r3, r3
 8001b14:	69fa      	ldr	r2, [r7, #28]
 8001b16:	4013      	ands	r3, r2
 8001b18:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Pull) << (pin_position * 2U));
 8001b1a:	683b      	ldr	r3, [r7, #0]
 8001b1c:	689a      	ldr	r2, [r3, #8]
 8001b1e:	69bb      	ldr	r3, [r7, #24]
 8001b20:	005b      	lsls	r3, r3, #1
 8001b22:	fa02 f303 	lsl.w	r3, r2, r3
 8001b26:	69fa      	ldr	r2, [r7, #28]
 8001b28:	4313      	orrs	r3, r2
 8001b2a:	61fb      	str	r3, [r7, #28]
        p_gpio->PUPDR = tmp;
 8001b2c:	693b      	ldr	r3, [r7, #16]
 8001b2e:	69fa      	ldr	r2, [r7, #28]
 8001b30:	60da      	str	r2, [r3, #12]
      }

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((pGPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001b32:	683b      	ldr	r3, [r7, #0]
 8001b34:	685b      	ldr	r3, [r3, #4]
 8001b36:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001b3a:	2b00      	cmp	r3, #0
 8001b3c:	d07c      	beq.n	8001c38 <HAL_GPIO_Init+0x384>
      {
        tmp = EXTI->EXTICR[position >> 2U];
 8001b3e:	4a47      	ldr	r2, [pc, #284]	; (8001c5c <HAL_GPIO_Init+0x3a8>)
 8001b40:	697b      	ldr	r3, [r7, #20]
 8001b42:	089b      	lsrs	r3, r3, #2
 8001b44:	3318      	adds	r3, #24
 8001b46:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8001b4a:	61fb      	str	r3, [r7, #28]
        tmp &= ~((0x0FUL) << (8U * (position & 0x03U)));
 8001b4c:	697b      	ldr	r3, [r7, #20]
 8001b4e:	f003 0303 	and.w	r3, r3, #3
 8001b52:	00db      	lsls	r3, r3, #3
 8001b54:	220f      	movs	r2, #15
 8001b56:	fa02 f303 	lsl.w	r3, r2, r3
 8001b5a:	43db      	mvns	r3, r3
 8001b5c:	69fa      	ldr	r2, [r7, #28]
 8001b5e:	4013      	ands	r3, r2
 8001b60:	61fb      	str	r3, [r7, #28]
        tmp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 8001b62:	687b      	ldr	r3, [r7, #4]
 8001b64:	0a9a      	lsrs	r2, r3, #10
 8001b66:	4b3e      	ldr	r3, [pc, #248]	; (8001c60 <HAL_GPIO_Init+0x3ac>)
 8001b68:	4013      	ands	r3, r2
 8001b6a:	697a      	ldr	r2, [r7, #20]
 8001b6c:	f002 0203 	and.w	r2, r2, #3
 8001b70:	00d2      	lsls	r2, r2, #3
 8001b72:	4093      	lsls	r3, r2
 8001b74:	69fa      	ldr	r2, [r7, #28]
 8001b76:	4313      	orrs	r3, r2
 8001b78:	61fb      	str	r3, [r7, #28]
        EXTI->EXTICR[position >> 2U] = tmp;
 8001b7a:	4938      	ldr	r1, [pc, #224]	; (8001c5c <HAL_GPIO_Init+0x3a8>)
 8001b7c:	697b      	ldr	r3, [r7, #20]
 8001b7e:	089b      	lsrs	r3, r3, #2
 8001b80:	3318      	adds	r3, #24
 8001b82:	69fa      	ldr	r2, [r7, #28]
 8001b84:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        tmp = EXTI->RTSR1;
 8001b88:	4b34      	ldr	r3, [pc, #208]	; (8001c5c <HAL_GPIO_Init+0x3a8>)
 8001b8a:	681b      	ldr	r3, [r3, #0]
 8001b8c:	61fb      	str	r3, [r7, #28]
        tmp &= ~((uint32_t)iocurrent);
 8001b8e:	68fb      	ldr	r3, [r7, #12]
 8001b90:	43db      	mvns	r3, r3
 8001b92:	69fa      	ldr	r2, [r7, #28]
 8001b94:	4013      	ands	r3, r2
 8001b96:	61fb      	str	r3, [r7, #28]
        if ((pGPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001b98:	683b      	ldr	r3, [r7, #0]
 8001b9a:	685b      	ldr	r3, [r3, #4]
 8001b9c:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8001ba0:	2b00      	cmp	r3, #0
 8001ba2:	d003      	beq.n	8001bac <HAL_GPIO_Init+0x2f8>
        {
          tmp |= iocurrent;
 8001ba4:	69fa      	ldr	r2, [r7, #28]
 8001ba6:	68fb      	ldr	r3, [r7, #12]
 8001ba8:	4313      	orrs	r3, r2
 8001baa:	61fb      	str	r3, [r7, #28]
        }
        EXTI->RTSR1 = tmp;
 8001bac:	4a2b      	ldr	r2, [pc, #172]	; (8001c5c <HAL_GPIO_Init+0x3a8>)
 8001bae:	69fb      	ldr	r3, [r7, #28]
 8001bb0:	6013      	str	r3, [r2, #0]

        tmp = EXTI->FTSR1;
 8001bb2:	4b2a      	ldr	r3, [pc, #168]	; (8001c5c <HAL_GPIO_Init+0x3a8>)
 8001bb4:	685b      	ldr	r3, [r3, #4]
 8001bb6:	61fb      	str	r3, [r7, #28]
        tmp &= ~((uint32_t)iocurrent);
 8001bb8:	68fb      	ldr	r3, [r7, #12]
 8001bba:	43db      	mvns	r3, r3
 8001bbc:	69fa      	ldr	r2, [r7, #28]
 8001bbe:	4013      	ands	r3, r2
 8001bc0:	61fb      	str	r3, [r7, #28]
        if ((pGPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001bc2:	683b      	ldr	r3, [r7, #0]
 8001bc4:	685b      	ldr	r3, [r3, #4]
 8001bc6:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8001bca:	2b00      	cmp	r3, #0
 8001bcc:	d003      	beq.n	8001bd6 <HAL_GPIO_Init+0x322>
        {
          tmp |= iocurrent;
 8001bce:	69fa      	ldr	r2, [r7, #28]
 8001bd0:	68fb      	ldr	r3, [r7, #12]
 8001bd2:	4313      	orrs	r3, r2
 8001bd4:	61fb      	str	r3, [r7, #28]
        }
        EXTI->FTSR1 = tmp;
 8001bd6:	4a21      	ldr	r2, [pc, #132]	; (8001c5c <HAL_GPIO_Init+0x3a8>)
 8001bd8:	69fb      	ldr	r3, [r7, #28]
 8001bda:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        tmp = EXTI->EMR1;
 8001bdc:	4b1f      	ldr	r3, [pc, #124]	; (8001c5c <HAL_GPIO_Init+0x3a8>)
 8001bde:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8001be2:	61fb      	str	r3, [r7, #28]
        tmp &= ~((uint32_t)iocurrent);
 8001be4:	68fb      	ldr	r3, [r7, #12]
 8001be6:	43db      	mvns	r3, r3
 8001be8:	69fa      	ldr	r2, [r7, #28]
 8001bea:	4013      	ands	r3, r2
 8001bec:	61fb      	str	r3, [r7, #28]
        if ((pGPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001bee:	683b      	ldr	r3, [r7, #0]
 8001bf0:	685b      	ldr	r3, [r3, #4]
 8001bf2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001bf6:	2b00      	cmp	r3, #0
 8001bf8:	d003      	beq.n	8001c02 <HAL_GPIO_Init+0x34e>
        {
          tmp |= iocurrent;
 8001bfa:	69fa      	ldr	r2, [r7, #28]
 8001bfc:	68fb      	ldr	r3, [r7, #12]
 8001bfe:	4313      	orrs	r3, r2
 8001c00:	61fb      	str	r3, [r7, #28]
        }
        EXTI->EMR1 = tmp;
 8001c02:	4a16      	ldr	r2, [pc, #88]	; (8001c5c <HAL_GPIO_Init+0x3a8>)
 8001c04:	69fb      	ldr	r3, [r7, #28]
 8001c06:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84

        tmp = EXTI->IMR1;
 8001c0a:	4b14      	ldr	r3, [pc, #80]	; (8001c5c <HAL_GPIO_Init+0x3a8>)
 8001c0c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8001c10:	61fb      	str	r3, [r7, #28]
        tmp &= ~((uint32_t)iocurrent);
 8001c12:	68fb      	ldr	r3, [r7, #12]
 8001c14:	43db      	mvns	r3, r3
 8001c16:	69fa      	ldr	r2, [r7, #28]
 8001c18:	4013      	ands	r3, r2
 8001c1a:	61fb      	str	r3, [r7, #28]
        if ((pGPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8001c1c:	683b      	ldr	r3, [r7, #0]
 8001c1e:	685b      	ldr	r3, [r3, #4]
 8001c20:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8001c24:	2b00      	cmp	r3, #0
 8001c26:	d003      	beq.n	8001c30 <HAL_GPIO_Init+0x37c>
        {
          tmp |= iocurrent;
 8001c28:	69fa      	ldr	r2, [r7, #28]
 8001c2a:	68fb      	ldr	r3, [r7, #12]
 8001c2c:	4313      	orrs	r3, r2
 8001c2e:	61fb      	str	r3, [r7, #28]
        }
        EXTI->IMR1 = tmp;
 8001c30:	4a0a      	ldr	r2, [pc, #40]	; (8001c5c <HAL_GPIO_Init+0x3a8>)
 8001c32:	69fb      	ldr	r3, [r7, #28]
 8001c34:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
      }
    }
    position++;
 8001c38:	697b      	ldr	r3, [r7, #20]
 8001c3a:	3301      	adds	r3, #1
 8001c3c:	617b      	str	r3, [r7, #20]
  while (((pGPIO_Init->Pin) >> position) != 0U)
 8001c3e:	683b      	ldr	r3, [r7, #0]
 8001c40:	681a      	ldr	r2, [r3, #0]
 8001c42:	697b      	ldr	r3, [r7, #20]
 8001c44:	fa22 f303 	lsr.w	r3, r2, r3
 8001c48:	2b00      	cmp	r3, #0
 8001c4a:	f47f ae3d 	bne.w	80018c8 <HAL_GPIO_Init+0x14>
  }
}
 8001c4e:	bf00      	nop
 8001c50:	bf00      	nop
 8001c52:	3724      	adds	r7, #36	; 0x24
 8001c54:	46bd      	mov	sp, r7
 8001c56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c5a:	4770      	bx	lr
 8001c5c:	46022000 	.word	0x46022000
 8001c60:	002f7f7f 	.word	0x002f7f7f

08001c64 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8001c64:	b480      	push	{r7}
 8001c66:	b083      	sub	sp, #12
 8001c68:	af00      	add	r7, sp, #0
 8001c6a:	6078      	str	r0, [r7, #4]
 8001c6c:	460b      	mov	r3, r1
 8001c6e:	807b      	strh	r3, [r7, #2]
 8001c70:	4613      	mov	r3, r2
 8001c72:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8001c74:	787b      	ldrb	r3, [r7, #1]
 8001c76:	2b00      	cmp	r3, #0
 8001c78:	d003      	beq.n	8001c82 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8001c7a:	887a      	ldrh	r2, [r7, #2]
 8001c7c:	687b      	ldr	r3, [r7, #4]
 8001c7e:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR  = (uint32_t)GPIO_Pin;
  }
}
 8001c80:	e002      	b.n	8001c88 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR  = (uint32_t)GPIO_Pin;
 8001c82:	887a      	ldrh	r2, [r7, #2]
 8001c84:	687b      	ldr	r3, [r7, #4]
 8001c86:	629a      	str	r2, [r3, #40]	; 0x28
}
 8001c88:	bf00      	nop
 8001c8a:	370c      	adds	r7, #12
 8001c8c:	46bd      	mov	sp, r7
 8001c8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c92:	4770      	bx	lr

08001c94 <HAL_GPIO_TogglePin>:
  * @param  GPIO_Pin specifies the pin to be toggled.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 8001c94:	b480      	push	{r7}
 8001c96:	b085      	sub	sp, #20
 8001c98:	af00      	add	r7, sp, #0
 8001c9a:	6078      	str	r0, [r7, #4]
 8001c9c:	460b      	mov	r3, r1
 8001c9e:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 8001ca0:	687b      	ldr	r3, [r7, #4]
 8001ca2:	695b      	ldr	r3, [r3, #20]
 8001ca4:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 8001ca6:	887a      	ldrh	r2, [r7, #2]
 8001ca8:	68fb      	ldr	r3, [r7, #12]
 8001caa:	4013      	ands	r3, r2
 8001cac:	041a      	lsls	r2, r3, #16
 8001cae:	68fb      	ldr	r3, [r7, #12]
 8001cb0:	43d9      	mvns	r1, r3
 8001cb2:	887b      	ldrh	r3, [r7, #2]
 8001cb4:	400b      	ands	r3, r1
 8001cb6:	431a      	orrs	r2, r3
 8001cb8:	687b      	ldr	r3, [r7, #4]
 8001cba:	619a      	str	r2, [r3, #24]
}
 8001cbc:	bf00      	nop
 8001cbe:	3714      	adds	r7, #20
 8001cc0:	46bd      	mov	sp, r7
 8001cc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001cc6:	4770      	bx	lr

08001cc8 <HAL_ICACHE_ConfigAssociativityMode>:
  *            @arg ICACHE_1WAY   1-way cache (direct mapped cache)
  *            @arg ICACHE_2WAYS  2-ways set associative cache (default)
  * @retval HAL status (HAL_OK/HAL_ERROR)
  */
HAL_StatusTypeDef HAL_ICACHE_ConfigAssociativityMode(uint32_t AssociativityMode)
{
 8001cc8:	b480      	push	{r7}
 8001cca:	b085      	sub	sp, #20
 8001ccc:	af00      	add	r7, sp, #0
 8001cce:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8001cd0:	2300      	movs	r3, #0
 8001cd2:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_ICACHE_ASSOCIATIVITY_MODE(AssociativityMode));

  /* Check cache is not enabled */
  if (READ_BIT(ICACHE->CR, ICACHE_CR_EN) != 0U)
 8001cd4:	4b0b      	ldr	r3, [pc, #44]	; (8001d04 <HAL_ICACHE_ConfigAssociativityMode+0x3c>)
 8001cd6:	681b      	ldr	r3, [r3, #0]
 8001cd8:	f003 0301 	and.w	r3, r3, #1
 8001cdc:	2b00      	cmp	r3, #0
 8001cde:	d002      	beq.n	8001ce6 <HAL_ICACHE_ConfigAssociativityMode+0x1e>
  {
    status = HAL_ERROR;
 8001ce0:	2301      	movs	r3, #1
 8001ce2:	73fb      	strb	r3, [r7, #15]
 8001ce4:	e007      	b.n	8001cf6 <HAL_ICACHE_ConfigAssociativityMode+0x2e>
  }
  else
  {
    MODIFY_REG(ICACHE->CR, ICACHE_CR_WAYSEL, AssociativityMode);
 8001ce6:	4b07      	ldr	r3, [pc, #28]	; (8001d04 <HAL_ICACHE_ConfigAssociativityMode+0x3c>)
 8001ce8:	681b      	ldr	r3, [r3, #0]
 8001cea:	f023 0204 	bic.w	r2, r3, #4
 8001cee:	4905      	ldr	r1, [pc, #20]	; (8001d04 <HAL_ICACHE_ConfigAssociativityMode+0x3c>)
 8001cf0:	687b      	ldr	r3, [r7, #4]
 8001cf2:	4313      	orrs	r3, r2
 8001cf4:	600b      	str	r3, [r1, #0]
  }

  return status;
 8001cf6:	7bfb      	ldrb	r3, [r7, #15]
}
 8001cf8:	4618      	mov	r0, r3
 8001cfa:	3714      	adds	r7, #20
 8001cfc:	46bd      	mov	sp, r7
 8001cfe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d02:	4770      	bx	lr
 8001d04:	40030400 	.word	0x40030400

08001d08 <HAL_ICACHE_Enable>:
  *         cache operation. The Instruction Cache is bypassed until the
  *         cache operation completes.
  * @retval HAL status (HAL_OK)
  */
HAL_StatusTypeDef HAL_ICACHE_Enable(void)
{
 8001d08:	b480      	push	{r7}
 8001d0a:	af00      	add	r7, sp, #0
  SET_BIT(ICACHE->CR, ICACHE_CR_EN);
 8001d0c:	4b05      	ldr	r3, [pc, #20]	; (8001d24 <HAL_ICACHE_Enable+0x1c>)
 8001d0e:	681b      	ldr	r3, [r3, #0]
 8001d10:	4a04      	ldr	r2, [pc, #16]	; (8001d24 <HAL_ICACHE_Enable+0x1c>)
 8001d12:	f043 0301 	orr.w	r3, r3, #1
 8001d16:	6013      	str	r3, [r2, #0]

  return HAL_OK;
 8001d18:	2300      	movs	r3, #0
}
 8001d1a:	4618      	mov	r0, r3
 8001d1c:	46bd      	mov	sp, r7
 8001d1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d22:	4770      	bx	lr
 8001d24:	40030400 	.word	0x40030400

08001d28 <HAL_PWREx_ControlVoltageScaling>:
  * @note  Before moving to voltage scaling 4, it is mandatory to ensure that
  *        the system frequency is below 24 MHz.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
 8001d28:	b480      	push	{r7}
 8001d2a:	b085      	sub	sp, #20
 8001d2c:	af00      	add	r7, sp, #0
 8001d2e:	6078      	str	r0, [r7, #4]

  /* Check the parameter */
  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));

  /* Get the current voltage scale applied */
  vos_old = READ_BIT(PWR->SVMSR, PWR_SVMSR_ACTVOS);
 8001d30:	4b39      	ldr	r3, [pc, #228]	; (8001e18 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 8001d32:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001d34:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8001d38:	60bb      	str	r3, [r7, #8]

  /* No change, nothing to do */
  if (vos_old == VoltageScaling)
 8001d3a:	68ba      	ldr	r2, [r7, #8]
 8001d3c:	687b      	ldr	r3, [r7, #4]
 8001d3e:	429a      	cmp	r2, r3
 8001d40:	d10b      	bne.n	8001d5a <HAL_PWREx_ControlVoltageScaling+0x32>
  {
    /* Enable USB BOOST after wake up from Stop mode */
    if (VoltageScaling > PWR_REGULATOR_VOLTAGE_SCALE3)
 8001d42:	687b      	ldr	r3, [r7, #4]
 8001d44:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001d48:	d905      	bls.n	8001d56 <HAL_PWREx_ControlVoltageScaling+0x2e>
    {
      /* Enable USB BOOST */
      SET_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN);
 8001d4a:	4b33      	ldr	r3, [pc, #204]	; (8001e18 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 8001d4c:	68db      	ldr	r3, [r3, #12]
 8001d4e:	4a32      	ldr	r2, [pc, #200]	; (8001e18 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 8001d50:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8001d54:	60d3      	str	r3, [r2, #12]
    }

    return HAL_OK;
 8001d56:	2300      	movs	r3, #0
 8001d58:	e057      	b.n	8001e0a <HAL_PWREx_ControlVoltageScaling+0xe2>
  /* Check voltage scaling level */
  /*
   *  The Embedded power distribution (EPOD) must be enabled before switching to
   *  voltage scale 1 / 2 from voltage scale lower.
   */
  if (VoltageScaling > PWR_REGULATOR_VOLTAGE_SCALE3)
 8001d5a:	687b      	ldr	r3, [r7, #4]
 8001d5c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001d60:	d90a      	bls.n	8001d78 <HAL_PWREx_ControlVoltageScaling+0x50>
  {
    MODIFY_REG(PWR->VOSR, (PWR_VOSR_VOS | PWR_VOSR_BOOSTEN), (VoltageScaling | PWR_VOSR_BOOSTEN));
 8001d62:	4b2d      	ldr	r3, [pc, #180]	; (8001e18 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 8001d64:	68db      	ldr	r3, [r3, #12]
 8001d66:	f423 22e0 	bic.w	r2, r3, #458752	; 0x70000
 8001d6a:	687b      	ldr	r3, [r7, #4]
 8001d6c:	4313      	orrs	r3, r2
 8001d6e:	4a2a      	ldr	r2, [pc, #168]	; (8001e18 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 8001d70:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8001d74:	60d3      	str	r3, [r2, #12]
 8001d76:	e007      	b.n	8001d88 <HAL_PWREx_ControlVoltageScaling+0x60>
  }
  else
  {
    MODIFY_REG(PWR->VOSR, (PWR_VOSR_VOS | PWR_VOSR_BOOSTEN), VoltageScaling);
 8001d78:	4b27      	ldr	r3, [pc, #156]	; (8001e18 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 8001d7a:	68db      	ldr	r3, [r3, #12]
 8001d7c:	f423 22e0 	bic.w	r2, r3, #458752	; 0x70000
 8001d80:	4925      	ldr	r1, [pc, #148]	; (8001e18 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 8001d82:	687b      	ldr	r3, [r7, #4]
 8001d84:	4313      	orrs	r3, r2
 8001d86:	60cb      	str	r3, [r1, #12]
  }

  /* Wait until VOSRDY is raised */
  timeout = ((PWR_FLAG_SETTING_DELAY * (SystemCoreClock / 1000U)) / 1000U) + 1U;
 8001d88:	4b24      	ldr	r3, [pc, #144]	; (8001e1c <HAL_PWREx_ControlVoltageScaling+0xf4>)
 8001d8a:	681b      	ldr	r3, [r3, #0]
 8001d8c:	4a24      	ldr	r2, [pc, #144]	; (8001e20 <HAL_PWREx_ControlVoltageScaling+0xf8>)
 8001d8e:	fba2 2303 	umull	r2, r3, r2, r3
 8001d92:	099b      	lsrs	r3, r3, #6
 8001d94:	2232      	movs	r2, #50	; 0x32
 8001d96:	fb02 f303 	mul.w	r3, r2, r3
 8001d9a:	4a21      	ldr	r2, [pc, #132]	; (8001e20 <HAL_PWREx_ControlVoltageScaling+0xf8>)
 8001d9c:	fba2 2303 	umull	r2, r3, r2, r3
 8001da0:	099b      	lsrs	r3, r3, #6
 8001da2:	3301      	adds	r3, #1
 8001da4:	60fb      	str	r3, [r7, #12]
  while (HAL_IS_BIT_CLR(PWR->VOSR, PWR_VOSR_VOSRDY) && (timeout != 0U))
 8001da6:	e002      	b.n	8001dae <HAL_PWREx_ControlVoltageScaling+0x86>
  {
    timeout--;
 8001da8:	68fb      	ldr	r3, [r7, #12]
 8001daa:	3b01      	subs	r3, #1
 8001dac:	60fb      	str	r3, [r7, #12]
  while (HAL_IS_BIT_CLR(PWR->VOSR, PWR_VOSR_VOSRDY) && (timeout != 0U))
 8001dae:	4b1a      	ldr	r3, [pc, #104]	; (8001e18 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 8001db0:	68db      	ldr	r3, [r3, #12]
 8001db2:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8001db6:	2b00      	cmp	r3, #0
 8001db8:	d102      	bne.n	8001dc0 <HAL_PWREx_ControlVoltageScaling+0x98>
 8001dba:	68fb      	ldr	r3, [r7, #12]
 8001dbc:	2b00      	cmp	r3, #0
 8001dbe:	d1f3      	bne.n	8001da8 <HAL_PWREx_ControlVoltageScaling+0x80>
  }

  /* Check time out */
  if (timeout != 0U)
 8001dc0:	68fb      	ldr	r3, [r7, #12]
 8001dc2:	2b00      	cmp	r3, #0
 8001dc4:	d01b      	beq.n	8001dfe <HAL_PWREx_ControlVoltageScaling+0xd6>
  {
    /* Wait until ACTVOSRDY is raised */
    timeout = ((PWR_FLAG_SETTING_DELAY * (SystemCoreClock / 1000U)) / 1000U) + 1U;
 8001dc6:	4b15      	ldr	r3, [pc, #84]	; (8001e1c <HAL_PWREx_ControlVoltageScaling+0xf4>)
 8001dc8:	681b      	ldr	r3, [r3, #0]
 8001dca:	4a15      	ldr	r2, [pc, #84]	; (8001e20 <HAL_PWREx_ControlVoltageScaling+0xf8>)
 8001dcc:	fba2 2303 	umull	r2, r3, r2, r3
 8001dd0:	099b      	lsrs	r3, r3, #6
 8001dd2:	2232      	movs	r2, #50	; 0x32
 8001dd4:	fb02 f303 	mul.w	r3, r2, r3
 8001dd8:	4a11      	ldr	r2, [pc, #68]	; (8001e20 <HAL_PWREx_ControlVoltageScaling+0xf8>)
 8001dda:	fba2 2303 	umull	r2, r3, r2, r3
 8001dde:	099b      	lsrs	r3, r3, #6
 8001de0:	3301      	adds	r3, #1
 8001de2:	60fb      	str	r3, [r7, #12]
    while ((HAL_IS_BIT_CLR(PWR->SVMSR, PWR_SVMSR_ACTVOSRDY)) && (timeout != 0U))
 8001de4:	e002      	b.n	8001dec <HAL_PWREx_ControlVoltageScaling+0xc4>
    {
      timeout--;
 8001de6:	68fb      	ldr	r3, [r7, #12]
 8001de8:	3b01      	subs	r3, #1
 8001dea:	60fb      	str	r3, [r7, #12]
    while ((HAL_IS_BIT_CLR(PWR->SVMSR, PWR_SVMSR_ACTVOSRDY)) && (timeout != 0U))
 8001dec:	4b0a      	ldr	r3, [pc, #40]	; (8001e18 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 8001dee:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001df0:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8001df4:	2b00      	cmp	r3, #0
 8001df6:	d102      	bne.n	8001dfe <HAL_PWREx_ControlVoltageScaling+0xd6>
 8001df8:	68fb      	ldr	r3, [r7, #12]
 8001dfa:	2b00      	cmp	r3, #0
 8001dfc:	d1f3      	bne.n	8001de6 <HAL_PWREx_ControlVoltageScaling+0xbe>
    }
  }

  /* Check time out */
  if (timeout == 0U)
 8001dfe:	68fb      	ldr	r3, [r7, #12]
 8001e00:	2b00      	cmp	r3, #0
 8001e02:	d101      	bne.n	8001e08 <HAL_PWREx_ControlVoltageScaling+0xe0>
  {
    return HAL_TIMEOUT;
 8001e04:	2303      	movs	r3, #3
 8001e06:	e000      	b.n	8001e0a <HAL_PWREx_ControlVoltageScaling+0xe2>
  }

  return HAL_OK;
 8001e08:	2300      	movs	r3, #0
}
 8001e0a:	4618      	mov	r0, r3
 8001e0c:	3714      	adds	r7, #20
 8001e0e:	46bd      	mov	sp, r7
 8001e10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e14:	4770      	bx	lr
 8001e16:	bf00      	nop
 8001e18:	46020800 	.word	0x46020800
 8001e1c:	20000000 	.word	0x20000000
 8001e20:	10624dd3 	.word	0x10624dd3

08001e24 <HAL_PWREx_GetVoltageRange>:
/**
  * @brief  Return Voltage Scaling Range.
  * @retval Applied voltage scaling value.
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
 8001e24:	b480      	push	{r7}
 8001e26:	af00      	add	r7, sp, #0
  return (PWR->SVMSR & PWR_SVMSR_ACTVOS);
 8001e28:	4b04      	ldr	r3, [pc, #16]	; (8001e3c <HAL_PWREx_GetVoltageRange+0x18>)
 8001e2a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001e2c:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
}
 8001e30:	4618      	mov	r0, r3
 8001e32:	46bd      	mov	sp, r7
 8001e34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e38:	4770      	bx	lr
 8001e3a:	bf00      	nop
 8001e3c:	46020800 	.word	0x46020800

08001e40 <HAL_PWREx_ConfigSupply>:
  *                        @arg PWR_LDO_SUPPLY  : The LDO regulator supplies the Vcore Power Domains.
  *                        @arg PWR_SMPS_SUPPLY : The SMPS regulator supplies the Vcore Power Domains.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply(uint32_t SupplySource)
{
 8001e40:	b480      	push	{r7}
 8001e42:	b085      	sub	sp, #20
 8001e44:	af00      	add	r7, sp, #0
 8001e46:	6078      	str	r0, [r7, #4]

  /* Check the parameter */
  assert_param(IS_PWR_SUPPLY(SupplySource));

  /* Set maximum time out */
  timeout = ((PWR_FLAG_SETTING_DELAY * (SystemCoreClock / 1000U)) / 1000U) + 1U;
 8001e48:	4b22      	ldr	r3, [pc, #136]	; (8001ed4 <HAL_PWREx_ConfigSupply+0x94>)
 8001e4a:	681b      	ldr	r3, [r3, #0]
 8001e4c:	4a22      	ldr	r2, [pc, #136]	; (8001ed8 <HAL_PWREx_ConfigSupply+0x98>)
 8001e4e:	fba2 2303 	umull	r2, r3, r2, r3
 8001e52:	099b      	lsrs	r3, r3, #6
 8001e54:	2232      	movs	r2, #50	; 0x32
 8001e56:	fb02 f303 	mul.w	r3, r2, r3
 8001e5a:	4a1f      	ldr	r2, [pc, #124]	; (8001ed8 <HAL_PWREx_ConfigSupply+0x98>)
 8001e5c:	fba2 2303 	umull	r2, r3, r2, r3
 8001e60:	099b      	lsrs	r3, r3, #6
 8001e62:	3301      	adds	r3, #1
 8001e64:	60fb      	str	r3, [r7, #12]

  /* Configure the LDO as system regulator supply */
  if (SupplySource == PWR_LDO_SUPPLY)
 8001e66:	687b      	ldr	r3, [r7, #4]
 8001e68:	2b00      	cmp	r3, #0
 8001e6a:	d113      	bne.n	8001e94 <HAL_PWREx_ConfigSupply+0x54>
  {
    /* Set the power supply configuration */
    CLEAR_BIT(PWR->CR3, PWR_CR3_REGSEL);
 8001e6c:	4b1b      	ldr	r3, [pc, #108]	; (8001edc <HAL_PWREx_ConfigSupply+0x9c>)
 8001e6e:	689b      	ldr	r3, [r3, #8]
 8001e70:	4a1a      	ldr	r2, [pc, #104]	; (8001edc <HAL_PWREx_ConfigSupply+0x9c>)
 8001e72:	f023 0302 	bic.w	r3, r3, #2
 8001e76:	6093      	str	r3, [r2, #8]

    /* Wait until system switch on new regulator */
    while (HAL_IS_BIT_SET(PWR->SVMSR, PWR_SVMSR_REGS) && (timeout != 0U))
 8001e78:	e002      	b.n	8001e80 <HAL_PWREx_ConfigSupply+0x40>
    {
      timeout--;
 8001e7a:	68fb      	ldr	r3, [r7, #12]
 8001e7c:	3b01      	subs	r3, #1
 8001e7e:	60fb      	str	r3, [r7, #12]
    while (HAL_IS_BIT_SET(PWR->SVMSR, PWR_SVMSR_REGS) && (timeout != 0U))
 8001e80:	4b16      	ldr	r3, [pc, #88]	; (8001edc <HAL_PWREx_ConfigSupply+0x9c>)
 8001e82:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001e84:	f003 0302 	and.w	r3, r3, #2
 8001e88:	2b02      	cmp	r3, #2
 8001e8a:	d116      	bne.n	8001eba <HAL_PWREx_ConfigSupply+0x7a>
 8001e8c:	68fb      	ldr	r3, [r7, #12]
 8001e8e:	2b00      	cmp	r3, #0
 8001e90:	d1f3      	bne.n	8001e7a <HAL_PWREx_ConfigSupply+0x3a>
 8001e92:	e012      	b.n	8001eba <HAL_PWREx_ConfigSupply+0x7a>
  }
  /* Configure the SMPS as system regulator supply */
  else
  {
    /* Set the power supply configuration */
    SET_BIT(PWR->CR3, PWR_CR3_REGSEL);
 8001e94:	4b11      	ldr	r3, [pc, #68]	; (8001edc <HAL_PWREx_ConfigSupply+0x9c>)
 8001e96:	689b      	ldr	r3, [r3, #8]
 8001e98:	4a10      	ldr	r2, [pc, #64]	; (8001edc <HAL_PWREx_ConfigSupply+0x9c>)
 8001e9a:	f043 0302 	orr.w	r3, r3, #2
 8001e9e:	6093      	str	r3, [r2, #8]

    /* Wait until system switch on new regulator */
    while (HAL_IS_BIT_CLR(PWR->SVMSR, PWR_SVMSR_REGS) && (timeout != 0U))
 8001ea0:	e002      	b.n	8001ea8 <HAL_PWREx_ConfigSupply+0x68>
    {
      timeout--;
 8001ea2:	68fb      	ldr	r3, [r7, #12]
 8001ea4:	3b01      	subs	r3, #1
 8001ea6:	60fb      	str	r3, [r7, #12]
    while (HAL_IS_BIT_CLR(PWR->SVMSR, PWR_SVMSR_REGS) && (timeout != 0U))
 8001ea8:	4b0c      	ldr	r3, [pc, #48]	; (8001edc <HAL_PWREx_ConfigSupply+0x9c>)
 8001eaa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001eac:	f003 0302 	and.w	r3, r3, #2
 8001eb0:	2b00      	cmp	r3, #0
 8001eb2:	d102      	bne.n	8001eba <HAL_PWREx_ConfigSupply+0x7a>
 8001eb4:	68fb      	ldr	r3, [r7, #12]
 8001eb6:	2b00      	cmp	r3, #0
 8001eb8:	d1f3      	bne.n	8001ea2 <HAL_PWREx_ConfigSupply+0x62>
    }
  }

  /* Check time out */
  if (timeout == 0U)
 8001eba:	68fb      	ldr	r3, [r7, #12]
 8001ebc:	2b00      	cmp	r3, #0
 8001ebe:	d101      	bne.n	8001ec4 <HAL_PWREx_ConfigSupply+0x84>
  {
    return HAL_TIMEOUT;
 8001ec0:	2303      	movs	r3, #3
 8001ec2:	e000      	b.n	8001ec6 <HAL_PWREx_ConfigSupply+0x86>
  }

  return HAL_OK;
 8001ec4:	2300      	movs	r3, #0
}
 8001ec6:	4618      	mov	r0, r3
 8001ec8:	3714      	adds	r7, #20
 8001eca:	46bd      	mov	sp, r7
 8001ecc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ed0:	4770      	bx	lr
 8001ed2:	bf00      	nop
 8001ed4:	20000000 	.word	0x20000000
 8001ed8:	10624dd3 	.word	0x10624dd3
 8001edc:	46020800 	.word	0x46020800

08001ee0 <HAL_PWREx_DisableUCPDDeadBattery>:
  *         pull-down or to handover control to the UCPD (the UCPD must be
  *         initialized before doing the disable).
  * @retval None.
  */
void HAL_PWREx_DisableUCPDDeadBattery(void)
{
 8001ee0:	b480      	push	{r7}
 8001ee2:	af00      	add	r7, sp, #0
  SET_BIT(PWR->UCPDR, PWR_UCPDR_UCPD_DBDIS);
 8001ee4:	4b05      	ldr	r3, [pc, #20]	; (8001efc <HAL_PWREx_DisableUCPDDeadBattery+0x1c>)
 8001ee6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001ee8:	4a04      	ldr	r2, [pc, #16]	; (8001efc <HAL_PWREx_DisableUCPDDeadBattery+0x1c>)
 8001eea:	f043 0301 	orr.w	r3, r3, #1
 8001eee:	62d3      	str	r3, [r2, #44]	; 0x2c
}
 8001ef0:	bf00      	nop
 8001ef2:	46bd      	mov	sp, r7
 8001ef4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ef8:	4770      	bx	lr
 8001efa:	bf00      	nop
 8001efc:	46020800 	.word	0x46020800

08001f00 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(const RCC_OscInitTypeDef  *pRCC_OscInitStruct)
{
 8001f00:	b580      	push	{r7, lr}
 8001f02:	b08e      	sub	sp, #56	; 0x38
 8001f04:	af00      	add	r7, sp, #0
 8001f06:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status;
  uint32_t sysclk_source;
  uint32_t pll_config;
  FlagStatus pwrboosten = RESET;
 8001f08:	2300      	movs	r3, #0
 8001f0a:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
  uint32_t temp1_pllckcfg;
  uint32_t temp2_pllckcfg;

  /* Check Null pointer */
  if (pRCC_OscInitStruct == NULL)
 8001f0e:	687b      	ldr	r3, [r7, #4]
 8001f10:	2b00      	cmp	r3, #0
 8001f12:	d102      	bne.n	8001f1a <HAL_RCC_OscConfig+0x1a>
  {
    return HAL_ERROR;
 8001f14:	2301      	movs	r3, #1
 8001f16:	f000 bec8 	b.w	8002caa <HAL_RCC_OscConfig+0xdaa>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(pRCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8001f1a:	4b99      	ldr	r3, [pc, #612]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8001f1c:	69db      	ldr	r3, [r3, #28]
 8001f1e:	f003 030c 	and.w	r3, r3, #12
 8001f22:	633b      	str	r3, [r7, #48]	; 0x30
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 8001f24:	4b96      	ldr	r3, [pc, #600]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8001f26:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001f28:	f003 0303 	and.w	r3, r3, #3
 8001f2c:	62fb      	str	r3, [r7, #44]	; 0x2c

  /*----------------------------- MSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8001f2e:	687b      	ldr	r3, [r7, #4]
 8001f30:	681b      	ldr	r3, [r3, #0]
 8001f32:	f003 0310 	and.w	r3, r3, #16
 8001f36:	2b00      	cmp	r3, #0
 8001f38:	f000 816c 	beq.w	8002214 <HAL_RCC_OscConfig+0x314>
    assert_param(IS_RCC_MSICALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(pRCC_OscInitStruct->MSIClockRange));

    /*Check if MSI is used as system clock or as PLL source when PLL is selected as system clock*/

    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 8001f3c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001f3e:	2b00      	cmp	r3, #0
 8001f40:	d007      	beq.n	8001f52 <HAL_RCC_OscConfig+0x52>
 8001f42:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001f44:	2b0c      	cmp	r3, #12
 8001f46:	f040 80de 	bne.w	8002106 <HAL_RCC_OscConfig+0x206>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_MSI)))
 8001f4a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001f4c:	2b01      	cmp	r3, #1
 8001f4e:	f040 80da 	bne.w	8002106 <HAL_RCC_OscConfig+0x206>
    {
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
 8001f52:	687b      	ldr	r3, [r7, #4]
 8001f54:	69db      	ldr	r3, [r3, #28]
 8001f56:	2b00      	cmp	r3, #0
 8001f58:	d102      	bne.n	8001f60 <HAL_RCC_OscConfig+0x60>
      {
        return HAL_ERROR;
 8001f5a:	2301      	movs	r3, #1
 8001f5c:	f000 bea5 	b.w	8002caa <HAL_RCC_OscConfig+0xdaa>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device */
        if (pRCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8001f60:	687b      	ldr	r3, [r7, #4]
 8001f62:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001f64:	4b86      	ldr	r3, [pc, #536]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8001f66:	689b      	ldr	r3, [r3, #8]
 8001f68:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8001f6c:	2b00      	cmp	r3, #0
 8001f6e:	d004      	beq.n	8001f7a <HAL_RCC_OscConfig+0x7a>
 8001f70:	4b83      	ldr	r3, [pc, #524]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8001f72:	689b      	ldr	r3, [r3, #8]
 8001f74:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 8001f78:	e005      	b.n	8001f86 <HAL_RCC_OscConfig+0x86>
 8001f7a:	4b81      	ldr	r3, [pc, #516]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8001f7c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8001f80:	041b      	lsls	r3, r3, #16
 8001f82:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 8001f86:	4293      	cmp	r3, r2
 8001f88:	d255      	bcs.n	8002036 <HAL_RCC_OscConfig+0x136>
        {
          /* Decrease number of wait states update if necessary */
          /* Only possible when MSI is the System clock source  */
          if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8001f8a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001f8c:	2b00      	cmp	r3, #0
 8001f8e:	d10a      	bne.n	8001fa6 <HAL_RCC_OscConfig+0xa6>
          {
            if (RCC_SetFlashLatencyFromMSIRange(pRCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8001f90:	687b      	ldr	r3, [r7, #4]
 8001f92:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001f94:	4618      	mov	r0, r3
 8001f96:	f001 fa11 	bl	80033bc <RCC_SetFlashLatencyFromMSIRange>
 8001f9a:	4603      	mov	r3, r0
 8001f9c:	2b00      	cmp	r3, #0
 8001f9e:	d002      	beq.n	8001fa6 <HAL_RCC_OscConfig+0xa6>
            {
              return HAL_ERROR;
 8001fa0:	2301      	movs	r3, #1
 8001fa2:	f000 be82 	b.w	8002caa <HAL_RCC_OscConfig+0xdaa>
            }
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range */
          __HAL_RCC_MSI_RANGE_CONFIG(pRCC_OscInitStruct->MSIClockRange);
 8001fa6:	4b76      	ldr	r3, [pc, #472]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8001fa8:	689b      	ldr	r3, [r3, #8]
 8001faa:	4a75      	ldr	r2, [pc, #468]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8001fac:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8001fb0:	6093      	str	r3, [r2, #8]
 8001fb2:	4b73      	ldr	r3, [pc, #460]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8001fb4:	689b      	ldr	r3, [r3, #8]
 8001fb6:	f023 4270 	bic.w	r2, r3, #4026531840	; 0xf0000000
 8001fba:	687b      	ldr	r3, [r7, #4]
 8001fbc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001fbe:	4970      	ldr	r1, [pc, #448]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8001fc0:	4313      	orrs	r3, r2
 8001fc2:	608b      	str	r3, [r1, #8]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value */
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST((pRCC_OscInitStruct->MSICalibrationValue), \
 8001fc4:	687b      	ldr	r3, [r7, #4]
 8001fc6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001fc8:	f1b3 4f40 	cmp.w	r3, #3221225472	; 0xc0000000
 8001fcc:	d309      	bcc.n	8001fe2 <HAL_RCC_OscConfig+0xe2>
 8001fce:	4b6c      	ldr	r3, [pc, #432]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8001fd0:	68db      	ldr	r3, [r3, #12]
 8001fd2:	f023 021f 	bic.w	r2, r3, #31
 8001fd6:	687b      	ldr	r3, [r7, #4]
 8001fd8:	6a1b      	ldr	r3, [r3, #32]
 8001fda:	4969      	ldr	r1, [pc, #420]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8001fdc:	4313      	orrs	r3, r2
 8001fde:	60cb      	str	r3, [r1, #12]
 8001fe0:	e07e      	b.n	80020e0 <HAL_RCC_OscConfig+0x1e0>
 8001fe2:	687b      	ldr	r3, [r7, #4]
 8001fe4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001fe6:	2b00      	cmp	r3, #0
 8001fe8:	da0a      	bge.n	8002000 <HAL_RCC_OscConfig+0x100>
 8001fea:	4b65      	ldr	r3, [pc, #404]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8001fec:	68db      	ldr	r3, [r3, #12]
 8001fee:	f423 7278 	bic.w	r2, r3, #992	; 0x3e0
 8001ff2:	687b      	ldr	r3, [r7, #4]
 8001ff4:	6a1b      	ldr	r3, [r3, #32]
 8001ff6:	015b      	lsls	r3, r3, #5
 8001ff8:	4961      	ldr	r1, [pc, #388]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8001ffa:	4313      	orrs	r3, r2
 8001ffc:	60cb      	str	r3, [r1, #12]
 8001ffe:	e06f      	b.n	80020e0 <HAL_RCC_OscConfig+0x1e0>
 8002000:	687b      	ldr	r3, [r7, #4]
 8002002:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002004:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8002008:	d30a      	bcc.n	8002020 <HAL_RCC_OscConfig+0x120>
 800200a:	4b5d      	ldr	r3, [pc, #372]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 800200c:	68db      	ldr	r3, [r3, #12]
 800200e:	f423 42f8 	bic.w	r2, r3, #31744	; 0x7c00
 8002012:	687b      	ldr	r3, [r7, #4]
 8002014:	6a1b      	ldr	r3, [r3, #32]
 8002016:	029b      	lsls	r3, r3, #10
 8002018:	4959      	ldr	r1, [pc, #356]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 800201a:	4313      	orrs	r3, r2
 800201c:	60cb      	str	r3, [r1, #12]
 800201e:	e05f      	b.n	80020e0 <HAL_RCC_OscConfig+0x1e0>
 8002020:	4b57      	ldr	r3, [pc, #348]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8002022:	68db      	ldr	r3, [r3, #12]
 8002024:	f423 2278 	bic.w	r2, r3, #1015808	; 0xf8000
 8002028:	687b      	ldr	r3, [r7, #4]
 800202a:	6a1b      	ldr	r3, [r3, #32]
 800202c:	03db      	lsls	r3, r3, #15
 800202e:	4954      	ldr	r1, [pc, #336]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8002030:	4313      	orrs	r3, r2
 8002032:	60cb      	str	r3, [r1, #12]
 8002034:	e054      	b.n	80020e0 <HAL_RCC_OscConfig+0x1e0>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range */
          __HAL_RCC_MSI_RANGE_CONFIG(pRCC_OscInitStruct->MSIClockRange);
 8002036:	4b52      	ldr	r3, [pc, #328]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8002038:	689b      	ldr	r3, [r3, #8]
 800203a:	4a51      	ldr	r2, [pc, #324]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 800203c:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8002040:	6093      	str	r3, [r2, #8]
 8002042:	4b4f      	ldr	r3, [pc, #316]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8002044:	689b      	ldr	r3, [r3, #8]
 8002046:	f023 4270 	bic.w	r2, r3, #4026531840	; 0xf0000000
 800204a:	687b      	ldr	r3, [r7, #4]
 800204c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800204e:	494c      	ldr	r1, [pc, #304]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8002050:	4313      	orrs	r3, r2
 8002052:	608b      	str	r3, [r1, #8]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value */
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST((pRCC_OscInitStruct->MSICalibrationValue), \
 8002054:	687b      	ldr	r3, [r7, #4]
 8002056:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002058:	f1b3 4f40 	cmp.w	r3, #3221225472	; 0xc0000000
 800205c:	d309      	bcc.n	8002072 <HAL_RCC_OscConfig+0x172>
 800205e:	4b48      	ldr	r3, [pc, #288]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8002060:	68db      	ldr	r3, [r3, #12]
 8002062:	f023 021f 	bic.w	r2, r3, #31
 8002066:	687b      	ldr	r3, [r7, #4]
 8002068:	6a1b      	ldr	r3, [r3, #32]
 800206a:	4945      	ldr	r1, [pc, #276]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 800206c:	4313      	orrs	r3, r2
 800206e:	60cb      	str	r3, [r1, #12]
 8002070:	e028      	b.n	80020c4 <HAL_RCC_OscConfig+0x1c4>
 8002072:	687b      	ldr	r3, [r7, #4]
 8002074:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002076:	2b00      	cmp	r3, #0
 8002078:	da0a      	bge.n	8002090 <HAL_RCC_OscConfig+0x190>
 800207a:	4b41      	ldr	r3, [pc, #260]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 800207c:	68db      	ldr	r3, [r3, #12]
 800207e:	f423 7278 	bic.w	r2, r3, #992	; 0x3e0
 8002082:	687b      	ldr	r3, [r7, #4]
 8002084:	6a1b      	ldr	r3, [r3, #32]
 8002086:	015b      	lsls	r3, r3, #5
 8002088:	493d      	ldr	r1, [pc, #244]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 800208a:	4313      	orrs	r3, r2
 800208c:	60cb      	str	r3, [r1, #12]
 800208e:	e019      	b.n	80020c4 <HAL_RCC_OscConfig+0x1c4>
 8002090:	687b      	ldr	r3, [r7, #4]
 8002092:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002094:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8002098:	d30a      	bcc.n	80020b0 <HAL_RCC_OscConfig+0x1b0>
 800209a:	4b39      	ldr	r3, [pc, #228]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 800209c:	68db      	ldr	r3, [r3, #12]
 800209e:	f423 42f8 	bic.w	r2, r3, #31744	; 0x7c00
 80020a2:	687b      	ldr	r3, [r7, #4]
 80020a4:	6a1b      	ldr	r3, [r3, #32]
 80020a6:	029b      	lsls	r3, r3, #10
 80020a8:	4935      	ldr	r1, [pc, #212]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 80020aa:	4313      	orrs	r3, r2
 80020ac:	60cb      	str	r3, [r1, #12]
 80020ae:	e009      	b.n	80020c4 <HAL_RCC_OscConfig+0x1c4>
 80020b0:	4b33      	ldr	r3, [pc, #204]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 80020b2:	68db      	ldr	r3, [r3, #12]
 80020b4:	f423 2278 	bic.w	r2, r3, #1015808	; 0xf8000
 80020b8:	687b      	ldr	r3, [r7, #4]
 80020ba:	6a1b      	ldr	r3, [r3, #32]
 80020bc:	03db      	lsls	r3, r3, #15
 80020be:	4930      	ldr	r1, [pc, #192]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 80020c0:	4313      	orrs	r3, r2
 80020c2:	60cb      	str	r3, [r1, #12]
                                                (pRCC_OscInitStruct->MSIClockRange));

          if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 80020c4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80020c6:	2b00      	cmp	r3, #0
 80020c8:	d10a      	bne.n	80020e0 <HAL_RCC_OscConfig+0x1e0>
          {
            if (RCC_SetFlashLatencyFromMSIRange(pRCC_OscInitStruct->MSIClockRange) != HAL_OK)
 80020ca:	687b      	ldr	r3, [r7, #4]
 80020cc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80020ce:	4618      	mov	r0, r3
 80020d0:	f001 f974 	bl	80033bc <RCC_SetFlashLatencyFromMSIRange>
 80020d4:	4603      	mov	r3, r0
 80020d6:	2b00      	cmp	r3, #0
 80020d8:	d002      	beq.n	80020e0 <HAL_RCC_OscConfig+0x1e0>
            {
              return HAL_ERROR;
 80020da:	2301      	movs	r3, #1
 80020dc:	f000 bde5 	b.w	8002caa <HAL_RCC_OscConfig+0xdaa>
            }
          }
        }

        /* Update the SystemCoreClock global variable */
        (void) HAL_RCC_GetHCLKFreq();
 80020e0:	f001 f8de 	bl	80032a0 <HAL_RCC_GetHCLKFreq>
        /* Configure the source of time base considering new system clocks settings*/
        status = HAL_InitTick(uwTickPrio);
 80020e4:	4b27      	ldr	r3, [pc, #156]	; (8002184 <HAL_RCC_OscConfig+0x284>)
 80020e6:	681b      	ldr	r3, [r3, #0]
 80020e8:	4618      	mov	r0, r3
 80020ea:	f7ff f92b 	bl	8001344 <HAL_InitTick>
 80020ee:	4603      	mov	r3, r0
 80020f0:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        if (status != HAL_OK)
 80020f4:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80020f8:	2b00      	cmp	r3, #0
 80020fa:	f000 808a 	beq.w	8002212 <HAL_RCC_OscConfig+0x312>
        {
          return status;
 80020fe:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8002102:	f000 bdd2 	b.w	8002caa <HAL_RCC_OscConfig+0xdaa>
      }
    }
    else
    {
      /* Check the MSI State */
      if (pRCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8002106:	687b      	ldr	r3, [r7, #4]
 8002108:	69db      	ldr	r3, [r3, #28]
 800210a:	2b00      	cmp	r3, #0
 800210c:	d066      	beq.n	80021dc <HAL_RCC_OscConfig+0x2dc>
      {
        /* Enable the Internal High Speed oscillator (MSI) */
        __HAL_RCC_MSI_ENABLE();
 800210e:	4b1c      	ldr	r3, [pc, #112]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8002110:	681b      	ldr	r3, [r3, #0]
 8002112:	4a1b      	ldr	r2, [pc, #108]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8002114:	f043 0301 	orr.w	r3, r3, #1
 8002118:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 800211a:	f7ff fabb 	bl	8001694 <HAL_GetTick>
 800211e:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait till MSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_MSISRDY) == 0U)
 8002120:	e009      	b.n	8002136 <HAL_RCC_OscConfig+0x236>
        {
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8002122:	f7ff fab7 	bl	8001694 <HAL_GetTick>
 8002126:	4602      	mov	r2, r0
 8002128:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800212a:	1ad3      	subs	r3, r2, r3
 800212c:	2b02      	cmp	r3, #2
 800212e:	d902      	bls.n	8002136 <HAL_RCC_OscConfig+0x236>
          {
            return HAL_TIMEOUT;
 8002130:	2303      	movs	r3, #3
 8002132:	f000 bdba 	b.w	8002caa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_MSISRDY) == 0U)
 8002136:	4b12      	ldr	r3, [pc, #72]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8002138:	681b      	ldr	r3, [r3, #0]
 800213a:	f003 0304 	and.w	r3, r3, #4
 800213e:	2b00      	cmp	r3, #0
 8002140:	d0ef      	beq.n	8002122 <HAL_RCC_OscConfig+0x222>
          }
        }
        /* Selects the Multiple Speed oscillator (MSI) clock range */
        __HAL_RCC_MSI_RANGE_CONFIG(pRCC_OscInitStruct->MSIClockRange);
 8002142:	4b0f      	ldr	r3, [pc, #60]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8002144:	689b      	ldr	r3, [r3, #8]
 8002146:	4a0e      	ldr	r2, [pc, #56]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8002148:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800214c:	6093      	str	r3, [r2, #8]
 800214e:	4b0c      	ldr	r3, [pc, #48]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8002150:	689b      	ldr	r3, [r3, #8]
 8002152:	f023 4270 	bic.w	r2, r3, #4026531840	; 0xf0000000
 8002156:	687b      	ldr	r3, [r7, #4]
 8002158:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800215a:	4909      	ldr	r1, [pc, #36]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 800215c:	4313      	orrs	r3, r2
 800215e:	608b      	str	r3, [r1, #8]
        /* Adjusts the Multiple Speed oscillator (MSI) calibration value */
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST((pRCC_OscInitStruct->MSICalibrationValue), \
 8002160:	687b      	ldr	r3, [r7, #4]
 8002162:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002164:	f1b3 4f40 	cmp.w	r3, #3221225472	; 0xc0000000
 8002168:	d30e      	bcc.n	8002188 <HAL_RCC_OscConfig+0x288>
 800216a:	4b05      	ldr	r3, [pc, #20]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 800216c:	68db      	ldr	r3, [r3, #12]
 800216e:	f023 021f 	bic.w	r2, r3, #31
 8002172:	687b      	ldr	r3, [r7, #4]
 8002174:	6a1b      	ldr	r3, [r3, #32]
 8002176:	4902      	ldr	r1, [pc, #8]	; (8002180 <HAL_RCC_OscConfig+0x280>)
 8002178:	4313      	orrs	r3, r2
 800217a:	60cb      	str	r3, [r1, #12]
 800217c:	e04a      	b.n	8002214 <HAL_RCC_OscConfig+0x314>
 800217e:	bf00      	nop
 8002180:	46020c00 	.word	0x46020c00
 8002184:	20000004 	.word	0x20000004
 8002188:	687b      	ldr	r3, [r7, #4]
 800218a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800218c:	2b00      	cmp	r3, #0
 800218e:	da0a      	bge.n	80021a6 <HAL_RCC_OscConfig+0x2a6>
 8002190:	4b98      	ldr	r3, [pc, #608]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 8002192:	68db      	ldr	r3, [r3, #12]
 8002194:	f423 7278 	bic.w	r2, r3, #992	; 0x3e0
 8002198:	687b      	ldr	r3, [r7, #4]
 800219a:	6a1b      	ldr	r3, [r3, #32]
 800219c:	015b      	lsls	r3, r3, #5
 800219e:	4995      	ldr	r1, [pc, #596]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80021a0:	4313      	orrs	r3, r2
 80021a2:	60cb      	str	r3, [r1, #12]
 80021a4:	e036      	b.n	8002214 <HAL_RCC_OscConfig+0x314>
 80021a6:	687b      	ldr	r3, [r7, #4]
 80021a8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80021aa:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80021ae:	d30a      	bcc.n	80021c6 <HAL_RCC_OscConfig+0x2c6>
 80021b0:	4b90      	ldr	r3, [pc, #576]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80021b2:	68db      	ldr	r3, [r3, #12]
 80021b4:	f423 42f8 	bic.w	r2, r3, #31744	; 0x7c00
 80021b8:	687b      	ldr	r3, [r7, #4]
 80021ba:	6a1b      	ldr	r3, [r3, #32]
 80021bc:	029b      	lsls	r3, r3, #10
 80021be:	498d      	ldr	r1, [pc, #564]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80021c0:	4313      	orrs	r3, r2
 80021c2:	60cb      	str	r3, [r1, #12]
 80021c4:	e026      	b.n	8002214 <HAL_RCC_OscConfig+0x314>
 80021c6:	4b8b      	ldr	r3, [pc, #556]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80021c8:	68db      	ldr	r3, [r3, #12]
 80021ca:	f423 2278 	bic.w	r2, r3, #1015808	; 0xf8000
 80021ce:	687b      	ldr	r3, [r7, #4]
 80021d0:	6a1b      	ldr	r3, [r3, #32]
 80021d2:	03db      	lsls	r3, r3, #15
 80021d4:	4987      	ldr	r1, [pc, #540]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80021d6:	4313      	orrs	r3, r2
 80021d8:	60cb      	str	r3, [r1, #12]
 80021da:	e01b      	b.n	8002214 <HAL_RCC_OscConfig+0x314>

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI) */
        __HAL_RCC_MSI_DISABLE();
 80021dc:	4b85      	ldr	r3, [pc, #532]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80021de:	681b      	ldr	r3, [r3, #0]
 80021e0:	4a84      	ldr	r2, [pc, #528]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80021e2:	f023 0301 	bic.w	r3, r3, #1
 80021e6:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 80021e8:	f7ff fa54 	bl	8001694 <HAL_GetTick>
 80021ec:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait till MSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_MSISRDY) != 0U)
 80021ee:	e009      	b.n	8002204 <HAL_RCC_OscConfig+0x304>
        {
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80021f0:	f7ff fa50 	bl	8001694 <HAL_GetTick>
 80021f4:	4602      	mov	r2, r0
 80021f6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80021f8:	1ad3      	subs	r3, r2, r3
 80021fa:	2b02      	cmp	r3, #2
 80021fc:	d902      	bls.n	8002204 <HAL_RCC_OscConfig+0x304>
          {
            return HAL_TIMEOUT;
 80021fe:	2303      	movs	r3, #3
 8002200:	f000 bd53 	b.w	8002caa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_MSISRDY) != 0U)
 8002204:	4b7b      	ldr	r3, [pc, #492]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 8002206:	681b      	ldr	r3, [r3, #0]
 8002208:	f003 0304 	and.w	r3, r3, #4
 800220c:	2b00      	cmp	r3, #0
 800220e:	d1ef      	bne.n	80021f0 <HAL_RCC_OscConfig+0x2f0>
 8002210:	e000      	b.n	8002214 <HAL_RCC_OscConfig+0x314>
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
 8002212:	bf00      	nop
        }
      }
    }
  }
  /*------------------------------- HSE Configuration ------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002214:	687b      	ldr	r3, [r7, #4]
 8002216:	681b      	ldr	r3, [r3, #0]
 8002218:	f003 0301 	and.w	r3, r3, #1
 800221c:	2b00      	cmp	r3, #0
 800221e:	f000 808b 	beq.w	8002338 <HAL_RCC_OscConfig+0x438>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(pRCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 8002222:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8002224:	2b08      	cmp	r3, #8
 8002226:	d005      	beq.n	8002234 <HAL_RCC_OscConfig+0x334>
 8002228:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800222a:	2b0c      	cmp	r3, #12
 800222c:	d109      	bne.n	8002242 <HAL_RCC_OscConfig+0x342>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 800222e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002230:	2b03      	cmp	r3, #3
 8002232:	d106      	bne.n	8002242 <HAL_RCC_OscConfig+0x342>
    {
      if (pRCC_OscInitStruct->HSEState == RCC_HSE_OFF)
 8002234:	687b      	ldr	r3, [r7, #4]
 8002236:	685b      	ldr	r3, [r3, #4]
 8002238:	2b00      	cmp	r3, #0
 800223a:	d17d      	bne.n	8002338 <HAL_RCC_OscConfig+0x438>
      {
        return HAL_ERROR;
 800223c:	2301      	movs	r3, #1
 800223e:	f000 bd34 	b.w	8002caa <HAL_RCC_OscConfig+0xdaa>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
 8002242:	687b      	ldr	r3, [r7, #4]
 8002244:	685b      	ldr	r3, [r3, #4]
 8002246:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800224a:	d106      	bne.n	800225a <HAL_RCC_OscConfig+0x35a>
 800224c:	4b69      	ldr	r3, [pc, #420]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 800224e:	681b      	ldr	r3, [r3, #0]
 8002250:	4a68      	ldr	r2, [pc, #416]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 8002252:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002256:	6013      	str	r3, [r2, #0]
 8002258:	e041      	b.n	80022de <HAL_RCC_OscConfig+0x3de>
 800225a:	687b      	ldr	r3, [r7, #4]
 800225c:	685b      	ldr	r3, [r3, #4]
 800225e:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8002262:	d112      	bne.n	800228a <HAL_RCC_OscConfig+0x38a>
 8002264:	4b63      	ldr	r3, [pc, #396]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 8002266:	681b      	ldr	r3, [r3, #0]
 8002268:	4a62      	ldr	r2, [pc, #392]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 800226a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800226e:	6013      	str	r3, [r2, #0]
 8002270:	4b60      	ldr	r3, [pc, #384]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 8002272:	681b      	ldr	r3, [r3, #0]
 8002274:	4a5f      	ldr	r2, [pc, #380]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 8002276:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 800227a:	6013      	str	r3, [r2, #0]
 800227c:	4b5d      	ldr	r3, [pc, #372]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 800227e:	681b      	ldr	r3, [r3, #0]
 8002280:	4a5c      	ldr	r2, [pc, #368]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 8002282:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002286:	6013      	str	r3, [r2, #0]
 8002288:	e029      	b.n	80022de <HAL_RCC_OscConfig+0x3de>
 800228a:	687b      	ldr	r3, [r7, #4]
 800228c:	685b      	ldr	r3, [r3, #4]
 800228e:	f5b3 1fa8 	cmp.w	r3, #1376256	; 0x150000
 8002292:	d112      	bne.n	80022ba <HAL_RCC_OscConfig+0x3ba>
 8002294:	4b57      	ldr	r3, [pc, #348]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 8002296:	681b      	ldr	r3, [r3, #0]
 8002298:	4a56      	ldr	r2, [pc, #344]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 800229a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800229e:	6013      	str	r3, [r2, #0]
 80022a0:	4b54      	ldr	r3, [pc, #336]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80022a2:	681b      	ldr	r3, [r3, #0]
 80022a4:	4a53      	ldr	r2, [pc, #332]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80022a6:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80022aa:	6013      	str	r3, [r2, #0]
 80022ac:	4b51      	ldr	r3, [pc, #324]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80022ae:	681b      	ldr	r3, [r3, #0]
 80022b0:	4a50      	ldr	r2, [pc, #320]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80022b2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80022b6:	6013      	str	r3, [r2, #0]
 80022b8:	e011      	b.n	80022de <HAL_RCC_OscConfig+0x3de>
 80022ba:	4b4e      	ldr	r3, [pc, #312]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80022bc:	681b      	ldr	r3, [r3, #0]
 80022be:	4a4d      	ldr	r2, [pc, #308]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80022c0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80022c4:	6013      	str	r3, [r2, #0]
 80022c6:	4b4b      	ldr	r3, [pc, #300]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80022c8:	681b      	ldr	r3, [r3, #0]
 80022ca:	4a4a      	ldr	r2, [pc, #296]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80022cc:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80022d0:	6013      	str	r3, [r2, #0]
 80022d2:	4b48      	ldr	r3, [pc, #288]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80022d4:	681b      	ldr	r3, [r3, #0]
 80022d6:	4a47      	ldr	r2, [pc, #284]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80022d8:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 80022dc:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80022de:	687b      	ldr	r3, [r7, #4]
 80022e0:	685b      	ldr	r3, [r3, #4]
 80022e2:	2b00      	cmp	r3, #0
 80022e4:	d014      	beq.n	8002310 <HAL_RCC_OscConfig+0x410>
      {
        tickstart = HAL_GetTick();
 80022e6:	f7ff f9d5 	bl	8001694 <HAL_GetTick>
 80022ea:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait till HSE is ready */
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 80022ec:	e009      	b.n	8002302 <HAL_RCC_OscConfig+0x402>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80022ee:	f7ff f9d1 	bl	8001694 <HAL_GetTick>
 80022f2:	4602      	mov	r2, r0
 80022f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80022f6:	1ad3      	subs	r3, r2, r3
 80022f8:	2b64      	cmp	r3, #100	; 0x64
 80022fa:	d902      	bls.n	8002302 <HAL_RCC_OscConfig+0x402>
          {
            return HAL_TIMEOUT;
 80022fc:	2303      	movs	r3, #3
 80022fe:	f000 bcd4 	b.w	8002caa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8002302:	4b3c      	ldr	r3, [pc, #240]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 8002304:	681b      	ldr	r3, [r3, #0]
 8002306:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800230a:	2b00      	cmp	r3, #0
 800230c:	d0ef      	beq.n	80022ee <HAL_RCC_OscConfig+0x3ee>
 800230e:	e013      	b.n	8002338 <HAL_RCC_OscConfig+0x438>
          }
        }
      }
      else
      {
        tickstart = HAL_GetTick();
 8002310:	f7ff f9c0 	bl	8001694 <HAL_GetTick>
 8002314:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait till HSE is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8002316:	e009      	b.n	800232c <HAL_RCC_OscConfig+0x42c>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8002318:	f7ff f9bc 	bl	8001694 <HAL_GetTick>
 800231c:	4602      	mov	r2, r0
 800231e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002320:	1ad3      	subs	r3, r2, r3
 8002322:	2b64      	cmp	r3, #100	; 0x64
 8002324:	d902      	bls.n	800232c <HAL_RCC_OscConfig+0x42c>
          {
            return HAL_TIMEOUT;
 8002326:	2303      	movs	r3, #3
 8002328:	f000 bcbf 	b.w	8002caa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 800232c:	4b31      	ldr	r3, [pc, #196]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 800232e:	681b      	ldr	r3, [r3, #0]
 8002330:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8002334:	2b00      	cmp	r3, #0
 8002336:	d1ef      	bne.n	8002318 <HAL_RCC_OscConfig+0x418>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8002338:	687b      	ldr	r3, [r7, #4]
 800233a:	681b      	ldr	r3, [r3, #0]
 800233c:	f003 0302 	and.w	r3, r3, #2
 8002340:	2b00      	cmp	r3, #0
 8002342:	d05f      	beq.n	8002404 <HAL_RCC_OscConfig+0x504>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(pRCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 8002344:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8002346:	2b04      	cmp	r3, #4
 8002348:	d005      	beq.n	8002356 <HAL_RCC_OscConfig+0x456>
 800234a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800234c:	2b0c      	cmp	r3, #12
 800234e:	d114      	bne.n	800237a <HAL_RCC_OscConfig+0x47a>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 8002350:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002352:	2b02      	cmp	r3, #2
 8002354:	d111      	bne.n	800237a <HAL_RCC_OscConfig+0x47a>
    {
      /* When HSI is used as system clock it will not be disabled */
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
 8002356:	687b      	ldr	r3, [r7, #4]
 8002358:	68db      	ldr	r3, [r3, #12]
 800235a:	2b00      	cmp	r3, #0
 800235c:	d102      	bne.n	8002364 <HAL_RCC_OscConfig+0x464>
      {
        return HAL_ERROR;
 800235e:	2301      	movs	r3, #1
 8002360:	f000 bca3 	b.w	8002caa <HAL_RCC_OscConfig+0xdaa>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
 8002364:	4b23      	ldr	r3, [pc, #140]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 8002366:	691b      	ldr	r3, [r3, #16]
 8002368:	f423 12f8 	bic.w	r2, r3, #2031616	; 0x1f0000
 800236c:	687b      	ldr	r3, [r7, #4]
 800236e:	691b      	ldr	r3, [r3, #16]
 8002370:	041b      	lsls	r3, r3, #16
 8002372:	4920      	ldr	r1, [pc, #128]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 8002374:	4313      	orrs	r3, r2
 8002376:	610b      	str	r3, [r1, #16]
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
 8002378:	e044      	b.n	8002404 <HAL_RCC_OscConfig+0x504>
      }
    }
    else
    {
      /* Check the HSI State */
      if (pRCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 800237a:	687b      	ldr	r3, [r7, #4]
 800237c:	68db      	ldr	r3, [r3, #12]
 800237e:	2b00      	cmp	r3, #0
 8002380:	d024      	beq.n	80023cc <HAL_RCC_OscConfig+0x4cc>
      {
        /* Enable the Internal High Speed oscillator (HSI) */
        __HAL_RCC_HSI_ENABLE();
 8002382:	4b1c      	ldr	r3, [pc, #112]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 8002384:	681b      	ldr	r3, [r3, #0]
 8002386:	4a1b      	ldr	r2, [pc, #108]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 8002388:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800238c:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 800238e:	f7ff f981 	bl	8001694 <HAL_GetTick>
 8002392:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait till HSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8002394:	e009      	b.n	80023aa <HAL_RCC_OscConfig+0x4aa>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8002396:	f7ff f97d 	bl	8001694 <HAL_GetTick>
 800239a:	4602      	mov	r2, r0
 800239c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800239e:	1ad3      	subs	r3, r2, r3
 80023a0:	2b02      	cmp	r3, #2
 80023a2:	d902      	bls.n	80023aa <HAL_RCC_OscConfig+0x4aa>
          {
            return HAL_TIMEOUT;
 80023a4:	2303      	movs	r3, #3
 80023a6:	f000 bc80 	b.w	8002caa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 80023aa:	4b12      	ldr	r3, [pc, #72]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80023ac:	681b      	ldr	r3, [r3, #0]
 80023ae:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80023b2:	2b00      	cmp	r3, #0
 80023b4:	d0ef      	beq.n	8002396 <HAL_RCC_OscConfig+0x496>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
 80023b6:	4b0f      	ldr	r3, [pc, #60]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80023b8:	691b      	ldr	r3, [r3, #16]
 80023ba:	f423 12f8 	bic.w	r2, r3, #2031616	; 0x1f0000
 80023be:	687b      	ldr	r3, [r7, #4]
 80023c0:	691b      	ldr	r3, [r3, #16]
 80023c2:	041b      	lsls	r3, r3, #16
 80023c4:	490b      	ldr	r1, [pc, #44]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80023c6:	4313      	orrs	r3, r2
 80023c8:	610b      	str	r3, [r1, #16]
 80023ca:	e01b      	b.n	8002404 <HAL_RCC_OscConfig+0x504>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI) */
        __HAL_RCC_HSI_DISABLE();
 80023cc:	4b09      	ldr	r3, [pc, #36]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80023ce:	681b      	ldr	r3, [r3, #0]
 80023d0:	4a08      	ldr	r2, [pc, #32]	; (80023f4 <HAL_RCC_OscConfig+0x4f4>)
 80023d2:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80023d6:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 80023d8:	f7ff f95c 	bl	8001694 <HAL_GetTick>
 80023dc:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait till HSI is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 80023de:	e00b      	b.n	80023f8 <HAL_RCC_OscConfig+0x4f8>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80023e0:	f7ff f958 	bl	8001694 <HAL_GetTick>
 80023e4:	4602      	mov	r2, r0
 80023e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80023e8:	1ad3      	subs	r3, r2, r3
 80023ea:	2b02      	cmp	r3, #2
 80023ec:	d904      	bls.n	80023f8 <HAL_RCC_OscConfig+0x4f8>
          {
            return HAL_TIMEOUT;
 80023ee:	2303      	movs	r3, #3
 80023f0:	f000 bc5b 	b.w	8002caa <HAL_RCC_OscConfig+0xdaa>
 80023f4:	46020c00 	.word	0x46020c00
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 80023f8:	4baf      	ldr	r3, [pc, #700]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 80023fa:	681b      	ldr	r3, [r3, #0]
 80023fc:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8002400:	2b00      	cmp	r3, #0
 8002402:	d1ed      	bne.n	80023e0 <HAL_RCC_OscConfig+0x4e0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8002404:	687b      	ldr	r3, [r7, #4]
 8002406:	681b      	ldr	r3, [r3, #0]
 8002408:	f003 0308 	and.w	r3, r3, #8
 800240c:	2b00      	cmp	r3, #0
 800240e:	f000 80c8 	beq.w	80025a2 <HAL_RCC_OscConfig+0x6a2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(pRCC_OscInitStruct->LSIState));

    FlagStatus  pwrclkchanged = RESET;
 8002412:	2300      	movs	r3, #0
 8002414:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

    /* Update LSI configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8002418:	4ba7      	ldr	r3, [pc, #668]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 800241a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800241e:	f003 0304 	and.w	r3, r3, #4
 8002422:	2b00      	cmp	r3, #0
 8002424:	d111      	bne.n	800244a <HAL_RCC_OscConfig+0x54a>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8002426:	4ba4      	ldr	r3, [pc, #656]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 8002428:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800242c:	4aa2      	ldr	r2, [pc, #648]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 800242e:	f043 0304 	orr.w	r3, r3, #4
 8002432:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 8002436:	4ba0      	ldr	r3, [pc, #640]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 8002438:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800243c:	f003 0304 	and.w	r3, r3, #4
 8002440:	617b      	str	r3, [r7, #20]
 8002442:	697b      	ldr	r3, [r7, #20]
      pwrclkchanged = SET;
 8002444:	2301      	movs	r3, #1
 8002446:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
    }

    if (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 800244a:	4b9c      	ldr	r3, [pc, #624]	; (80026bc <HAL_RCC_OscConfig+0x7bc>)
 800244c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800244e:	f003 0301 	and.w	r3, r3, #1
 8002452:	2b00      	cmp	r3, #0
 8002454:	d119      	bne.n	800248a <HAL_RCC_OscConfig+0x58a>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPR, PWR_DBPR_DBP);
 8002456:	4b99      	ldr	r3, [pc, #612]	; (80026bc <HAL_RCC_OscConfig+0x7bc>)
 8002458:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800245a:	4a98      	ldr	r2, [pc, #608]	; (80026bc <HAL_RCC_OscConfig+0x7bc>)
 800245c:	f043 0301 	orr.w	r3, r3, #1
 8002460:	6293      	str	r3, [r2, #40]	; 0x28

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8002462:	f7ff f917 	bl	8001694 <HAL_GetTick>
 8002466:	62b8      	str	r0, [r7, #40]	; 0x28

      while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8002468:	e009      	b.n	800247e <HAL_RCC_OscConfig+0x57e>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800246a:	f7ff f913 	bl	8001694 <HAL_GetTick>
 800246e:	4602      	mov	r2, r0
 8002470:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002472:	1ad3      	subs	r3, r2, r3
 8002474:	2b02      	cmp	r3, #2
 8002476:	d902      	bls.n	800247e <HAL_RCC_OscConfig+0x57e>
        {
          return HAL_TIMEOUT;
 8002478:	2303      	movs	r3, #3
 800247a:	f000 bc16 	b.w	8002caa <HAL_RCC_OscConfig+0xdaa>
      while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 800247e:	4b8f      	ldr	r3, [pc, #572]	; (80026bc <HAL_RCC_OscConfig+0x7bc>)
 8002480:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002482:	f003 0301 	and.w	r3, r3, #1
 8002486:	2b00      	cmp	r3, #0
 8002488:	d0ef      	beq.n	800246a <HAL_RCC_OscConfig+0x56a>
        }
      }
    }
    /* Check the LSI State */
    if (pRCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800248a:	687b      	ldr	r3, [r7, #4]
 800248c:	695b      	ldr	r3, [r3, #20]
 800248e:	2b00      	cmp	r3, #0
 8002490:	d05f      	beq.n	8002552 <HAL_RCC_OscConfig+0x652>
    {
      uint32_t bdcr_temp = RCC->BDCR;
 8002492:	4b89      	ldr	r3, [pc, #548]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 8002494:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8002498:	623b      	str	r3, [r7, #32]

      /* Check LSI division factor */
      assert_param(IS_RCC_LSIDIV(pRCC_OscInitStruct->LSIDiv));

      if (pRCC_OscInitStruct->LSIDiv != (bdcr_temp & RCC_BDCR_LSIPREDIV))
 800249a:	687b      	ldr	r3, [r7, #4]
 800249c:	699a      	ldr	r2, [r3, #24]
 800249e:	6a3b      	ldr	r3, [r7, #32]
 80024a0:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80024a4:	429a      	cmp	r2, r3
 80024a6:	d037      	beq.n	8002518 <HAL_RCC_OscConfig+0x618>
      {
        if (((bdcr_temp & RCC_BDCR_LSIRDY) == RCC_BDCR_LSIRDY) && \
 80024a8:	6a3b      	ldr	r3, [r7, #32]
 80024aa:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80024ae:	2b00      	cmp	r3, #0
 80024b0:	d006      	beq.n	80024c0 <HAL_RCC_OscConfig+0x5c0>
            ((bdcr_temp & RCC_BDCR_LSION) != RCC_BDCR_LSION))
 80024b2:	6a3b      	ldr	r3, [r7, #32]
 80024b4:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
        if (((bdcr_temp & RCC_BDCR_LSIRDY) == RCC_BDCR_LSIRDY) && \
 80024b8:	2b00      	cmp	r3, #0
 80024ba:	d101      	bne.n	80024c0 <HAL_RCC_OscConfig+0x5c0>
        {
          /* If LSIRDY is set while LSION is not enabled, LSIPREDIV can't be updated */
          /* The LSIPREDIV cannot be changed if the LSI is used by the IWDG or by the RTC */
          return HAL_ERROR;
 80024bc:	2301      	movs	r3, #1
 80024be:	e3f4      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
        }

        /* Turn off LSI before changing RCC_BDCR_LSIPREDIV */
        if ((bdcr_temp & RCC_BDCR_LSION) == RCC_BDCR_LSION)
 80024c0:	6a3b      	ldr	r3, [r7, #32]
 80024c2:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 80024c6:	2b00      	cmp	r3, #0
 80024c8:	d01b      	beq.n	8002502 <HAL_RCC_OscConfig+0x602>
        {
          __HAL_RCC_LSI_DISABLE();
 80024ca:	4b7b      	ldr	r3, [pc, #492]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 80024cc:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80024d0:	4a79      	ldr	r2, [pc, #484]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 80024d2:	f023 53a0 	bic.w	r3, r3, #335544320	; 0x14000000
 80024d6:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0

          tickstart = HAL_GetTick();
 80024da:	f7ff f8db 	bl	8001694 <HAL_GetTick>
 80024de:	62b8      	str	r0, [r7, #40]	; 0x28

          /* Wait till LSI is disabled */
          while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
 80024e0:	e008      	b.n	80024f4 <HAL_RCC_OscConfig+0x5f4>
          {
            if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80024e2:	f7ff f8d7 	bl	8001694 <HAL_GetTick>
 80024e6:	4602      	mov	r2, r0
 80024e8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80024ea:	1ad3      	subs	r3, r2, r3
 80024ec:	2b05      	cmp	r3, #5
 80024ee:	d901      	bls.n	80024f4 <HAL_RCC_OscConfig+0x5f4>
            {
              return HAL_TIMEOUT;
 80024f0:	2303      	movs	r3, #3
 80024f2:	e3da      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
          while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
 80024f4:	4b70      	ldr	r3, [pc, #448]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 80024f6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80024fa:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80024fe:	2b00      	cmp	r3, #0
 8002500:	d1ef      	bne.n	80024e2 <HAL_RCC_OscConfig+0x5e2>
            }
          }
        }

        /* Set LSI division factor */
        MODIFY_REG(RCC->BDCR, RCC_BDCR_LSIPREDIV, pRCC_OscInitStruct->LSIDiv);
 8002502:	4b6d      	ldr	r3, [pc, #436]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 8002504:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8002508:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
 800250c:	687b      	ldr	r3, [r7, #4]
 800250e:	699b      	ldr	r3, [r3, #24]
 8002510:	4969      	ldr	r1, [pc, #420]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 8002512:	4313      	orrs	r3, r2
 8002514:	f8c1 30f0 	str.w	r3, [r1, #240]	; 0xf0
      }

      /* Enable the Internal Low Speed oscillator (LSI) */
      __HAL_RCC_LSI_ENABLE();
 8002518:	4b67      	ldr	r3, [pc, #412]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 800251a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 800251e:	4a66      	ldr	r2, [pc, #408]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 8002520:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8002524:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0

      tickstart = HAL_GetTick();
 8002528:	f7ff f8b4 	bl	8001694 <HAL_GetTick>
 800252c:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till LSI is ready */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) == 0U)
 800252e:	e008      	b.n	8002542 <HAL_RCC_OscConfig+0x642>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8002530:	f7ff f8b0 	bl	8001694 <HAL_GetTick>
 8002534:	4602      	mov	r2, r0
 8002536:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002538:	1ad3      	subs	r3, r2, r3
 800253a:	2b05      	cmp	r3, #5
 800253c:	d901      	bls.n	8002542 <HAL_RCC_OscConfig+0x642>
        {
          return HAL_TIMEOUT;
 800253e:	2303      	movs	r3, #3
 8002540:	e3b3      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) == 0U)
 8002542:	4b5d      	ldr	r3, [pc, #372]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 8002544:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8002548:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800254c:	2b00      	cmp	r3, #0
 800254e:	d0ef      	beq.n	8002530 <HAL_RCC_OscConfig+0x630>
 8002550:	e01b      	b.n	800258a <HAL_RCC_OscConfig+0x68a>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI) */
      __HAL_RCC_LSI_DISABLE();
 8002552:	4b59      	ldr	r3, [pc, #356]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 8002554:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8002558:	4a57      	ldr	r2, [pc, #348]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 800255a:	f023 53a0 	bic.w	r3, r3, #335544320	; 0x14000000
 800255e:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0

      tickstart = HAL_GetTick();
 8002562:	f7ff f897 	bl	8001694 <HAL_GetTick>
 8002566:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till LSI is disabled */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
 8002568:	e008      	b.n	800257c <HAL_RCC_OscConfig+0x67c>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800256a:	f7ff f893 	bl	8001694 <HAL_GetTick>
 800256e:	4602      	mov	r2, r0
 8002570:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002572:	1ad3      	subs	r3, r2, r3
 8002574:	2b05      	cmp	r3, #5
 8002576:	d901      	bls.n	800257c <HAL_RCC_OscConfig+0x67c>
        {
          return HAL_TIMEOUT;
 8002578:	2303      	movs	r3, #3
 800257a:	e396      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
 800257c:	4b4e      	ldr	r3, [pc, #312]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 800257e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8002582:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8002586:	2b00      	cmp	r3, #0
 8002588:	d1ef      	bne.n	800256a <HAL_RCC_OscConfig+0x66a>
        }
      }
    }
    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 800258a:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 800258e:	2b01      	cmp	r3, #1
 8002590:	d107      	bne.n	80025a2 <HAL_RCC_OscConfig+0x6a2>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8002592:	4b49      	ldr	r3, [pc, #292]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 8002594:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002598:	4a47      	ldr	r2, [pc, #284]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 800259a:	f023 0304 	bic.w	r3, r3, #4
 800259e:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80025a2:	687b      	ldr	r3, [r7, #4]
 80025a4:	681b      	ldr	r3, [r3, #0]
 80025a6:	f003 0304 	and.w	r3, r3, #4
 80025aa:	2b00      	cmp	r3, #0
 80025ac:	f000 8111 	beq.w	80027d2 <HAL_RCC_OscConfig+0x8d2>
  {
    FlagStatus pwrclkchanged = RESET;
 80025b0:	2300      	movs	r3, #0
 80025b2:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
    /* Check the parameters */
    assert_param(IS_RCC_LSE(pRCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 80025b6:	4b40      	ldr	r3, [pc, #256]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 80025b8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80025bc:	f003 0304 	and.w	r3, r3, #4
 80025c0:	2b00      	cmp	r3, #0
 80025c2:	d111      	bne.n	80025e8 <HAL_RCC_OscConfig+0x6e8>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80025c4:	4b3c      	ldr	r3, [pc, #240]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 80025c6:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80025ca:	4a3b      	ldr	r2, [pc, #236]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 80025cc:	f043 0304 	orr.w	r3, r3, #4
 80025d0:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 80025d4:	4b38      	ldr	r3, [pc, #224]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 80025d6:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80025da:	f003 0304 	and.w	r3, r3, #4
 80025de:	613b      	str	r3, [r7, #16]
 80025e0:	693b      	ldr	r3, [r7, #16]
      pwrclkchanged = SET;
 80025e2:	2301      	movs	r3, #1
 80025e4:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
    }

    if (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 80025e8:	4b34      	ldr	r3, [pc, #208]	; (80026bc <HAL_RCC_OscConfig+0x7bc>)
 80025ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80025ec:	f003 0301 	and.w	r3, r3, #1
 80025f0:	2b00      	cmp	r3, #0
 80025f2:	d118      	bne.n	8002626 <HAL_RCC_OscConfig+0x726>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPR, PWR_DBPR_DBP);
 80025f4:	4b31      	ldr	r3, [pc, #196]	; (80026bc <HAL_RCC_OscConfig+0x7bc>)
 80025f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80025f8:	4a30      	ldr	r2, [pc, #192]	; (80026bc <HAL_RCC_OscConfig+0x7bc>)
 80025fa:	f043 0301 	orr.w	r3, r3, #1
 80025fe:	6293      	str	r3, [r2, #40]	; 0x28

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8002600:	f7ff f848 	bl	8001694 <HAL_GetTick>
 8002604:	62b8      	str	r0, [r7, #40]	; 0x28

      while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8002606:	e008      	b.n	800261a <HAL_RCC_OscConfig+0x71a>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8002608:	f7ff f844 	bl	8001694 <HAL_GetTick>
 800260c:	4602      	mov	r2, r0
 800260e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002610:	1ad3      	subs	r3, r2, r3
 8002612:	2b02      	cmp	r3, #2
 8002614:	d901      	bls.n	800261a <HAL_RCC_OscConfig+0x71a>
        {
          return HAL_TIMEOUT;
 8002616:	2303      	movs	r3, #3
 8002618:	e347      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
      while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 800261a:	4b28      	ldr	r3, [pc, #160]	; (80026bc <HAL_RCC_OscConfig+0x7bc>)
 800261c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800261e:	f003 0301 	and.w	r3, r3, #1
 8002622:	2b00      	cmp	r3, #0
 8002624:	d0f0      	beq.n	8002608 <HAL_RCC_OscConfig+0x708>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    if ((pRCC_OscInitStruct->LSEState & RCC_BDCR_LSEON) != 0U)
 8002626:	687b      	ldr	r3, [r7, #4]
 8002628:	689b      	ldr	r3, [r3, #8]
 800262a:	f003 0301 	and.w	r3, r3, #1
 800262e:	2b00      	cmp	r3, #0
 8002630:	d01f      	beq.n	8002672 <HAL_RCC_OscConfig+0x772>
    {
      if ((pRCC_OscInitStruct->LSEState & RCC_BDCR_LSEBYP) != 0U)
 8002632:	687b      	ldr	r3, [r7, #4]
 8002634:	689b      	ldr	r3, [r3, #8]
 8002636:	f003 0304 	and.w	r3, r3, #4
 800263a:	2b00      	cmp	r3, #0
 800263c:	d010      	beq.n	8002660 <HAL_RCC_OscConfig+0x760>
      {
        /* LSE oscillator bypass enable */
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 800263e:	4b1e      	ldr	r3, [pc, #120]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 8002640:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8002644:	4a1c      	ldr	r2, [pc, #112]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 8002646:	f043 0304 	orr.w	r3, r3, #4
 800264a:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 800264e:	4b1a      	ldr	r3, [pc, #104]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 8002650:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8002654:	4a18      	ldr	r2, [pc, #96]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 8002656:	f043 0301 	orr.w	r3, r3, #1
 800265a:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
 800265e:	e018      	b.n	8002692 <HAL_RCC_OscConfig+0x792>
      }
      else
      {
        /* LSE oscillator enable */
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8002660:	4b15      	ldr	r3, [pc, #84]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 8002662:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8002666:	4a14      	ldr	r2, [pc, #80]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 8002668:	f043 0301 	orr.w	r3, r3, #1
 800266c:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
 8002670:	e00f      	b.n	8002692 <HAL_RCC_OscConfig+0x792>
      }
    }
    else
    {
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8002672:	4b11      	ldr	r3, [pc, #68]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 8002674:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8002678:	4a0f      	ldr	r2, [pc, #60]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 800267a:	f023 0301 	bic.w	r3, r3, #1
 800267e:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 8002682:	4b0d      	ldr	r3, [pc, #52]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 8002684:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8002688:	4a0b      	ldr	r2, [pc, #44]	; (80026b8 <HAL_RCC_OscConfig+0x7b8>)
 800268a:	f023 0304 	bic.w	r3, r3, #4
 800268e:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
    }

    /* Check the LSE State */
    if (pRCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8002692:	687b      	ldr	r3, [r7, #4]
 8002694:	689b      	ldr	r3, [r3, #8]
 8002696:	2b00      	cmp	r3, #0
 8002698:	d057      	beq.n	800274a <HAL_RCC_OscConfig+0x84a>
    {
      tickstart = HAL_GetTick();
 800269a:	f7fe fffb 	bl	8001694 <HAL_GetTick>
 800269e:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till LSE is ready */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80026a0:	e00e      	b.n	80026c0 <HAL_RCC_OscConfig+0x7c0>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80026a2:	f7fe fff7 	bl	8001694 <HAL_GetTick>
 80026a6:	4602      	mov	r2, r0
 80026a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80026aa:	1ad3      	subs	r3, r2, r3
 80026ac:	f241 3288 	movw	r2, #5000	; 0x1388
 80026b0:	4293      	cmp	r3, r2
 80026b2:	d905      	bls.n	80026c0 <HAL_RCC_OscConfig+0x7c0>
        {
          return HAL_TIMEOUT;
 80026b4:	2303      	movs	r3, #3
 80026b6:	e2f8      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
 80026b8:	46020c00 	.word	0x46020c00
 80026bc:	46020800 	.word	0x46020800
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80026c0:	4b9c      	ldr	r3, [pc, #624]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 80026c2:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80026c6:	f003 0302 	and.w	r3, r3, #2
 80026ca:	2b00      	cmp	r3, #0
 80026cc:	d0e9      	beq.n	80026a2 <HAL_RCC_OscConfig+0x7a2>
        }
      }

      /* Enable LSESYS additionally if requested */
      if ((pRCC_OscInitStruct->LSEState & RCC_BDCR_LSESYSEN) != 0U)
 80026ce:	687b      	ldr	r3, [r7, #4]
 80026d0:	689b      	ldr	r3, [r3, #8]
 80026d2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80026d6:	2b00      	cmp	r3, #0
 80026d8:	d01b      	beq.n	8002712 <HAL_RCC_OscConfig+0x812>
      {
        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 80026da:	4b96      	ldr	r3, [pc, #600]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 80026dc:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80026e0:	4a94      	ldr	r2, [pc, #592]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 80026e2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80026e6:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0

        /* Wait till LSESYS is ready */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 80026ea:	e00a      	b.n	8002702 <HAL_RCC_OscConfig+0x802>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80026ec:	f7fe ffd2 	bl	8001694 <HAL_GetTick>
 80026f0:	4602      	mov	r2, r0
 80026f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80026f4:	1ad3      	subs	r3, r2, r3
 80026f6:	f241 3288 	movw	r2, #5000	; 0x1388
 80026fa:	4293      	cmp	r3, r2
 80026fc:	d901      	bls.n	8002702 <HAL_RCC_OscConfig+0x802>
          {
            return HAL_TIMEOUT;
 80026fe:	2303      	movs	r3, #3
 8002700:	e2d3      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 8002702:	4b8c      	ldr	r3, [pc, #560]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 8002704:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8002708:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800270c:	2b00      	cmp	r3, #0
 800270e:	d0ed      	beq.n	80026ec <HAL_RCC_OscConfig+0x7ec>
 8002710:	e053      	b.n	80027ba <HAL_RCC_OscConfig+0x8ba>
        }
      }
      else
      {
        /* Make sure LSESYSEN/LSESYSRDY are reset */
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8002712:	4b88      	ldr	r3, [pc, #544]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 8002714:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8002718:	4a86      	ldr	r2, [pc, #536]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 800271a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800271e:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0

        /* Wait till LSESYSRDY is cleared */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8002722:	e00a      	b.n	800273a <HAL_RCC_OscConfig+0x83a>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002724:	f7fe ffb6 	bl	8001694 <HAL_GetTick>
 8002728:	4602      	mov	r2, r0
 800272a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800272c:	1ad3      	subs	r3, r2, r3
 800272e:	f241 3288 	movw	r2, #5000	; 0x1388
 8002732:	4293      	cmp	r3, r2
 8002734:	d901      	bls.n	800273a <HAL_RCC_OscConfig+0x83a>
          {
            return HAL_TIMEOUT;
 8002736:	2303      	movs	r3, #3
 8002738:	e2b7      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 800273a:	4b7e      	ldr	r3, [pc, #504]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 800273c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8002740:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8002744:	2b00      	cmp	r3, #0
 8002746:	d1ed      	bne.n	8002724 <HAL_RCC_OscConfig+0x824>
 8002748:	e037      	b.n	80027ba <HAL_RCC_OscConfig+0x8ba>
        }
      }
    }
    else
    {
      tickstart = HAL_GetTick();
 800274a:	f7fe ffa3 	bl	8001694 <HAL_GetTick>
 800274e:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till LSE is disabled */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8002750:	e00a      	b.n	8002768 <HAL_RCC_OscConfig+0x868>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002752:	f7fe ff9f 	bl	8001694 <HAL_GetTick>
 8002756:	4602      	mov	r2, r0
 8002758:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800275a:	1ad3      	subs	r3, r2, r3
 800275c:	f241 3288 	movw	r2, #5000	; 0x1388
 8002760:	4293      	cmp	r3, r2
 8002762:	d901      	bls.n	8002768 <HAL_RCC_OscConfig+0x868>
        {
          return HAL_TIMEOUT;
 8002764:	2303      	movs	r3, #3
 8002766:	e2a0      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8002768:	4b72      	ldr	r3, [pc, #456]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 800276a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 800276e:	f003 0302 	and.w	r3, r3, #2
 8002772:	2b00      	cmp	r3, #0
 8002774:	d1ed      	bne.n	8002752 <HAL_RCC_OscConfig+0x852>
        }
      }

      if (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN) != 0U)
 8002776:	4b6f      	ldr	r3, [pc, #444]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 8002778:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 800277c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8002780:	2b00      	cmp	r3, #0
 8002782:	d01a      	beq.n	80027ba <HAL_RCC_OscConfig+0x8ba>
      {
        /* Reset LSESYSEN once LSE is disabled */
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8002784:	4b6b      	ldr	r3, [pc, #428]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 8002786:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 800278a:	4a6a      	ldr	r2, [pc, #424]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 800278c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8002790:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0

        /* Wait till LSESYSRDY is cleared */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8002794:	e00a      	b.n	80027ac <HAL_RCC_OscConfig+0x8ac>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002796:	f7fe ff7d 	bl	8001694 <HAL_GetTick>
 800279a:	4602      	mov	r2, r0
 800279c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800279e:	1ad3      	subs	r3, r2, r3
 80027a0:	f241 3288 	movw	r2, #5000	; 0x1388
 80027a4:	4293      	cmp	r3, r2
 80027a6:	d901      	bls.n	80027ac <HAL_RCC_OscConfig+0x8ac>
          {
            return HAL_TIMEOUT;
 80027a8:	2303      	movs	r3, #3
 80027aa:	e27e      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 80027ac:	4b61      	ldr	r3, [pc, #388]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 80027ae:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80027b2:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80027b6:	2b00      	cmp	r3, #0
 80027b8:	d1ed      	bne.n	8002796 <HAL_RCC_OscConfig+0x896>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 80027ba:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
 80027be:	2b01      	cmp	r3, #1
 80027c0:	d107      	bne.n	80027d2 <HAL_RCC_OscConfig+0x8d2>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 80027c2:	4b5c      	ldr	r3, [pc, #368]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 80027c4:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80027c8:	4a5a      	ldr	r2, [pc, #360]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 80027ca:	f023 0304 	bic.w	r3, r3, #4
 80027ce:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
    }
  }
  /*------------------------------ HSI48 Configuration -----------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 80027d2:	687b      	ldr	r3, [r7, #4]
 80027d4:	681b      	ldr	r3, [r3, #0]
 80027d6:	f003 0320 	and.w	r3, r3, #32
 80027da:	2b00      	cmp	r3, #0
 80027dc:	d036      	beq.n	800284c <HAL_RCC_OscConfig+0x94c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(pRCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if (pRCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 80027de:	687b      	ldr	r3, [r7, #4]
 80027e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80027e2:	2b00      	cmp	r3, #0
 80027e4:	d019      	beq.n	800281a <HAL_RCC_OscConfig+0x91a>
    {
      /* Enable the Internal High Speed oscillator (HSI48) */
      __HAL_RCC_HSI48_ENABLE();
 80027e6:	4b53      	ldr	r3, [pc, #332]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 80027e8:	681b      	ldr	r3, [r3, #0]
 80027ea:	4a52      	ldr	r2, [pc, #328]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 80027ec:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80027f0:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 80027f2:	f7fe ff4f 	bl	8001694 <HAL_GetTick>
 80027f6:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till HSI48 is ready */
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) == 0U)
 80027f8:	e008      	b.n	800280c <HAL_RCC_OscConfig+0x90c>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 80027fa:	f7fe ff4b 	bl	8001694 <HAL_GetTick>
 80027fe:	4602      	mov	r2, r0
 8002800:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002802:	1ad3      	subs	r3, r2, r3
 8002804:	2b02      	cmp	r3, #2
 8002806:	d901      	bls.n	800280c <HAL_RCC_OscConfig+0x90c>
        {
          return HAL_TIMEOUT;
 8002808:	2303      	movs	r3, #3
 800280a:	e24e      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) == 0U)
 800280c:	4b49      	ldr	r3, [pc, #292]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 800280e:	681b      	ldr	r3, [r3, #0]
 8002810:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8002814:	2b00      	cmp	r3, #0
 8002816:	d0f0      	beq.n	80027fa <HAL_RCC_OscConfig+0x8fa>
 8002818:	e018      	b.n	800284c <HAL_RCC_OscConfig+0x94c>
      }
    }
    else
    {
      /* Disable the Internal High Speed oscillator (HSI48) */
      __HAL_RCC_HSI48_DISABLE();
 800281a:	4b46      	ldr	r3, [pc, #280]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 800281c:	681b      	ldr	r3, [r3, #0]
 800281e:	4a45      	ldr	r2, [pc, #276]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 8002820:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8002824:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 8002826:	f7fe ff35 	bl	8001694 <HAL_GetTick>
 800282a:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till HSI48 is disabled */
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) != 0U)
 800282c:	e008      	b.n	8002840 <HAL_RCC_OscConfig+0x940>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800282e:	f7fe ff31 	bl	8001694 <HAL_GetTick>
 8002832:	4602      	mov	r2, r0
 8002834:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002836:	1ad3      	subs	r3, r2, r3
 8002838:	2b02      	cmp	r3, #2
 800283a:	d901      	bls.n	8002840 <HAL_RCC_OscConfig+0x940>
        {
          return HAL_TIMEOUT;
 800283c:	2303      	movs	r3, #3
 800283e:	e234      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) != 0U)
 8002840:	4b3c      	ldr	r3, [pc, #240]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 8002842:	681b      	ldr	r3, [r3, #0]
 8002844:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8002848:	2b00      	cmp	r3, #0
 800284a:	d1f0      	bne.n	800282e <HAL_RCC_OscConfig+0x92e>
      }
    }
  }

  /*------------------------------ SHSI Configuration -----------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_SHSI) == RCC_OSCILLATORTYPE_SHSI)
 800284c:	687b      	ldr	r3, [r7, #4]
 800284e:	681b      	ldr	r3, [r3, #0]
 8002850:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8002854:	2b00      	cmp	r3, #0
 8002856:	d036      	beq.n	80028c6 <HAL_RCC_OscConfig+0x9c6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SHSI(pRCC_OscInitStruct->SHSIState));

    /* Check the SHSI State */
    if (pRCC_OscInitStruct->SHSIState != RCC_SHSI_OFF)
 8002858:	687b      	ldr	r3, [r7, #4]
 800285a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800285c:	2b00      	cmp	r3, #0
 800285e:	d019      	beq.n	8002894 <HAL_RCC_OscConfig+0x994>
    {
      /* Enable the Secure Internal High Speed oscillator (SHSI) */
      __HAL_RCC_SHSI_ENABLE();
 8002860:	4b34      	ldr	r3, [pc, #208]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 8002862:	681b      	ldr	r3, [r3, #0]
 8002864:	4a33      	ldr	r2, [pc, #204]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 8002866:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800286a:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 800286c:	f7fe ff12 	bl	8001694 <HAL_GetTick>
 8002870:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till SHSI is ready */
      while (READ_BIT(RCC->CR, RCC_CR_SHSIRDY) == 0U)
 8002872:	e008      	b.n	8002886 <HAL_RCC_OscConfig+0x986>
      {
        if ((HAL_GetTick() - tickstart) > SHSI_TIMEOUT_VALUE)
 8002874:	f7fe ff0e 	bl	8001694 <HAL_GetTick>
 8002878:	4602      	mov	r2, r0
 800287a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800287c:	1ad3      	subs	r3, r2, r3
 800287e:	2b02      	cmp	r3, #2
 8002880:	d901      	bls.n	8002886 <HAL_RCC_OscConfig+0x986>
        {
          return HAL_TIMEOUT;
 8002882:	2303      	movs	r3, #3
 8002884:	e211      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_SHSIRDY) == 0U)
 8002886:	4b2b      	ldr	r3, [pc, #172]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 8002888:	681b      	ldr	r3, [r3, #0]
 800288a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800288e:	2b00      	cmp	r3, #0
 8002890:	d0f0      	beq.n	8002874 <HAL_RCC_OscConfig+0x974>
 8002892:	e018      	b.n	80028c6 <HAL_RCC_OscConfig+0x9c6>
      }
    }
    else
    {
      /* Disable the Secure Internal High Speed oscillator (SHSI) */
      __HAL_RCC_SHSI_DISABLE();
 8002894:	4b27      	ldr	r3, [pc, #156]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 8002896:	681b      	ldr	r3, [r3, #0]
 8002898:	4a26      	ldr	r2, [pc, #152]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 800289a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800289e:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 80028a0:	f7fe fef8 	bl	8001694 <HAL_GetTick>
 80028a4:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till SHSI is disabled */
      while (READ_BIT(RCC->CR, RCC_CR_SHSIRDY) != 0U)
 80028a6:	e008      	b.n	80028ba <HAL_RCC_OscConfig+0x9ba>
      {
        if ((HAL_GetTick() - tickstart) > SHSI_TIMEOUT_VALUE)
 80028a8:	f7fe fef4 	bl	8001694 <HAL_GetTick>
 80028ac:	4602      	mov	r2, r0
 80028ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80028b0:	1ad3      	subs	r3, r2, r3
 80028b2:	2b02      	cmp	r3, #2
 80028b4:	d901      	bls.n	80028ba <HAL_RCC_OscConfig+0x9ba>
        {
          return HAL_TIMEOUT;
 80028b6:	2303      	movs	r3, #3
 80028b8:	e1f7      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_SHSIRDY) != 0U)
 80028ba:	4b1e      	ldr	r3, [pc, #120]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 80028bc:	681b      	ldr	r3, [r3, #0]
 80028be:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80028c2:	2b00      	cmp	r3, #0
 80028c4:	d1f0      	bne.n	80028a8 <HAL_RCC_OscConfig+0x9a8>
        }
      }
    }
  }
  /*------------------------------ MSIK Configuration -----------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSIK) == RCC_OSCILLATORTYPE_MSIK)
 80028c6:	687b      	ldr	r3, [r7, #4]
 80028c8:	681b      	ldr	r3, [r3, #0]
 80028ca:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80028ce:	2b00      	cmp	r3, #0
 80028d0:	d07f      	beq.n	80029d2 <HAL_RCC_OscConfig+0xad2>
    assert_param(IS_RCC_MSIK(pRCC_OscInitStruct->MSIKState));
    assert_param(IS_RCC_MSIK_CLOCK_RANGE(pRCC_OscInitStruct->MSIKClockRange));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));

    /* Check the MSIK State */
    if (pRCC_OscInitStruct->MSIKState != RCC_MSIK_OFF)
 80028d2:	687b      	ldr	r3, [r7, #4]
 80028d4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80028d6:	2b00      	cmp	r3, #0
 80028d8:	d062      	beq.n	80029a0 <HAL_RCC_OscConfig+0xaa0>
    {

      /* Selects the Multiple Speed of kernel high speed oscillator (MSIK) clock range .*/
      __HAL_RCC_MSIK_RANGE_CONFIG(pRCC_OscInitStruct->MSIKClockRange);
 80028da:	4b16      	ldr	r3, [pc, #88]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 80028dc:	689b      	ldr	r3, [r3, #8]
 80028de:	4a15      	ldr	r2, [pc, #84]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 80028e0:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80028e4:	6093      	str	r3, [r2, #8]
 80028e6:	4b13      	ldr	r3, [pc, #76]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 80028e8:	689b      	ldr	r3, [r3, #8]
 80028ea:	f023 6270 	bic.w	r2, r3, #251658240	; 0xf000000
 80028ee:	687b      	ldr	r3, [r7, #4]
 80028f0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80028f2:	4910      	ldr	r1, [pc, #64]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 80028f4:	4313      	orrs	r3, r2
 80028f6:	608b      	str	r3, [r1, #8]
      /* Adjusts the Multiple Speed of kernel high speed oscillator (MSIK) calibration value.*/
      __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST((pRCC_OscInitStruct->MSICalibrationValue), \
 80028f8:	687b      	ldr	r3, [r7, #4]
 80028fa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80028fc:	f1b3 4f40 	cmp.w	r3, #3221225472	; 0xc0000000
 8002900:	d309      	bcc.n	8002916 <HAL_RCC_OscConfig+0xa16>
 8002902:	4b0c      	ldr	r3, [pc, #48]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 8002904:	68db      	ldr	r3, [r3, #12]
 8002906:	f023 021f 	bic.w	r2, r3, #31
 800290a:	687b      	ldr	r3, [r7, #4]
 800290c:	6a1b      	ldr	r3, [r3, #32]
 800290e:	4909      	ldr	r1, [pc, #36]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 8002910:	4313      	orrs	r3, r2
 8002912:	60cb      	str	r3, [r1, #12]
 8002914:	e02a      	b.n	800296c <HAL_RCC_OscConfig+0xa6c>
 8002916:	687b      	ldr	r3, [r7, #4]
 8002918:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800291a:	2b00      	cmp	r3, #0
 800291c:	da0c      	bge.n	8002938 <HAL_RCC_OscConfig+0xa38>
 800291e:	4b05      	ldr	r3, [pc, #20]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 8002920:	68db      	ldr	r3, [r3, #12]
 8002922:	f423 7278 	bic.w	r2, r3, #992	; 0x3e0
 8002926:	687b      	ldr	r3, [r7, #4]
 8002928:	6a1b      	ldr	r3, [r3, #32]
 800292a:	015b      	lsls	r3, r3, #5
 800292c:	4901      	ldr	r1, [pc, #4]	; (8002934 <HAL_RCC_OscConfig+0xa34>)
 800292e:	4313      	orrs	r3, r2
 8002930:	60cb      	str	r3, [r1, #12]
 8002932:	e01b      	b.n	800296c <HAL_RCC_OscConfig+0xa6c>
 8002934:	46020c00 	.word	0x46020c00
 8002938:	687b      	ldr	r3, [r7, #4]
 800293a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800293c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8002940:	d30a      	bcc.n	8002958 <HAL_RCC_OscConfig+0xa58>
 8002942:	4ba1      	ldr	r3, [pc, #644]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002944:	68db      	ldr	r3, [r3, #12]
 8002946:	f423 42f8 	bic.w	r2, r3, #31744	; 0x7c00
 800294a:	687b      	ldr	r3, [r7, #4]
 800294c:	6a1b      	ldr	r3, [r3, #32]
 800294e:	029b      	lsls	r3, r3, #10
 8002950:	499d      	ldr	r1, [pc, #628]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002952:	4313      	orrs	r3, r2
 8002954:	60cb      	str	r3, [r1, #12]
 8002956:	e009      	b.n	800296c <HAL_RCC_OscConfig+0xa6c>
 8002958:	4b9b      	ldr	r3, [pc, #620]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 800295a:	68db      	ldr	r3, [r3, #12]
 800295c:	f423 2278 	bic.w	r2, r3, #1015808	; 0xf8000
 8002960:	687b      	ldr	r3, [r7, #4]
 8002962:	6a1b      	ldr	r3, [r3, #32]
 8002964:	03db      	lsls	r3, r3, #15
 8002966:	4998      	ldr	r1, [pc, #608]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002968:	4313      	orrs	r3, r2
 800296a:	60cb      	str	r3, [r1, #12]
                                            (pRCC_OscInitStruct->MSIClockRange));

      /* Enable the Internal kernel High Speed oscillator (MSIK) */
      __HAL_RCC_MSIK_ENABLE();
 800296c:	4b96      	ldr	r3, [pc, #600]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 800296e:	681b      	ldr	r3, [r3, #0]
 8002970:	4a95      	ldr	r2, [pc, #596]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002972:	f043 0310 	orr.w	r3, r3, #16
 8002976:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 8002978:	f7fe fe8c 	bl	8001694 <HAL_GetTick>
 800297c:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till MSIK is ready */
      while (READ_BIT(RCC->CR, RCC_CR_MSIKRDY) == 0U)
 800297e:	e008      	b.n	8002992 <HAL_RCC_OscConfig+0xa92>
      {
        if ((HAL_GetTick() - tickstart) > MSIK_TIMEOUT_VALUE)
 8002980:	f7fe fe88 	bl	8001694 <HAL_GetTick>
 8002984:	4602      	mov	r2, r0
 8002986:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002988:	1ad3      	subs	r3, r2, r3
 800298a:	2b02      	cmp	r3, #2
 800298c:	d901      	bls.n	8002992 <HAL_RCC_OscConfig+0xa92>
        {
          return HAL_TIMEOUT;
 800298e:	2303      	movs	r3, #3
 8002990:	e18b      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_MSIKRDY) == 0U)
 8002992:	4b8d      	ldr	r3, [pc, #564]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002994:	681b      	ldr	r3, [r3, #0]
 8002996:	f003 0320 	and.w	r3, r3, #32
 800299a:	2b00      	cmp	r3, #0
 800299c:	d0f0      	beq.n	8002980 <HAL_RCC_OscConfig+0xa80>
 800299e:	e018      	b.n	80029d2 <HAL_RCC_OscConfig+0xad2>
      }
    }
    else
    {
      /* Disable the Internal High Speed Kernel oscillator (MSIK) */
      __HAL_RCC_MSIK_DISABLE();
 80029a0:	4b89      	ldr	r3, [pc, #548]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 80029a2:	681b      	ldr	r3, [r3, #0]
 80029a4:	4a88      	ldr	r2, [pc, #544]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 80029a6:	f023 0310 	bic.w	r3, r3, #16
 80029aa:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 80029ac:	f7fe fe72 	bl	8001694 <HAL_GetTick>
 80029b0:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till MSIK is disabled */
      while (READ_BIT(RCC->CR, RCC_CR_MSIKRDY) != 0U)
 80029b2:	e008      	b.n	80029c6 <HAL_RCC_OscConfig+0xac6>
      {
        if ((HAL_GetTick() - tickstart) > MSIK_TIMEOUT_VALUE)
 80029b4:	f7fe fe6e 	bl	8001694 <HAL_GetTick>
 80029b8:	4602      	mov	r2, r0
 80029ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80029bc:	1ad3      	subs	r3, r2, r3
 80029be:	2b02      	cmp	r3, #2
 80029c0:	d901      	bls.n	80029c6 <HAL_RCC_OscConfig+0xac6>
        {
          return HAL_TIMEOUT;
 80029c2:	2303      	movs	r3, #3
 80029c4:	e171      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_MSIKRDY) != 0U)
 80029c6:	4b80      	ldr	r3, [pc, #512]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 80029c8:	681b      	ldr	r3, [r3, #0]
 80029ca:	f003 0320 	and.w	r3, r3, #32
 80029ce:	2b00      	cmp	r3, #0
 80029d0:	d1f0      	bne.n	80029b4 <HAL_RCC_OscConfig+0xab4>
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL.PLLState));

  if ((pRCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80029d2:	687b      	ldr	r3, [r7, #4]
 80029d4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80029d6:	2b00      	cmp	r3, #0
 80029d8:	f000 8166 	beq.w	8002ca8 <HAL_RCC_OscConfig+0xda8>
  {
    FlagStatus  pwrclkchanged = RESET;
 80029dc:	2300      	movs	r3, #0
 80029de:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34

    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80029e2:	4b79      	ldr	r3, [pc, #484]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 80029e4:	69db      	ldr	r3, [r3, #28]
 80029e6:	f003 030c 	and.w	r3, r3, #12
 80029ea:	2b0c      	cmp	r3, #12
 80029ec:	f000 80f2 	beq.w	8002bd4 <HAL_RCC_OscConfig+0xcd4>
    {
      if ((pRCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80029f0:	687b      	ldr	r3, [r7, #4]
 80029f2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80029f4:	2b02      	cmp	r3, #2
 80029f6:	f040 80c5 	bne.w	8002b84 <HAL_RCC_OscConfig+0xc84>
        assert_param(IS_RCC_PLLP_VALUE(pRCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(pRCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(pRCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL */
        __HAL_RCC_PLL_DISABLE();
 80029fa:	4b73      	ldr	r3, [pc, #460]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 80029fc:	681b      	ldr	r3, [r3, #0]
 80029fe:	4a72      	ldr	r2, [pc, #456]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002a00:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8002a04:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8002a06:	f7fe fe45 	bl	8001694 <HAL_GetTick>
 8002a0a:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 8002a0c:	e008      	b.n	8002a20 <HAL_RCC_OscConfig+0xb20>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8002a0e:	f7fe fe41 	bl	8001694 <HAL_GetTick>
 8002a12:	4602      	mov	r2, r0
 8002a14:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002a16:	1ad3      	subs	r3, r2, r3
 8002a18:	2b02      	cmp	r3, #2
 8002a1a:	d901      	bls.n	8002a20 <HAL_RCC_OscConfig+0xb20>
          {
            return HAL_TIMEOUT;
 8002a1c:	2303      	movs	r3, #3
 8002a1e:	e144      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 8002a20:	4b69      	ldr	r3, [pc, #420]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002a22:	681b      	ldr	r3, [r3, #0]
 8002a24:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8002a28:	2b00      	cmp	r3, #0
 8002a2a:	d1f0      	bne.n	8002a0e <HAL_RCC_OscConfig+0xb0e>
          }
        }

        /* Requires to enable write access to Backup Domain of necessary */
        if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8002a2c:	4b66      	ldr	r3, [pc, #408]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002a2e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002a32:	f003 0304 	and.w	r3, r3, #4
 8002a36:	2b00      	cmp	r3, #0
 8002a38:	d111      	bne.n	8002a5e <HAL_RCC_OscConfig+0xb5e>
        {
          __HAL_RCC_PWR_CLK_ENABLE();
 8002a3a:	4b63      	ldr	r3, [pc, #396]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002a3c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002a40:	4a61      	ldr	r2, [pc, #388]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002a42:	f043 0304 	orr.w	r3, r3, #4
 8002a46:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 8002a4a:	4b5f      	ldr	r3, [pc, #380]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002a4c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002a50:	f003 0304 	and.w	r3, r3, #4
 8002a54:	60fb      	str	r3, [r7, #12]
 8002a56:	68fb      	ldr	r3, [r7, #12]
          pwrclkchanged = SET;
 8002a58:	2301      	movs	r3, #1
 8002a5a:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
        }

        /*Disable EPOD to configure PLL1MBOOST*/
        if (READ_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN) == PWR_VOSR_BOOSTEN)
 8002a5e:	4b5b      	ldr	r3, [pc, #364]	; (8002bcc <HAL_RCC_OscConfig+0xccc>)
 8002a60:	68db      	ldr	r3, [r3, #12]
 8002a62:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8002a66:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8002a6a:	d102      	bne.n	8002a72 <HAL_RCC_OscConfig+0xb72>
        {
          pwrboosten = SET;
 8002a6c:	2301      	movs	r3, #1
 8002a6e:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        }
        CLEAR_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN);
 8002a72:	4b56      	ldr	r3, [pc, #344]	; (8002bcc <HAL_RCC_OscConfig+0xccc>)
 8002a74:	68db      	ldr	r3, [r3, #12]
 8002a76:	4a55      	ldr	r2, [pc, #340]	; (8002bcc <HAL_RCC_OscConfig+0xccc>)
 8002a78:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8002a7c:	60d3      	str	r3, [r2, #12]

        /* Configure the main PLL clock source, multiplication and division factors */
        __HAL_RCC_PLL_CONFIG(pRCC_OscInitStruct->PLL.PLLSource,
 8002a7e:	4b52      	ldr	r3, [pc, #328]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002a80:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002a82:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8002a86:	f023 0303 	bic.w	r3, r3, #3
 8002a8a:	687a      	ldr	r2, [r7, #4]
 8002a8c:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
 8002a8e:	687a      	ldr	r2, [r7, #4]
 8002a90:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8002a92:	3a01      	subs	r2, #1
 8002a94:	0212      	lsls	r2, r2, #8
 8002a96:	4311      	orrs	r1, r2
 8002a98:	687a      	ldr	r2, [r7, #4]
 8002a9a:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8002a9c:	430a      	orrs	r2, r1
 8002a9e:	494a      	ldr	r1, [pc, #296]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002aa0:	4313      	orrs	r3, r2
 8002aa2:	628b      	str	r3, [r1, #40]	; 0x28
 8002aa4:	4b48      	ldr	r3, [pc, #288]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002aa6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002aa8:	4b49      	ldr	r3, [pc, #292]	; (8002bd0 <HAL_RCC_OscConfig+0xcd0>)
 8002aaa:	4013      	ands	r3, r2
 8002aac:	687a      	ldr	r2, [r7, #4]
 8002aae:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8002ab0:	3a01      	subs	r2, #1
 8002ab2:	f3c2 0108 	ubfx	r1, r2, #0, #9
 8002ab6:	687a      	ldr	r2, [r7, #4]
 8002ab8:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8002aba:	3a01      	subs	r2, #1
 8002abc:	0252      	lsls	r2, r2, #9
 8002abe:	b292      	uxth	r2, r2
 8002ac0:	4311      	orrs	r1, r2
 8002ac2:	687a      	ldr	r2, [r7, #4]
 8002ac4:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8002ac6:	3a01      	subs	r2, #1
 8002ac8:	0412      	lsls	r2, r2, #16
 8002aca:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
 8002ace:	4311      	orrs	r1, r2
 8002ad0:	687a      	ldr	r2, [r7, #4]
 8002ad2:	6d52      	ldr	r2, [r2, #84]	; 0x54
 8002ad4:	3a01      	subs	r2, #1
 8002ad6:	0612      	lsls	r2, r2, #24
 8002ad8:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
 8002adc:	430a      	orrs	r2, r1
 8002ade:	493a      	ldr	r1, [pc, #232]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002ae0:	4313      	orrs	r3, r2
 8002ae2:	634b      	str	r3, [r1, #52]	; 0x34
                             pRCC_OscInitStruct->PLL.PLLR);

        assert_param(IS_RCC_PLL_FRACN_VALUE(pRCC_OscInitStruct->PLL.PLLFRACN));

        /* Disable PLL1FRACN  */
        __HAL_RCC_PLL_FRACN_DISABLE();
 8002ae4:	4b38      	ldr	r3, [pc, #224]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002ae6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002ae8:	4a37      	ldr	r2, [pc, #220]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002aea:	f023 0310 	bic.w	r3, r3, #16
 8002aee:	6293      	str	r3, [r2, #40]	; 0x28

        /* Configure PLL  PLL1FRACN */
        __HAL_RCC_PLL_FRACN_CONFIG(pRCC_OscInitStruct->PLL.PLLFRACN);
 8002af0:	687b      	ldr	r3, [r7, #4]
 8002af2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002af4:	4a34      	ldr	r2, [pc, #208]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002af6:	00db      	lsls	r3, r3, #3
 8002af8:	6393      	str	r3, [r2, #56]	; 0x38

        /* Enable PLL1FRACN  */
        __HAL_RCC_PLL_FRACN_ENABLE();
 8002afa:	4b33      	ldr	r3, [pc, #204]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002afc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002afe:	4a32      	ldr	r2, [pc, #200]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002b00:	f043 0310 	orr.w	r3, r3, #16
 8002b04:	6293      	str	r3, [r2, #40]	; 0x28

        assert_param(IS_RCC_PLLRGE_VALUE(pRCC_OscInitStruct->PLL.PLLRGE));

        /* Select PLL1 input reference frequency range: VCI */
        __HAL_RCC_PLL_VCIRANGE(pRCC_OscInitStruct->PLL.PLLRGE);
 8002b06:	4b30      	ldr	r3, [pc, #192]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002b08:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002b0a:	f023 020c 	bic.w	r2, r3, #12
 8002b0e:	687b      	ldr	r3, [r7, #4]
 8002b10:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8002b12:	492d      	ldr	r1, [pc, #180]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002b14:	4313      	orrs	r3, r2
 8002b16:	628b      	str	r3, [r1, #40]	; 0x28

        if (pwrboosten == SET)
 8002b18:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8002b1c:	2b01      	cmp	r3, #1
 8002b1e:	d105      	bne.n	8002b2c <HAL_RCC_OscConfig+0xc2c>
        {
          /* Enable the EPOD to reach max frequency */
          SET_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN);
 8002b20:	4b2a      	ldr	r3, [pc, #168]	; (8002bcc <HAL_RCC_OscConfig+0xccc>)
 8002b22:	68db      	ldr	r3, [r3, #12]
 8002b24:	4a29      	ldr	r2, [pc, #164]	; (8002bcc <HAL_RCC_OscConfig+0xccc>)
 8002b26:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8002b2a:	60d3      	str	r3, [r2, #12]
        }

        /* Restore clock configuration if changed */
        if (pwrclkchanged == SET)
 8002b2c:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 8002b30:	2b01      	cmp	r3, #1
 8002b32:	d107      	bne.n	8002b44 <HAL_RCC_OscConfig+0xc44>
        {
          __HAL_RCC_PWR_CLK_DISABLE();
 8002b34:	4b24      	ldr	r3, [pc, #144]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002b36:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002b3a:	4a23      	ldr	r2, [pc, #140]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002b3c:	f023 0304 	bic.w	r3, r3, #4
 8002b40:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
        }

        /* Enable PLL System Clock output */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
 8002b44:	4b20      	ldr	r3, [pc, #128]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002b46:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002b48:	4a1f      	ldr	r2, [pc, #124]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002b4a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8002b4e:	6293      	str	r3, [r2, #40]	; 0x28

        /* Enable the main PLL */
        __HAL_RCC_PLL_ENABLE();
 8002b50:	4b1d      	ldr	r3, [pc, #116]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002b52:	681b      	ldr	r3, [r3, #0]
 8002b54:	4a1c      	ldr	r2, [pc, #112]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002b56:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8002b5a:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8002b5c:	f7fe fd9a 	bl	8001694 <HAL_GetTick>
 8002b60:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait till PLL is ready */
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
 8002b62:	e008      	b.n	8002b76 <HAL_RCC_OscConfig+0xc76>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8002b64:	f7fe fd96 	bl	8001694 <HAL_GetTick>
 8002b68:	4602      	mov	r2, r0
 8002b6a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002b6c:	1ad3      	subs	r3, r2, r3
 8002b6e:	2b02      	cmp	r3, #2
 8002b70:	d901      	bls.n	8002b76 <HAL_RCC_OscConfig+0xc76>
          {
            return HAL_TIMEOUT;
 8002b72:	2303      	movs	r3, #3
 8002b74:	e099      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
 8002b76:	4b14      	ldr	r3, [pc, #80]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002b78:	681b      	ldr	r3, [r3, #0]
 8002b7a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8002b7e:	2b00      	cmp	r3, #0
 8002b80:	d0f0      	beq.n	8002b64 <HAL_RCC_OscConfig+0xc64>
 8002b82:	e091      	b.n	8002ca8 <HAL_RCC_OscConfig+0xda8>
        }
      }
      else
      {
        /* Disable the main PLL */
        __HAL_RCC_PLL_DISABLE();
 8002b84:	4b10      	ldr	r3, [pc, #64]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002b86:	681b      	ldr	r3, [r3, #0]
 8002b88:	4a0f      	ldr	r2, [pc, #60]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002b8a:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8002b8e:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8002b90:	f7fe fd80 	bl	8001694 <HAL_GetTick>
 8002b94:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 8002b96:	e008      	b.n	8002baa <HAL_RCC_OscConfig+0xcaa>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8002b98:	f7fe fd7c 	bl	8001694 <HAL_GetTick>
 8002b9c:	4602      	mov	r2, r0
 8002b9e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002ba0:	1ad3      	subs	r3, r2, r3
 8002ba2:	2b02      	cmp	r3, #2
 8002ba4:	d901      	bls.n	8002baa <HAL_RCC_OscConfig+0xcaa>
          {
            return HAL_TIMEOUT;
 8002ba6:	2303      	movs	r3, #3
 8002ba8:	e07f      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 8002baa:	4b07      	ldr	r3, [pc, #28]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002bac:	681b      	ldr	r3, [r3, #0]
 8002bae:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8002bb2:	2b00      	cmp	r3, #0
 8002bb4:	d1f0      	bne.n	8002b98 <HAL_RCC_OscConfig+0xc98>
          }
        }

        /* Unselect main PLL clock source and disable main PLL outputs to save power */
        RCC->PLL1CFGR &= ~(RCC_PLL1CFGR_PLL1SRC | RCC_PLL1CFGR_PLL1PEN | RCC_PLL1CFGR_PLL1QEN | RCC_PLL1CFGR_PLL1REN);
 8002bb6:	4b04      	ldr	r3, [pc, #16]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002bb8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002bba:	4a03      	ldr	r2, [pc, #12]	; (8002bc8 <HAL_RCC_OscConfig+0xcc8>)
 8002bbc:	f423 23e0 	bic.w	r3, r3, #458752	; 0x70000
 8002bc0:	f023 0303 	bic.w	r3, r3, #3
 8002bc4:	6293      	str	r3, [r2, #40]	; 0x28
 8002bc6:	e06f      	b.n	8002ca8 <HAL_RCC_OscConfig+0xda8>
 8002bc8:	46020c00 	.word	0x46020c00
 8002bcc:	46020800 	.word	0x46020800
 8002bd0:	80800000 	.word	0x80800000
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      temp1_pllckcfg = RCC->PLL1CFGR;
 8002bd4:	4b37      	ldr	r3, [pc, #220]	; (8002cb4 <HAL_RCC_OscConfig+0xdb4>)
 8002bd6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002bd8:	61fb      	str	r3, [r7, #28]
      temp2_pllckcfg = RCC->PLL1DIVR;
 8002bda:	4b36      	ldr	r3, [pc, #216]	; (8002cb4 <HAL_RCC_OscConfig+0xdb4>)
 8002bdc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002bde:	61bb      	str	r3, [r7, #24]
      if (((pRCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8002be0:	687b      	ldr	r3, [r7, #4]
 8002be2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002be4:	2b01      	cmp	r3, #1
 8002be6:	d039      	beq.n	8002c5c <HAL_RCC_OscConfig+0xd5c>
          (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1SRC) != pRCC_OscInitStruct->PLL.PLLSource) ||
 8002be8:	69fb      	ldr	r3, [r7, #28]
 8002bea:	f003 0203 	and.w	r2, r3, #3
 8002bee:	687b      	ldr	r3, [r7, #4]
 8002bf0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
      if (((pRCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8002bf2:	429a      	cmp	r2, r3
 8002bf4:	d132      	bne.n	8002c5c <HAL_RCC_OscConfig+0xd5c>
          ((READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1M) >> \
 8002bf6:	69fb      	ldr	r3, [r7, #28]
 8002bf8:	0a1b      	lsrs	r3, r3, #8
 8002bfa:	f003 020f 	and.w	r2, r3, #15
            RCC_PLL1CFGR_PLL1M_Pos) != (pRCC_OscInitStruct->PLL.PLLM - 1U)) ||
 8002bfe:	687b      	ldr	r3, [r7, #4]
 8002c00:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002c02:	3b01      	subs	r3, #1
          (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1SRC) != pRCC_OscInitStruct->PLL.PLLSource) ||
 8002c04:	429a      	cmp	r2, r3
 8002c06:	d129      	bne.n	8002c5c <HAL_RCC_OscConfig+0xd5c>
          (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1MBOOST) != pRCC_OscInitStruct->PLL.PLLMBOOST) ||
 8002c08:	69fb      	ldr	r3, [r7, #28]
 8002c0a:	f403 4270 	and.w	r2, r3, #61440	; 0xf000
 8002c0e:	687b      	ldr	r3, [r7, #4]
 8002c10:	6c5b      	ldr	r3, [r3, #68]	; 0x44
            RCC_PLL1CFGR_PLL1M_Pos) != (pRCC_OscInitStruct->PLL.PLLM - 1U)) ||
 8002c12:	429a      	cmp	r2, r3
 8002c14:	d122      	bne.n	8002c5c <HAL_RCC_OscConfig+0xd5c>
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1N) != (pRCC_OscInitStruct->PLL.PLLN - 1U)) ||
 8002c16:	69bb      	ldr	r3, [r7, #24]
 8002c18:	f3c3 0208 	ubfx	r2, r3, #0, #9
 8002c1c:	687b      	ldr	r3, [r7, #4]
 8002c1e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8002c20:	3b01      	subs	r3, #1
          (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1MBOOST) != pRCC_OscInitStruct->PLL.PLLMBOOST) ||
 8002c22:	429a      	cmp	r2, r3
 8002c24:	d11a      	bne.n	8002c5c <HAL_RCC_OscConfig+0xd5c>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1P) >> \
 8002c26:	69bb      	ldr	r3, [r7, #24]
 8002c28:	0a5b      	lsrs	r3, r3, #9
 8002c2a:	f003 027f 	and.w	r2, r3, #127	; 0x7f
            RCC_PLL1DIVR_PLL1P_Pos) != (pRCC_OscInitStruct->PLL.PLLP - 1U)) ||
 8002c2e:	687b      	ldr	r3, [r7, #4]
 8002c30:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8002c32:	3b01      	subs	r3, #1
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1N) != (pRCC_OscInitStruct->PLL.PLLN - 1U)) ||
 8002c34:	429a      	cmp	r2, r3
 8002c36:	d111      	bne.n	8002c5c <HAL_RCC_OscConfig+0xd5c>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1Q) >> \
 8002c38:	69bb      	ldr	r3, [r7, #24]
 8002c3a:	0c1b      	lsrs	r3, r3, #16
 8002c3c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
            RCC_PLL1DIVR_PLL1Q_Pos) != (pRCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 8002c40:	687b      	ldr	r3, [r7, #4]
 8002c42:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8002c44:	3b01      	subs	r3, #1
            RCC_PLL1DIVR_PLL1P_Pos) != (pRCC_OscInitStruct->PLL.PLLP - 1U)) ||
 8002c46:	429a      	cmp	r2, r3
 8002c48:	d108      	bne.n	8002c5c <HAL_RCC_OscConfig+0xd5c>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1R) >> \
 8002c4a:	69bb      	ldr	r3, [r7, #24]
 8002c4c:	0e1b      	lsrs	r3, r3, #24
 8002c4e:	f003 027f 	and.w	r2, r3, #127	; 0x7f
            RCC_PLL1DIVR_PLL1R_Pos) != (pRCC_OscInitStruct->PLL.PLLR - 1U)))
 8002c52:	687b      	ldr	r3, [r7, #4]
 8002c54:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8002c56:	3b01      	subs	r3, #1
            RCC_PLL1DIVR_PLL1Q_Pos) != (pRCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 8002c58:	429a      	cmp	r2, r3
 8002c5a:	d001      	beq.n	8002c60 <HAL_RCC_OscConfig+0xd60>
      {
        return HAL_ERROR;
 8002c5c:	2301      	movs	r3, #1
 8002c5e:	e024      	b.n	8002caa <HAL_RCC_OscConfig+0xdaa>
      }

      /* FRACN1 on-the-fly value update */
      if ((READ_BIT(RCC->PLL1FRACR, RCC_PLL1FRACR_PLL1FRACN) >> \
 8002c60:	4b14      	ldr	r3, [pc, #80]	; (8002cb4 <HAL_RCC_OscConfig+0xdb4>)
 8002c62:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002c64:	08db      	lsrs	r3, r3, #3
 8002c66:	f3c3 020c 	ubfx	r2, r3, #0, #13
           RCC_PLL1FRACR_PLL1FRACN_Pos) != (pRCC_OscInitStruct->PLL.PLLFRACN))
 8002c6a:	687b      	ldr	r3, [r7, #4]
 8002c6c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
      if ((READ_BIT(RCC->PLL1FRACR, RCC_PLL1FRACR_PLL1FRACN) >> \
 8002c6e:	429a      	cmp	r2, r3
 8002c70:	d01a      	beq.n	8002ca8 <HAL_RCC_OscConfig+0xda8>
      {
        assert_param(IS_RCC_PLL_FRACN_VALUE(pRCC_OscInitStruct->PLL.PLLFRACN));

        /* Disable PLL1FRACN. */
        __HAL_RCC_PLL_FRACN_DISABLE();
 8002c72:	4b10      	ldr	r3, [pc, #64]	; (8002cb4 <HAL_RCC_OscConfig+0xdb4>)
 8002c74:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002c76:	4a0f      	ldr	r2, [pc, #60]	; (8002cb4 <HAL_RCC_OscConfig+0xdb4>)
 8002c78:	f023 0310 	bic.w	r3, r3, #16
 8002c7c:	6293      	str	r3, [r2, #40]	; 0x28

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002c7e:	f7fe fd09 	bl	8001694 <HAL_GetTick>
 8002c82:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait at least 2 CK_REF (PLL1 input source divided by M) period to make sure next latched value
           will be taken into account. */
        while ((HAL_GetTick() - tickstart) < PLL_FRAC_WAIT_VALUE)
 8002c84:	bf00      	nop
 8002c86:	f7fe fd05 	bl	8001694 <HAL_GetTick>
 8002c8a:	4602      	mov	r2, r0
 8002c8c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002c8e:	4293      	cmp	r3, r2
 8002c90:	d0f9      	beq.n	8002c86 <HAL_RCC_OscConfig+0xd86>
        {
        }

        /* Configure PLL PLL1FRACN */
        __HAL_RCC_PLL_FRACN_CONFIG(pRCC_OscInitStruct->PLL.PLLFRACN);
 8002c92:	687b      	ldr	r3, [r7, #4]
 8002c94:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002c96:	4a07      	ldr	r2, [pc, #28]	; (8002cb4 <HAL_RCC_OscConfig+0xdb4>)
 8002c98:	00db      	lsls	r3, r3, #3
 8002c9a:	6393      	str	r3, [r2, #56]	; 0x38

        /* Enable PLL1FRACN to latch the new value. */
        __HAL_RCC_PLL_FRACN_ENABLE();
 8002c9c:	4b05      	ldr	r3, [pc, #20]	; (8002cb4 <HAL_RCC_OscConfig+0xdb4>)
 8002c9e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002ca0:	4a04      	ldr	r2, [pc, #16]	; (8002cb4 <HAL_RCC_OscConfig+0xdb4>)
 8002ca2:	f043 0310 	orr.w	r3, r3, #16
 8002ca6:	6293      	str	r3, [r2, #40]	; 0x28
      }
    }
  }
  return HAL_OK;
 8002ca8:	2300      	movs	r3, #0
}
 8002caa:	4618      	mov	r0, r3
 8002cac:	3738      	adds	r7, #56	; 0x38
 8002cae:	46bd      	mov	sp, r7
 8002cb0:	bd80      	pop	{r7, pc}
 8002cb2:	bf00      	nop
 8002cb4:	46020c00 	.word	0x46020c00

08002cb8 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(const RCC_ClkInitTypeDef   *const pRCC_ClkInitStruct, uint32_t FLatency)
{
 8002cb8:	b580      	push	{r7, lr}
 8002cba:	b086      	sub	sp, #24
 8002cbc:	af00      	add	r7, sp, #0
 8002cbe:	6078      	str	r0, [r7, #4]
 8002cc0:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart;

  /* Check Null pointer */
  if (pRCC_ClkInitStruct == NULL)
 8002cc2:	687b      	ldr	r3, [r7, #4]
 8002cc4:	2b00      	cmp	r3, #0
 8002cc6:	d101      	bne.n	8002ccc <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8002cc8:	2301      	movs	r3, #1
 8002cca:	e1d9      	b.n	8003080 <HAL_RCC_ClockConfig+0x3c8>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
   must be correctly programmed according to the frequency of the CPU clock
   (HCLK) and the supply voltage of the device */

  /* Increasing the number of wait states because of higher CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8002ccc:	4b9b      	ldr	r3, [pc, #620]	; (8002f3c <HAL_RCC_ClockConfig+0x284>)
 8002cce:	681b      	ldr	r3, [r3, #0]
 8002cd0:	f003 030f 	and.w	r3, r3, #15
 8002cd4:	683a      	ldr	r2, [r7, #0]
 8002cd6:	429a      	cmp	r2, r3
 8002cd8:	d910      	bls.n	8002cfc <HAL_RCC_ClockConfig+0x44>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002cda:	4b98      	ldr	r3, [pc, #608]	; (8002f3c <HAL_RCC_ClockConfig+0x284>)
 8002cdc:	681b      	ldr	r3, [r3, #0]
 8002cde:	f023 020f 	bic.w	r2, r3, #15
 8002ce2:	4996      	ldr	r1, [pc, #600]	; (8002f3c <HAL_RCC_ClockConfig+0x284>)
 8002ce4:	683b      	ldr	r3, [r7, #0]
 8002ce6:	4313      	orrs	r3, r2
 8002ce8:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8002cea:	4b94      	ldr	r3, [pc, #592]	; (8002f3c <HAL_RCC_ClockConfig+0x284>)
 8002cec:	681b      	ldr	r3, [r3, #0]
 8002cee:	f003 030f 	and.w	r3, r3, #15
 8002cf2:	683a      	ldr	r2, [r7, #0]
 8002cf4:	429a      	cmp	r2, r3
 8002cf6:	d001      	beq.n	8002cfc <HAL_RCC_ClockConfig+0x44>
    {
      return HAL_ERROR;
 8002cf8:	2301      	movs	r3, #1
 8002cfa:	e1c1      	b.n	8003080 <HAL_RCC_ClockConfig+0x3c8>
    }
  }

  /* Increasing the BUS frequency divider */
  /*-------------------------- PCLK3 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK3) == RCC_CLOCKTYPE_PCLK3)
 8002cfc:	687b      	ldr	r3, [r7, #4]
 8002cfe:	681b      	ldr	r3, [r3, #0]
 8002d00:	f003 0310 	and.w	r3, r3, #16
 8002d04:	2b00      	cmp	r3, #0
 8002d06:	d010      	beq.n	8002d2a <HAL_RCC_ClockConfig+0x72>
  {
    if ((pRCC_ClkInitStruct->APB3CLKDivider) > (RCC->CFGR3 & RCC_CFGR3_PPRE3))
 8002d08:	687b      	ldr	r3, [r7, #4]
 8002d0a:	695a      	ldr	r2, [r3, #20]
 8002d0c:	4b8c      	ldr	r3, [pc, #560]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002d0e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002d10:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8002d14:	429a      	cmp	r2, r3
 8002d16:	d908      	bls.n	8002d2a <HAL_RCC_ClockConfig+0x72>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->CFGR3, RCC_CFGR3_PPRE3, pRCC_ClkInitStruct->APB3CLKDivider);
 8002d18:	4b89      	ldr	r3, [pc, #548]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002d1a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002d1c:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 8002d20:	687b      	ldr	r3, [r7, #4]
 8002d22:	695b      	ldr	r3, [r3, #20]
 8002d24:	4986      	ldr	r1, [pc, #536]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002d26:	4313      	orrs	r3, r2
 8002d28:	624b      	str	r3, [r1, #36]	; 0x24
    }
  }
  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002d2a:	687b      	ldr	r3, [r7, #4]
 8002d2c:	681b      	ldr	r3, [r3, #0]
 8002d2e:	f003 0308 	and.w	r3, r3, #8
 8002d32:	2b00      	cmp	r3, #0
 8002d34:	d012      	beq.n	8002d5c <HAL_RCC_ClockConfig+0xa4>
  {
    if ((pRCC_ClkInitStruct->APB2CLKDivider) > ((RCC->CFGR2 & RCC_CFGR2_PPRE2) >> 4))
 8002d36:	687b      	ldr	r3, [r7, #4]
 8002d38:	691a      	ldr	r2, [r3, #16]
 8002d3a:	4b81      	ldr	r3, [pc, #516]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002d3c:	6a1b      	ldr	r3, [r3, #32]
 8002d3e:	091b      	lsrs	r3, r3, #4
 8002d40:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8002d44:	429a      	cmp	r2, r3
 8002d46:	d909      	bls.n	8002d5c <HAL_RCC_ClockConfig+0xa4>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, ((pRCC_ClkInitStruct->APB2CLKDivider) << 4));
 8002d48:	4b7d      	ldr	r3, [pc, #500]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002d4a:	6a1b      	ldr	r3, [r3, #32]
 8002d4c:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 8002d50:	687b      	ldr	r3, [r7, #4]
 8002d52:	691b      	ldr	r3, [r3, #16]
 8002d54:	011b      	lsls	r3, r3, #4
 8002d56:	497a      	ldr	r1, [pc, #488]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002d58:	4313      	orrs	r3, r2
 8002d5a:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8002d5c:	687b      	ldr	r3, [r7, #4]
 8002d5e:	681b      	ldr	r3, [r3, #0]
 8002d60:	f003 0304 	and.w	r3, r3, #4
 8002d64:	2b00      	cmp	r3, #0
 8002d66:	d010      	beq.n	8002d8a <HAL_RCC_ClockConfig+0xd2>
  {
    if ((pRCC_ClkInitStruct->APB1CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE1))
 8002d68:	687b      	ldr	r3, [r7, #4]
 8002d6a:	68da      	ldr	r2, [r3, #12]
 8002d6c:	4b74      	ldr	r3, [pc, #464]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002d6e:	6a1b      	ldr	r3, [r3, #32]
 8002d70:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8002d74:	429a      	cmp	r2, r3
 8002d76:	d908      	bls.n	8002d8a <HAL_RCC_ClockConfig+0xd2>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, pRCC_ClkInitStruct->APB1CLKDivider);
 8002d78:	4b71      	ldr	r3, [pc, #452]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002d7a:	6a1b      	ldr	r3, [r3, #32]
 8002d7c:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 8002d80:	687b      	ldr	r3, [r7, #4]
 8002d82:	68db      	ldr	r3, [r3, #12]
 8002d84:	496e      	ldr	r1, [pc, #440]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002d86:	4313      	orrs	r3, r2
 8002d88:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8002d8a:	687b      	ldr	r3, [r7, #4]
 8002d8c:	681b      	ldr	r3, [r3, #0]
 8002d8e:	f003 0302 	and.w	r3, r3, #2
 8002d92:	2b00      	cmp	r3, #0
 8002d94:	d010      	beq.n	8002db8 <HAL_RCC_ClockConfig+0x100>
  {
    if ((pRCC_ClkInitStruct->AHBCLKDivider) > (RCC->CFGR2 & RCC_CFGR2_HPRE))
 8002d96:	687b      	ldr	r3, [r7, #4]
 8002d98:	689a      	ldr	r2, [r3, #8]
 8002d9a:	4b69      	ldr	r3, [pc, #420]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002d9c:	6a1b      	ldr	r3, [r3, #32]
 8002d9e:	f003 030f 	and.w	r3, r3, #15
 8002da2:	429a      	cmp	r2, r3
 8002da4:	d908      	bls.n	8002db8 <HAL_RCC_ClockConfig+0x100>
    {
      assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
 8002da6:	4b66      	ldr	r3, [pc, #408]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002da8:	6a1b      	ldr	r3, [r3, #32]
 8002daa:	f023 020f 	bic.w	r2, r3, #15
 8002dae:	687b      	ldr	r3, [r7, #4]
 8002db0:	689b      	ldr	r3, [r3, #8]
 8002db2:	4963      	ldr	r1, [pc, #396]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002db4:	4313      	orrs	r3, r2
 8002db6:	620b      	str	r3, [r1, #32]
    }
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8002db8:	687b      	ldr	r3, [r7, #4]
 8002dba:	681b      	ldr	r3, [r3, #0]
 8002dbc:	f003 0301 	and.w	r3, r3, #1
 8002dc0:	2b00      	cmp	r3, #0
 8002dc2:	f000 80d2 	beq.w	8002f6a <HAL_RCC_ClockConfig+0x2b2>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(pRCC_ClkInitStruct->SYSCLKSource));
    FlagStatus  pwrclkchanged = RESET;
 8002dc6:	2300      	movs	r3, #0
 8002dc8:	75fb      	strb	r3, [r7, #23]

    /* PLL is selected as System Clock Source */
    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8002dca:	687b      	ldr	r3, [r7, #4]
 8002dcc:	685b      	ldr	r3, [r3, #4]
 8002dce:	2b03      	cmp	r3, #3
 8002dd0:	d143      	bne.n	8002e5a <HAL_RCC_ClockConfig+0x1a2>
    {
      if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8002dd2:	4b5b      	ldr	r3, [pc, #364]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002dd4:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002dd8:	f003 0304 	and.w	r3, r3, #4
 8002ddc:	2b00      	cmp	r3, #0
 8002dde:	d110      	bne.n	8002e02 <HAL_RCC_ClockConfig+0x14a>
      {
        __HAL_RCC_PWR_CLK_ENABLE();
 8002de0:	4b57      	ldr	r3, [pc, #348]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002de2:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002de6:	4a56      	ldr	r2, [pc, #344]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002de8:	f043 0304 	orr.w	r3, r3, #4
 8002dec:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 8002df0:	4b53      	ldr	r3, [pc, #332]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002df2:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002df6:	f003 0304 	and.w	r3, r3, #4
 8002dfa:	60bb      	str	r3, [r7, #8]
 8002dfc:	68bb      	ldr	r3, [r7, #8]
        pwrclkchanged = SET;
 8002dfe:	2301      	movs	r3, #1
 8002e00:	75fb      	strb	r3, [r7, #23]
      }
      tickstart = HAL_GetTick();
 8002e02:	f7fe fc47 	bl	8001694 <HAL_GetTick>
 8002e06:	6138      	str	r0, [r7, #16]
      /* Check if EPOD is enabled */
      if (READ_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN) != 0U)
 8002e08:	4b4e      	ldr	r3, [pc, #312]	; (8002f44 <HAL_RCC_ClockConfig+0x28c>)
 8002e0a:	68db      	ldr	r3, [r3, #12]
 8002e0c:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8002e10:	2b00      	cmp	r3, #0
 8002e12:	d00f      	beq.n	8002e34 <HAL_RCC_ClockConfig+0x17c>
      {
        /* Wait till BOOST is ready */
        while (READ_BIT(PWR->VOSR, PWR_VOSR_BOOSTRDY) == 0U)
 8002e14:	e008      	b.n	8002e28 <HAL_RCC_ClockConfig+0x170>
        {
          if ((HAL_GetTick() - tickstart) > EPOD_TIMEOUT_VALUE)
 8002e16:	f7fe fc3d 	bl	8001694 <HAL_GetTick>
 8002e1a:	4602      	mov	r2, r0
 8002e1c:	693b      	ldr	r3, [r7, #16]
 8002e1e:	1ad3      	subs	r3, r2, r3
 8002e20:	2b02      	cmp	r3, #2
 8002e22:	d901      	bls.n	8002e28 <HAL_RCC_ClockConfig+0x170>
          {
            return HAL_TIMEOUT;
 8002e24:	2303      	movs	r3, #3
 8002e26:	e12b      	b.n	8003080 <HAL_RCC_ClockConfig+0x3c8>
        while (READ_BIT(PWR->VOSR, PWR_VOSR_BOOSTRDY) == 0U)
 8002e28:	4b46      	ldr	r3, [pc, #280]	; (8002f44 <HAL_RCC_ClockConfig+0x28c>)
 8002e2a:	68db      	ldr	r3, [r3, #12]
 8002e2c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8002e30:	2b00      	cmp	r3, #0
 8002e32:	d0f0      	beq.n	8002e16 <HAL_RCC_ClockConfig+0x15e>
          }
        }
      }

      /* Restore clock configuration if changed */
      if (pwrclkchanged == SET)
 8002e34:	7dfb      	ldrb	r3, [r7, #23]
 8002e36:	2b01      	cmp	r3, #1
 8002e38:	d107      	bne.n	8002e4a <HAL_RCC_ClockConfig+0x192>
      {
        __HAL_RCC_PWR_CLK_DISABLE();
 8002e3a:	4b41      	ldr	r3, [pc, #260]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002e3c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002e40:	4a3f      	ldr	r2, [pc, #252]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002e42:	f023 0304 	bic.w	r3, r3, #4
 8002e46:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
      }

      /* Check the PLL ready flag */
      if (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
 8002e4a:	4b3d      	ldr	r3, [pc, #244]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002e4c:	681b      	ldr	r3, [r3, #0]
 8002e4e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8002e52:	2b00      	cmp	r3, #0
 8002e54:	d121      	bne.n	8002e9a <HAL_RCC_ClockConfig+0x1e2>
      {
        return HAL_ERROR;
 8002e56:	2301      	movs	r3, #1
 8002e58:	e112      	b.n	8003080 <HAL_RCC_ClockConfig+0x3c8>
      }
    }
    else
    {
      /* HSE is selected as System Clock Source */
      if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8002e5a:	687b      	ldr	r3, [r7, #4]
 8002e5c:	685b      	ldr	r3, [r3, #4]
 8002e5e:	2b02      	cmp	r3, #2
 8002e60:	d107      	bne.n	8002e72 <HAL_RCC_ClockConfig+0x1ba>
      {
        /* Check the HSE ready flag */
        if (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8002e62:	4b37      	ldr	r3, [pc, #220]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002e64:	681b      	ldr	r3, [r3, #0]
 8002e66:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8002e6a:	2b00      	cmp	r3, #0
 8002e6c:	d115      	bne.n	8002e9a <HAL_RCC_ClockConfig+0x1e2>
        {
          return HAL_ERROR;
 8002e6e:	2301      	movs	r3, #1
 8002e70:	e106      	b.n	8003080 <HAL_RCC_ClockConfig+0x3c8>
        }
      }
      /* MSI is selected as System Clock Source */
      else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8002e72:	687b      	ldr	r3, [r7, #4]
 8002e74:	685b      	ldr	r3, [r3, #4]
 8002e76:	2b00      	cmp	r3, #0
 8002e78:	d107      	bne.n	8002e8a <HAL_RCC_ClockConfig+0x1d2>
      {
        /* Check the MSI ready flag */
        if (READ_BIT(RCC->CR, RCC_CR_MSISRDY) == 0U)
 8002e7a:	4b31      	ldr	r3, [pc, #196]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002e7c:	681b      	ldr	r3, [r3, #0]
 8002e7e:	f003 0304 	and.w	r3, r3, #4
 8002e82:	2b00      	cmp	r3, #0
 8002e84:	d109      	bne.n	8002e9a <HAL_RCC_ClockConfig+0x1e2>
        {
          return HAL_ERROR;
 8002e86:	2301      	movs	r3, #1
 8002e88:	e0fa      	b.n	8003080 <HAL_RCC_ClockConfig+0x3c8>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8002e8a:	4b2d      	ldr	r3, [pc, #180]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002e8c:	681b      	ldr	r3, [r3, #0]
 8002e8e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8002e92:	2b00      	cmp	r3, #0
 8002e94:	d101      	bne.n	8002e9a <HAL_RCC_ClockConfig+0x1e2>
        {
          return HAL_ERROR;
 8002e96:	2301      	movs	r3, #1
 8002e98:	e0f2      	b.n	8003080 <HAL_RCC_ClockConfig+0x3c8>
        }
      }
    }

    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SW, pRCC_ClkInitStruct->SYSCLKSource);
 8002e9a:	4b29      	ldr	r3, [pc, #164]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002e9c:	69db      	ldr	r3, [r3, #28]
 8002e9e:	f023 0203 	bic.w	r2, r3, #3
 8002ea2:	687b      	ldr	r3, [r7, #4]
 8002ea4:	685b      	ldr	r3, [r3, #4]
 8002ea6:	4926      	ldr	r1, [pc, #152]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002ea8:	4313      	orrs	r3, r2
 8002eaa:	61cb      	str	r3, [r1, #28]

    tickstart = HAL_GetTick();
 8002eac:	f7fe fbf2 	bl	8001694 <HAL_GetTick>
 8002eb0:	6138      	str	r0, [r7, #16]

    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8002eb2:	687b      	ldr	r3, [r7, #4]
 8002eb4:	685b      	ldr	r3, [r3, #4]
 8002eb6:	2b03      	cmp	r3, #3
 8002eb8:	d112      	bne.n	8002ee0 <HAL_RCC_ClockConfig+0x228>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8002eba:	e00a      	b.n	8002ed2 <HAL_RCC_ClockConfig+0x21a>
      {
        if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002ebc:	f7fe fbea 	bl	8001694 <HAL_GetTick>
 8002ec0:	4602      	mov	r2, r0
 8002ec2:	693b      	ldr	r3, [r7, #16]
 8002ec4:	1ad3      	subs	r3, r2, r3
 8002ec6:	f241 3288 	movw	r2, #5000	; 0x1388
 8002eca:	4293      	cmp	r3, r2
 8002ecc:	d901      	bls.n	8002ed2 <HAL_RCC_ClockConfig+0x21a>
        {
          return HAL_TIMEOUT;
 8002ece:	2303      	movs	r3, #3
 8002ed0:	e0d6      	b.n	8003080 <HAL_RCC_ClockConfig+0x3c8>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8002ed2:	4b1b      	ldr	r3, [pc, #108]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002ed4:	69db      	ldr	r3, [r3, #28]
 8002ed6:	f003 030c 	and.w	r3, r3, #12
 8002eda:	2b0c      	cmp	r3, #12
 8002edc:	d1ee      	bne.n	8002ebc <HAL_RCC_ClockConfig+0x204>
 8002ede:	e044      	b.n	8002f6a <HAL_RCC_ClockConfig+0x2b2>
        }
      }
    }
    else
    {
      if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8002ee0:	687b      	ldr	r3, [r7, #4]
 8002ee2:	685b      	ldr	r3, [r3, #4]
 8002ee4:	2b02      	cmp	r3, #2
 8002ee6:	d112      	bne.n	8002f0e <HAL_RCC_ClockConfig+0x256>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8002ee8:	e00a      	b.n	8002f00 <HAL_RCC_ClockConfig+0x248>
        {
          if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002eea:	f7fe fbd3 	bl	8001694 <HAL_GetTick>
 8002eee:	4602      	mov	r2, r0
 8002ef0:	693b      	ldr	r3, [r7, #16]
 8002ef2:	1ad3      	subs	r3, r2, r3
 8002ef4:	f241 3288 	movw	r2, #5000	; 0x1388
 8002ef8:	4293      	cmp	r3, r2
 8002efa:	d901      	bls.n	8002f00 <HAL_RCC_ClockConfig+0x248>
          {
            return HAL_TIMEOUT;
 8002efc:	2303      	movs	r3, #3
 8002efe:	e0bf      	b.n	8003080 <HAL_RCC_ClockConfig+0x3c8>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8002f00:	4b0f      	ldr	r3, [pc, #60]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002f02:	69db      	ldr	r3, [r3, #28]
 8002f04:	f003 030c 	and.w	r3, r3, #12
 8002f08:	2b08      	cmp	r3, #8
 8002f0a:	d1ee      	bne.n	8002eea <HAL_RCC_ClockConfig+0x232>
 8002f0c:	e02d      	b.n	8002f6a <HAL_RCC_ClockConfig+0x2b2>
          }
        }
      }
      else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8002f0e:	687b      	ldr	r3, [r7, #4]
 8002f10:	685b      	ldr	r3, [r3, #4]
 8002f12:	2b00      	cmp	r3, #0
 8002f14:	d123      	bne.n	8002f5e <HAL_RCC_ClockConfig+0x2a6>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 8002f16:	e00a      	b.n	8002f2e <HAL_RCC_ClockConfig+0x276>
        {
          if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002f18:	f7fe fbbc 	bl	8001694 <HAL_GetTick>
 8002f1c:	4602      	mov	r2, r0
 8002f1e:	693b      	ldr	r3, [r7, #16]
 8002f20:	1ad3      	subs	r3, r2, r3
 8002f22:	f241 3288 	movw	r2, #5000	; 0x1388
 8002f26:	4293      	cmp	r3, r2
 8002f28:	d901      	bls.n	8002f2e <HAL_RCC_ClockConfig+0x276>
          {
            return HAL_TIMEOUT;
 8002f2a:	2303      	movs	r3, #3
 8002f2c:	e0a8      	b.n	8003080 <HAL_RCC_ClockConfig+0x3c8>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 8002f2e:	4b04      	ldr	r3, [pc, #16]	; (8002f40 <HAL_RCC_ClockConfig+0x288>)
 8002f30:	69db      	ldr	r3, [r3, #28]
 8002f32:	f003 030c 	and.w	r3, r3, #12
 8002f36:	2b00      	cmp	r3, #0
 8002f38:	d1ee      	bne.n	8002f18 <HAL_RCC_ClockConfig+0x260>
 8002f3a:	e016      	b.n	8002f6a <HAL_RCC_ClockConfig+0x2b2>
 8002f3c:	40022000 	.word	0x40022000
 8002f40:	46020c00 	.word	0x46020c00
 8002f44:	46020800 	.word	0x46020800
      }
      else
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
        {
          if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002f48:	f7fe fba4 	bl	8001694 <HAL_GetTick>
 8002f4c:	4602      	mov	r2, r0
 8002f4e:	693b      	ldr	r3, [r7, #16]
 8002f50:	1ad3      	subs	r3, r2, r3
 8002f52:	f241 3288 	movw	r2, #5000	; 0x1388
 8002f56:	4293      	cmp	r3, r2
 8002f58:	d901      	bls.n	8002f5e <HAL_RCC_ClockConfig+0x2a6>
          {
            return HAL_TIMEOUT;
 8002f5a:	2303      	movs	r3, #3
 8002f5c:	e090      	b.n	8003080 <HAL_RCC_ClockConfig+0x3c8>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8002f5e:	4b4a      	ldr	r3, [pc, #296]	; (8003088 <HAL_RCC_ClockConfig+0x3d0>)
 8002f60:	69db      	ldr	r3, [r3, #28]
 8002f62:	f003 030c 	and.w	r3, r3, #12
 8002f66:	2b04      	cmp	r3, #4
 8002f68:	d1ee      	bne.n	8002f48 <HAL_RCC_ClockConfig+0x290>
    }
  }

  /* Decreasing the BUS frequency divider */
  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8002f6a:	687b      	ldr	r3, [r7, #4]
 8002f6c:	681b      	ldr	r3, [r3, #0]
 8002f6e:	f003 0302 	and.w	r3, r3, #2
 8002f72:	2b00      	cmp	r3, #0
 8002f74:	d010      	beq.n	8002f98 <HAL_RCC_ClockConfig+0x2e0>
  {
    if ((pRCC_ClkInitStruct->AHBCLKDivider) < (RCC->CFGR2 & RCC_CFGR2_HPRE))
 8002f76:	687b      	ldr	r3, [r7, #4]
 8002f78:	689a      	ldr	r2, [r3, #8]
 8002f7a:	4b43      	ldr	r3, [pc, #268]	; (8003088 <HAL_RCC_ClockConfig+0x3d0>)
 8002f7c:	6a1b      	ldr	r3, [r3, #32]
 8002f7e:	f003 030f 	and.w	r3, r3, #15
 8002f82:	429a      	cmp	r2, r3
 8002f84:	d208      	bcs.n	8002f98 <HAL_RCC_ClockConfig+0x2e0>
    {
      assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
 8002f86:	4b40      	ldr	r3, [pc, #256]	; (8003088 <HAL_RCC_ClockConfig+0x3d0>)
 8002f88:	6a1b      	ldr	r3, [r3, #32]
 8002f8a:	f023 020f 	bic.w	r2, r3, #15
 8002f8e:	687b      	ldr	r3, [r7, #4]
 8002f90:	689b      	ldr	r3, [r3, #8]
 8002f92:	493d      	ldr	r1, [pc, #244]	; (8003088 <HAL_RCC_ClockConfig+0x3d0>)
 8002f94:	4313      	orrs	r3, r2
 8002f96:	620b      	str	r3, [r1, #32]
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8002f98:	4b3c      	ldr	r3, [pc, #240]	; (800308c <HAL_RCC_ClockConfig+0x3d4>)
 8002f9a:	681b      	ldr	r3, [r3, #0]
 8002f9c:	f003 030f 	and.w	r3, r3, #15
 8002fa0:	683a      	ldr	r2, [r7, #0]
 8002fa2:	429a      	cmp	r2, r3
 8002fa4:	d210      	bcs.n	8002fc8 <HAL_RCC_ClockConfig+0x310>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002fa6:	4b39      	ldr	r3, [pc, #228]	; (800308c <HAL_RCC_ClockConfig+0x3d4>)
 8002fa8:	681b      	ldr	r3, [r3, #0]
 8002faa:	f023 020f 	bic.w	r2, r3, #15
 8002fae:	4937      	ldr	r1, [pc, #220]	; (800308c <HAL_RCC_ClockConfig+0x3d4>)
 8002fb0:	683b      	ldr	r3, [r7, #0]
 8002fb2:	4313      	orrs	r3, r2
 8002fb4:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8002fb6:	4b35      	ldr	r3, [pc, #212]	; (800308c <HAL_RCC_ClockConfig+0x3d4>)
 8002fb8:	681b      	ldr	r3, [r3, #0]
 8002fba:	f003 030f 	and.w	r3, r3, #15
 8002fbe:	683a      	ldr	r2, [r7, #0]
 8002fc0:	429a      	cmp	r2, r3
 8002fc2:	d001      	beq.n	8002fc8 <HAL_RCC_ClockConfig+0x310>
    {
      return HAL_ERROR;
 8002fc4:	2301      	movs	r3, #1
 8002fc6:	e05b      	b.n	8003080 <HAL_RCC_ClockConfig+0x3c8>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8002fc8:	687b      	ldr	r3, [r7, #4]
 8002fca:	681b      	ldr	r3, [r3, #0]
 8002fcc:	f003 0304 	and.w	r3, r3, #4
 8002fd0:	2b00      	cmp	r3, #0
 8002fd2:	d010      	beq.n	8002ff6 <HAL_RCC_ClockConfig+0x33e>
  {
    if ((pRCC_ClkInitStruct->APB1CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE1))
 8002fd4:	687b      	ldr	r3, [r7, #4]
 8002fd6:	68da      	ldr	r2, [r3, #12]
 8002fd8:	4b2b      	ldr	r3, [pc, #172]	; (8003088 <HAL_RCC_ClockConfig+0x3d0>)
 8002fda:	6a1b      	ldr	r3, [r3, #32]
 8002fdc:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8002fe0:	429a      	cmp	r2, r3
 8002fe2:	d208      	bcs.n	8002ff6 <HAL_RCC_ClockConfig+0x33e>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, pRCC_ClkInitStruct->APB1CLKDivider);
 8002fe4:	4b28      	ldr	r3, [pc, #160]	; (8003088 <HAL_RCC_ClockConfig+0x3d0>)
 8002fe6:	6a1b      	ldr	r3, [r3, #32]
 8002fe8:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 8002fec:	687b      	ldr	r3, [r7, #4]
 8002fee:	68db      	ldr	r3, [r3, #12]
 8002ff0:	4925      	ldr	r1, [pc, #148]	; (8003088 <HAL_RCC_ClockConfig+0x3d0>)
 8002ff2:	4313      	orrs	r3, r2
 8002ff4:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002ff6:	687b      	ldr	r3, [r7, #4]
 8002ff8:	681b      	ldr	r3, [r3, #0]
 8002ffa:	f003 0308 	and.w	r3, r3, #8
 8002ffe:	2b00      	cmp	r3, #0
 8003000:	d012      	beq.n	8003028 <HAL_RCC_ClockConfig+0x370>
  {
    if ((pRCC_ClkInitStruct->APB2CLKDivider) < ((RCC->CFGR2 & RCC_CFGR2_PPRE2) >> 4))
 8003002:	687b      	ldr	r3, [r7, #4]
 8003004:	691a      	ldr	r2, [r3, #16]
 8003006:	4b20      	ldr	r3, [pc, #128]	; (8003088 <HAL_RCC_ClockConfig+0x3d0>)
 8003008:	6a1b      	ldr	r3, [r3, #32]
 800300a:	091b      	lsrs	r3, r3, #4
 800300c:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8003010:	429a      	cmp	r2, r3
 8003012:	d209      	bcs.n	8003028 <HAL_RCC_ClockConfig+0x370>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, ((pRCC_ClkInitStruct->APB2CLKDivider) << 4));
 8003014:	4b1c      	ldr	r3, [pc, #112]	; (8003088 <HAL_RCC_ClockConfig+0x3d0>)
 8003016:	6a1b      	ldr	r3, [r3, #32]
 8003018:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 800301c:	687b      	ldr	r3, [r7, #4]
 800301e:	691b      	ldr	r3, [r3, #16]
 8003020:	011b      	lsls	r3, r3, #4
 8003022:	4919      	ldr	r1, [pc, #100]	; (8003088 <HAL_RCC_ClockConfig+0x3d0>)
 8003024:	4313      	orrs	r3, r2
 8003026:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- PCLK3 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK3) == RCC_CLOCKTYPE_PCLK3)
 8003028:	687b      	ldr	r3, [r7, #4]
 800302a:	681b      	ldr	r3, [r3, #0]
 800302c:	f003 0310 	and.w	r3, r3, #16
 8003030:	2b00      	cmp	r3, #0
 8003032:	d010      	beq.n	8003056 <HAL_RCC_ClockConfig+0x39e>
  {
    if ((pRCC_ClkInitStruct->APB3CLKDivider) < (RCC->CFGR3 & RCC_CFGR3_PPRE3))
 8003034:	687b      	ldr	r3, [r7, #4]
 8003036:	695a      	ldr	r2, [r3, #20]
 8003038:	4b13      	ldr	r3, [pc, #76]	; (8003088 <HAL_RCC_ClockConfig+0x3d0>)
 800303a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800303c:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8003040:	429a      	cmp	r2, r3
 8003042:	d208      	bcs.n	8003056 <HAL_RCC_ClockConfig+0x39e>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->CFGR3, RCC_CFGR3_PPRE3, (pRCC_ClkInitStruct->APB3CLKDivider));
 8003044:	4b10      	ldr	r3, [pc, #64]	; (8003088 <HAL_RCC_ClockConfig+0x3d0>)
 8003046:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003048:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 800304c:	687b      	ldr	r3, [r7, #4]
 800304e:	695b      	ldr	r3, [r3, #20]
 8003050:	490d      	ldr	r1, [pc, #52]	; (8003088 <HAL_RCC_ClockConfig+0x3d0>)
 8003052:	4313      	orrs	r3, r2
 8003054:	624b      	str	r3, [r1, #36]	; 0x24
    }
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
 8003056:	f000 f821 	bl	800309c <HAL_RCC_GetSysClockFreq>
 800305a:	4602      	mov	r2, r0
 800305c:	4b0a      	ldr	r3, [pc, #40]	; (8003088 <HAL_RCC_ClockConfig+0x3d0>)
 800305e:	6a1b      	ldr	r3, [r3, #32]
 8003060:	f003 030f 	and.w	r3, r3, #15
 8003064:	490a      	ldr	r1, [pc, #40]	; (8003090 <HAL_RCC_ClockConfig+0x3d8>)
 8003066:	5ccb      	ldrb	r3, [r1, r3]
 8003068:	fa22 f303 	lsr.w	r3, r2, r3
 800306c:	4a09      	ldr	r2, [pc, #36]	; (8003094 <HAL_RCC_ClockConfig+0x3dc>)
 800306e:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(uwTickPrio);
 8003070:	4b09      	ldr	r3, [pc, #36]	; (8003098 <HAL_RCC_ClockConfig+0x3e0>)
 8003072:	681b      	ldr	r3, [r3, #0]
 8003074:	4618      	mov	r0, r3
 8003076:	f7fe f965 	bl	8001344 <HAL_InitTick>
 800307a:	4603      	mov	r3, r0
 800307c:	73fb      	strb	r3, [r7, #15]

  return status;
 800307e:	7bfb      	ldrb	r3, [r7, #15]
}
 8003080:	4618      	mov	r0, r3
 8003082:	3718      	adds	r7, #24
 8003084:	46bd      	mov	sp, r7
 8003086:	bd80      	pop	{r7, pc}
 8003088:	46020c00 	.word	0x46020c00
 800308c:	40022000 	.word	0x40022000
 8003090:	08017a94 	.word	0x08017a94
 8003094:	20000000 	.word	0x20000000
 8003098:	20000004 	.word	0x20000004

0800309c <HAL_RCC_GetSysClockFreq>:
  * @note   Each time SYSCLK changes, this function must be called to update the
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800309c:	b480      	push	{r7}
 800309e:	b08b      	sub	sp, #44	; 0x2c
 80030a0:	af00      	add	r7, sp, #0
  uint32_t msirange = 0U;
 80030a2:	2300      	movs	r3, #0
 80030a4:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t pllsource;
  uint32_t pllr;
  uint32_t pllm;
  uint32_t pllfracen;
  uint32_t sysclockfreq = 0U;
 80030a6:	2300      	movs	r3, #0
 80030a8:	623b      	str	r3, [r7, #32]
  uint32_t sysclk_source;
  uint32_t pll_oscsource;
  float_t fracn1;
  float_t pllvco;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 80030aa:	4b78      	ldr	r3, [pc, #480]	; (800328c <HAL_RCC_GetSysClockFreq+0x1f0>)
 80030ac:	69db      	ldr	r3, [r3, #28]
 80030ae:	f003 030c 	and.w	r3, r3, #12
 80030b2:	61bb      	str	r3, [r7, #24]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 80030b4:	4b75      	ldr	r3, [pc, #468]	; (800328c <HAL_RCC_GetSysClockFreq+0x1f0>)
 80030b6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80030b8:	f003 0303 	and.w	r3, r3, #3
 80030bc:	617b      	str	r3, [r7, #20]

  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 80030be:	69bb      	ldr	r3, [r7, #24]
 80030c0:	2b00      	cmp	r3, #0
 80030c2:	d005      	beq.n	80030d0 <HAL_RCC_GetSysClockFreq+0x34>
 80030c4:	69bb      	ldr	r3, [r7, #24]
 80030c6:	2b0c      	cmp	r3, #12
 80030c8:	d121      	bne.n	800310e <HAL_RCC_GetSysClockFreq+0x72>
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 80030ca:	697b      	ldr	r3, [r7, #20]
 80030cc:	2b01      	cmp	r3, #1
 80030ce:	d11e      	bne.n	800310e <HAL_RCC_GetSysClockFreq+0x72>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if (READ_BIT(RCC->ICSCR1, RCC_ICSCR1_MSIRGSEL) == 0U)
 80030d0:	4b6e      	ldr	r3, [pc, #440]	; (800328c <HAL_RCC_GetSysClockFreq+0x1f0>)
 80030d2:	689b      	ldr	r3, [r3, #8]
 80030d4:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 80030d8:	2b00      	cmp	r3, #0
 80030da:	d107      	bne.n	80030ec <HAL_RCC_GetSysClockFreq+0x50>
    {
      /* MSISRANGE from RCC_CSR applies */
      msirange = (RCC->CSR & RCC_CSR_MSISSRANGE) >> RCC_CSR_MSISSRANGE_Pos;
 80030dc:	4b6b      	ldr	r3, [pc, #428]	; (800328c <HAL_RCC_GetSysClockFreq+0x1f0>)
 80030de:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 80030e2:	0b1b      	lsrs	r3, r3, #12
 80030e4:	f003 030f 	and.w	r3, r3, #15
 80030e8:	627b      	str	r3, [r7, #36]	; 0x24
 80030ea:	e005      	b.n	80030f8 <HAL_RCC_GetSysClockFreq+0x5c>
    }
    else
    {
      /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->ICSCR1 & RCC_ICSCR1_MSISRANGE) >> RCC_ICSCR1_MSISRANGE_Pos;
 80030ec:	4b67      	ldr	r3, [pc, #412]	; (800328c <HAL_RCC_GetSysClockFreq+0x1f0>)
 80030ee:	689b      	ldr	r3, [r3, #8]
 80030f0:	0f1b      	lsrs	r3, r3, #28
 80030f2:	f003 030f 	and.w	r3, r3, #15
 80030f6:	627b      	str	r3, [r7, #36]	; 0x24
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 80030f8:	4a65      	ldr	r2, [pc, #404]	; (8003290 <HAL_RCC_GetSysClockFreq+0x1f4>)
 80030fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80030fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8003100:	627b      	str	r3, [r7, #36]	; 0x24

    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8003102:	69bb      	ldr	r3, [r7, #24]
 8003104:	2b00      	cmp	r3, #0
 8003106:	d110      	bne.n	800312a <HAL_RCC_GetSysClockFreq+0x8e>
    {
      /* MSI used as system clock source */
      sysclockfreq = msirange;
 8003108:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800310a:	623b      	str	r3, [r7, #32]
    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 800310c:	e00d      	b.n	800312a <HAL_RCC_GetSysClockFreq+0x8e>
    }
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 800310e:	4b5f      	ldr	r3, [pc, #380]	; (800328c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8003110:	69db      	ldr	r3, [r3, #28]
 8003112:	f003 030c 	and.w	r3, r3, #12
 8003116:	2b04      	cmp	r3, #4
 8003118:	d102      	bne.n	8003120 <HAL_RCC_GetSysClockFreq+0x84>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 800311a:	4b5e      	ldr	r3, [pc, #376]	; (8003294 <HAL_RCC_GetSysClockFreq+0x1f8>)
 800311c:	623b      	str	r3, [r7, #32]
 800311e:	e004      	b.n	800312a <HAL_RCC_GetSysClockFreq+0x8e>
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 8003120:	69bb      	ldr	r3, [r7, #24]
 8003122:	2b08      	cmp	r3, #8
 8003124:	d101      	bne.n	800312a <HAL_RCC_GetSysClockFreq+0x8e>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
 8003126:	4b5b      	ldr	r3, [pc, #364]	; (8003294 <HAL_RCC_GetSysClockFreq+0x1f8>)
 8003128:	623b      	str	r3, [r7, #32]
  else
  {
    /* Nothing to do */
  }

  if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800312a:	69bb      	ldr	r3, [r7, #24]
 800312c:	2b0c      	cmp	r3, #12
 800312e:	f040 80a5 	bne.w	800327c <HAL_RCC_GetSysClockFreq+0x1e0>
  {
    /* PLL used as system clock  source
       PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
       SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
 8003132:	4b56      	ldr	r3, [pc, #344]	; (800328c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8003134:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003136:	f003 0303 	and.w	r3, r3, #3
 800313a:	613b      	str	r3, [r7, #16]
    pllm = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos) + 1U;
 800313c:	4b53      	ldr	r3, [pc, #332]	; (800328c <HAL_RCC_GetSysClockFreq+0x1f0>)
 800313e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003140:	0a1b      	lsrs	r3, r3, #8
 8003142:	f003 030f 	and.w	r3, r3, #15
 8003146:	3301      	adds	r3, #1
 8003148:	60fb      	str	r3, [r7, #12]
    pllfracen = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN) >> RCC_PLL1CFGR_PLL1FRACEN_Pos);
 800314a:	4b50      	ldr	r3, [pc, #320]	; (800328c <HAL_RCC_GetSysClockFreq+0x1f0>)
 800314c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800314e:	091b      	lsrs	r3, r3, #4
 8003150:	f003 0301 	and.w	r3, r3, #1
 8003154:	60bb      	str	r3, [r7, #8]
    fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 8003156:	4b4d      	ldr	r3, [pc, #308]	; (800328c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8003158:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800315a:	08db      	lsrs	r3, r3, #3
 800315c:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8003160:	68ba      	ldr	r2, [r7, #8]
 8003162:	fb02 f303 	mul.w	r3, r2, r3
 8003166:	ee07 3a90 	vmov	s15, r3
 800316a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800316e:	edc7 7a01 	vstr	s15, [r7, #4]
                                              RCC_PLL1FRACR_PLL1FRACN_Pos));

    switch (pllsource)
 8003172:	693b      	ldr	r3, [r7, #16]
 8003174:	2b02      	cmp	r3, #2
 8003176:	d003      	beq.n	8003180 <HAL_RCC_GetSysClockFreq+0xe4>
 8003178:	693b      	ldr	r3, [r7, #16]
 800317a:	2b03      	cmp	r3, #3
 800317c:	d022      	beq.n	80031c4 <HAL_RCC_GetSysClockFreq+0x128>
 800317e:	e043      	b.n	8003208 <HAL_RCC_GetSysClockFreq+0x16c>
    {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
        pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8003180:	68fb      	ldr	r3, [r7, #12]
 8003182:	ee07 3a90 	vmov	s15, r3
 8003186:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800318a:	eddf 6a43 	vldr	s13, [pc, #268]	; 8003298 <HAL_RCC_GetSysClockFreq+0x1fc>
 800318e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8003192:	4b3e      	ldr	r3, [pc, #248]	; (800328c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8003194:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003196:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800319a:	ee07 3a90 	vmov	s15, r3
 800319e:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 80031a2:	ed97 6a01 	vldr	s12, [r7, #4]
 80031a6:	eddf 5a3d 	vldr	s11, [pc, #244]	; 800329c <HAL_RCC_GetSysClockFreq+0x200>
 80031aa:	eec6 7a25 	vdiv.f32	s15, s12, s11
        pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 80031ae:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 80031b2:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 80031b6:	ee77 7aa6 	vadd.f32	s15, s15, s13
        pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 80031ba:	ee67 7a27 	vmul.f32	s15, s14, s15
 80031be:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 80031c2:	e046      	b.n	8003252 <HAL_RCC_GetSysClockFreq+0x1b6>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 80031c4:	68fb      	ldr	r3, [r7, #12]
 80031c6:	ee07 3a90 	vmov	s15, r3
 80031ca:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80031ce:	eddf 6a32 	vldr	s13, [pc, #200]	; 8003298 <HAL_RCC_GetSysClockFreq+0x1fc>
 80031d2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 80031d6:	4b2d      	ldr	r3, [pc, #180]	; (800328c <HAL_RCC_GetSysClockFreq+0x1f0>)
 80031d8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80031da:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80031de:	ee07 3a90 	vmov	s15, r3
 80031e2:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 80031e6:	ed97 6a01 	vldr	s12, [r7, #4]
 80031ea:	eddf 5a2c 	vldr	s11, [pc, #176]	; 800329c <HAL_RCC_GetSysClockFreq+0x200>
 80031ee:	eec6 7a25 	vdiv.f32	s15, s12, s11
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 80031f2:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 80031f6:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 80031fa:	ee77 7aa6 	vadd.f32	s15, s15, s13
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 80031fe:	ee67 7a27 	vmul.f32	s15, s14, s15
 8003202:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8003206:	e024      	b.n	8003252 <HAL_RCC_GetSysClockFreq+0x1b6>

      case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      default:
        pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8003208:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800320a:	ee07 3a90 	vmov	s15, r3
 800320e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8003212:	68fb      	ldr	r3, [r7, #12]
 8003214:	ee07 3a90 	vmov	s15, r3
 8003218:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800321c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8003220:	4b1a      	ldr	r3, [pc, #104]	; (800328c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8003222:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003224:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003228:	ee07 3a90 	vmov	s15, r3
 800322c:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 8003230:	ed97 6a01 	vldr	s12, [r7, #4]
 8003234:	eddf 5a19 	vldr	s11, [pc, #100]	; 800329c <HAL_RCC_GetSysClockFreq+0x200>
 8003238:	eec6 7a25 	vdiv.f32	s15, s12, s11
        pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800323c:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 8003240:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8003244:	ee77 7aa6 	vadd.f32	s15, s15, s13
        pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8003248:	ee67 7a27 	vmul.f32	s15, s14, s15
 800324c:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8003250:	bf00      	nop
    }

    pllr = (((RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1R) >> RCC_PLL1DIVR_PLL1R_Pos) + 1U);
 8003252:	4b0e      	ldr	r3, [pc, #56]	; (800328c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8003254:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003256:	0e1b      	lsrs	r3, r3, #24
 8003258:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800325c:	3301      	adds	r3, #1
 800325e:	603b      	str	r3, [r7, #0]
    sysclockfreq = (uint32_t)(float_t)((float_t)pllvco / (float_t)pllr);
 8003260:	683b      	ldr	r3, [r7, #0]
 8003262:	ee07 3a90 	vmov	s15, r3
 8003266:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 800326a:	edd7 6a07 	vldr	s13, [r7, #28]
 800326e:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8003272:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8003276:	ee17 3a90 	vmov	r3, s15
 800327a:	623b      	str	r3, [r7, #32]
  }

  return sysclockfreq;
 800327c:	6a3b      	ldr	r3, [r7, #32]
}
 800327e:	4618      	mov	r0, r3
 8003280:	372c      	adds	r7, #44	; 0x2c
 8003282:	46bd      	mov	sp, r7
 8003284:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003288:	4770      	bx	lr
 800328a:	bf00      	nop
 800328c:	46020c00 	.word	0x46020c00
 8003290:	08017aac 	.word	0x08017aac
 8003294:	00f42400 	.word	0x00f42400
 8003298:	4b742400 	.word	0x4b742400
 800329c:	46000000 	.word	0x46000000

080032a0 <HAL_RCC_GetHCLKFreq>:
  *
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 80032a0:	b580      	push	{r7, lr}
 80032a2:	af00      	add	r7, sp, #0
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
 80032a4:	f7ff fefa 	bl	800309c <HAL_RCC_GetSysClockFreq>
 80032a8:	4602      	mov	r2, r0
 80032aa:	4b07      	ldr	r3, [pc, #28]	; (80032c8 <HAL_RCC_GetHCLKFreq+0x28>)
 80032ac:	6a1b      	ldr	r3, [r3, #32]
 80032ae:	f003 030f 	and.w	r3, r3, #15
 80032b2:	4906      	ldr	r1, [pc, #24]	; (80032cc <HAL_RCC_GetHCLKFreq+0x2c>)
 80032b4:	5ccb      	ldrb	r3, [r1, r3]
 80032b6:	fa22 f303 	lsr.w	r3, r2, r3
 80032ba:	4a05      	ldr	r2, [pc, #20]	; (80032d0 <HAL_RCC_GetHCLKFreq+0x30>)
 80032bc:	6013      	str	r3, [r2, #0]
  return SystemCoreClock;
 80032be:	4b04      	ldr	r3, [pc, #16]	; (80032d0 <HAL_RCC_GetHCLKFreq+0x30>)
 80032c0:	681b      	ldr	r3, [r3, #0]
}
 80032c2:	4618      	mov	r0, r3
 80032c4:	bd80      	pop	{r7, pc}
 80032c6:	bf00      	nop
 80032c8:	46020c00 	.word	0x46020c00
 80032cc:	08017a94 	.word	0x08017a94
 80032d0:	20000000 	.word	0x20000000

080032d4 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 80032d4:	b580      	push	{r7, lr}
 80032d6:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR2 & RCC_CFGR2_PPRE1) >> RCC_CFGR2_PPRE1_Pos]);
 80032d8:	f7ff ffe2 	bl	80032a0 <HAL_RCC_GetHCLKFreq>
 80032dc:	4602      	mov	r2, r0
 80032de:	4b05      	ldr	r3, [pc, #20]	; (80032f4 <HAL_RCC_GetPCLK1Freq+0x20>)
 80032e0:	6a1b      	ldr	r3, [r3, #32]
 80032e2:	091b      	lsrs	r3, r3, #4
 80032e4:	f003 0307 	and.w	r3, r3, #7
 80032e8:	4903      	ldr	r1, [pc, #12]	; (80032f8 <HAL_RCC_GetPCLK1Freq+0x24>)
 80032ea:	5ccb      	ldrb	r3, [r1, r3]
 80032ec:	fa22 f303 	lsr.w	r3, r2, r3
}
 80032f0:	4618      	mov	r0, r3
 80032f2:	bd80      	pop	{r7, pc}
 80032f4:	46020c00 	.word	0x46020c00
 80032f8:	08017aa4 	.word	0x08017aa4

080032fc <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 80032fc:	b580      	push	{r7, lr}
 80032fe:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR2 & RCC_CFGR2_PPRE2) >> RCC_CFGR2_PPRE2_Pos]);
 8003300:	f7ff ffce 	bl	80032a0 <HAL_RCC_GetHCLKFreq>
 8003304:	4602      	mov	r2, r0
 8003306:	4b05      	ldr	r3, [pc, #20]	; (800331c <HAL_RCC_GetPCLK2Freq+0x20>)
 8003308:	6a1b      	ldr	r3, [r3, #32]
 800330a:	0a1b      	lsrs	r3, r3, #8
 800330c:	f003 0307 	and.w	r3, r3, #7
 8003310:	4903      	ldr	r1, [pc, #12]	; (8003320 <HAL_RCC_GetPCLK2Freq+0x24>)
 8003312:	5ccb      	ldrb	r3, [r1, r3]
 8003314:	fa22 f303 	lsr.w	r3, r2, r3
}
 8003318:	4618      	mov	r0, r3
 800331a:	bd80      	pop	{r7, pc}
 800331c:	46020c00 	.word	0x46020c00
 8003320:	08017aa4 	.word	0x08017aa4

08003324 <HAL_RCC_GetPCLK3Freq>:
  * @note   Each time PCLK3 changes, this function must be called to update the
  *         right PCLK3 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK3 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK3Freq(void)
{
 8003324:	b580      	push	{r7, lr}
 8003326:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR3 & RCC_CFGR3_PPRE3) >> RCC_CFGR3_PPRE3_Pos]);
 8003328:	f7ff ffba 	bl	80032a0 <HAL_RCC_GetHCLKFreq>
 800332c:	4602      	mov	r2, r0
 800332e:	4b05      	ldr	r3, [pc, #20]	; (8003344 <HAL_RCC_GetPCLK3Freq+0x20>)
 8003330:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003332:	091b      	lsrs	r3, r3, #4
 8003334:	f003 0307 	and.w	r3, r3, #7
 8003338:	4903      	ldr	r1, [pc, #12]	; (8003348 <HAL_RCC_GetPCLK3Freq+0x24>)
 800333a:	5ccb      	ldrb	r3, [r1, r3]
 800333c:	fa22 f303 	lsr.w	r3, r2, r3
}
 8003340:	4618      	mov	r0, r3
 8003342:	bd80      	pop	{r7, pc}
 8003344:	46020c00 	.word	0x46020c00
 8003348:	08017aa4 	.word	0x08017aa4

0800334c <HAL_RCC_GetClockConfig>:
  *         will be configured.
  * @param  pFLatency  Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *pRCC_ClkInitStruct, uint32_t *pFLatency)
{
 800334c:	b480      	push	{r7}
 800334e:	b083      	sub	sp, #12
 8003350:	af00      	add	r7, sp, #0
 8003352:	6078      	str	r0, [r7, #4]
 8003354:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(pRCC_ClkInitStruct != (void *)NULL);
  assert_param(pFLatency != (void *)NULL);

  /* Set all possible values for the Clock type parameter --------------------*/
  pRCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | \
 8003356:	687b      	ldr	r3, [r7, #4]
 8003358:	221f      	movs	r2, #31
 800335a:	601a      	str	r2, [r3, #0]
                                  RCC_CLOCKTYPE_PCLK2 | RCC_CLOCKTYPE_PCLK3;

  /* Get the SYSCLK configuration --------------------------------------------*/
  pRCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR1 & RCC_CFGR1_SW);
 800335c:	4b15      	ldr	r3, [pc, #84]	; (80033b4 <HAL_RCC_GetClockConfig+0x68>)
 800335e:	69db      	ldr	r3, [r3, #28]
 8003360:	f003 0203 	and.w	r2, r3, #3
 8003364:	687b      	ldr	r3, [r7, #4]
 8003366:	605a      	str	r2, [r3, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR2 & RCC_CFGR2_HPRE);
 8003368:	4b12      	ldr	r3, [pc, #72]	; (80033b4 <HAL_RCC_GetClockConfig+0x68>)
 800336a:	6a1b      	ldr	r3, [r3, #32]
 800336c:	f003 020f 	and.w	r2, r3, #15
 8003370:	687b      	ldr	r3, [r7, #4]
 8003372:	609a      	str	r2, [r3, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR2 & RCC_CFGR2_PPRE1);
 8003374:	4b0f      	ldr	r3, [pc, #60]	; (80033b4 <HAL_RCC_GetClockConfig+0x68>)
 8003376:	6a1b      	ldr	r3, [r3, #32]
 8003378:	f003 0270 	and.w	r2, r3, #112	; 0x70
 800337c:	687b      	ldr	r3, [r7, #4]
 800337e:	60da      	str	r2, [r3, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR2 & RCC_CFGR2_PPRE2) >> 4);
 8003380:	4b0c      	ldr	r3, [pc, #48]	; (80033b4 <HAL_RCC_GetClockConfig+0x68>)
 8003382:	6a1b      	ldr	r3, [r3, #32]
 8003384:	091b      	lsrs	r3, r3, #4
 8003386:	f003 0270 	and.w	r2, r3, #112	; 0x70
 800338a:	687b      	ldr	r3, [r7, #4]
 800338c:	611a      	str	r2, [r3, #16]

  /* Get the APB3 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->CFGR3 & RCC_CFGR3_PPRE3);
 800338e:	4b09      	ldr	r3, [pc, #36]	; (80033b4 <HAL_RCC_GetClockConfig+0x68>)
 8003390:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003392:	f003 0270 	and.w	r2, r3, #112	; 0x70
 8003396:	687b      	ldr	r3, [r7, #4]
 8003398:	615a      	str	r2, [r3, #20]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 800339a:	4b07      	ldr	r3, [pc, #28]	; (80033b8 <HAL_RCC_GetClockConfig+0x6c>)
 800339c:	681b      	ldr	r3, [r3, #0]
 800339e:	f003 020f 	and.w	r2, r3, #15
 80033a2:	683b      	ldr	r3, [r7, #0]
 80033a4:	601a      	str	r2, [r3, #0]
}
 80033a6:	bf00      	nop
 80033a8:	370c      	adds	r7, #12
 80033aa:	46bd      	mov	sp, r7
 80033ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80033b0:	4770      	bx	lr
 80033b2:	bf00      	nop
 80033b4:	46020c00 	.word	0x46020c00
 80033b8:	40022000 	.word	0x40022000

080033bc <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_15
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 80033bc:	b580      	push	{r7, lr}
 80033be:	b086      	sub	sp, #24
 80033c0:	af00      	add	r7, sp, #0
 80033c2:	6078      	str	r0, [r7, #4]
  uint32_t vos;
  uint32_t latency;  /* default value 0WS */

  if (__HAL_RCC_PWR_IS_CLK_ENABLED())
 80033c4:	4b3e      	ldr	r3, [pc, #248]	; (80034c0 <RCC_SetFlashLatencyFromMSIRange+0x104>)
 80033c6:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80033ca:	f003 0304 	and.w	r3, r3, #4
 80033ce:	2b00      	cmp	r3, #0
 80033d0:	d003      	beq.n	80033da <RCC_SetFlashLatencyFromMSIRange+0x1e>
  {
    vos = HAL_PWREx_GetVoltageRange();
 80033d2:	f7fe fd27 	bl	8001e24 <HAL_PWREx_GetVoltageRange>
 80033d6:	6178      	str	r0, [r7, #20]
 80033d8:	e019      	b.n	800340e <RCC_SetFlashLatencyFromMSIRange+0x52>
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
 80033da:	4b39      	ldr	r3, [pc, #228]	; (80034c0 <RCC_SetFlashLatencyFromMSIRange+0x104>)
 80033dc:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80033e0:	4a37      	ldr	r2, [pc, #220]	; (80034c0 <RCC_SetFlashLatencyFromMSIRange+0x104>)
 80033e2:	f043 0304 	orr.w	r3, r3, #4
 80033e6:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 80033ea:	4b35      	ldr	r3, [pc, #212]	; (80034c0 <RCC_SetFlashLatencyFromMSIRange+0x104>)
 80033ec:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80033f0:	f003 0304 	and.w	r3, r3, #4
 80033f4:	60fb      	str	r3, [r7, #12]
 80033f6:	68fb      	ldr	r3, [r7, #12]
    vos = HAL_PWREx_GetVoltageRange();
 80033f8:	f7fe fd14 	bl	8001e24 <HAL_PWREx_GetVoltageRange>
 80033fc:	6178      	str	r0, [r7, #20]
    __HAL_RCC_PWR_CLK_DISABLE();
 80033fe:	4b30      	ldr	r3, [pc, #192]	; (80034c0 <RCC_SetFlashLatencyFromMSIRange+0x104>)
 8003400:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003404:	4a2e      	ldr	r2, [pc, #184]	; (80034c0 <RCC_SetFlashLatencyFromMSIRange+0x104>)
 8003406:	f023 0304 	bic.w	r3, r3, #4
 800340a:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  }

  if ((vos == PWR_REGULATOR_VOLTAGE_SCALE1) || (vos == PWR_REGULATOR_VOLTAGE_SCALE2))
 800340e:	697b      	ldr	r3, [r7, #20]
 8003410:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 8003414:	d003      	beq.n	800341e <RCC_SetFlashLatencyFromMSIRange+0x62>
 8003416:	697b      	ldr	r3, [r7, #20]
 8003418:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800341c:	d109      	bne.n	8003432 <RCC_SetFlashLatencyFromMSIRange+0x76>
  {

    if (msirange < RCC_MSIRANGE_1)
 800341e:	687b      	ldr	r3, [r7, #4]
 8003420:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8003424:	d202      	bcs.n	800342c <RCC_SetFlashLatencyFromMSIRange+0x70>
    {
      /* MSI = 48Mhz */
      latency = FLASH_LATENCY_1; /* 1WS */
 8003426:	2301      	movs	r3, #1
 8003428:	613b      	str	r3, [r7, #16]
    if (msirange < RCC_MSIRANGE_1)
 800342a:	e033      	b.n	8003494 <RCC_SetFlashLatencyFromMSIRange+0xd8>
    }
    else
    {
      /*  MSI < 48Mhz */
      latency = FLASH_LATENCY_0; /* 0WS */
 800342c:	2300      	movs	r3, #0
 800342e:	613b      	str	r3, [r7, #16]
    if (msirange < RCC_MSIRANGE_1)
 8003430:	e030      	b.n	8003494 <RCC_SetFlashLatencyFromMSIRange+0xd8>
    }
  }
  else
  {
    if (msirange < RCC_MSIRANGE_1)
 8003432:	687b      	ldr	r3, [r7, #4]
 8003434:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8003438:	d208      	bcs.n	800344c <RCC_SetFlashLatencyFromMSIRange+0x90>
    {
      /* MSI = 48Mhz */
      if (vos == PWR_REGULATOR_VOLTAGE_SCALE3)
 800343a:	697b      	ldr	r3, [r7, #20]
 800343c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003440:	d102      	bne.n	8003448 <RCC_SetFlashLatencyFromMSIRange+0x8c>
      {
        latency = FLASH_LATENCY_3; /* 3WS */
 8003442:	2303      	movs	r3, #3
 8003444:	613b      	str	r3, [r7, #16]
 8003446:	e025      	b.n	8003494 <RCC_SetFlashLatencyFromMSIRange+0xd8>
      }
      else
      {
        return HAL_ERROR;
 8003448:	2301      	movs	r3, #1
 800344a:	e035      	b.n	80034b8 <RCC_SetFlashLatencyFromMSIRange+0xfc>
      }
    }
    else
    {
      if (msirange > RCC_MSIRANGE_2)
 800344c:	687b      	ldr	r3, [r7, #4]
 800344e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8003452:	d90f      	bls.n	8003474 <RCC_SetFlashLatencyFromMSIRange+0xb8>
      {
        if (vos == PWR_REGULATOR_VOLTAGE_SCALE4)
 8003454:	697b      	ldr	r3, [r7, #20]
 8003456:	2b00      	cmp	r3, #0
 8003458:	d109      	bne.n	800346e <RCC_SetFlashLatencyFromMSIRange+0xb2>
        {
          if (msirange > RCC_MSIRANGE_3)
 800345a:	687b      	ldr	r3, [r7, #4]
 800345c:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 8003460:	d902      	bls.n	8003468 <RCC_SetFlashLatencyFromMSIRange+0xac>
          {
            latency = FLASH_LATENCY_0; /* 1WS */
 8003462:	2300      	movs	r3, #0
 8003464:	613b      	str	r3, [r7, #16]
 8003466:	e015      	b.n	8003494 <RCC_SetFlashLatencyFromMSIRange+0xd8>
          }
          else
          {
            latency = FLASH_LATENCY_1; /* 0WS */
 8003468:	2301      	movs	r3, #1
 800346a:	613b      	str	r3, [r7, #16]
 800346c:	e012      	b.n	8003494 <RCC_SetFlashLatencyFromMSIRange+0xd8>
          }
        }
        else
        {
          latency = FLASH_LATENCY_0; /* 0WS */
 800346e:	2300      	movs	r3, #0
 8003470:	613b      	str	r3, [r7, #16]
 8003472:	e00f      	b.n	8003494 <RCC_SetFlashLatencyFromMSIRange+0xd8>
        }
      }
      else
      {
        if (msirange == RCC_MSIRANGE_1)
 8003474:	687b      	ldr	r3, [r7, #4]
 8003476:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800347a:	d109      	bne.n	8003490 <RCC_SetFlashLatencyFromMSIRange+0xd4>
        {
          if (vos == PWR_REGULATOR_VOLTAGE_SCALE3)
 800347c:	697b      	ldr	r3, [r7, #20]
 800347e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003482:	d102      	bne.n	800348a <RCC_SetFlashLatencyFromMSIRange+0xce>
          {
            latency = FLASH_LATENCY_1; /* 1WS */
 8003484:	2301      	movs	r3, #1
 8003486:	613b      	str	r3, [r7, #16]
 8003488:	e004      	b.n	8003494 <RCC_SetFlashLatencyFromMSIRange+0xd8>
          }
          else
          {
            latency = FLASH_LATENCY_2; /* 2WS */
 800348a:	2302      	movs	r3, #2
 800348c:	613b      	str	r3, [r7, #16]
 800348e:	e001      	b.n	8003494 <RCC_SetFlashLatencyFromMSIRange+0xd8>
          }
        }
        else
        {
          latency = FLASH_LATENCY_1; /* 1WS */
 8003490:	2301      	movs	r3, #1
 8003492:	613b      	str	r3, [r7, #16]
        }
      }
    }
  }

  __HAL_FLASH_SET_LATENCY(latency);
 8003494:	4b0b      	ldr	r3, [pc, #44]	; (80034c4 <RCC_SetFlashLatencyFromMSIRange+0x108>)
 8003496:	681b      	ldr	r3, [r3, #0]
 8003498:	f023 020f 	bic.w	r2, r3, #15
 800349c:	4909      	ldr	r1, [pc, #36]	; (80034c4 <RCC_SetFlashLatencyFromMSIRange+0x108>)
 800349e:	693b      	ldr	r3, [r7, #16]
 80034a0:	4313      	orrs	r3, r2
 80034a2:	600b      	str	r3, [r1, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
  memory by reading the FLASH_ACR register */
  if ((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
 80034a4:	4b07      	ldr	r3, [pc, #28]	; (80034c4 <RCC_SetFlashLatencyFromMSIRange+0x108>)
 80034a6:	681b      	ldr	r3, [r3, #0]
 80034a8:	f003 030f 	and.w	r3, r3, #15
 80034ac:	693a      	ldr	r2, [r7, #16]
 80034ae:	429a      	cmp	r2, r3
 80034b0:	d001      	beq.n	80034b6 <RCC_SetFlashLatencyFromMSIRange+0xfa>
  {
    return HAL_ERROR;
 80034b2:	2301      	movs	r3, #1
 80034b4:	e000      	b.n	80034b8 <RCC_SetFlashLatencyFromMSIRange+0xfc>
  }

  return HAL_OK;
 80034b6:	2300      	movs	r3, #0
}
 80034b8:	4618      	mov	r0, r3
 80034ba:	3718      	adds	r7, #24
 80034bc:	46bd      	mov	sp, r7
 80034be:	bd80      	pop	{r7, pc}
 80034c0:	46020c00 	.word	0x46020c00
 80034c4:	40022000 	.word	0x40022000

080034c8 <HAL_RCCEx_PeriphCLKConfig>:
  * @retval HAL status
  *
  *         (*) value not defined in all devices.
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(const RCC_PeriphCLKInitTypeDef  *pPeriphClkInit)
{
 80034c8:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80034cc:	b0b8      	sub	sp, #224	; 0xe0
 80034ce:	af00      	add	r7, sp, #0
 80034d0:	f8c7 00cc 	str.w	r0, [r7, #204]	; 0xcc
  uint32_t tmpregister;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 80034d4:	2300      	movs	r3, #0
 80034d6:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 80034da:	2300      	movs	r3, #0
 80034dc:	f887 30da 	strb.w	r3, [r7, #218]	; 0xda

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(pPeriphClkInit->PeriphClockSelection));

  /*-------------------------- USART1 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 80034e0:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80034e4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80034e8:	f002 0401 	and.w	r4, r2, #1
 80034ec:	2500      	movs	r5, #0
 80034ee:	ea54 0305 	orrs.w	r3, r4, r5
 80034f2:	d00b      	beq.n	800350c <HAL_RCCEx_PeriphCLKConfig+0x44>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(pPeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(pPeriphClkInit->Usart1ClockSelection);
 80034f4:	4bca      	ldr	r3, [pc, #808]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 80034f6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80034fa:	f023 0103 	bic.w	r1, r3, #3
 80034fe:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003502:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003504:	4ac6      	ldr	r2, [pc, #792]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 8003506:	430b      	orrs	r3, r1
 8003508:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
  }

#if defined(USART2)
  /*-------------------------- USART2 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 800350c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003510:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003514:	f002 0802 	and.w	r8, r2, #2
 8003518:	f04f 0900 	mov.w	r9, #0
 800351c:	ea58 0309 	orrs.w	r3, r8, r9
 8003520:	d00b      	beq.n	800353a <HAL_RCCEx_PeriphCLKConfig+0x72>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(pPeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(pPeriphClkInit->Usart2ClockSelection);
 8003522:	4bbf      	ldr	r3, [pc, #764]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 8003524:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8003528:	f023 010c 	bic.w	r1, r3, #12
 800352c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003530:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003532:	4abb      	ldr	r2, [pc, #748]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 8003534:	430b      	orrs	r3, r1
 8003536:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
  }
#endif /* USART2 */

  /*-------------------------- USART3 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 800353a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800353e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003542:	f002 0a04 	and.w	sl, r2, #4
 8003546:	f04f 0b00 	mov.w	fp, #0
 800354a:	ea5a 030b 	orrs.w	r3, sl, fp
 800354e:	d00b      	beq.n	8003568 <HAL_RCCEx_PeriphCLKConfig+0xa0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(pPeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(pPeriphClkInit->Usart3ClockSelection);
 8003550:	4bb3      	ldr	r3, [pc, #716]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 8003552:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8003556:	f023 0130 	bic.w	r1, r3, #48	; 0x30
 800355a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800355e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003560:	4aaf      	ldr	r2, [pc, #700]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 8003562:	430b      	orrs	r3, r1
 8003564:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
  }

  /*-------------------------- UART4 clock source configuration --------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8003568:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800356c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003570:	f002 0308 	and.w	r3, r2, #8
 8003574:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 8003578:	2300      	movs	r3, #0
 800357a:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 800357e:	e9d7 1230 	ldrd	r1, r2, [r7, #192]	; 0xc0
 8003582:	460b      	mov	r3, r1
 8003584:	4313      	orrs	r3, r2
 8003586:	d00b      	beq.n	80035a0 <HAL_RCCEx_PeriphCLKConfig+0xd8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(pPeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(pPeriphClkInit->Uart4ClockSelection);
 8003588:	4ba5      	ldr	r3, [pc, #660]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 800358a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800358e:	f023 01c0 	bic.w	r1, r3, #192	; 0xc0
 8003592:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003596:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8003598:	4aa1      	ldr	r2, [pc, #644]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 800359a:	430b      	orrs	r3, r1
 800359c:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
  }

  /*-------------------------- UART5 clock source configuration --------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 80035a0:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80035a4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80035a8:	f002 0310 	and.w	r3, r2, #16
 80035ac:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 80035b0:	2300      	movs	r3, #0
 80035b2:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 80035b6:	e9d7 122e 	ldrd	r1, r2, [r7, #184]	; 0xb8
 80035ba:	460b      	mov	r3, r1
 80035bc:	4313      	orrs	r3, r2
 80035be:	d00b      	beq.n	80035d8 <HAL_RCCEx_PeriphCLKConfig+0x110>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(pPeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(pPeriphClkInit->Uart5ClockSelection);
 80035c0:	4b97      	ldr	r3, [pc, #604]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 80035c2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80035c6:	f423 7140 	bic.w	r1, r3, #768	; 0x300
 80035ca:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80035ce:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80035d0:	4a93      	ldr	r2, [pc, #588]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 80035d2:	430b      	orrs	r3, r1
 80035d4:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
    __HAL_RCC_USART6_CONFIG(pPeriphClkInit->Usart6ClockSelection);
  }
#endif /* USART6 */

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 80035d8:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80035dc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80035e0:	f002 0320 	and.w	r3, r2, #32
 80035e4:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 80035e8:	2300      	movs	r3, #0
 80035ea:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 80035ee:	e9d7 122c 	ldrd	r1, r2, [r7, #176]	; 0xb0
 80035f2:	460b      	mov	r3, r1
 80035f4:	4313      	orrs	r3, r2
 80035f6:	d00b      	beq.n	8003610 <HAL_RCCEx_PeriphCLKConfig+0x148>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(pPeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUART1 clock source */
    __HAL_RCC_LPUART1_CONFIG(pPeriphClkInit->Lpuart1ClockSelection);
 80035f8:	4b89      	ldr	r3, [pc, #548]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 80035fa:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 80035fe:	f023 0107 	bic.w	r1, r3, #7
 8003602:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003606:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8003608:	4a85      	ldr	r2, [pc, #532]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 800360a:	430b      	orrs	r3, r1
 800360c:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8003610:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003614:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003618:	f002 0340 	and.w	r3, r2, #64	; 0x40
 800361c:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 8003620:	2300      	movs	r3, #0
 8003622:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8003626:	e9d7 122a 	ldrd	r1, r2, [r7, #168]	; 0xa8
 800362a:	460b      	mov	r3, r1
 800362c:	4313      	orrs	r3, r2
 800362e:	d00b      	beq.n	8003648 <HAL_RCCEx_PeriphCLKConfig+0x180>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(pPeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(pPeriphClkInit->I2c1ClockSelection);
 8003630:	4b7b      	ldr	r3, [pc, #492]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 8003632:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8003636:	f423 6140 	bic.w	r1, r3, #3072	; 0xc00
 800363a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800363e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8003640:	4a77      	ldr	r2, [pc, #476]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 8003642:	430b      	orrs	r3, r1
 8003644:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
  }

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8003648:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800364c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003650:	f002 0380 	and.w	r3, r2, #128	; 0x80
 8003654:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8003658:	2300      	movs	r3, #0
 800365a:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 800365e:	e9d7 1228 	ldrd	r1, r2, [r7, #160]	; 0xa0
 8003662:	460b      	mov	r3, r1
 8003664:	4313      	orrs	r3, r2
 8003666:	d00b      	beq.n	8003680 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(pPeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(pPeriphClkInit->I2c2ClockSelection);
 8003668:	4b6d      	ldr	r3, [pc, #436]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 800366a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800366e:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
 8003672:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003676:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8003678:	4a69      	ldr	r2, [pc, #420]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 800367a:	430b      	orrs	r3, r1
 800367c:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
  }

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8003680:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003684:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003688:	f402 7380 	and.w	r3, r2, #256	; 0x100
 800368c:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 8003690:	2300      	movs	r3, #0
 8003692:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 8003696:	e9d7 1226 	ldrd	r1, r2, [r7, #152]	; 0x98
 800369a:	460b      	mov	r3, r1
 800369c:	4313      	orrs	r3, r2
 800369e:	d00b      	beq.n	80036b8 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(pPeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(pPeriphClkInit->I2c3ClockSelection);
 80036a0:	4b5f      	ldr	r3, [pc, #380]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 80036a2:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 80036a6:	f023 01c0 	bic.w	r1, r3, #192	; 0xc0
 80036aa:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80036ae:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80036b0:	4a5b      	ldr	r2, [pc, #364]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 80036b2:	430b      	orrs	r3, r1
 80036b4:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
  }

  /*-------------------------- I2C4 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 80036b8:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80036bc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80036c0:	f402 0380 	and.w	r3, r2, #4194304	; 0x400000
 80036c4:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 80036c8:	2300      	movs	r3, #0
 80036ca:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 80036ce:	e9d7 1224 	ldrd	r1, r2, [r7, #144]	; 0x90
 80036d2:	460b      	mov	r3, r1
 80036d4:	4313      	orrs	r3, r2
 80036d6:	d00b      	beq.n	80036f0 <HAL_RCCEx_PeriphCLKConfig+0x228>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(pPeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(pPeriphClkInit->I2c4ClockSelection);
 80036d8:	4b51      	ldr	r3, [pc, #324]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 80036da:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80036de:	f423 4140 	bic.w	r1, r3, #49152	; 0xc000
 80036e2:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80036e6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80036e8:	4a4d      	ldr	r2, [pc, #308]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 80036ea:	430b      	orrs	r3, r1
 80036ec:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
    __HAL_RCC_I2C6_CONFIG(pPeriphClkInit->I2c6ClockSelection);
  }
#endif /* I2C6 */

  /*-------------------------- LPTIM1 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 80036f0:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80036f4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80036f8:	f402 7300 	and.w	r3, r2, #512	; 0x200
 80036fc:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8003700:	2300      	movs	r3, #0
 8003702:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 8003706:	e9d7 1222 	ldrd	r1, r2, [r7, #136]	; 0x88
 800370a:	460b      	mov	r3, r1
 800370c:	4313      	orrs	r3, r2
 800370e:	d00b      	beq.n	8003728 <HAL_RCCEx_PeriphCLKConfig+0x260>
  {
    assert_param(IS_RCC_LPTIM1CLK(pPeriphClkInit->Lptim1ClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(pPeriphClkInit->Lptim1ClockSelection);
 8003710:	4b43      	ldr	r3, [pc, #268]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 8003712:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8003716:	f423 6140 	bic.w	r1, r3, #3072	; 0xc00
 800371a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800371e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8003720:	4a3f      	ldr	r2, [pc, #252]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 8003722:	430b      	orrs	r3, r1
 8003724:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
  }

  /*-------------------------- LPTIM2 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8003728:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800372c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003730:	f402 6380 	and.w	r3, r2, #1024	; 0x400
 8003734:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 8003738:	2300      	movs	r3, #0
 800373a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 800373e:	e9d7 1220 	ldrd	r1, r2, [r7, #128]	; 0x80
 8003742:	460b      	mov	r3, r1
 8003744:	4313      	orrs	r3, r2
 8003746:	d00b      	beq.n	8003760 <HAL_RCCEx_PeriphCLKConfig+0x298>
  {
    assert_param(IS_RCC_LPTIM2CLK(pPeriphClkInit->Lptim2ClockSelection));
    __HAL_RCC_LPTIM2_CONFIG(pPeriphClkInit->Lptim2ClockSelection);
 8003748:	4b35      	ldr	r3, [pc, #212]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 800374a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800374e:	f423 2140 	bic.w	r1, r3, #786432	; 0xc0000
 8003752:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003756:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8003758:	4a31      	ldr	r2, [pc, #196]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 800375a:	430b      	orrs	r3, r1
 800375c:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
  }

  /*-------------------------- LPTIM34 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM34) == (RCC_PERIPHCLK_LPTIM34))
 8003760:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003764:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003768:	f402 6300 	and.w	r3, r2, #2048	; 0x800
 800376c:	67bb      	str	r3, [r7, #120]	; 0x78
 800376e:	2300      	movs	r3, #0
 8003770:	67fb      	str	r3, [r7, #124]	; 0x7c
 8003772:	e9d7 121e 	ldrd	r1, r2, [r7, #120]	; 0x78
 8003776:	460b      	mov	r3, r1
 8003778:	4313      	orrs	r3, r2
 800377a:	d00c      	beq.n	8003796 <HAL_RCCEx_PeriphCLKConfig+0x2ce>
  {
    assert_param(IS_RCC_LPTIM34CLK(pPeriphClkInit->Lptim34ClockSelection));
    __HAL_RCC_LPTIM34_CONFIG(pPeriphClkInit->Lptim34ClockSelection);
 800377c:	4b28      	ldr	r3, [pc, #160]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 800377e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8003782:	f423 7140 	bic.w	r1, r3, #768	; 0x300
 8003786:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800378a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800378e:	4a24      	ldr	r2, [pc, #144]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 8003790:	430b      	orrs	r3, r1
 8003792:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
  }

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if ((((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8003796:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800379a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800379e:	f402 5300 	and.w	r3, r2, #8192	; 0x2000
 80037a2:	673b      	str	r3, [r7, #112]	; 0x70
 80037a4:	2300      	movs	r3, #0
 80037a6:	677b      	str	r3, [r7, #116]	; 0x74
 80037a8:	e9d7 121c 	ldrd	r1, r2, [r7, #112]	; 0x70
 80037ac:	460b      	mov	r3, r1
 80037ae:	4313      	orrs	r3, r2
 80037b0:	d04f      	beq.n	8003852 <HAL_RCCEx_PeriphCLKConfig+0x38a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(pPeriphClkInit->Sai1ClockSelection));

    switch (pPeriphClkInit->Sai1ClockSelection)
 80037b2:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80037b6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80037ba:	2b80      	cmp	r3, #128	; 0x80
 80037bc:	d02d      	beq.n	800381a <HAL_RCCEx_PeriphCLKConfig+0x352>
 80037be:	2b80      	cmp	r3, #128	; 0x80
 80037c0:	d827      	bhi.n	8003812 <HAL_RCCEx_PeriphCLKConfig+0x34a>
 80037c2:	2b60      	cmp	r3, #96	; 0x60
 80037c4:	d02e      	beq.n	8003824 <HAL_RCCEx_PeriphCLKConfig+0x35c>
 80037c6:	2b60      	cmp	r3, #96	; 0x60
 80037c8:	d823      	bhi.n	8003812 <HAL_RCCEx_PeriphCLKConfig+0x34a>
 80037ca:	2b40      	cmp	r3, #64	; 0x40
 80037cc:	d006      	beq.n	80037dc <HAL_RCCEx_PeriphCLKConfig+0x314>
 80037ce:	2b40      	cmp	r3, #64	; 0x40
 80037d0:	d81f      	bhi.n	8003812 <HAL_RCCEx_PeriphCLKConfig+0x34a>
 80037d2:	2b00      	cmp	r3, #0
 80037d4:	d009      	beq.n	80037ea <HAL_RCCEx_PeriphCLKConfig+0x322>
 80037d6:	2b20      	cmp	r3, #32
 80037d8:	d011      	beq.n	80037fe <HAL_RCCEx_PeriphCLKConfig+0x336>
 80037da:	e01a      	b.n	8003812 <HAL_RCCEx_PeriphCLKConfig+0x34a>
    {
      case RCC_SAI1CLKSOURCE_PLL1:      /* PLL is used as clock source for SAI1*/
        /* Enable SAI Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 80037dc:	4b10      	ldr	r3, [pc, #64]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 80037de:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80037e0:	4a0f      	ldr	r2, [pc, #60]	; (8003820 <HAL_RCCEx_PeriphCLKConfig+0x358>)
 80037e2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80037e6:	6293      	str	r3, [r2, #40]	; 0x28
        /* SAI1 clock source config set later after clock selection check */
        break;
 80037e8:	e01d      	b.n	8003826 <HAL_RCCEx_PeriphCLKConfig+0x35e>

      case RCC_SAI1CLKSOURCE_PLL2:  /* PLL2 is used as clock source for SAI1*/
        /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 80037ea:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80037ee:	3308      	adds	r3, #8
 80037f0:	4618      	mov	r0, r3
 80037f2:	f002 f9d1 	bl	8005b98 <RCCEx_PLL2_Config>
 80037f6:	4603      	mov	r3, r0
 80037f8:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        /* SAI1 clock source config set later after clock selection check */
        break;
 80037fc:	e013      	b.n	8003826 <HAL_RCCEx_PeriphCLKConfig+0x35e>

      case RCC_SAI1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI1*/
        /* PLL3 P input clock, parameters M, N & P configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 80037fe:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003802:	332c      	adds	r3, #44	; 0x2c
 8003804:	4618      	mov	r0, r3
 8003806:	f002 fa5f 	bl	8005cc8 <RCCEx_PLL3_Config>
 800380a:	4603      	mov	r3, r0
 800380c:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        /* SAI1 clock source config set later after clock selection check */
        break;
 8003810:	e009      	b.n	8003826 <HAL_RCCEx_PeriphCLKConfig+0x35e>
      case RCC_SAI1CLKSOURCE_HSI:      /* HSI is used as source of SAI1 clock*/
        /* SAI1 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8003812:	2301      	movs	r3, #1
 8003814:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        break;
 8003818:	e005      	b.n	8003826 <HAL_RCCEx_PeriphCLKConfig+0x35e>
        break;
 800381a:	bf00      	nop
 800381c:	e003      	b.n	8003826 <HAL_RCCEx_PeriphCLKConfig+0x35e>
 800381e:	bf00      	nop
 8003820:	46020c00 	.word	0x46020c00
        break;
 8003824:	bf00      	nop
    }

    if (ret == HAL_OK)
 8003826:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 800382a:	2b00      	cmp	r3, #0
 800382c:	d10d      	bne.n	800384a <HAL_RCCEx_PeriphCLKConfig+0x382>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(pPeriphClkInit->Sai1ClockSelection);
 800382e:	4bb6      	ldr	r3, [pc, #728]	; (8003b08 <HAL_RCCEx_PeriphCLKConfig+0x640>)
 8003830:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 8003834:	f023 01e0 	bic.w	r1, r3, #224	; 0xe0
 8003838:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800383c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8003840:	4ab1      	ldr	r2, [pc, #708]	; (8003b08 <HAL_RCCEx_PeriphCLKConfig+0x640>)
 8003842:	430b      	orrs	r3, r1
 8003844:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
 8003848:	e003      	b.n	8003852 <HAL_RCCEx_PeriphCLKConfig+0x38a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800384a:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 800384e:	f887 30da 	strb.w	r3, [r7, #218]	; 0xda
    }
  }

#if defined(SAI2)
  /*-------------------------- SAI2 clock source configuration ---------------------*/
  if ((((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 8003852:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003856:	e9d3 2300 	ldrd	r2, r3, [r3]
 800385a:	f402 4380 	and.w	r3, r2, #16384	; 0x4000
 800385e:	66bb      	str	r3, [r7, #104]	; 0x68
 8003860:	2300      	movs	r3, #0
 8003862:	66fb      	str	r3, [r7, #108]	; 0x6c
 8003864:	e9d7 121a 	ldrd	r1, r2, [r7, #104]	; 0x68
 8003868:	460b      	mov	r3, r1
 800386a:	4313      	orrs	r3, r2
 800386c:	d053      	beq.n	8003916 <HAL_RCCEx_PeriphCLKConfig+0x44e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLK(pPeriphClkInit->Sai2ClockSelection));

    switch (pPeriphClkInit->Sai2ClockSelection)
 800386e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003872:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003876:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800387a:	d033      	beq.n	80038e4 <HAL_RCCEx_PeriphCLKConfig+0x41c>
 800387c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8003880:	d82c      	bhi.n	80038dc <HAL_RCCEx_PeriphCLKConfig+0x414>
 8003882:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8003886:	d02f      	beq.n	80038e8 <HAL_RCCEx_PeriphCLKConfig+0x420>
 8003888:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800388c:	d826      	bhi.n	80038dc <HAL_RCCEx_PeriphCLKConfig+0x414>
 800388e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8003892:	d008      	beq.n	80038a6 <HAL_RCCEx_PeriphCLKConfig+0x3de>
 8003894:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8003898:	d820      	bhi.n	80038dc <HAL_RCCEx_PeriphCLKConfig+0x414>
 800389a:	2b00      	cmp	r3, #0
 800389c:	d00a      	beq.n	80038b4 <HAL_RCCEx_PeriphCLKConfig+0x3ec>
 800389e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80038a2:	d011      	beq.n	80038c8 <HAL_RCCEx_PeriphCLKConfig+0x400>
 80038a4:	e01a      	b.n	80038dc <HAL_RCCEx_PeriphCLKConfig+0x414>
    {
      case RCC_SAI2CLKSOURCE_PLL1:      /* PLL is used as clock source for SAI2*/
        /* Enable SAI Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 80038a6:	4b98      	ldr	r3, [pc, #608]	; (8003b08 <HAL_RCCEx_PeriphCLKConfig+0x640>)
 80038a8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80038aa:	4a97      	ldr	r2, [pc, #604]	; (8003b08 <HAL_RCCEx_PeriphCLKConfig+0x640>)
 80038ac:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80038b0:	6293      	str	r3, [r2, #40]	; 0x28
        /* SAI2 clock source config set later after clock selection check */
        break;
 80038b2:	e01a      	b.n	80038ea <HAL_RCCEx_PeriphCLKConfig+0x422>

      case RCC_SAI2CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/
        /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 80038b4:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80038b8:	3308      	adds	r3, #8
 80038ba:	4618      	mov	r0, r3
 80038bc:	f002 f96c 	bl	8005b98 <RCCEx_PLL2_Config>
 80038c0:	4603      	mov	r3, r0
 80038c2:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        /* SAI2 clock source config set later after clock selection check */
        break;
 80038c6:	e010      	b.n	80038ea <HAL_RCCEx_PeriphCLKConfig+0x422>

      case RCC_SAI2CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
        /* PLL3 P input clock, parameters M, N & P configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 80038c8:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80038cc:	332c      	adds	r3, #44	; 0x2c
 80038ce:	4618      	mov	r0, r3
 80038d0:	f002 f9fa 	bl	8005cc8 <RCCEx_PLL3_Config>
 80038d4:	4603      	mov	r3, r0
 80038d6:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        /* SAI2 clock source config set later after clock selection check */
        break;
 80038da:	e006      	b.n	80038ea <HAL_RCCEx_PeriphCLKConfig+0x422>
      case RCC_SAI2CLKSOURCE_HSI:      /* HSI is used as source of SAI2 clock*/
        /* SAI2 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 80038dc:	2301      	movs	r3, #1
 80038de:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        break;
 80038e2:	e002      	b.n	80038ea <HAL_RCCEx_PeriphCLKConfig+0x422>
        break;
 80038e4:	bf00      	nop
 80038e6:	e000      	b.n	80038ea <HAL_RCCEx_PeriphCLKConfig+0x422>
        break;
 80038e8:	bf00      	nop
    }

    if (ret == HAL_OK)
 80038ea:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 80038ee:	2b00      	cmp	r3, #0
 80038f0:	d10d      	bne.n	800390e <HAL_RCCEx_PeriphCLKConfig+0x446>
    {
      /* Set the source of SAI2 clock*/
      __HAL_RCC_SAI2_CONFIG(pPeriphClkInit->Sai2ClockSelection);
 80038f2:	4b85      	ldr	r3, [pc, #532]	; (8003b08 <HAL_RCCEx_PeriphCLKConfig+0x640>)
 80038f4:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 80038f8:	f423 61e0 	bic.w	r1, r3, #1792	; 0x700
 80038fc:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003900:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003904:	4a80      	ldr	r2, [pc, #512]	; (8003b08 <HAL_RCCEx_PeriphCLKConfig+0x640>)
 8003906:	430b      	orrs	r3, r1
 8003908:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
 800390c:	e003      	b.n	8003916 <HAL_RCCEx_PeriphCLKConfig+0x44e>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800390e:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8003912:	f887 30da 	strb.w	r3, [r7, #218]	; 0xda
    }
  }
#endif /* SAI2 */

  /*-------------------------- ADCDAC clock source configuration ----------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADCDAC) == RCC_PERIPHCLK_ADCDAC)
 8003916:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800391a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800391e:	f402 4300 	and.w	r3, r2, #32768	; 0x8000
 8003922:	663b      	str	r3, [r7, #96]	; 0x60
 8003924:	2300      	movs	r3, #0
 8003926:	667b      	str	r3, [r7, #100]	; 0x64
 8003928:	e9d7 1218 	ldrd	r1, r2, [r7, #96]	; 0x60
 800392c:	460b      	mov	r3, r1
 800392e:	4313      	orrs	r3, r2
 8003930:	d046      	beq.n	80039c0 <HAL_RCCEx_PeriphCLKConfig+0x4f8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCDACCLKSOURCE(pPeriphClkInit->AdcDacClockSelection));

    switch (pPeriphClkInit->AdcDacClockSelection)
 8003932:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003936:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 800393a:	f5b3 4fa0 	cmp.w	r3, #20480	; 0x5000
 800393e:	d028      	beq.n	8003992 <HAL_RCCEx_PeriphCLKConfig+0x4ca>
 8003940:	f5b3 4fa0 	cmp.w	r3, #20480	; 0x5000
 8003944:	d821      	bhi.n	800398a <HAL_RCCEx_PeriphCLKConfig+0x4c2>
 8003946:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800394a:	d022      	beq.n	8003992 <HAL_RCCEx_PeriphCLKConfig+0x4ca>
 800394c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8003950:	d81b      	bhi.n	800398a <HAL_RCCEx_PeriphCLKConfig+0x4c2>
 8003952:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 8003956:	d01c      	beq.n	8003992 <HAL_RCCEx_PeriphCLKConfig+0x4ca>
 8003958:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 800395c:	d815      	bhi.n	800398a <HAL_RCCEx_PeriphCLKConfig+0x4c2>
 800395e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8003962:	d008      	beq.n	8003976 <HAL_RCCEx_PeriphCLKConfig+0x4ae>
 8003964:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8003968:	d80f      	bhi.n	800398a <HAL_RCCEx_PeriphCLKConfig+0x4c2>
 800396a:	2b00      	cmp	r3, #0
 800396c:	d011      	beq.n	8003992 <HAL_RCCEx_PeriphCLKConfig+0x4ca>
 800396e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003972:	d00e      	beq.n	8003992 <HAL_RCCEx_PeriphCLKConfig+0x4ca>
 8003974:	e009      	b.n	800398a <HAL_RCCEx_PeriphCLKConfig+0x4c2>
    {
      case RCC_ADCDACCLKSOURCE_PLL2:
        /* PLL2 input clock, parameters M, N,P, & R configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8003976:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800397a:	3308      	adds	r3, #8
 800397c:	4618      	mov	r0, r3
 800397e:	f002 f90b 	bl	8005b98 <RCCEx_PLL2_Config>
 8003982:	4603      	mov	r3, r0
 8003984:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        break;
 8003988:	e004      	b.n	8003994 <HAL_RCCEx_PeriphCLKConfig+0x4cc>
      case RCC_ADCDACCLKSOURCE_HSE:
      case RCC_ADCDACCLKSOURCE_HSI:
      case RCC_ADCDACCLKSOURCE_MSIK:
        break;
      default:
        ret = HAL_ERROR;
 800398a:	2301      	movs	r3, #1
 800398c:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        break;
 8003990:	e000      	b.n	8003994 <HAL_RCCEx_PeriphCLKConfig+0x4cc>
        break;
 8003992:	bf00      	nop
    }

    if (ret == HAL_OK)
 8003994:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8003998:	2b00      	cmp	r3, #0
 800399a:	d10d      	bne.n	80039b8 <HAL_RCCEx_PeriphCLKConfig+0x4f0>
    {
      /* Configure the ADC1 interface clock source */
      __HAL_RCC_ADCDAC_CONFIG(pPeriphClkInit->AdcDacClockSelection);
 800399c:	4b5a      	ldr	r3, [pc, #360]	; (8003b08 <HAL_RCCEx_PeriphCLKConfig+0x640>)
 800399e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 80039a2:	f423 41e0 	bic.w	r1, r3, #28672	; 0x7000
 80039a6:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80039aa:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 80039ae:	4a56      	ldr	r2, [pc, #344]	; (8003b08 <HAL_RCCEx_PeriphCLKConfig+0x640>)
 80039b0:	430b      	orrs	r3, r1
 80039b2:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
 80039b6:	e003      	b.n	80039c0 <HAL_RCCEx_PeriphCLKConfig+0x4f8>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80039b8:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 80039bc:	f887 30da 	strb.w	r3, [r7, #218]	; 0xda
    }
  }

  /*-------------------------- MDF1 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
 80039c0:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80039c4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80039c8:	f402 3380 	and.w	r3, r2, #65536	; 0x10000
 80039cc:	65bb      	str	r3, [r7, #88]	; 0x58
 80039ce:	2300      	movs	r3, #0
 80039d0:	65fb      	str	r3, [r7, #92]	; 0x5c
 80039d2:	e9d7 1216 	ldrd	r1, r2, [r7, #88]	; 0x58
 80039d6:	460b      	mov	r3, r1
 80039d8:	4313      	orrs	r3, r2
 80039da:	d03f      	beq.n	8003a5c <HAL_RCCEx_PeriphCLKConfig+0x594>
  {
    /* Check the parameters */
    assert_param(IS_RCC_MDF1CLKSOURCE(pPeriphClkInit->Mdf1ClockSelection));

    switch (pPeriphClkInit->Mdf1ClockSelection)
 80039dc:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80039e0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80039e4:	2b04      	cmp	r3, #4
 80039e6:	d81e      	bhi.n	8003a26 <HAL_RCCEx_PeriphCLKConfig+0x55e>
 80039e8:	a201      	add	r2, pc, #4	; (adr r2, 80039f0 <HAL_RCCEx_PeriphCLKConfig+0x528>)
 80039ea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80039ee:	bf00      	nop
 80039f0:	08003a2f 	.word	0x08003a2f
 80039f4:	08003a05 	.word	0x08003a05
 80039f8:	08003a13 	.word	0x08003a13
 80039fc:	08003a2f 	.word	0x08003a2f
 8003a00:	08003a2f 	.word	0x08003a2f
    {
      case RCC_MDF1CLKSOURCE_PLL1:
        /* Enable PLL1 Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 8003a04:	4b40      	ldr	r3, [pc, #256]	; (8003b08 <HAL_RCCEx_PeriphCLKConfig+0x640>)
 8003a06:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003a08:	4a3f      	ldr	r2, [pc, #252]	; (8003b08 <HAL_RCCEx_PeriphCLKConfig+0x640>)
 8003a0a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003a0e:	6293      	str	r3, [r2, #40]	; 0x28
        break;
 8003a10:	e00e      	b.n	8003a30 <HAL_RCCEx_PeriphCLKConfig+0x568>
      case RCC_MDF1CLKSOURCE_PLL3:
        /* PLL3 Q input clock, parameters M, N & Q configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 8003a12:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003a16:	332c      	adds	r3, #44	; 0x2c
 8003a18:	4618      	mov	r0, r3
 8003a1a:	f002 f955 	bl	8005cc8 <RCCEx_PLL3_Config>
 8003a1e:	4603      	mov	r3, r0
 8003a20:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        break;
 8003a24:	e004      	b.n	8003a30 <HAL_RCCEx_PeriphCLKConfig+0x568>
      case RCC_MDF1CLKSOURCE_PIN:
        break;
      case RCC_MDF1CLKSOURCE_MSIK:
        break;
      default:
        ret = HAL_ERROR;
 8003a26:	2301      	movs	r3, #1
 8003a28:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        break;
 8003a2c:	e000      	b.n	8003a30 <HAL_RCCEx_PeriphCLKConfig+0x568>
        break;
 8003a2e:	bf00      	nop
    }
    if (ret == HAL_OK)
 8003a30:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8003a34:	2b00      	cmp	r3, #0
 8003a36:	d10d      	bne.n	8003a54 <HAL_RCCEx_PeriphCLKConfig+0x58c>
    {
      /* Configure the MDF1 interface clock source */
      __HAL_RCC_MDF1_CONFIG(pPeriphClkInit->Mdf1ClockSelection);
 8003a38:	4b33      	ldr	r3, [pc, #204]	; (8003b08 <HAL_RCCEx_PeriphCLKConfig+0x640>)
 8003a3a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 8003a3e:	f023 0107 	bic.w	r1, r3, #7
 8003a42:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003a46:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8003a4a:	4a2f      	ldr	r2, [pc, #188]	; (8003b08 <HAL_RCCEx_PeriphCLKConfig+0x640>)
 8003a4c:	430b      	orrs	r3, r1
 8003a4e:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
 8003a52:	e003      	b.n	8003a5c <HAL_RCCEx_PeriphCLKConfig+0x594>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003a54:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8003a58:	f887 30da 	strb.w	r3, [r7, #218]	; 0xda
    }
  }

  /*-------------------------- ADF1 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
 8003a5c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003a60:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003a64:	f402 3300 	and.w	r3, r2, #131072	; 0x20000
 8003a68:	653b      	str	r3, [r7, #80]	; 0x50
 8003a6a:	2300      	movs	r3, #0
 8003a6c:	657b      	str	r3, [r7, #84]	; 0x54
 8003a6e:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	; 0x50
 8003a72:	460b      	mov	r3, r1
 8003a74:	4313      	orrs	r3, r2
 8003a76:	d04d      	beq.n	8003b14 <HAL_RCCEx_PeriphCLKConfig+0x64c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADF1CLKSOURCE(pPeriphClkInit->Adf1ClockSelection));
    switch (pPeriphClkInit->Adf1ClockSelection)
 8003a78:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003a7c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8003a80:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8003a84:	d028      	beq.n	8003ad8 <HAL_RCCEx_PeriphCLKConfig+0x610>
 8003a86:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8003a8a:	d821      	bhi.n	8003ad0 <HAL_RCCEx_PeriphCLKConfig+0x608>
 8003a8c:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 8003a90:	d024      	beq.n	8003adc <HAL_RCCEx_PeriphCLKConfig+0x614>
 8003a92:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 8003a96:	d81b      	bhi.n	8003ad0 <HAL_RCCEx_PeriphCLKConfig+0x608>
 8003a98:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8003a9c:	d00e      	beq.n	8003abc <HAL_RCCEx_PeriphCLKConfig+0x5f4>
 8003a9e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8003aa2:	d815      	bhi.n	8003ad0 <HAL_RCCEx_PeriphCLKConfig+0x608>
 8003aa4:	2b00      	cmp	r3, #0
 8003aa6:	d01b      	beq.n	8003ae0 <HAL_RCCEx_PeriphCLKConfig+0x618>
 8003aa8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003aac:	d110      	bne.n	8003ad0 <HAL_RCCEx_PeriphCLKConfig+0x608>
    {
      case RCC_ADF1CLKSOURCE_PLL1:
        /* Enable PLL1 Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 8003aae:	4b16      	ldr	r3, [pc, #88]	; (8003b08 <HAL_RCCEx_PeriphCLKConfig+0x640>)
 8003ab0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003ab2:	4a15      	ldr	r2, [pc, #84]	; (8003b08 <HAL_RCCEx_PeriphCLKConfig+0x640>)
 8003ab4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003ab8:	6293      	str	r3, [r2, #40]	; 0x28
        break;
 8003aba:	e012      	b.n	8003ae2 <HAL_RCCEx_PeriphCLKConfig+0x61a>
      case RCC_ADF1CLKSOURCE_PLL3:
        /* PLL3 Q input clock, parameters M, N & Q configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 8003abc:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003ac0:	332c      	adds	r3, #44	; 0x2c
 8003ac2:	4618      	mov	r0, r3
 8003ac4:	f002 f900 	bl	8005cc8 <RCCEx_PLL3_Config>
 8003ac8:	4603      	mov	r3, r0
 8003aca:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        break;
 8003ace:	e008      	b.n	8003ae2 <HAL_RCCEx_PeriphCLKConfig+0x61a>
      case RCC_ADF1CLKSOURCE_PIN:
        break;
      case RCC_ADF1CLKSOURCE_MSIK:
        break;
      default:
        ret = HAL_ERROR;
 8003ad0:	2301      	movs	r3, #1
 8003ad2:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        break;
 8003ad6:	e004      	b.n	8003ae2 <HAL_RCCEx_PeriphCLKConfig+0x61a>
        break;
 8003ad8:	bf00      	nop
 8003ada:	e002      	b.n	8003ae2 <HAL_RCCEx_PeriphCLKConfig+0x61a>
        break;
 8003adc:	bf00      	nop
 8003ade:	e000      	b.n	8003ae2 <HAL_RCCEx_PeriphCLKConfig+0x61a>
        break;
 8003ae0:	bf00      	nop
    }
    if (ret == HAL_OK)
 8003ae2:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8003ae6:	2b00      	cmp	r3, #0
 8003ae8:	d110      	bne.n	8003b0c <HAL_RCCEx_PeriphCLKConfig+0x644>
    {
      /* Configure the ADF1 interface clock source */
      __HAL_RCC_ADF1_CONFIG(pPeriphClkInit->Adf1ClockSelection);
 8003aea:	4b07      	ldr	r3, [pc, #28]	; (8003b08 <HAL_RCCEx_PeriphCLKConfig+0x640>)
 8003aec:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8003af0:	f423 21e0 	bic.w	r1, r3, #458752	; 0x70000
 8003af4:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003af8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8003afc:	4a02      	ldr	r2, [pc, #8]	; (8003b08 <HAL_RCCEx_PeriphCLKConfig+0x640>)
 8003afe:	430b      	orrs	r3, r1
 8003b00:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
 8003b04:	e006      	b.n	8003b14 <HAL_RCCEx_PeriphCLKConfig+0x64c>
 8003b06:	bf00      	nop
 8003b08:	46020c00 	.word	0x46020c00
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003b0c:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8003b10:	f887 30da 	strb.w	r3, [r7, #218]	; 0xda
    }
  }

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((pPeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8003b14:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003b18:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003b1c:	f402 2380 	and.w	r3, r2, #262144	; 0x40000
 8003b20:	64bb      	str	r3, [r7, #72]	; 0x48
 8003b22:	2300      	movs	r3, #0
 8003b24:	64fb      	str	r3, [r7, #76]	; 0x4c
 8003b26:	e9d7 1212 	ldrd	r1, r2, [r7, #72]	; 0x48
 8003b2a:	460b      	mov	r3, r1
 8003b2c:	4313      	orrs	r3, r2
 8003b2e:	f000 80b5 	beq.w	8003c9c <HAL_RCCEx_PeriphCLKConfig+0x7d4>
  {
    FlagStatus       pwrclkchanged = RESET;
 8003b32:	2300      	movs	r3, #0
 8003b34:	f887 30d9 	strb.w	r3, [r7, #217]	; 0xd9
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(pPeriphClkInit->RTCClockSelection));
    /* Enable Power Clock */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8003b38:	4b9d      	ldr	r3, [pc, #628]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003b3a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003b3e:	f003 0304 	and.w	r3, r3, #4
 8003b42:	2b00      	cmp	r3, #0
 8003b44:	d113      	bne.n	8003b6e <HAL_RCCEx_PeriphCLKConfig+0x6a6>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8003b46:	4b9a      	ldr	r3, [pc, #616]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003b48:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003b4c:	4a98      	ldr	r2, [pc, #608]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003b4e:	f043 0304 	orr.w	r3, r3, #4
 8003b52:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 8003b56:	4b96      	ldr	r3, [pc, #600]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003b58:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003b5c:	f003 0304 	and.w	r3, r3, #4
 8003b60:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 8003b64:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
      pwrclkchanged = SET;
 8003b68:	2301      	movs	r3, #1
 8003b6a:	f887 30d9 	strb.w	r3, [r7, #217]	; 0xd9
    }
    /* Enable write access to Backup domain */
    SET_BIT(PWR->DBPR, PWR_DBPR_DBP);
 8003b6e:	4b91      	ldr	r3, [pc, #580]	; (8003db4 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 8003b70:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003b72:	4a90      	ldr	r2, [pc, #576]	; (8003db4 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 8003b74:	f043 0301 	orr.w	r3, r3, #1
 8003b78:	6293      	str	r3, [r2, #40]	; 0x28

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8003b7a:	f7fd fd8b 	bl	8001694 <HAL_GetTick>
 8003b7e:	f8c7 00d4 	str.w	r0, [r7, #212]	; 0xd4

    while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8003b82:	e00b      	b.n	8003b9c <HAL_RCCEx_PeriphCLKConfig+0x6d4>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8003b84:	f7fd fd86 	bl	8001694 <HAL_GetTick>
 8003b88:	4602      	mov	r2, r0
 8003b8a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8003b8e:	1ad3      	subs	r3, r2, r3
 8003b90:	2b02      	cmp	r3, #2
 8003b92:	d903      	bls.n	8003b9c <HAL_RCCEx_PeriphCLKConfig+0x6d4>
      {
        ret = HAL_TIMEOUT;
 8003b94:	2303      	movs	r3, #3
 8003b96:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        break;
 8003b9a:	e005      	b.n	8003ba8 <HAL_RCCEx_PeriphCLKConfig+0x6e0>
    while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8003b9c:	4b85      	ldr	r3, [pc, #532]	; (8003db4 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 8003b9e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003ba0:	f003 0301 	and.w	r3, r3, #1
 8003ba4:	2b00      	cmp	r3, #0
 8003ba6:	d0ed      	beq.n	8003b84 <HAL_RCCEx_PeriphCLKConfig+0x6bc>
      }
    }

    if (ret == HAL_OK)
 8003ba8:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8003bac:	2b00      	cmp	r3, #0
 8003bae:	d165      	bne.n	8003c7c <HAL_RCCEx_PeriphCLKConfig+0x7b4>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8003bb0:	4b7f      	ldr	r3, [pc, #508]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003bb2:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003bb6:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8003bba:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc

      if ((tmpregister != RCC_RTCCLKSOURCE_NO_CLK) && (tmpregister != pPeriphClkInit->RTCClockSelection))
 8003bbe:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8003bc2:	2b00      	cmp	r3, #0
 8003bc4:	d023      	beq.n	8003c0e <HAL_RCCEx_PeriphCLKConfig+0x746>
 8003bc6:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003bca:	f8d3 20bc 	ldr.w	r2, [r3, #188]	; 0xbc
 8003bce:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8003bd2:	4293      	cmp	r3, r2
 8003bd4:	d01b      	beq.n	8003c0e <HAL_RCCEx_PeriphCLKConfig+0x746>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8003bd6:	4b76      	ldr	r3, [pc, #472]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003bd8:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003bdc:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8003be0:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 8003be4:	4b72      	ldr	r3, [pc, #456]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003be6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003bea:	4a71      	ldr	r2, [pc, #452]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003bec:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003bf0:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
        __HAL_RCC_BACKUPRESET_RELEASE();
 8003bf4:	4b6e      	ldr	r3, [pc, #440]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003bf6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003bfa:	4a6d      	ldr	r2, [pc, #436]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003bfc:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8003c00:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
 8003c04:	4a6a      	ldr	r2, [pc, #424]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003c06:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8003c0a:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8003c0e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8003c12:	f003 0301 	and.w	r3, r3, #1
 8003c16:	2b00      	cmp	r3, #0
 8003c18:	d019      	beq.n	8003c4e <HAL_RCCEx_PeriphCLKConfig+0x786>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8003c1a:	f7fd fd3b 	bl	8001694 <HAL_GetTick>
 8003c1e:	f8c7 00d4 	str.w	r0, [r7, #212]	; 0xd4

        /* Wait till LSE is ready */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8003c22:	e00d      	b.n	8003c40 <HAL_RCCEx_PeriphCLKConfig+0x778>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003c24:	f7fd fd36 	bl	8001694 <HAL_GetTick>
 8003c28:	4602      	mov	r2, r0
 8003c2a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8003c2e:	1ad2      	subs	r2, r2, r3
 8003c30:	f241 3388 	movw	r3, #5000	; 0x1388
 8003c34:	429a      	cmp	r2, r3
 8003c36:	d903      	bls.n	8003c40 <HAL_RCCEx_PeriphCLKConfig+0x778>
          {
            ret = HAL_TIMEOUT;
 8003c38:	2303      	movs	r3, #3
 8003c3a:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
            break;
 8003c3e:	e006      	b.n	8003c4e <HAL_RCCEx_PeriphCLKConfig+0x786>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8003c40:	4b5b      	ldr	r3, [pc, #364]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003c42:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003c46:	f003 0302 	and.w	r3, r3, #2
 8003c4a:	2b00      	cmp	r3, #0
 8003c4c:	d0ea      	beq.n	8003c24 <HAL_RCCEx_PeriphCLKConfig+0x75c>
          }
        }
      }

      if (ret == HAL_OK)
 8003c4e:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8003c52:	2b00      	cmp	r3, #0
 8003c54:	d10d      	bne.n	8003c72 <HAL_RCCEx_PeriphCLKConfig+0x7aa>
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(pPeriphClkInit->RTCClockSelection);
 8003c56:	4b56      	ldr	r3, [pc, #344]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003c58:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003c5c:	f423 7140 	bic.w	r1, r3, #768	; 0x300
 8003c60:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003c64:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8003c68:	4a51      	ldr	r2, [pc, #324]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003c6a:	430b      	orrs	r3, r1
 8003c6c:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
 8003c70:	e008      	b.n	8003c84 <HAL_RCCEx_PeriphCLKConfig+0x7bc>
      }
      else
      {
        /* set overall return value */
        status = ret;
 8003c72:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8003c76:	f887 30da 	strb.w	r3, [r7, #218]	; 0xda
 8003c7a:	e003      	b.n	8003c84 <HAL_RCCEx_PeriphCLKConfig+0x7bc>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003c7c:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8003c80:	f887 30da 	strb.w	r3, [r7, #218]	; 0xda
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 8003c84:	f897 30d9 	ldrb.w	r3, [r7, #217]	; 0xd9
 8003c88:	2b01      	cmp	r3, #1
 8003c8a:	d107      	bne.n	8003c9c <HAL_RCCEx_PeriphCLKConfig+0x7d4>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8003c8c:	4b48      	ldr	r3, [pc, #288]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003c8e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003c92:	4a47      	ldr	r2, [pc, #284]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003c94:	f023 0304 	bic.w	r3, r3, #4
 8003c98:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
    }
  }

  /*-------------------------------------- ICLK Configuration -----------------------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ICLK) == RCC_PERIPHCLK_ICLK)
 8003c9c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003ca0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003ca4:	f402 1380 	and.w	r3, r2, #1048576	; 0x100000
 8003ca8:	643b      	str	r3, [r7, #64]	; 0x40
 8003caa:	2300      	movs	r3, #0
 8003cac:	647b      	str	r3, [r7, #68]	; 0x44
 8003cae:	e9d7 1210 	ldrd	r1, r2, [r7, #64]	; 0x40
 8003cb2:	460b      	mov	r3, r1
 8003cb4:	4313      	orrs	r3, r2
 8003cb6:	d042      	beq.n	8003d3e <HAL_RCCEx_PeriphCLKConfig+0x876>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ICLKCLKSOURCE(pPeriphClkInit->IclkClockSelection));

    switch (pPeriphClkInit->IclkClockSelection)
 8003cb8:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003cbc:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8003cc0:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
 8003cc4:	d022      	beq.n	8003d0c <HAL_RCCEx_PeriphCLKConfig+0x844>
 8003cc6:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
 8003cca:	d81b      	bhi.n	8003d04 <HAL_RCCEx_PeriphCLKConfig+0x83c>
 8003ccc:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8003cd0:	d011      	beq.n	8003cf6 <HAL_RCCEx_PeriphCLKConfig+0x82e>
 8003cd2:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8003cd6:	d815      	bhi.n	8003d04 <HAL_RCCEx_PeriphCLKConfig+0x83c>
 8003cd8:	2b00      	cmp	r3, #0
 8003cda:	d019      	beq.n	8003d10 <HAL_RCCEx_PeriphCLKConfig+0x848>
 8003cdc:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8003ce0:	d110      	bne.n	8003d04 <HAL_RCCEx_PeriphCLKConfig+0x83c>
    {
      case RCC_ICLK_CLKSOURCE_PLL2:
        /* PLL2 input clock, parameters M, N,P,Q & R configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8003ce2:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003ce6:	3308      	adds	r3, #8
 8003ce8:	4618      	mov	r0, r3
 8003cea:	f001 ff55 	bl	8005b98 <RCCEx_PLL2_Config>
 8003cee:	4603      	mov	r3, r0
 8003cf0:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        break;
 8003cf4:	e00d      	b.n	8003d12 <HAL_RCCEx_PeriphCLKConfig+0x84a>
      case RCC_ICLK_CLKSOURCE_PLL1:
        /* Enable ICLK Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8003cf6:	4b2e      	ldr	r3, [pc, #184]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003cf8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003cfa:	4a2d      	ldr	r2, [pc, #180]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003cfc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8003d00:	6293      	str	r3, [r2, #40]	; 0x28
        break;
 8003d02:	e006      	b.n	8003d12 <HAL_RCCEx_PeriphCLKConfig+0x84a>
      case RCC_ICLK_CLKSOURCE_HSI48:
        break;
      case RCC_ICLK_CLKSOURCE_MSIK:
        break;
      default:
        ret = HAL_ERROR;
 8003d04:	2301      	movs	r3, #1
 8003d06:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        break;
 8003d0a:	e002      	b.n	8003d12 <HAL_RCCEx_PeriphCLKConfig+0x84a>
        break;
 8003d0c:	bf00      	nop
 8003d0e:	e000      	b.n	8003d12 <HAL_RCCEx_PeriphCLKConfig+0x84a>
        break;
 8003d10:	bf00      	nop
    }
    if (ret == HAL_OK)
 8003d12:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8003d16:	2b00      	cmp	r3, #0
 8003d18:	d10d      	bne.n	8003d36 <HAL_RCCEx_PeriphCLKConfig+0x86e>
    {
      /* Configure the CLK48 source */
      __HAL_RCC_CLK48_CONFIG(pPeriphClkInit->IclkClockSelection);
 8003d1a:	4b25      	ldr	r3, [pc, #148]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003d1c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8003d20:	f023 6140 	bic.w	r1, r3, #201326592	; 0xc000000
 8003d24:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003d28:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8003d2c:	4a20      	ldr	r2, [pc, #128]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003d2e:	430b      	orrs	r3, r1
 8003d30:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8003d34:	e003      	b.n	8003d3e <HAL_RCCEx_PeriphCLKConfig+0x876>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003d36:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8003d3a:	f887 30da 	strb.w	r3, [r7, #218]	; 0xda
    }
  }

  /*------------------------------ RNG Configuration -------------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
 8003d3e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003d42:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003d46:	f402 2300 	and.w	r3, r2, #524288	; 0x80000
 8003d4a:	63bb      	str	r3, [r7, #56]	; 0x38
 8003d4c:	2300      	movs	r3, #0
 8003d4e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8003d50:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	; 0x38
 8003d54:	460b      	mov	r3, r1
 8003d56:	4313      	orrs	r3, r2
 8003d58:	d032      	beq.n	8003dc0 <HAL_RCCEx_PeriphCLKConfig+0x8f8>
  {

    /* Check the parameters */
    assert_param(IS_RCC_RNGCLKSOURCE(pPeriphClkInit->RngClockSelection));

    switch (pPeriphClkInit->RngClockSelection)
 8003d5a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003d5e:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8003d62:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8003d66:	d00b      	beq.n	8003d80 <HAL_RCCEx_PeriphCLKConfig+0x8b8>
 8003d68:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8003d6c:	d804      	bhi.n	8003d78 <HAL_RCCEx_PeriphCLKConfig+0x8b0>
 8003d6e:	2b00      	cmp	r3, #0
 8003d70:	d008      	beq.n	8003d84 <HAL_RCCEx_PeriphCLKConfig+0x8bc>
 8003d72:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003d76:	d007      	beq.n	8003d88 <HAL_RCCEx_PeriphCLKConfig+0x8c0>
      case RCC_RNGCLKSOURCE_HSI48:
        /* HSI48 oscillator is used as source of RNG clock */
        /* RNG clock source configuration done later after clock selection check */
        break;
      default:
        ret = HAL_ERROR;
 8003d78:	2301      	movs	r3, #1
 8003d7a:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        break;
 8003d7e:	e004      	b.n	8003d8a <HAL_RCCEx_PeriphCLKConfig+0x8c2>
        break;
 8003d80:	bf00      	nop
 8003d82:	e002      	b.n	8003d8a <HAL_RCCEx_PeriphCLKConfig+0x8c2>
        break;
 8003d84:	bf00      	nop
 8003d86:	e000      	b.n	8003d8a <HAL_RCCEx_PeriphCLKConfig+0x8c2>
        break;
 8003d88:	bf00      	nop
    }
    if (ret == HAL_OK)
 8003d8a:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8003d8e:	2b00      	cmp	r3, #0
 8003d90:	d112      	bne.n	8003db8 <HAL_RCCEx_PeriphCLKConfig+0x8f0>
    {
      /* Set the source of RNG clock*/
      __HAL_RCC_RNG_CONFIG(pPeriphClkInit->RngClockSelection);
 8003d92:	4b07      	ldr	r3, [pc, #28]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003d94:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 8003d98:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
 8003d9c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003da0:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8003da4:	4a02      	ldr	r2, [pc, #8]	; (8003db0 <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
 8003da6:	430b      	orrs	r3, r1
 8003da8:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
 8003dac:	e008      	b.n	8003dc0 <HAL_RCCEx_PeriphCLKConfig+0x8f8>
 8003dae:	bf00      	nop
 8003db0:	46020c00 	.word	0x46020c00
 8003db4:	46020800 	.word	0x46020800
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003db8:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8003dbc:	f887 30da 	strb.w	r3, [r7, #218]	; 0xda
    __HAL_RCC_SAES_CONFIG(pPeriphClkInit->SaesClockSelection);
  }
#endif /* SAES */

  /*-------------------------- SDMMC1/2 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == (RCC_PERIPHCLK_SDMMC))
 8003dc0:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003dc4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003dc8:	f402 1300 	and.w	r3, r2, #2097152	; 0x200000
 8003dcc:	633b      	str	r3, [r7, #48]	; 0x30
 8003dce:	2300      	movs	r3, #0
 8003dd0:	637b      	str	r3, [r7, #52]	; 0x34
 8003dd2:	e9d7 120c 	ldrd	r1, r2, [r7, #48]	; 0x30
 8003dd6:	460b      	mov	r3, r1
 8003dd8:	4313      	orrs	r3, r2
 8003dda:	d019      	beq.n	8003e10 <HAL_RCCEx_PeriphCLKConfig+0x948>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMCCLKSOURCE(pPeriphClkInit->SdmmcClockSelection));

    if (pPeriphClkInit->SdmmcClockSelection == RCC_SDMMCCLKSOURCE_PLL1)
 8003ddc:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003de0:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8003de4:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8003de8:	d105      	bne.n	8003df6 <HAL_RCCEx_PeriphCLKConfig+0x92e>
    {
      /* Enable PLL1 P CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 8003dea:	4b88      	ldr	r3, [pc, #544]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003dec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003dee:	4a87      	ldr	r2, [pc, #540]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003df0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003df4:	6293      	str	r3, [r2, #40]	; 0x28
    }

    /* Configure the SDMMC1/2 clock source */
    __HAL_RCC_SDMMC_CONFIG(pPeriphClkInit->SdmmcClockSelection);
 8003df6:	4b85      	ldr	r3, [pc, #532]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003df8:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 8003dfc:	f423 4180 	bic.w	r1, r3, #16384	; 0x4000
 8003e00:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003e04:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8003e08:	4a80      	ldr	r2, [pc, #512]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003e0a:	430b      	orrs	r3, r1
 8003e0c:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
  }

  /*-------------------------- SPI1 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
 8003e10:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003e14:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003e18:	f402 0300 	and.w	r3, r2, #8388608	; 0x800000
 8003e1c:	62bb      	str	r3, [r7, #40]	; 0x28
 8003e1e:	2300      	movs	r3, #0
 8003e20:	62fb      	str	r3, [r7, #44]	; 0x2c
 8003e22:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	; 0x28
 8003e26:	460b      	mov	r3, r1
 8003e28:	4313      	orrs	r3, r2
 8003e2a:	d00c      	beq.n	8003e46 <HAL_RCCEx_PeriphCLKConfig+0x97e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI1CLKSOURCE(pPeriphClkInit->Spi1ClockSelection));

    /* Configure the SPI1 clock source */
    __HAL_RCC_SPI1_CONFIG(pPeriphClkInit->Spi1ClockSelection);
 8003e2c:	4b77      	ldr	r3, [pc, #476]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003e2e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8003e32:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 8003e36:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003e3a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 8003e3e:	4973      	ldr	r1, [pc, #460]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003e40:	4313      	orrs	r3, r2
 8003e42:	f8c1 30e0 	str.w	r3, [r1, #224]	; 0xe0
  }

  /*-------------------------- SPI2 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
 8003e46:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003e4a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003e4e:	f002 7380 	and.w	r3, r2, #16777216	; 0x1000000
 8003e52:	623b      	str	r3, [r7, #32]
 8003e54:	2300      	movs	r3, #0
 8003e56:	627b      	str	r3, [r7, #36]	; 0x24
 8003e58:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
 8003e5c:	460b      	mov	r3, r1
 8003e5e:	4313      	orrs	r3, r2
 8003e60:	d00c      	beq.n	8003e7c <HAL_RCCEx_PeriphCLKConfig+0x9b4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI2CLKSOURCE(pPeriphClkInit->Spi2ClockSelection));

    /* Configure the SPI2 clock source */
    __HAL_RCC_SPI2_CONFIG(pPeriphClkInit->Spi2ClockSelection);
 8003e62:	4b6a      	ldr	r3, [pc, #424]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003e64:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8003e68:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 8003e6c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003e70:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8003e74:	4965      	ldr	r1, [pc, #404]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003e76:	4313      	orrs	r3, r2
 8003e78:	f8c1 30e0 	str.w	r3, [r1, #224]	; 0xe0
  }

  /*-------------------------- SPI3 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
 8003e7c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003e80:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003e84:	f002 7300 	and.w	r3, r2, #33554432	; 0x2000000
 8003e88:	61bb      	str	r3, [r7, #24]
 8003e8a:	2300      	movs	r3, #0
 8003e8c:	61fb      	str	r3, [r7, #28]
 8003e8e:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 8003e92:	460b      	mov	r3, r1
 8003e94:	4313      	orrs	r3, r2
 8003e96:	d00c      	beq.n	8003eb2 <HAL_RCCEx_PeriphCLKConfig+0x9ea>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI3CLKSOURCE(pPeriphClkInit->Spi3ClockSelection));

    /* Configure the SPI3 clock source */
    __HAL_RCC_SPI3_CONFIG(pPeriphClkInit->Spi3ClockSelection);
 8003e98:	4b5c      	ldr	r3, [pc, #368]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003e9a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8003e9e:	f023 0218 	bic.w	r2, r3, #24
 8003ea2:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003ea6:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8003eaa:	4958      	ldr	r1, [pc, #352]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003eac:	4313      	orrs	r3, r2
 8003eae:	f8c1 30e8 	str.w	r3, [r1, #232]	; 0xe8
  }

  /*-------------------------- OctoSPIx clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
 8003eb2:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003eb6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003eba:	f002 6380 	and.w	r3, r2, #67108864	; 0x4000000
 8003ebe:	613b      	str	r3, [r7, #16]
 8003ec0:	2300      	movs	r3, #0
 8003ec2:	617b      	str	r3, [r7, #20]
 8003ec4:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 8003ec8:	460b      	mov	r3, r1
 8003eca:	4313      	orrs	r3, r2
 8003ecc:	d032      	beq.n	8003f34 <HAL_RCCEx_PeriphCLKConfig+0xa6c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_OSPICLKSOURCE(pPeriphClkInit->OspiClockSelection));

    if (pPeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL1)
 8003ece:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003ed2:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8003ed6:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8003eda:	d105      	bne.n	8003ee8 <HAL_RCCEx_PeriphCLKConfig+0xa20>
    {
      /* Enable PLL1 Q CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8003edc:	4b4b      	ldr	r3, [pc, #300]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003ede:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003ee0:	4a4a      	ldr	r2, [pc, #296]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003ee2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8003ee6:	6293      	str	r3, [r2, #40]	; 0x28
    }
    if (pPeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL2)
 8003ee8:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003eec:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8003ef0:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 8003ef4:	d108      	bne.n	8003f08 <HAL_RCCEx_PeriphCLKConfig+0xa40>
    {
      /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
      ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8003ef6:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003efa:	3308      	adds	r3, #8
 8003efc:	4618      	mov	r0, r3
 8003efe:	f001 fe4b 	bl	8005b98 <RCCEx_PLL2_Config>
 8003f02:	4603      	mov	r3, r0
 8003f04:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
    }
    if (ret == HAL_OK)
 8003f08:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8003f0c:	2b00      	cmp	r3, #0
 8003f0e:	d10d      	bne.n	8003f2c <HAL_RCCEx_PeriphCLKConfig+0xa64>
    {
      /* Configure the OctoSPI clock source */
      __HAL_RCC_OSPI_CONFIG(pPeriphClkInit->OspiClockSelection);
 8003f10:	4b3e      	ldr	r3, [pc, #248]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003f12:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 8003f16:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 8003f1a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003f1e:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8003f22:	493a      	ldr	r1, [pc, #232]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003f24:	4313      	orrs	r3, r2
 8003f26:	f8c1 30e4 	str.w	r3, [r1, #228]	; 0xe4
 8003f2a:	e003      	b.n	8003f34 <HAL_RCCEx_PeriphCLKConfig+0xa6c>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003f2c:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8003f30:	f887 30da 	strb.w	r3, [r7, #218]	; 0xda
    }
  }
#endif /* defined(HSPI1) */

  /*-------------------------- FDCAN1 kernel clock source configuration -------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN1) == (RCC_PERIPHCLK_FDCAN1))
 8003f34:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003f38:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003f3c:	f002 6300 	and.w	r3, r2, #134217728	; 0x8000000
 8003f40:	60bb      	str	r3, [r7, #8]
 8003f42:	2300      	movs	r3, #0
 8003f44:	60fb      	str	r3, [r7, #12]
 8003f46:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 8003f4a:	460b      	mov	r3, r1
 8003f4c:	4313      	orrs	r3, r2
 8003f4e:	d03a      	beq.n	8003fc6 <HAL_RCCEx_PeriphCLKConfig+0xafe>
  {
    assert_param(IS_RCC_FDCAN1CLK(pPeriphClkInit->Fdcan1ClockSelection));

    switch (pPeriphClkInit->Fdcan1ClockSelection)
 8003f50:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003f54:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8003f58:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8003f5c:	d00e      	beq.n	8003f7c <HAL_RCCEx_PeriphCLKConfig+0xab4>
 8003f5e:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8003f62:	d815      	bhi.n	8003f90 <HAL_RCCEx_PeriphCLKConfig+0xac8>
 8003f64:	2b00      	cmp	r3, #0
 8003f66:	d017      	beq.n	8003f98 <HAL_RCCEx_PeriphCLKConfig+0xad0>
 8003f68:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8003f6c:	d110      	bne.n	8003f90 <HAL_RCCEx_PeriphCLKConfig+0xac8>
      case RCC_FDCAN1CLKSOURCE_HSE:      /* HSE is used as source of FDCAN1 kernel clock*/
        /* FDCAN1 kernel clock source config set later after clock selection check */
        break;
      case RCC_FDCAN1CLKSOURCE_PLL1:      /* PLL1 is used as clock source for FDCAN1 kernel clock*/
        /* Enable 48M2 Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8003f6e:	4b27      	ldr	r3, [pc, #156]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003f70:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003f72:	4a26      	ldr	r2, [pc, #152]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003f74:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8003f78:	6293      	str	r3, [r2, #40]	; 0x28
        /* FDCAN1 kernel clock source config set later after clock selection check */
        break;
 8003f7a:	e00e      	b.n	8003f9a <HAL_RCCEx_PeriphCLKConfig+0xad2>
      case RCC_FDCAN1CLKSOURCE_PLL2:  /* PLL2 is used as clock source for FDCAN1 kernel clock*/
        /* PLL2 input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8003f7c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003f80:	3308      	adds	r3, #8
 8003f82:	4618      	mov	r0, r3
 8003f84:	f001 fe08 	bl	8005b98 <RCCEx_PLL2_Config>
 8003f88:	4603      	mov	r3, r0
 8003f8a:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        /* FDCAN1 kernel clock source config set later after clock selection check */
        break;
 8003f8e:	e004      	b.n	8003f9a <HAL_RCCEx_PeriphCLKConfig+0xad2>
      default:
        ret = HAL_ERROR;
 8003f90:	2301      	movs	r3, #1
 8003f92:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        break;
 8003f96:	e000      	b.n	8003f9a <HAL_RCCEx_PeriphCLKConfig+0xad2>
        break;
 8003f98:	bf00      	nop
    }
    if (ret == HAL_OK)
 8003f9a:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8003f9e:	2b00      	cmp	r3, #0
 8003fa0:	d10d      	bne.n	8003fbe <HAL_RCCEx_PeriphCLKConfig+0xaf6>
    {
      /* Set the source of FDCAN1 kernel clock*/
      __HAL_RCC_FDCAN1_CONFIG(pPeriphClkInit->Fdcan1ClockSelection);
 8003fa2:	4b1a      	ldr	r3, [pc, #104]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003fa4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8003fa8:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
 8003fac:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003fb0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8003fb4:	4915      	ldr	r1, [pc, #84]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003fb6:	4313      	orrs	r3, r2
 8003fb8:	f8c1 30e0 	str.w	r3, [r1, #224]	; 0xe0
 8003fbc:	e003      	b.n	8003fc6 <HAL_RCCEx_PeriphCLKConfig+0xafe>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003fbe:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8003fc2:	f887 30da 	strb.w	r3, [r7, #218]	; 0xda
    }
  }

  /*-------------------------- DAC1 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DAC1) == RCC_PERIPHCLK_DAC1)
 8003fc6:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003fca:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003fce:	f002 5380 	and.w	r3, r2, #268435456	; 0x10000000
 8003fd2:	603b      	str	r3, [r7, #0]
 8003fd4:	2300      	movs	r3, #0
 8003fd6:	607b      	str	r3, [r7, #4]
 8003fd8:	e9d7 1200 	ldrd	r1, r2, [r7]
 8003fdc:	460b      	mov	r3, r1
 8003fde:	4313      	orrs	r3, r2
 8003fe0:	d00c      	beq.n	8003ffc <HAL_RCCEx_PeriphCLKConfig+0xb34>

    /* Check the parameters */
    assert_param(IS_RCC_DAC1CLKSOURCE(pPeriphClkInit->Dac1ClockSelection));

    /* Configure the DAC1 clock source */
    __HAL_RCC_DAC1_CONFIG(pPeriphClkInit->Dac1ClockSelection);
 8003fe2:	4b0a      	ldr	r3, [pc, #40]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003fe4:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8003fe8:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 8003fec:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8003ff0:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8003ff4:	4905      	ldr	r1, [pc, #20]	; (800400c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
 8003ff6:	4313      	orrs	r3, r2
 8003ff8:	f8c1 30e8 	str.w	r3, [r1, #232]	; 0xe8
    }
  }

#endif /* defined(USB_OTG_HS) */

  return status;
 8003ffc:	f897 30da 	ldrb.w	r3, [r7, #218]	; 0xda
}
 8004000:	4618      	mov	r0, r3
 8004002:	37e0      	adds	r7, #224	; 0xe0
 8004004:	46bd      	mov	sp, r7
 8004006:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 800400a:	bf00      	nop
 800400c:	46020c00 	.word	0x46020c00

08004010 <HAL_RCCEx_GetPLL1ClockFreq>:
  *         right PLL1CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL1_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL1ClockFreq(PLL1_ClocksTypeDef *PLL1_Clocks)
{
 8004010:	b480      	push	{r7}
 8004012:	b089      	sub	sp, #36	; 0x24
 8004014:	af00      	add	r7, sp, #0
 8004016:	6078      	str	r0, [r7, #4]
  uint32_t pll1n;
  uint32_t pll1fracen;
  float_t fracn1;
  float_t pll1vco;

  pll1n = (RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N);
 8004018:	4ba6      	ldr	r3, [pc, #664]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 800401a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800401c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004020:	61bb      	str	r3, [r7, #24]
  pll1source = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
 8004022:	4ba4      	ldr	r3, [pc, #656]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8004024:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004026:	f003 0303 	and.w	r3, r3, #3
 800402a:	617b      	str	r3, [r7, #20]
  pll1m = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos) + 1U;
 800402c:	4ba1      	ldr	r3, [pc, #644]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 800402e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004030:	0a1b      	lsrs	r3, r3, #8
 8004032:	f003 030f 	and.w	r3, r3, #15
 8004036:	3301      	adds	r3, #1
 8004038:	613b      	str	r3, [r7, #16]
  pll1fracen = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN) >> RCC_PLL1CFGR_PLL1FRACEN_Pos);
 800403a:	4b9e      	ldr	r3, [pc, #632]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 800403c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800403e:	091b      	lsrs	r3, r3, #4
 8004040:	f003 0301 	and.w	r3, r3, #1
 8004044:	60fb      	str	r3, [r7, #12]
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 8004046:	4b9b      	ldr	r3, [pc, #620]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8004048:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800404a:	08db      	lsrs	r3, r3, #3
 800404c:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8004050:	68fa      	ldr	r2, [r7, #12]
 8004052:	fb02 f303 	mul.w	r3, r2, r3
 8004056:	ee07 3a90 	vmov	s15, r3
 800405a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800405e:	edc7 7a02 	vstr	s15, [r7, #8]
                                             RCC_PLL1FRACR_PLL1FRACN_Pos));

  switch (pll1source)
 8004062:	697b      	ldr	r3, [r7, #20]
 8004064:	2b03      	cmp	r3, #3
 8004066:	d062      	beq.n	800412e <HAL_RCCEx_GetPLL1ClockFreq+0x11e>
 8004068:	697b      	ldr	r3, [r7, #20]
 800406a:	2b03      	cmp	r3, #3
 800406c:	f200 8081 	bhi.w	8004172 <HAL_RCCEx_GetPLL1ClockFreq+0x162>
 8004070:	697b      	ldr	r3, [r7, #20]
 8004072:	2b01      	cmp	r3, #1
 8004074:	d024      	beq.n	80040c0 <HAL_RCCEx_GetPLL1ClockFreq+0xb0>
 8004076:	697b      	ldr	r3, [r7, #20]
 8004078:	2b02      	cmp	r3, #2
 800407a:	d17a      	bne.n	8004172 <HAL_RCCEx_GetPLL1ClockFreq+0x162>
  {

    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800407c:	693b      	ldr	r3, [r7, #16]
 800407e:	ee07 3a90 	vmov	s15, r3
 8004082:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8004086:	eddf 6a8c 	vldr	s13, [pc, #560]	; 80042b8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a8>
 800408a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800408e:	4b89      	ldr	r3, [pc, #548]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8004090:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004092:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004096:	ee07 3a90 	vmov	s15, r3
 800409a:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1);
 800409e:	ed97 6a02 	vldr	s12, [r7, #8]
 80040a2:	eddf 5a86 	vldr	s11, [pc, #536]	; 80042bc <HAL_RCCEx_GetPLL1ClockFreq+0x2ac>
 80040a6:	eec6 7a25 	vdiv.f32	s15, s12, s11
      pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 80040aa:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1);
 80040ae:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 80040b2:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 80040b6:	ee67 7a27 	vmul.f32	s15, s14, s15
 80040ba:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 80040be:	e08f      	b.n	80041e0 <HAL_RCCEx_GetPLL1ClockFreq+0x1d0>
    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      pll1vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll1m) * \
 80040c0:	4b7c      	ldr	r3, [pc, #496]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 80040c2:	689b      	ldr	r3, [r3, #8]
 80040c4:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 80040c8:	2b00      	cmp	r3, #0
 80040ca:	d005      	beq.n	80040d8 <HAL_RCCEx_GetPLL1ClockFreq+0xc8>
 80040cc:	4b79      	ldr	r3, [pc, #484]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 80040ce:	689b      	ldr	r3, [r3, #8]
 80040d0:	0f1b      	lsrs	r3, r3, #28
 80040d2:	f003 030f 	and.w	r3, r3, #15
 80040d6:	e006      	b.n	80040e6 <HAL_RCCEx_GetPLL1ClockFreq+0xd6>
 80040d8:	4b76      	ldr	r3, [pc, #472]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 80040da:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 80040de:	041b      	lsls	r3, r3, #16
 80040e0:	0f1b      	lsrs	r3, r3, #28
 80040e2:	f003 030f 	and.w	r3, r3, #15
 80040e6:	4a76      	ldr	r2, [pc, #472]	; (80042c0 <HAL_RCCEx_GetPLL1ClockFreq+0x2b0>)
 80040e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80040ec:	ee07 3a90 	vmov	s15, r3
 80040f0:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80040f4:	693b      	ldr	r3, [r7, #16]
 80040f6:	ee07 3a90 	vmov	s15, r3
 80040fa:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80040fe:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                ((float_t)pll1n + (fracn1 / (float_t)0x2000) + (float_t)1);
 8004102:	69bb      	ldr	r3, [r7, #24]
 8004104:	ee07 3a90 	vmov	s15, r3
 8004108:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800410c:	ed97 6a02 	vldr	s12, [r7, #8]
 8004110:	eddf 5a6a 	vldr	s11, [pc, #424]	; 80042bc <HAL_RCCEx_GetPLL1ClockFreq+0x2ac>
 8004114:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8004118:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800411c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8004120:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll1vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll1m) * \
 8004124:	ee67 7a27 	vmul.f32	s15, s14, s15
 8004128:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 800412c:	e058      	b.n	80041e0 <HAL_RCCEx_GetPLL1ClockFreq+0x1d0>
    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800412e:	693b      	ldr	r3, [r7, #16]
 8004130:	ee07 3a90 	vmov	s15, r3
 8004134:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8004138:	eddf 6a5f 	vldr	s13, [pc, #380]	; 80042b8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a8>
 800413c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8004140:	4b5c      	ldr	r3, [pc, #368]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8004142:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004144:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004148:	ee07 3a90 	vmov	s15, r3
 800414c:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1);
 8004150:	ed97 6a02 	vldr	s12, [r7, #8]
 8004154:	eddf 5a59 	vldr	s11, [pc, #356]	; 80042bc <HAL_RCCEx_GetPLL1ClockFreq+0x2ac>
 8004158:	eec6 7a25 	vdiv.f32	s15, s12, s11
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800415c:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1);
 8004160:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8004164:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8004168:	ee67 7a27 	vmul.f32	s15, s14, s15
 800416c:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8004170:	e036      	b.n	80041e0 <HAL_RCCEx_GetPLL1ClockFreq+0x1d0>
    default:
      pll1vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll1m) * \
 8004172:	4b50      	ldr	r3, [pc, #320]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8004174:	689b      	ldr	r3, [r3, #8]
 8004176:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800417a:	2b00      	cmp	r3, #0
 800417c:	d005      	beq.n	800418a <HAL_RCCEx_GetPLL1ClockFreq+0x17a>
 800417e:	4b4d      	ldr	r3, [pc, #308]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8004180:	689b      	ldr	r3, [r3, #8]
 8004182:	0f1b      	lsrs	r3, r3, #28
 8004184:	f003 030f 	and.w	r3, r3, #15
 8004188:	e006      	b.n	8004198 <HAL_RCCEx_GetPLL1ClockFreq+0x188>
 800418a:	4b4a      	ldr	r3, [pc, #296]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 800418c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8004190:	041b      	lsls	r3, r3, #16
 8004192:	0f1b      	lsrs	r3, r3, #28
 8004194:	f003 030f 	and.w	r3, r3, #15
 8004198:	4a49      	ldr	r2, [pc, #292]	; (80042c0 <HAL_RCCEx_GetPLL1ClockFreq+0x2b0>)
 800419a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800419e:	ee07 3a90 	vmov	s15, r3
 80041a2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80041a6:	693b      	ldr	r3, [r7, #16]
 80041a8:	ee07 3a90 	vmov	s15, r3
 80041ac:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80041b0:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                ((float_t)pll1n + (fracn1 / (float_t)0x2000) + (float_t)1);
 80041b4:	69bb      	ldr	r3, [r7, #24]
 80041b6:	ee07 3a90 	vmov	s15, r3
 80041ba:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80041be:	ed97 6a02 	vldr	s12, [r7, #8]
 80041c2:	eddf 5a3e 	vldr	s11, [pc, #248]	; 80042bc <HAL_RCCEx_GetPLL1ClockFreq+0x2ac>
 80041c6:	eec6 7a25 	vdiv.f32	s15, s12, s11
 80041ca:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80041ce:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 80041d2:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll1vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll1m) * \
 80041d6:	ee67 7a27 	vmul.f32	s15, s14, s15
 80041da:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 80041de:	bf00      	nop
  }

  if (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL1_DIVP) != 0U)
 80041e0:	4b34      	ldr	r3, [pc, #208]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 80041e2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80041e4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80041e8:	2b00      	cmp	r3, #0
 80041ea:	d017      	beq.n	800421c <HAL_RCCEx_GetPLL1ClockFreq+0x20c>
  {
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 80041ec:	4b31      	ldr	r3, [pc, #196]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 80041ee:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80041f0:	0a5b      	lsrs	r3, r3, #9
 80041f2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80041f6:	ee07 3a90 	vmov	s15, r3
 80041fa:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL1DIVR_PLL1P) >> RCC_PLL1DIVR_PLL1P_Pos) + \
 80041fe:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8004202:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 8004206:	edd7 6a07 	vldr	s13, [r7, #28]
 800420a:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800420e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8004212:	ee17 2a90 	vmov	r2, s15
 8004216:	687b      	ldr	r3, [r7, #4]
 8004218:	601a      	str	r2, [r3, #0]
 800421a:	e002      	b.n	8004222 <HAL_RCCEx_GetPLL1ClockFreq+0x212>
                                                                   (float_t)1));
  }
  else
  {
    PLL1_Clocks->PLL1_P_Frequency = 0U;
 800421c:	687b      	ldr	r3, [r7, #4]
 800421e:	2200      	movs	r2, #0
 8004220:	601a      	str	r2, [r3, #0]
  }

  if (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL1_DIVQ) != 0U)
 8004222:	4b24      	ldr	r3, [pc, #144]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8004224:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004226:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800422a:	2b00      	cmp	r3, #0
 800422c:	d017      	beq.n	800425e <HAL_RCCEx_GetPLL1ClockFreq+0x24e>
  {
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 800422e:	4b21      	ldr	r3, [pc, #132]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8004230:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004232:	0c1b      	lsrs	r3, r3, #16
 8004234:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8004238:	ee07 3a90 	vmov	s15, r3
 800423c:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL1DIVR_PLL1Q) >> RCC_PLL1DIVR_PLL1Q_Pos) + \
 8004240:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8004244:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 8004248:	edd7 6a07 	vldr	s13, [r7, #28]
 800424c:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8004250:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8004254:	ee17 2a90 	vmov	r2, s15
 8004258:	687b      	ldr	r3, [r7, #4]
 800425a:	605a      	str	r2, [r3, #4]
 800425c:	e002      	b.n	8004264 <HAL_RCCEx_GetPLL1ClockFreq+0x254>
                                                                   (float_t)1));
  }
  else
  {
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
 800425e:	687b      	ldr	r3, [r7, #4]
 8004260:	2200      	movs	r2, #0
 8004262:	605a      	str	r2, [r3, #4]
  }

  if (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL1_DIVR) != 0U)
 8004264:	4b13      	ldr	r3, [pc, #76]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8004266:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004268:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800426c:	2b00      	cmp	r3, #0
 800426e:	d017      	beq.n	80042a0 <HAL_RCCEx_GetPLL1ClockFreq+0x290>
  {
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 8004270:	4b10      	ldr	r3, [pc, #64]	; (80042b4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8004272:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004274:	0e1b      	lsrs	r3, r3, #24
 8004276:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800427a:	ee07 3a90 	vmov	s15, r3
 800427e:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL1DIVR_PLL1R) >> RCC_PLL1DIVR_PLL1R_Pos) + \
 8004282:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8004286:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 800428a:	edd7 6a07 	vldr	s13, [r7, #28]
 800428e:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8004292:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8004296:	ee17 2a90 	vmov	r2, s15
 800429a:	687b      	ldr	r3, [r7, #4]
 800429c:	609a      	str	r2, [r3, #8]
  else
  {
    PLL1_Clocks->PLL1_R_Frequency = 0U;
  }

}
 800429e:	e002      	b.n	80042a6 <HAL_RCCEx_GetPLL1ClockFreq+0x296>
    PLL1_Clocks->PLL1_R_Frequency = 0U;
 80042a0:	687b      	ldr	r3, [r7, #4]
 80042a2:	2200      	movs	r2, #0
 80042a4:	609a      	str	r2, [r3, #8]
}
 80042a6:	bf00      	nop
 80042a8:	3724      	adds	r7, #36	; 0x24
 80042aa:	46bd      	mov	sp, r7
 80042ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80042b0:	4770      	bx	lr
 80042b2:	bf00      	nop
 80042b4:	46020c00 	.word	0x46020c00
 80042b8:	4b742400 	.word	0x4b742400
 80042bc:	46000000 	.word	0x46000000
 80042c0:	08017aac 	.word	0x08017aac

080042c4 <HAL_RCCEx_GetPLL2ClockFreq>:
  *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL2_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef *PLL2_Clocks)
{
 80042c4:	b480      	push	{r7}
 80042c6:	b089      	sub	sp, #36	; 0x24
 80042c8:	af00      	add	r7, sp, #0
 80042ca:	6078      	str	r0, [r7, #4]
  float_t fracn2;
  float_t pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x */
  pll2n = (RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N);
 80042cc:	4ba6      	ldr	r3, [pc, #664]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 80042ce:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80042d0:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80042d4:	61bb      	str	r3, [r7, #24]
  pll2source = (RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2SRC);
 80042d6:	4ba4      	ldr	r3, [pc, #656]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 80042d8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80042da:	f003 0303 	and.w	r3, r3, #3
 80042de:	617b      	str	r3, [r7, #20]
  pll2m = ((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2M) >> RCC_PLL2CFGR_PLL2M_Pos) + 1U;
 80042e0:	4ba1      	ldr	r3, [pc, #644]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 80042e2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80042e4:	0a1b      	lsrs	r3, r3, #8
 80042e6:	f003 030f 	and.w	r3, r3, #15
 80042ea:	3301      	adds	r3, #1
 80042ec:	613b      	str	r3, [r7, #16]
  pll2fracen = ((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2FRACEN) >> RCC_PLL2CFGR_PLL2FRACEN_Pos);
 80042ee:	4b9e      	ldr	r3, [pc, #632]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 80042f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80042f2:	091b      	lsrs	r3, r3, #4
 80042f4:	f003 0301 	and.w	r3, r3, #1
 80042f8:	60fb      	str	r3, [r7, #12]
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_PLL2FRACN) >> \
 80042fa:	4b9b      	ldr	r3, [pc, #620]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 80042fc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80042fe:	08db      	lsrs	r3, r3, #3
 8004300:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8004304:	68fa      	ldr	r2, [r7, #12]
 8004306:	fb02 f303 	mul.w	r3, r2, r3
 800430a:	ee07 3a90 	vmov	s15, r3
 800430e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8004312:	edc7 7a02 	vstr	s15, [r7, #8]
                                             RCC_PLL2FRACR_PLL2FRACN_Pos));

  switch (pll2source)
 8004316:	697b      	ldr	r3, [r7, #20]
 8004318:	2b03      	cmp	r3, #3
 800431a:	d062      	beq.n	80043e2 <HAL_RCCEx_GetPLL2ClockFreq+0x11e>
 800431c:	697b      	ldr	r3, [r7, #20]
 800431e:	2b03      	cmp	r3, #3
 8004320:	f200 8081 	bhi.w	8004426 <HAL_RCCEx_GetPLL2ClockFreq+0x162>
 8004324:	697b      	ldr	r3, [r7, #20]
 8004326:	2b01      	cmp	r3, #1
 8004328:	d024      	beq.n	8004374 <HAL_RCCEx_GetPLL2ClockFreq+0xb0>
 800432a:	697b      	ldr	r3, [r7, #20]
 800432c:	2b02      	cmp	r3, #2
 800432e:	d17a      	bne.n	8004426 <HAL_RCCEx_GetPLL2ClockFreq+0x162>
  {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 8004330:	693b      	ldr	r3, [r7, #16]
 8004332:	ee07 3a90 	vmov	s15, r3
 8004336:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800433a:	eddf 6a8c 	vldr	s13, [pc, #560]	; 800456c <HAL_RCCEx_GetPLL2ClockFreq+0x2a8>
 800433e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8004342:	4b89      	ldr	r3, [pc, #548]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8004344:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004346:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800434a:	ee07 3a90 	vmov	s15, r3
 800434e:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn2 / (float_t)0x2000) + (float_t)1);
 8004352:	ed97 6a02 	vldr	s12, [r7, #8]
 8004356:	eddf 5a86 	vldr	s11, [pc, #536]	; 8004570 <HAL_RCCEx_GetPLL2ClockFreq+0x2ac>
 800435a:	eec6 7a25 	vdiv.f32	s15, s12, s11
      pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 800435e:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn2 / (float_t)0x2000) + (float_t)1);
 8004362:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8004366:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 800436a:	ee67 7a27 	vmul.f32	s15, s14, s15
 800436e:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8004372:	e08f      	b.n	8004494 <HAL_RCCEx_GetPLL2ClockFreq+0x1d0>

    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      pll2vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll2m) * \
 8004374:	4b7c      	ldr	r3, [pc, #496]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8004376:	689b      	ldr	r3, [r3, #8]
 8004378:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800437c:	2b00      	cmp	r3, #0
 800437e:	d005      	beq.n	800438c <HAL_RCCEx_GetPLL2ClockFreq+0xc8>
 8004380:	4b79      	ldr	r3, [pc, #484]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8004382:	689b      	ldr	r3, [r3, #8]
 8004384:	0f1b      	lsrs	r3, r3, #28
 8004386:	f003 030f 	and.w	r3, r3, #15
 800438a:	e006      	b.n	800439a <HAL_RCCEx_GetPLL2ClockFreq+0xd6>
 800438c:	4b76      	ldr	r3, [pc, #472]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 800438e:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8004392:	041b      	lsls	r3, r3, #16
 8004394:	0f1b      	lsrs	r3, r3, #28
 8004396:	f003 030f 	and.w	r3, r3, #15
 800439a:	4a76      	ldr	r2, [pc, #472]	; (8004574 <HAL_RCCEx_GetPLL2ClockFreq+0x2b0>)
 800439c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80043a0:	ee07 3a90 	vmov	s15, r3
 80043a4:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80043a8:	693b      	ldr	r3, [r7, #16]
 80043aa:	ee07 3a90 	vmov	s15, r3
 80043ae:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80043b2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                ((float_t)pll2n + (fracn2 / (float_t)0x2000) + (float_t)1);
 80043b6:	69bb      	ldr	r3, [r7, #24]
 80043b8:	ee07 3a90 	vmov	s15, r3
 80043bc:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80043c0:	ed97 6a02 	vldr	s12, [r7, #8]
 80043c4:	eddf 5a6a 	vldr	s11, [pc, #424]	; 8004570 <HAL_RCCEx_GetPLL2ClockFreq+0x2ac>
 80043c8:	eec6 7a25 	vdiv.f32	s15, s12, s11
 80043cc:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80043d0:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 80043d4:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll2vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll2m) * \
 80043d8:	ee67 7a27 	vmul.f32	s15, s14, s15
 80043dc:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 80043e0:	e058      	b.n	8004494 <HAL_RCCEx_GetPLL2ClockFreq+0x1d0>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 80043e2:	693b      	ldr	r3, [r7, #16]
 80043e4:	ee07 3a90 	vmov	s15, r3
 80043e8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80043ec:	eddf 6a5f 	vldr	s13, [pc, #380]	; 800456c <HAL_RCCEx_GetPLL2ClockFreq+0x2a8>
 80043f0:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 80043f4:	4b5c      	ldr	r3, [pc, #368]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 80043f6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80043f8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80043fc:	ee07 3a90 	vmov	s15, r3
 8004400:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn2 / (float_t)0x2000) + (float_t)1);
 8004404:	ed97 6a02 	vldr	s12, [r7, #8]
 8004408:	eddf 5a59 	vldr	s11, [pc, #356]	; 8004570 <HAL_RCCEx_GetPLL2ClockFreq+0x2ac>
 800440c:	eec6 7a25 	vdiv.f32	s15, s12, s11
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 8004410:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn2 / (float_t)0x2000) + (float_t)1);
 8004414:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8004418:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 800441c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8004420:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8004424:	e036      	b.n	8004494 <HAL_RCCEx_GetPLL2ClockFreq+0x1d0>

    default:
      pll2vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t) pll2m) \
 8004426:	4b50      	ldr	r3, [pc, #320]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8004428:	689b      	ldr	r3, [r3, #8]
 800442a:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800442e:	2b00      	cmp	r3, #0
 8004430:	d005      	beq.n	800443e <HAL_RCCEx_GetPLL2ClockFreq+0x17a>
 8004432:	4b4d      	ldr	r3, [pc, #308]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8004434:	689b      	ldr	r3, [r3, #8]
 8004436:	0f1b      	lsrs	r3, r3, #28
 8004438:	f003 030f 	and.w	r3, r3, #15
 800443c:	e006      	b.n	800444c <HAL_RCCEx_GetPLL2ClockFreq+0x188>
 800443e:	4b4a      	ldr	r3, [pc, #296]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8004440:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8004444:	041b      	lsls	r3, r3, #16
 8004446:	0f1b      	lsrs	r3, r3, #28
 8004448:	f003 030f 	and.w	r3, r3, #15
 800444c:	4a49      	ldr	r2, [pc, #292]	; (8004574 <HAL_RCCEx_GetPLL2ClockFreq+0x2b0>)
 800444e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004452:	ee07 3a90 	vmov	s15, r3
 8004456:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800445a:	693b      	ldr	r3, [r7, #16]
 800445c:	ee07 3a90 	vmov	s15, r3
 8004460:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8004464:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                * ((float_t)pll2n + (fracn2 / (float_t)0x2000) + (float_t)1);
 8004468:	69bb      	ldr	r3, [r7, #24]
 800446a:	ee07 3a90 	vmov	s15, r3
 800446e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8004472:	ed97 6a02 	vldr	s12, [r7, #8]
 8004476:	eddf 5a3e 	vldr	s11, [pc, #248]	; 8004570 <HAL_RCCEx_GetPLL2ClockFreq+0x2ac>
 800447a:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800447e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8004482:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8004486:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll2vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t) pll2m) \
 800448a:	ee67 7a27 	vmul.f32	s15, s14, s15
 800448e:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8004492:	bf00      	nop
  }
  if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL2_DIVP) != 0U)
 8004494:	4b34      	ldr	r3, [pc, #208]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8004496:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004498:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800449c:	2b00      	cmp	r3, #0
 800449e:	d017      	beq.n	80044d0 <HAL_RCCEx_GetPLL2ClockFreq+0x20c>
  {
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 80044a0:	4b31      	ldr	r3, [pc, #196]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 80044a2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80044a4:	0a5b      	lsrs	r3, r3, #9
 80044a6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80044aa:	ee07 3a90 	vmov	s15, r3
 80044ae:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL2DIVR_PLL2P) >> RCC_PLL2DIVR_PLL2P_Pos) + \
 80044b2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80044b6:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 80044ba:	edd7 6a07 	vldr	s13, [r7, #28]
 80044be:	eec6 7a87 	vdiv.f32	s15, s13, s14
 80044c2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80044c6:	ee17 2a90 	vmov	r2, s15
 80044ca:	687b      	ldr	r3, [r7, #4]
 80044cc:	601a      	str	r2, [r3, #0]
 80044ce:	e002      	b.n	80044d6 <HAL_RCCEx_GetPLL2ClockFreq+0x212>
                                                                   (float_t)1));
  }
  else
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
 80044d0:	687b      	ldr	r3, [r7, #4]
 80044d2:	2200      	movs	r2, #0
 80044d4:	601a      	str	r2, [r3, #0]
  }
  if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL2_DIVQ) != 0U)
 80044d6:	4b24      	ldr	r3, [pc, #144]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 80044d8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80044da:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80044de:	2b00      	cmp	r3, #0
 80044e0:	d017      	beq.n	8004512 <HAL_RCCEx_GetPLL2ClockFreq+0x24e>
  {
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 80044e2:	4b21      	ldr	r3, [pc, #132]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 80044e4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80044e6:	0c1b      	lsrs	r3, r3, #16
 80044e8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80044ec:	ee07 3a90 	vmov	s15, r3
 80044f0:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL2DIVR_PLL2Q) >> RCC_PLL2DIVR_PLL2Q_Pos) + \
 80044f4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80044f8:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 80044fc:	edd7 6a07 	vldr	s13, [r7, #28]
 8004500:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8004504:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8004508:	ee17 2a90 	vmov	r2, s15
 800450c:	687b      	ldr	r3, [r7, #4]
 800450e:	605a      	str	r2, [r3, #4]
 8004510:	e002      	b.n	8004518 <HAL_RCCEx_GetPLL2ClockFreq+0x254>
                                                                   (float_t)1));
  }
  else
  {
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
 8004512:	687b      	ldr	r3, [r7, #4]
 8004514:	2200      	movs	r2, #0
 8004516:	605a      	str	r2, [r3, #4]
  }
  if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL2_DIVR) != 0U)
 8004518:	4b13      	ldr	r3, [pc, #76]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 800451a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800451c:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8004520:	2b00      	cmp	r3, #0
 8004522:	d017      	beq.n	8004554 <HAL_RCCEx_GetPLL2ClockFreq+0x290>
  {
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 8004524:	4b10      	ldr	r3, [pc, #64]	; (8004568 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8004526:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004528:	0e1b      	lsrs	r3, r3, #24
 800452a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800452e:	ee07 3a90 	vmov	s15, r3
 8004532:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL2DIVR_PLL2R) >> RCC_PLL2DIVR_PLL2R_Pos) + \
 8004536:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 800453a:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 800453e:	edd7 6a07 	vldr	s13, [r7, #28]
 8004542:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8004546:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800454a:	ee17 2a90 	vmov	r2, s15
 800454e:	687b      	ldr	r3, [r7, #4]
 8004550:	609a      	str	r2, [r3, #8]
  }
  else
  {
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
 8004552:	e002      	b.n	800455a <HAL_RCCEx_GetPLL2ClockFreq+0x296>
    PLL2_Clocks->PLL2_R_Frequency = 0U;
 8004554:	687b      	ldr	r3, [r7, #4]
 8004556:	2200      	movs	r2, #0
 8004558:	609a      	str	r2, [r3, #8]
}
 800455a:	bf00      	nop
 800455c:	3724      	adds	r7, #36	; 0x24
 800455e:	46bd      	mov	sp, r7
 8004560:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004564:	4770      	bx	lr
 8004566:	bf00      	nop
 8004568:	46020c00 	.word	0x46020c00
 800456c:	4b742400 	.word	0x4b742400
 8004570:	46000000 	.word	0x46000000
 8004574:	08017aac 	.word	0x08017aac

08004578 <HAL_RCCEx_GetPLL3ClockFreq>:
  *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL3_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef *PLL3_Clocks)
{
 8004578:	b480      	push	{r7}
 800457a:	b089      	sub	sp, #36	; 0x24
 800457c:	af00      	add	r7, sp, #0
 800457e:	6078      	str	r0, [r7, #4]

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
  PLL3xCLK = PLL3_VCO / PLLxR
  */

  pll3n = (RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N);
 8004580:	4ba6      	ldr	r3, [pc, #664]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8004582:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8004584:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004588:	61bb      	str	r3, [r7, #24]
  pll3source = (RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3SRC);
 800458a:	4ba4      	ldr	r3, [pc, #656]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 800458c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800458e:	f003 0303 	and.w	r3, r3, #3
 8004592:	617b      	str	r3, [r7, #20]
  pll3m = ((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3M) >> RCC_PLL3CFGR_PLL3M_Pos) + 1U;
 8004594:	4ba1      	ldr	r3, [pc, #644]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8004596:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004598:	0a1b      	lsrs	r3, r3, #8
 800459a:	f003 030f 	and.w	r3, r3, #15
 800459e:	3301      	adds	r3, #1
 80045a0:	613b      	str	r3, [r7, #16]
  pll3fracen = ((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3FRACEN) >> RCC_PLL3CFGR_PLL3FRACEN_Pos);
 80045a2:	4b9e      	ldr	r3, [pc, #632]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 80045a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80045a6:	091b      	lsrs	r3, r3, #4
 80045a8:	f003 0301 	and.w	r3, r3, #1
 80045ac:	60fb      	str	r3, [r7, #12]
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_PLL3FRACN) >> \
 80045ae:	4b9b      	ldr	r3, [pc, #620]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 80045b0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80045b2:	08db      	lsrs	r3, r3, #3
 80045b4:	f3c3 030c 	ubfx	r3, r3, #0, #13
 80045b8:	68fa      	ldr	r2, [r7, #12]
 80045ba:	fb02 f303 	mul.w	r3, r2, r3
 80045be:	ee07 3a90 	vmov	s15, r3
 80045c2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80045c6:	edc7 7a02 	vstr	s15, [r7, #8]
                                             RCC_PLL3FRACR_PLL3FRACN_Pos));

  switch (pll3source)
 80045ca:	697b      	ldr	r3, [r7, #20]
 80045cc:	2b03      	cmp	r3, #3
 80045ce:	d062      	beq.n	8004696 <HAL_RCCEx_GetPLL3ClockFreq+0x11e>
 80045d0:	697b      	ldr	r3, [r7, #20]
 80045d2:	2b03      	cmp	r3, #3
 80045d4:	f200 8081 	bhi.w	80046da <HAL_RCCEx_GetPLL3ClockFreq+0x162>
 80045d8:	697b      	ldr	r3, [r7, #20]
 80045da:	2b01      	cmp	r3, #1
 80045dc:	d024      	beq.n	8004628 <HAL_RCCEx_GetPLL3ClockFreq+0xb0>
 80045de:	697b      	ldr	r3, [r7, #20]
 80045e0:	2b02      	cmp	r3, #2
 80045e2:	d17a      	bne.n	80046da <HAL_RCCEx_GetPLL3ClockFreq+0x162>
  {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 80045e4:	693b      	ldr	r3, [r7, #16]
 80045e6:	ee07 3a90 	vmov	s15, r3
 80045ea:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80045ee:	eddf 6a8c 	vldr	s13, [pc, #560]	; 8004820 <HAL_RCCEx_GetPLL3ClockFreq+0x2a8>
 80045f2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 80045f6:	4b89      	ldr	r3, [pc, #548]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 80045f8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80045fa:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80045fe:	ee07 3a90 	vmov	s15, r3
 8004602:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn3 / (float_t)0x2000) + (float_t)1);
 8004606:	ed97 6a02 	vldr	s12, [r7, #8]
 800460a:	eddf 5a86 	vldr	s11, [pc, #536]	; 8004824 <HAL_RCCEx_GetPLL3ClockFreq+0x2ac>
 800460e:	eec6 7a25 	vdiv.f32	s15, s12, s11
      pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 8004612:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn3 / (float_t)0x2000) + (float_t)1);
 8004616:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 800461a:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 800461e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8004622:	edc7 7a07 	vstr	s15, [r7, #28]

      break;
 8004626:	e08f      	b.n	8004748 <HAL_RCCEx_GetPLL3ClockFreq+0x1d0>
    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      pll3vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll3m) * \
 8004628:	4b7c      	ldr	r3, [pc, #496]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 800462a:	689b      	ldr	r3, [r3, #8]
 800462c:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8004630:	2b00      	cmp	r3, #0
 8004632:	d005      	beq.n	8004640 <HAL_RCCEx_GetPLL3ClockFreq+0xc8>
 8004634:	4b79      	ldr	r3, [pc, #484]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8004636:	689b      	ldr	r3, [r3, #8]
 8004638:	0f1b      	lsrs	r3, r3, #28
 800463a:	f003 030f 	and.w	r3, r3, #15
 800463e:	e006      	b.n	800464e <HAL_RCCEx_GetPLL3ClockFreq+0xd6>
 8004640:	4b76      	ldr	r3, [pc, #472]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8004642:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8004646:	041b      	lsls	r3, r3, #16
 8004648:	0f1b      	lsrs	r3, r3, #28
 800464a:	f003 030f 	and.w	r3, r3, #15
 800464e:	4a76      	ldr	r2, [pc, #472]	; (8004828 <HAL_RCCEx_GetPLL3ClockFreq+0x2b0>)
 8004650:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004654:	ee07 3a90 	vmov	s15, r3
 8004658:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800465c:	693b      	ldr	r3, [r7, #16]
 800465e:	ee07 3a90 	vmov	s15, r3
 8004662:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8004666:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                ((float_t)pll3n + (fracn3 / (float_t)0x2000) + (float_t)1);
 800466a:	69bb      	ldr	r3, [r7, #24]
 800466c:	ee07 3a90 	vmov	s15, r3
 8004670:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8004674:	ed97 6a02 	vldr	s12, [r7, #8]
 8004678:	eddf 5a6a 	vldr	s11, [pc, #424]	; 8004824 <HAL_RCCEx_GetPLL3ClockFreq+0x2ac>
 800467c:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8004680:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8004684:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8004688:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll3vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll3m) * \
 800468c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8004690:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8004694:	e058      	b.n	8004748 <HAL_RCCEx_GetPLL3ClockFreq+0x1d0>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 8004696:	693b      	ldr	r3, [r7, #16]
 8004698:	ee07 3a90 	vmov	s15, r3
 800469c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80046a0:	eddf 6a5f 	vldr	s13, [pc, #380]	; 8004820 <HAL_RCCEx_GetPLL3ClockFreq+0x2a8>
 80046a4:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 80046a8:	4b5c      	ldr	r3, [pc, #368]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 80046aa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80046ac:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80046b0:	ee07 3a90 	vmov	s15, r3
 80046b4:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn3 / (float_t)0x2000) + (float_t)1);
 80046b8:	ed97 6a02 	vldr	s12, [r7, #8]
 80046bc:	eddf 5a59 	vldr	s11, [pc, #356]	; 8004824 <HAL_RCCEx_GetPLL3ClockFreq+0x2ac>
 80046c0:	eec6 7a25 	vdiv.f32	s15, s12, s11
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 80046c4:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn3 / (float_t)0x2000) + (float_t)1);
 80046c8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 80046cc:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 80046d0:	ee67 7a27 	vmul.f32	s15, s14, s15
 80046d4:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 80046d8:	e036      	b.n	8004748 <HAL_RCCEx_GetPLL3ClockFreq+0x1d0>

    default:
      pll3vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll3m) * \
 80046da:	4b50      	ldr	r3, [pc, #320]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 80046dc:	689b      	ldr	r3, [r3, #8]
 80046de:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 80046e2:	2b00      	cmp	r3, #0
 80046e4:	d005      	beq.n	80046f2 <HAL_RCCEx_GetPLL3ClockFreq+0x17a>
 80046e6:	4b4d      	ldr	r3, [pc, #308]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 80046e8:	689b      	ldr	r3, [r3, #8]
 80046ea:	0f1b      	lsrs	r3, r3, #28
 80046ec:	f003 030f 	and.w	r3, r3, #15
 80046f0:	e006      	b.n	8004700 <HAL_RCCEx_GetPLL3ClockFreq+0x188>
 80046f2:	4b4a      	ldr	r3, [pc, #296]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 80046f4:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 80046f8:	041b      	lsls	r3, r3, #16
 80046fa:	0f1b      	lsrs	r3, r3, #28
 80046fc:	f003 030f 	and.w	r3, r3, #15
 8004700:	4a49      	ldr	r2, [pc, #292]	; (8004828 <HAL_RCCEx_GetPLL3ClockFreq+0x2b0>)
 8004702:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004706:	ee07 3a90 	vmov	s15, r3
 800470a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800470e:	693b      	ldr	r3, [r7, #16]
 8004710:	ee07 3a90 	vmov	s15, r3
 8004714:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8004718:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                ((float_t)pll3n + (fracn3 / (float_t)0x2000) + (float_t)1);
 800471c:	69bb      	ldr	r3, [r7, #24]
 800471e:	ee07 3a90 	vmov	s15, r3
 8004722:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8004726:	ed97 6a02 	vldr	s12, [r7, #8]
 800472a:	eddf 5a3e 	vldr	s11, [pc, #248]	; 8004824 <HAL_RCCEx_GetPLL3ClockFreq+0x2ac>
 800472e:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8004732:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8004736:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 800473a:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll3vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll3m) * \
 800473e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8004742:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8004746:	bf00      	nop
  }

  if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL3_DIVP) != 0U)
 8004748:	4b34      	ldr	r3, [pc, #208]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 800474a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800474c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8004750:	2b00      	cmp	r3, #0
 8004752:	d017      	beq.n	8004784 <HAL_RCCEx_GetPLL3ClockFreq+0x20c>
  {
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 8004754:	4b31      	ldr	r3, [pc, #196]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8004756:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8004758:	0a5b      	lsrs	r3, r3, #9
 800475a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800475e:	ee07 3a90 	vmov	s15, r3
 8004762:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL3DIVR_PLL3P) >> RCC_PLL3DIVR_PLL3P_Pos) + \
 8004766:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 800476a:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 800476e:	edd7 6a07 	vldr	s13, [r7, #28]
 8004772:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8004776:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800477a:	ee17 2a90 	vmov	r2, s15
 800477e:	687b      	ldr	r3, [r7, #4]
 8004780:	601a      	str	r2, [r3, #0]
 8004782:	e002      	b.n	800478a <HAL_RCCEx_GetPLL3ClockFreq+0x212>
                                                                   (float_t)1));
  }
  else
  {
    PLL3_Clocks->PLL3_P_Frequency = 0U;
 8004784:	687b      	ldr	r3, [r7, #4]
 8004786:	2200      	movs	r2, #0
 8004788:	601a      	str	r2, [r3, #0]
  }

  if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL3_DIVQ) != 0U)
 800478a:	4b24      	ldr	r3, [pc, #144]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 800478c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800478e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8004792:	2b00      	cmp	r3, #0
 8004794:	d017      	beq.n	80047c6 <HAL_RCCEx_GetPLL3ClockFreq+0x24e>
  {
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 8004796:	4b21      	ldr	r3, [pc, #132]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8004798:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800479a:	0c1b      	lsrs	r3, r3, #16
 800479c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80047a0:	ee07 3a90 	vmov	s15, r3
 80047a4:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL3DIVR_PLL3Q) >> RCC_PLL3DIVR_PLL3Q_Pos) + \
 80047a8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80047ac:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 80047b0:	edd7 6a07 	vldr	s13, [r7, #28]
 80047b4:	eec6 7a87 	vdiv.f32	s15, s13, s14
 80047b8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80047bc:	ee17 2a90 	vmov	r2, s15
 80047c0:	687b      	ldr	r3, [r7, #4]
 80047c2:	605a      	str	r2, [r3, #4]
 80047c4:	e002      	b.n	80047cc <HAL_RCCEx_GetPLL3ClockFreq+0x254>
                                                                   (float_t)1));
  }
  else
  {
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
 80047c6:	687b      	ldr	r3, [r7, #4]
 80047c8:	2200      	movs	r2, #0
 80047ca:	605a      	str	r2, [r3, #4]
  }

  if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL3_DIVR) != 0U)
 80047cc:	4b13      	ldr	r3, [pc, #76]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 80047ce:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80047d0:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80047d4:	2b00      	cmp	r3, #0
 80047d6:	d017      	beq.n	8004808 <HAL_RCCEx_GetPLL3ClockFreq+0x290>
  {
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 80047d8:	4b10      	ldr	r3, [pc, #64]	; (800481c <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 80047da:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80047dc:	0e1b      	lsrs	r3, r3, #24
 80047de:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80047e2:	ee07 3a90 	vmov	s15, r3
 80047e6:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL3DIVR_PLL3R) >> RCC_PLL3DIVR_PLL3R_Pos) + \
 80047ea:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80047ee:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 80047f2:	edd7 6a07 	vldr	s13, [r7, #28]
 80047f6:	eec6 7a87 	vdiv.f32	s15, s13, s14
 80047fa:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80047fe:	ee17 2a90 	vmov	r2, s15
 8004802:	687b      	ldr	r3, [r7, #4]
 8004804:	609a      	str	r2, [r3, #8]
  else
  {
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }

}
 8004806:	e002      	b.n	800480e <HAL_RCCEx_GetPLL3ClockFreq+0x296>
    PLL3_Clocks->PLL3_R_Frequency = 0U;
 8004808:	687b      	ldr	r3, [r7, #4]
 800480a:	2200      	movs	r2, #0
 800480c:	609a      	str	r2, [r3, #8]
}
 800480e:	bf00      	nop
 8004810:	3724      	adds	r7, #36	; 0x24
 8004812:	46bd      	mov	sp, r7
 8004814:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004818:	4770      	bx	lr
 800481a:	bf00      	nop
 800481c:	46020c00 	.word	0x46020c00
 8004820:	4b742400 	.word	0x4b742400
 8004824:	46000000 	.word	0x46000000
 8004828:	08017aac 	.word	0x08017aac

0800482c <HAL_RCCEx_GetPeriphCLKFreq>:
  * @retval Frequency in Hz
  *
  *        (*) value not defined in all devices.
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint64_t PeriphClk)
{
 800482c:	b580      	push	{r7, lr}
 800482e:	b08e      	sub	sp, #56	; 0x38
 8004830:	af00      	add	r7, sp, #0
 8004832:	e9c7 0100 	strd	r0, r1, [r7]
  uint32_t srcclk;

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));

  if (PeriphClk == RCC_PERIPHCLK_RTC)
 8004836:	e9d7 2300 	ldrd	r2, r3, [r7]
 800483a:	f5a2 2180 	sub.w	r1, r2, #262144	; 0x40000
 800483e:	430b      	orrs	r3, r1
 8004840:	d145      	bne.n	80048ce <HAL_RCCEx_GetPeriphCLKFreq+0xa2>
  {
    /* Get the current RTC source */
    srcclk = __HAL_RCC_GET_RTC_SOURCE();
 8004842:	4baa      	ldr	r3, [pc, #680]	; (8004aec <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 8004844:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8004848:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800484c:	633b      	str	r3, [r7, #48]	; 0x30

    /* Check if LSE is ready and if RTC clock selection is LSE */
    if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_RTCCLKSOURCE_LSE))
 800484e:	4ba7      	ldr	r3, [pc, #668]	; (8004aec <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 8004850:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8004854:	f003 0302 	and.w	r3, r3, #2
 8004858:	2b02      	cmp	r3, #2
 800485a:	d108      	bne.n	800486e <HAL_RCCEx_GetPeriphCLKFreq+0x42>
 800485c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800485e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8004862:	d104      	bne.n	800486e <HAL_RCCEx_GetPeriphCLKFreq+0x42>
    {
      frequency = LSE_VALUE;
 8004864:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8004868:	637b      	str	r3, [r7, #52]	; 0x34
 800486a:	f001 b987 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    /* Check if LSI is ready and if RTC clock selection is LSI */
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_RTCCLKSOURCE_LSI))
 800486e:	4b9f      	ldr	r3, [pc, #636]	; (8004aec <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 8004870:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8004874:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8004878:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800487c:	d114      	bne.n	80048a8 <HAL_RCCEx_GetPeriphCLKFreq+0x7c>
 800487e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004880:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8004884:	d110      	bne.n	80048a8 <HAL_RCCEx_GetPeriphCLKFreq+0x7c>
    {
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8004886:	4b99      	ldr	r3, [pc, #612]	; (8004aec <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 8004888:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 800488c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8004890:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8004894:	d103      	bne.n	800489e <HAL_RCCEx_GetPeriphCLKFreq+0x72>
      {
        frequency = LSI_VALUE / 128U;
 8004896:	23fa      	movs	r3, #250	; 0xfa
 8004898:	637b      	str	r3, [r7, #52]	; 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 800489a:	f001 b96f 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
      else
      {
        frequency = LSI_VALUE;
 800489e:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
 80048a2:	637b      	str	r3, [r7, #52]	; 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 80048a4:	f001 b96a 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
    }
    /* Check if HSE is ready  and if RTC clock selection is HSI_DIV32*/
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_RTCCLKSOURCE_HSE_DIV32))
 80048a8:	4b90      	ldr	r3, [pc, #576]	; (8004aec <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 80048aa:	681b      	ldr	r3, [r3, #0]
 80048ac:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80048b0:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 80048b4:	d107      	bne.n	80048c6 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
 80048b6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80048b8:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80048bc:	d103      	bne.n	80048c6 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
    {
      frequency = HSE_VALUE / 32U;
 80048be:	4b8c      	ldr	r3, [pc, #560]	; (8004af0 <HAL_RCCEx_GetPeriphCLKFreq+0x2c4>)
 80048c0:	637b      	str	r3, [r7, #52]	; 0x34
 80048c2:	f001 b95b 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    /* Clock not enabled for RTC*/
    else
    {
      frequency = 0U;
 80048c6:	2300      	movs	r3, #0
 80048c8:	637b      	str	r3, [r7, #52]	; 0x34
 80048ca:	f001 b957 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SAI1)
 80048ce:	e9d7 2300 	ldrd	r2, r3, [r7]
 80048d2:	f5a2 5100 	sub.w	r1, r2, #8192	; 0x2000
 80048d6:	430b      	orrs	r3, r1
 80048d8:	d151      	bne.n	800497e <HAL_RCCEx_GetPeriphCLKFreq+0x152>
  {
    srcclk = __HAL_RCC_GET_SAI1_SOURCE();
 80048da:	4b84      	ldr	r3, [pc, #528]	; (8004aec <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 80048dc:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 80048e0:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 80048e4:	633b      	str	r3, [r7, #48]	; 0x30

    switch (srcclk)
 80048e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80048e8:	2b80      	cmp	r3, #128	; 0x80
 80048ea:	d035      	beq.n	8004958 <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
 80048ec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80048ee:	2b80      	cmp	r3, #128	; 0x80
 80048f0:	d841      	bhi.n	8004976 <HAL_RCCEx_GetPeriphCLKFreq+0x14a>
 80048f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80048f4:	2b60      	cmp	r3, #96	; 0x60
 80048f6:	d02a      	beq.n	800494e <HAL_RCCEx_GetPeriphCLKFreq+0x122>
 80048f8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80048fa:	2b60      	cmp	r3, #96	; 0x60
 80048fc:	d83b      	bhi.n	8004976 <HAL_RCCEx_GetPeriphCLKFreq+0x14a>
 80048fe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004900:	2b40      	cmp	r3, #64	; 0x40
 8004902:	d009      	beq.n	8004918 <HAL_RCCEx_GetPeriphCLKFreq+0xec>
 8004904:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004906:	2b40      	cmp	r3, #64	; 0x40
 8004908:	d835      	bhi.n	8004976 <HAL_RCCEx_GetPeriphCLKFreq+0x14a>
 800490a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800490c:	2b00      	cmp	r3, #0
 800490e:	d00c      	beq.n	800492a <HAL_RCCEx_GetPeriphCLKFreq+0xfe>
 8004910:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004912:	2b20      	cmp	r3, #32
 8004914:	d012      	beq.n	800493c <HAL_RCCEx_GetPeriphCLKFreq+0x110>
 8004916:	e02e      	b.n	8004976 <HAL_RCCEx_GetPeriphCLKFreq+0x14a>
    {
      case RCC_SAI1CLKSOURCE_PLL1: /* PLL1P is the clock source for SAI1 */

        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8004918:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800491c:	4618      	mov	r0, r3
 800491e:	f7ff fb77 	bl	8004010 <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_P_Frequency;
 8004922:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004924:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8004926:	f001 b929 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2P is the clock source for SAI1 */

        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800492a:	f107 0318 	add.w	r3, r7, #24
 800492e:	4618      	mov	r0, r3
 8004930:	f7ff fcc8 	bl	80042c4 <HAL_RCCEx_GetPLL2ClockFreq>
        frequency = pll2_clocks.PLL2_P_Frequency;
 8004934:	69bb      	ldr	r3, [r7, #24]
 8004936:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8004938:	f001 b920 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_SAI1CLKSOURCE_PLL3: /* PLLI3P is the clock source for SAI1 */

        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800493c:	f107 030c 	add.w	r3, r7, #12
 8004940:	4618      	mov	r0, r3
 8004942:	f7ff fe19 	bl	8004578 <HAL_RCCEx_GetPLL3ClockFreq>
        frequency = pll3_clocks.PLL3_P_Frequency;
 8004946:	68fb      	ldr	r3, [r7, #12]
 8004948:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 800494a:	f001 b917 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_SAI1CLKSOURCE_PIN:

        frequency = EXTERNAL_SAI1_CLOCK_VALUE;
 800494e:	f64b 3380 	movw	r3, #48000	; 0xbb80
 8004952:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8004954:	f001 b912 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_SAI1CLKSOURCE_HSI: /* HSI is the clock source for SAI1 */

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8004958:	4b64      	ldr	r3, [pc, #400]	; (8004aec <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 800495a:	681b      	ldr	r3, [r3, #0]
 800495c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8004960:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8004964:	d103      	bne.n	800496e <HAL_RCCEx_GetPeriphCLKFreq+0x142>
        {
          frequency = HSI_VALUE;
 8004966:	4b63      	ldr	r3, [pc, #396]	; (8004af4 <HAL_RCCEx_GetPeriphCLKFreq+0x2c8>)
 8004968:	637b      	str	r3, [r7, #52]	; 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 800496a:	f001 b907 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
          frequency = 0U;
 800496e:	2300      	movs	r3, #0
 8004970:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8004972:	f001 b903 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      default :
      {
        frequency = 0U;
 8004976:	2300      	movs	r3, #0
 8004978:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 800497a:	f001 b8ff 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
    }
  }
#if defined(SAI2)
  else if (PeriphClk == RCC_PERIPHCLK_SAI2)
 800497e:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004982:	f5a2 4180 	sub.w	r1, r2, #16384	; 0x4000
 8004986:	430b      	orrs	r3, r1
 8004988:	d158      	bne.n	8004a3c <HAL_RCCEx_GetPeriphCLKFreq+0x210>
  {
    srcclk = __HAL_RCC_GET_SAI2_SOURCE();
 800498a:	4b58      	ldr	r3, [pc, #352]	; (8004aec <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 800498c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 8004990:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8004994:	633b      	str	r3, [r7, #48]	; 0x30

    switch (srcclk)
 8004996:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004998:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800499c:	d03b      	beq.n	8004a16 <HAL_RCCEx_GetPeriphCLKFreq+0x1ea>
 800499e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80049a0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80049a4:	d846      	bhi.n	8004a34 <HAL_RCCEx_GetPeriphCLKFreq+0x208>
 80049a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80049a8:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80049ac:	d02e      	beq.n	8004a0c <HAL_RCCEx_GetPeriphCLKFreq+0x1e0>
 80049ae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80049b0:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80049b4:	d83e      	bhi.n	8004a34 <HAL_RCCEx_GetPeriphCLKFreq+0x208>
 80049b6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80049b8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80049bc:	d00b      	beq.n	80049d6 <HAL_RCCEx_GetPeriphCLKFreq+0x1aa>
 80049be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80049c0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80049c4:	d836      	bhi.n	8004a34 <HAL_RCCEx_GetPeriphCLKFreq+0x208>
 80049c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80049c8:	2b00      	cmp	r3, #0
 80049ca:	d00d      	beq.n	80049e8 <HAL_RCCEx_GetPeriphCLKFreq+0x1bc>
 80049cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80049ce:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80049d2:	d012      	beq.n	80049fa <HAL_RCCEx_GetPeriphCLKFreq+0x1ce>
 80049d4:	e02e      	b.n	8004a34 <HAL_RCCEx_GetPeriphCLKFreq+0x208>
    {
      case RCC_SAI2CLKSOURCE_PLL1: /* PLL1P is the clock source for SAI1 */

        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 80049d6:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80049da:	4618      	mov	r0, r3
 80049dc:	f7ff fb18 	bl	8004010 <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_P_Frequency;
 80049e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80049e2:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 80049e4:	f001 b8ca 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_SAI2CLKSOURCE_PLL2: /* PLL2P is the clock source for SAI1 */

        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 80049e8:	f107 0318 	add.w	r3, r7, #24
 80049ec:	4618      	mov	r0, r3
 80049ee:	f7ff fc69 	bl	80042c4 <HAL_RCCEx_GetPLL2ClockFreq>
        frequency = pll2_clocks.PLL2_P_Frequency;
 80049f2:	69bb      	ldr	r3, [r7, #24]
 80049f4:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 80049f6:	f001 b8c1 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_SAI2CLKSOURCE_PLL3: /* PLLI3P is the clock source for SAI1 */

        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 80049fa:	f107 030c 	add.w	r3, r7, #12
 80049fe:	4618      	mov	r0, r3
 8004a00:	f7ff fdba 	bl	8004578 <HAL_RCCEx_GetPLL3ClockFreq>
        frequency = pll3_clocks.PLL3_P_Frequency;
 8004a04:	68fb      	ldr	r3, [r7, #12]
 8004a06:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8004a08:	f001 b8b8 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_SAI2CLKSOURCE_PIN:

        frequency = EXTERNAL_SAI1_CLOCK_VALUE;
 8004a0c:	f64b 3380 	movw	r3, #48000	; 0xbb80
 8004a10:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8004a12:	f001 b8b3 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_SAI2CLKSOURCE_HSI: /* HSI is the clock source for SAI1 */

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8004a16:	4b35      	ldr	r3, [pc, #212]	; (8004aec <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 8004a18:	681b      	ldr	r3, [r3, #0]
 8004a1a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8004a1e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8004a22:	d103      	bne.n	8004a2c <HAL_RCCEx_GetPeriphCLKFreq+0x200>
        {
          frequency = HSI_VALUE;
 8004a24:	4b33      	ldr	r3, [pc, #204]	; (8004af4 <HAL_RCCEx_GetPeriphCLKFreq+0x2c8>)
 8004a26:	637b      	str	r3, [r7, #52]	; 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8004a28:	f001 b8a8 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
          frequency = 0U;
 8004a2c:	2300      	movs	r3, #0
 8004a2e:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8004a30:	f001 b8a4 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      default :

        frequency = 0U;
 8004a34:	2300      	movs	r3, #0
 8004a36:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8004a38:	f001 b8a0 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    {
      frequency = 0U;
    }
  }
#endif /* SAES */
  else if (PeriphClk == RCC_PERIPHCLK_ICLK)
 8004a3c:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004a40:	f5a2 1180 	sub.w	r1, r2, #1048576	; 0x100000
 8004a44:	430b      	orrs	r3, r1
 8004a46:	d16e      	bne.n	8004b26 <HAL_RCCEx_GetPeriphCLKFreq+0x2fa>
  {
    srcclk = __HAL_RCC_GET_ICLK_SOURCE();
 8004a48:	4b28      	ldr	r3, [pc, #160]	; (8004aec <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 8004a4a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004a4e:	f003 6340 	and.w	r3, r3, #201326592	; 0xc000000
 8004a52:	633b      	str	r3, [r7, #48]	; 0x30

    switch (srcclk)
 8004a54:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004a56:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
 8004a5a:	d034      	beq.n	8004ac6 <HAL_RCCEx_GetPeriphCLKFreq+0x29a>
 8004a5c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004a5e:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
 8004a62:	d85c      	bhi.n	8004b1e <HAL_RCCEx_GetPeriphCLKFreq+0x2f2>
 8004a64:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004a66:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8004a6a:	d00b      	beq.n	8004a84 <HAL_RCCEx_GetPeriphCLKFreq+0x258>
 8004a6c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004a6e:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8004a72:	d854      	bhi.n	8004b1e <HAL_RCCEx_GetPeriphCLKFreq+0x2f2>
 8004a74:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004a76:	2b00      	cmp	r3, #0
 8004a78:	d016      	beq.n	8004aa8 <HAL_RCCEx_GetPeriphCLKFreq+0x27c>
 8004a7a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004a7c:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8004a80:	d009      	beq.n	8004a96 <HAL_RCCEx_GetPeriphCLKFreq+0x26a>
 8004a82:	e04c      	b.n	8004b1e <HAL_RCCEx_GetPeriphCLKFreq+0x2f2>
    {
      case RCC_ICLK_CLKSOURCE_PLL1: /* PLL1Q  */

        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8004a84:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8004a88:	4618      	mov	r0, r3
 8004a8a:	f7ff fac1 	bl	8004010 <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_Q_Frequency;
 8004a8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004a90:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8004a92:	f001 b873 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_ICLK_CLKSOURCE_PLL2: /* PLL2Q */

        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8004a96:	f107 0318 	add.w	r3, r7, #24
 8004a9a:	4618      	mov	r0, r3
 8004a9c:	f7ff fc12 	bl	80042c4 <HAL_RCCEx_GetPLL2ClockFreq>
        frequency = pll2_clocks.PLL2_Q_Frequency;
 8004aa0:	69fb      	ldr	r3, [r7, #28]
 8004aa2:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8004aa4:	f001 b86a 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_ICLK_CLKSOURCE_HSI48: /* HSI48 */

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY))
 8004aa8:	4b10      	ldr	r3, [pc, #64]	; (8004aec <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 8004aaa:	681b      	ldr	r3, [r3, #0]
 8004aac:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8004ab0:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8004ab4:	d103      	bne.n	8004abe <HAL_RCCEx_GetPeriphCLKFreq+0x292>
        {
          frequency = HSI48_VALUE;
 8004ab6:	4b10      	ldr	r3, [pc, #64]	; (8004af8 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
 8004ab8:	637b      	str	r3, [r7, #52]	; 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8004aba:	f001 b85f 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
          frequency = 0U;
 8004abe:	2300      	movs	r3, #0
 8004ac0:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8004ac2:	f001 b85b 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_ICLK_CLKSOURCE_MSIK: /* MSIK frequency range in HZ */

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8004ac6:	4b09      	ldr	r3, [pc, #36]	; (8004aec <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 8004ac8:	681b      	ldr	r3, [r3, #0]
 8004aca:	f003 0320 	and.w	r3, r3, #32
 8004ace:	2b20      	cmp	r3, #32
 8004ad0:	d121      	bne.n	8004b16 <HAL_RCCEx_GetPeriphCLKFreq+0x2ea>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8004ad2:	4b06      	ldr	r3, [pc, #24]	; (8004aec <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 8004ad4:	689b      	ldr	r3, [r3, #8]
 8004ad6:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8004ada:	2b00      	cmp	r3, #0
 8004adc:	d00e      	beq.n	8004afc <HAL_RCCEx_GetPeriphCLKFreq+0x2d0>
 8004ade:	4b03      	ldr	r3, [pc, #12]	; (8004aec <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 8004ae0:	689b      	ldr	r3, [r3, #8]
 8004ae2:	0e1b      	lsrs	r3, r3, #24
 8004ae4:	f003 030f 	and.w	r3, r3, #15
 8004ae8:	e00f      	b.n	8004b0a <HAL_RCCEx_GetPeriphCLKFreq+0x2de>
 8004aea:	bf00      	nop
 8004aec:	46020c00 	.word	0x46020c00
 8004af0:	0007a120 	.word	0x0007a120
 8004af4:	00f42400 	.word	0x00f42400
 8004af8:	02dc6c00 	.word	0x02dc6c00
 8004afc:	4ba7      	ldr	r3, [pc, #668]	; (8004d9c <HAL_RCCEx_GetPeriphCLKFreq+0x570>)
 8004afe:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8004b02:	041b      	lsls	r3, r3, #16
 8004b04:	0e1b      	lsrs	r3, r3, #24
 8004b06:	f003 030f 	and.w	r3, r3, #15
 8004b0a:	4aa5      	ldr	r2, [pc, #660]	; (8004da0 <HAL_RCCEx_GetPeriphCLKFreq+0x574>)
 8004b0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004b10:	637b      	str	r3, [r7, #52]	; 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8004b12:	f001 b833 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
          frequency = 0U;
 8004b16:	2300      	movs	r3, #0
 8004b18:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8004b1a:	f001 b82f 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      default :

        frequency = 0U;
 8004b1e:	2300      	movs	r3, #0
 8004b20:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8004b22:	f001 b82b 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
 8004b26:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004b2a:	f5a2 1100 	sub.w	r1, r2, #2097152	; 0x200000
 8004b2e:	430b      	orrs	r3, r1
 8004b30:	d17f      	bne.n	8004c32 <HAL_RCCEx_GetPeriphCLKFreq+0x406>
  {
    srcclk = __HAL_RCC_GET_SDMMC_SOURCE();
 8004b32:	4b9a      	ldr	r3, [pc, #616]	; (8004d9c <HAL_RCCEx_GetPeriphCLKFreq+0x570>)
 8004b34:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 8004b38:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8004b3c:	633b      	str	r3, [r7, #48]	; 0x30
    if (srcclk == RCC_SDMMCCLKSOURCE_CLK48)
 8004b3e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004b40:	2b00      	cmp	r3, #0
 8004b42:	d165      	bne.n	8004c10 <HAL_RCCEx_GetPeriphCLKFreq+0x3e4>
    {
      srcclk = __HAL_RCC_GET_ICLK_SOURCE();
 8004b44:	4b95      	ldr	r3, [pc, #596]	; (8004d9c <HAL_RCCEx_GetPeriphCLKFreq+0x570>)
 8004b46:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004b4a:	f003 6340 	and.w	r3, r3, #201326592	; 0xc000000
 8004b4e:	633b      	str	r3, [r7, #48]	; 0x30

      switch (srcclk)
 8004b50:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004b52:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
 8004b56:	d034      	beq.n	8004bc2 <HAL_RCCEx_GetPeriphCLKFreq+0x396>
 8004b58:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004b5a:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
 8004b5e:	d853      	bhi.n	8004c08 <HAL_RCCEx_GetPeriphCLKFreq+0x3dc>
 8004b60:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004b62:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8004b66:	d00b      	beq.n	8004b80 <HAL_RCCEx_GetPeriphCLKFreq+0x354>
 8004b68:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004b6a:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8004b6e:	d84b      	bhi.n	8004c08 <HAL_RCCEx_GetPeriphCLKFreq+0x3dc>
 8004b70:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004b72:	2b00      	cmp	r3, #0
 8004b74:	d016      	beq.n	8004ba4 <HAL_RCCEx_GetPeriphCLKFreq+0x378>
 8004b76:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004b78:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8004b7c:	d009      	beq.n	8004b92 <HAL_RCCEx_GetPeriphCLKFreq+0x366>
 8004b7e:	e043      	b.n	8004c08 <HAL_RCCEx_GetPeriphCLKFreq+0x3dc>
      {
        case RCC_ICLK_CLKSOURCE_PLL1: /* PLL1Q  */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8004b80:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8004b84:	4618      	mov	r0, r3
 8004b86:	f7ff fa43 	bl	8004010 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 8004b8a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004b8c:	637b      	str	r3, [r7, #52]	; 0x34
          break;
 8004b8e:	f000 bff5 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
        }
        case RCC_ICLK_CLKSOURCE_PLL2: /* PLL2Q */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8004b92:	f107 0318 	add.w	r3, r7, #24
 8004b96:	4618      	mov	r0, r3
 8004b98:	f7ff fb94 	bl	80042c4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8004b9c:	69fb      	ldr	r3, [r7, #28]
 8004b9e:	637b      	str	r3, [r7, #52]	; 0x34
          break;
 8004ba0:	f000 bfec 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
        }
        case RCC_ICLK_CLKSOURCE_HSI48: /* HSI48 */
        {
          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY))
 8004ba4:	4b7d      	ldr	r3, [pc, #500]	; (8004d9c <HAL_RCCEx_GetPeriphCLKFreq+0x570>)
 8004ba6:	681b      	ldr	r3, [r3, #0]
 8004ba8:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8004bac:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8004bb0:	d103      	bne.n	8004bba <HAL_RCCEx_GetPeriphCLKFreq+0x38e>
          {
            frequency = HSI48_VALUE;
 8004bb2:	4b7c      	ldr	r3, [pc, #496]	; (8004da4 <HAL_RCCEx_GetPeriphCLKFreq+0x578>)
 8004bb4:	637b      	str	r3, [r7, #52]	; 0x34
          }
          else
          {
            frequency = 0U;
          }
          break;
 8004bb6:	f000 bfe1 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
            frequency = 0U;
 8004bba:	2300      	movs	r3, #0
 8004bbc:	637b      	str	r3, [r7, #52]	; 0x34
          break;
 8004bbe:	f000 bfdd 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
        }
        case RCC_ICLK_CLKSOURCE_MSIK: /* MSIK frequency range in HZ */
        {
          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8004bc2:	4b76      	ldr	r3, [pc, #472]	; (8004d9c <HAL_RCCEx_GetPeriphCLKFreq+0x570>)
 8004bc4:	681b      	ldr	r3, [r3, #0]
 8004bc6:	f003 0320 	and.w	r3, r3, #32
 8004bca:	2b20      	cmp	r3, #32
 8004bcc:	d118      	bne.n	8004c00 <HAL_RCCEx_GetPeriphCLKFreq+0x3d4>
          {
            frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8004bce:	4b73      	ldr	r3, [pc, #460]	; (8004d9c <HAL_RCCEx_GetPeriphCLKFreq+0x570>)
 8004bd0:	689b      	ldr	r3, [r3, #8]
 8004bd2:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8004bd6:	2b00      	cmp	r3, #0
 8004bd8:	d005      	beq.n	8004be6 <HAL_RCCEx_GetPeriphCLKFreq+0x3ba>
 8004bda:	4b70      	ldr	r3, [pc, #448]	; (8004d9c <HAL_RCCEx_GetPeriphCLKFreq+0x570>)
 8004bdc:	689b      	ldr	r3, [r3, #8]
 8004bde:	0e1b      	lsrs	r3, r3, #24
 8004be0:	f003 030f 	and.w	r3, r3, #15
 8004be4:	e006      	b.n	8004bf4 <HAL_RCCEx_GetPeriphCLKFreq+0x3c8>
 8004be6:	4b6d      	ldr	r3, [pc, #436]	; (8004d9c <HAL_RCCEx_GetPeriphCLKFreq+0x570>)
 8004be8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8004bec:	041b      	lsls	r3, r3, #16
 8004bee:	0e1b      	lsrs	r3, r3, #24
 8004bf0:	f003 030f 	and.w	r3, r3, #15
 8004bf4:	4a6a      	ldr	r2, [pc, #424]	; (8004da0 <HAL_RCCEx_GetPeriphCLKFreq+0x574>)
 8004bf6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004bfa:	637b      	str	r3, [r7, #52]	; 0x34
          }
          else
          {
            frequency = 0U;
          }
          break;
 8004bfc:	f000 bfbe 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
            frequency = 0U;
 8004c00:	2300      	movs	r3, #0
 8004c02:	637b      	str	r3, [r7, #52]	; 0x34
          break;
 8004c04:	f000 bfba 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
        }
        default :
        {
          frequency = 0U;
 8004c08:	2300      	movs	r3, #0
 8004c0a:	637b      	str	r3, [r7, #52]	; 0x34
          break;
 8004c0c:	f000 bfb6 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
        }
      }
    }
    else if (srcclk == RCC_SDMMCCLKSOURCE_PLL1)
 8004c10:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004c12:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8004c16:	d108      	bne.n	8004c2a <HAL_RCCEx_GetPeriphCLKFreq+0x3fe>
    {
      HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8004c18:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8004c1c:	4618      	mov	r0, r3
 8004c1e:	f7ff f9f7 	bl	8004010 <HAL_RCCEx_GetPLL1ClockFreq>
      frequency = pll1_clocks.PLL1_P_Frequency;
 8004c22:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004c24:	637b      	str	r3, [r7, #52]	; 0x34
 8004c26:	f000 bfa9 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else
    {
      frequency = 0U;
 8004c2a:	2300      	movs	r3, #0
 8004c2c:	637b      	str	r3, [r7, #52]	; 0x34
 8004c2e:	f000 bfa5 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_USART1)
 8004c32:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004c36:	1e51      	subs	r1, r2, #1
 8004c38:	430b      	orrs	r3, r1
 8004c3a:	d136      	bne.n	8004caa <HAL_RCCEx_GetPeriphCLKFreq+0x47e>
  {
    /* Get the current USART1 source */
    srcclk = __HAL_RCC_GET_USART1_SOURCE();
 8004c3c:	4b57      	ldr	r3, [pc, #348]	; (8004d9c <HAL_RCCEx_GetPeriphCLKFreq+0x570>)
 8004c3e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004c42:	f003 0303 	and.w	r3, r3, #3
 8004c46:	633b      	str	r3, [r7, #48]	; 0x30

    if (srcclk == RCC_USART1CLKSOURCE_PCLK2)
 8004c48:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004c4a:	2b00      	cmp	r3, #0
 8004c4c:	d104      	bne.n	8004c58 <HAL_RCCEx_GetPeriphCLKFreq+0x42c>
    {
      frequency = HAL_RCC_GetPCLK2Freq();
 8004c4e:	f7fe fb55 	bl	80032fc <HAL_RCC_GetPCLK2Freq>
 8004c52:	6378      	str	r0, [r7, #52]	; 0x34
 8004c54:	f000 bf92 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if (srcclk == RCC_USART1CLKSOURCE_SYSCLK)
 8004c58:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004c5a:	2b01      	cmp	r3, #1
 8004c5c:	d104      	bne.n	8004c68 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8004c5e:	f7fe fa1d 	bl	800309c <HAL_RCC_GetSysClockFreq>
 8004c62:	6378      	str	r0, [r7, #52]	; 0x34
 8004c64:	f000 bf8a 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART1CLKSOURCE_HSI))
 8004c68:	4b4c      	ldr	r3, [pc, #304]	; (8004d9c <HAL_RCCEx_GetPeriphCLKFreq+0x570>)
 8004c6a:	681b      	ldr	r3, [r3, #0]
 8004c6c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8004c70:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8004c74:	d106      	bne.n	8004c84 <HAL_RCCEx_GetPeriphCLKFreq+0x458>
 8004c76:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004c78:	2b02      	cmp	r3, #2
 8004c7a:	d103      	bne.n	8004c84 <HAL_RCCEx_GetPeriphCLKFreq+0x458>
    {
      frequency = HSI_VALUE;
 8004c7c:	4b4a      	ldr	r3, [pc, #296]	; (8004da8 <HAL_RCCEx_GetPeriphCLKFreq+0x57c>)
 8004c7e:	637b      	str	r3, [r7, #52]	; 0x34
 8004c80:	f000 bf7c 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART1CLKSOURCE_LSE))
 8004c84:	4b45      	ldr	r3, [pc, #276]	; (8004d9c <HAL_RCCEx_GetPeriphCLKFreq+0x570>)
 8004c86:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8004c8a:	f003 0302 	and.w	r3, r3, #2
 8004c8e:	2b02      	cmp	r3, #2
 8004c90:	d107      	bne.n	8004ca2 <HAL_RCCEx_GetPeriphCLKFreq+0x476>
 8004c92:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004c94:	2b03      	cmp	r3, #3
 8004c96:	d104      	bne.n	8004ca2 <HAL_RCCEx_GetPeriphCLKFreq+0x476>
    {
      frequency = LSE_VALUE;
 8004c98:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8004c9c:	637b      	str	r3, [r7, #52]	; 0x34
 8004c9e:	f000 bf6d 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    /* Clock not enabled for USART1 */
    else
    {
      frequency = 0U;
 8004ca2:	2300      	movs	r3, #0
 8004ca4:	637b      	str	r3, [r7, #52]	; 0x34
 8004ca6:	f000 bf69 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
  }
#if defined(USART2)
  else if (PeriphClk == RCC_PERIPHCLK_USART2)
 8004caa:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004cae:	1e91      	subs	r1, r2, #2
 8004cb0:	430b      	orrs	r3, r1
 8004cb2:	d136      	bne.n	8004d22 <HAL_RCCEx_GetPeriphCLKFreq+0x4f6>
  {
    /* Get the current USART2 source */
    srcclk = __HAL_RCC_GET_USART2_SOURCE();
 8004cb4:	4b39      	ldr	r3, [pc, #228]	; (8004d9c <HAL_RCCEx_GetPeriphCLKFreq+0x570>)
 8004cb6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004cba:	f003 030c 	and.w	r3, r3, #12
 8004cbe:	633b      	str	r3, [r7, #48]	; 0x30

    if (srcclk == RCC_USART2CLKSOURCE_PCLK1)
 8004cc0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004cc2:	2b00      	cmp	r3, #0
 8004cc4:	d104      	bne.n	8004cd0 <HAL_RCCEx_GetPeriphCLKFreq+0x4a4>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 8004cc6:	f7fe fb05 	bl	80032d4 <HAL_RCC_GetPCLK1Freq>
 8004cca:	6378      	str	r0, [r7, #52]	; 0x34
 8004ccc:	f000 bf56 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if (srcclk == RCC_USART2CLKSOURCE_SYSCLK)
 8004cd0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004cd2:	2b04      	cmp	r3, #4
 8004cd4:	d104      	bne.n	8004ce0 <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8004cd6:	f7fe f9e1 	bl	800309c <HAL_RCC_GetSysClockFreq>
 8004cda:	6378      	str	r0, [r7, #52]	; 0x34
 8004cdc:	f000 bf4e 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART2CLKSOURCE_HSI))
 8004ce0:	4b2e      	ldr	r3, [pc, #184]	; (8004d9c <HAL_RCCEx_GetPeriphCLKFreq+0x570>)
 8004ce2:	681b      	ldr	r3, [r3, #0]
 8004ce4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8004ce8:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8004cec:	d106      	bne.n	8004cfc <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
 8004cee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004cf0:	2b08      	cmp	r3, #8
 8004cf2:	d103      	bne.n	8004cfc <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
    {
      frequency = HSI_VALUE;
 8004cf4:	4b2c      	ldr	r3, [pc, #176]	; (8004da8 <HAL_RCCEx_GetPeriphCLKFreq+0x57c>)
 8004cf6:	637b      	str	r3, [r7, #52]	; 0x34
 8004cf8:	f000 bf40 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART2CLKSOURCE_LSE))
 8004cfc:	4b27      	ldr	r3, [pc, #156]	; (8004d9c <HAL_RCCEx_GetPeriphCLKFreq+0x570>)
 8004cfe:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8004d02:	f003 0302 	and.w	r3, r3, #2
 8004d06:	2b02      	cmp	r3, #2
 8004d08:	d107      	bne.n	8004d1a <HAL_RCCEx_GetPeriphCLKFreq+0x4ee>
 8004d0a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004d0c:	2b0c      	cmp	r3, #12
 8004d0e:	d104      	bne.n	8004d1a <HAL_RCCEx_GetPeriphCLKFreq+0x4ee>
    {
      frequency = LSE_VALUE;
 8004d10:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8004d14:	637b      	str	r3, [r7, #52]	; 0x34
 8004d16:	f000 bf31 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    /* Clock not enabled for USART2 */
    else
    {
      frequency = 0U;
 8004d1a:	2300      	movs	r3, #0
 8004d1c:	637b      	str	r3, [r7, #52]	; 0x34
 8004d1e:	f000 bf2d 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
  }
#endif /* USART2 */
  else if (PeriphClk == RCC_PERIPHCLK_USART3)
 8004d22:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004d26:	1f11      	subs	r1, r2, #4
 8004d28:	430b      	orrs	r3, r1
 8004d2a:	d13f      	bne.n	8004dac <HAL_RCCEx_GetPeriphCLKFreq+0x580>
  {
    /* Get the current USART3 source */
    srcclk = __HAL_RCC_GET_USART3_SOURCE();
 8004d2c:	4b1b      	ldr	r3, [pc, #108]	; (8004d9c <HAL_RCCEx_GetPeriphCLKFreq+0x570>)
 8004d2e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004d32:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8004d36:	633b      	str	r3, [r7, #48]	; 0x30

    if (srcclk == RCC_USART3CLKSOURCE_PCLK1)
 8004d38:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004d3a:	2b00      	cmp	r3, #0
 8004d3c:	d104      	bne.n	8004d48 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 8004d3e:	f7fe fac9 	bl	80032d4 <HAL_RCC_GetPCLK1Freq>
 8004d42:	6378      	str	r0, [r7, #52]	; 0x34
 8004d44:	f000 bf1a 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if (srcclk == RCC_USART3CLKSOURCE_SYSCLK)
 8004d48:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004d4a:	2b10      	cmp	r3, #16
 8004d4c:	d104      	bne.n	8004d58 <HAL_RCCEx_GetPeriphCLKFreq+0x52c>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8004d4e:	f7fe f9a5 	bl	800309c <HAL_RCC_GetSysClockFreq>
 8004d52:	6378      	str	r0, [r7, #52]	; 0x34
 8004d54:	f000 bf12 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART3CLKSOURCE_HSI))
 8004d58:	4b10      	ldr	r3, [pc, #64]	; (8004d9c <HAL_RCCEx_GetPeriphCLKFreq+0x570>)
 8004d5a:	681b      	ldr	r3, [r3, #0]
 8004d5c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8004d60:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8004d64:	d106      	bne.n	8004d74 <HAL_RCCEx_GetPeriphCLKFreq+0x548>
 8004d66:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004d68:	2b20      	cmp	r3, #32
 8004d6a:	d103      	bne.n	8004d74 <HAL_RCCEx_GetPeriphCLKFreq+0x548>
    {
      frequency = HSI_VALUE;
 8004d6c:	4b0e      	ldr	r3, [pc, #56]	; (8004da8 <HAL_RCCEx_GetPeriphCLKFreq+0x57c>)
 8004d6e:	637b      	str	r3, [r7, #52]	; 0x34
 8004d70:	f000 bf04 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART3CLKSOURCE_LSE))
 8004d74:	4b09      	ldr	r3, [pc, #36]	; (8004d9c <HAL_RCCEx_GetPeriphCLKFreq+0x570>)
 8004d76:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8004d7a:	f003 0302 	and.w	r3, r3, #2
 8004d7e:	2b02      	cmp	r3, #2
 8004d80:	d107      	bne.n	8004d92 <HAL_RCCEx_GetPeriphCLKFreq+0x566>
 8004d82:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004d84:	2b30      	cmp	r3, #48	; 0x30
 8004d86:	d104      	bne.n	8004d92 <HAL_RCCEx_GetPeriphCLKFreq+0x566>
    {
      frequency = LSE_VALUE;
 8004d88:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8004d8c:	637b      	str	r3, [r7, #52]	; 0x34
 8004d8e:	f000 bef5 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    /* Clock not enabled for USART3 */
    else
    {
      frequency = 0U;
 8004d92:	2300      	movs	r3, #0
 8004d94:	637b      	str	r3, [r7, #52]	; 0x34
 8004d96:	f000 bef1 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
 8004d9a:	bf00      	nop
 8004d9c:	46020c00 	.word	0x46020c00
 8004da0:	08017aac 	.word	0x08017aac
 8004da4:	02dc6c00 	.word	0x02dc6c00
 8004da8:	00f42400 	.word	0x00f42400
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_UART4)
 8004dac:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004db0:	f1a2 0108 	sub.w	r1, r2, #8
 8004db4:	430b      	orrs	r3, r1
 8004db6:	d136      	bne.n	8004e26 <HAL_RCCEx_GetPeriphCLKFreq+0x5fa>
  {
    /* Get the current UART4 source */
    srcclk = __HAL_RCC_GET_UART4_SOURCE();
 8004db8:	4ba4      	ldr	r3, [pc, #656]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8004dba:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004dbe:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 8004dc2:	633b      	str	r3, [r7, #48]	; 0x30

    if (srcclk == RCC_UART4CLKSOURCE_PCLK1)
 8004dc4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004dc6:	2b00      	cmp	r3, #0
 8004dc8:	d104      	bne.n	8004dd4 <HAL_RCCEx_GetPeriphCLKFreq+0x5a8>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 8004dca:	f7fe fa83 	bl	80032d4 <HAL_RCC_GetPCLK1Freq>
 8004dce:	6378      	str	r0, [r7, #52]	; 0x34
 8004dd0:	f000 bed4 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if (srcclk == RCC_UART4CLKSOURCE_SYSCLK)
 8004dd4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004dd6:	2b40      	cmp	r3, #64	; 0x40
 8004dd8:	d104      	bne.n	8004de4 <HAL_RCCEx_GetPeriphCLKFreq+0x5b8>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8004dda:	f7fe f95f 	bl	800309c <HAL_RCC_GetSysClockFreq>
 8004dde:	6378      	str	r0, [r7, #52]	; 0x34
 8004de0:	f000 becc 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART4CLKSOURCE_HSI))
 8004de4:	4b99      	ldr	r3, [pc, #612]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8004de6:	681b      	ldr	r3, [r3, #0]
 8004de8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8004dec:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8004df0:	d106      	bne.n	8004e00 <HAL_RCCEx_GetPeriphCLKFreq+0x5d4>
 8004df2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004df4:	2b80      	cmp	r3, #128	; 0x80
 8004df6:	d103      	bne.n	8004e00 <HAL_RCCEx_GetPeriphCLKFreq+0x5d4>
    {
      frequency = HSI_VALUE;
 8004df8:	4b95      	ldr	r3, [pc, #596]	; (8005050 <HAL_RCCEx_GetPeriphCLKFreq+0x824>)
 8004dfa:	637b      	str	r3, [r7, #52]	; 0x34
 8004dfc:	f000 bebe 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART4CLKSOURCE_LSE))
 8004e00:	4b92      	ldr	r3, [pc, #584]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8004e02:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8004e06:	f003 0302 	and.w	r3, r3, #2
 8004e0a:	2b02      	cmp	r3, #2
 8004e0c:	d107      	bne.n	8004e1e <HAL_RCCEx_GetPeriphCLKFreq+0x5f2>
 8004e0e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004e10:	2bc0      	cmp	r3, #192	; 0xc0
 8004e12:	d104      	bne.n	8004e1e <HAL_RCCEx_GetPeriphCLKFreq+0x5f2>
    {
      frequency = LSE_VALUE;
 8004e14:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8004e18:	637b      	str	r3, [r7, #52]	; 0x34
 8004e1a:	f000 beaf 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    /* Clock not enabled for UART4 */
    else
    {
      frequency = 0U;
 8004e1e:	2300      	movs	r3, #0
 8004e20:	637b      	str	r3, [r7, #52]	; 0x34
 8004e22:	f000 beab 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_UART5)
 8004e26:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004e2a:	f1a2 0110 	sub.w	r1, r2, #16
 8004e2e:	430b      	orrs	r3, r1
 8004e30:	d139      	bne.n	8004ea6 <HAL_RCCEx_GetPeriphCLKFreq+0x67a>
  {
    /* Get the current UART5 source */
    srcclk = __HAL_RCC_GET_UART5_SOURCE();
 8004e32:	4b86      	ldr	r3, [pc, #536]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8004e34:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004e38:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8004e3c:	633b      	str	r3, [r7, #48]	; 0x30

    if (srcclk == RCC_UART5CLKSOURCE_PCLK1)
 8004e3e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004e40:	2b00      	cmp	r3, #0
 8004e42:	d104      	bne.n	8004e4e <HAL_RCCEx_GetPeriphCLKFreq+0x622>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 8004e44:	f7fe fa46 	bl	80032d4 <HAL_RCC_GetPCLK1Freq>
 8004e48:	6378      	str	r0, [r7, #52]	; 0x34
 8004e4a:	f000 be97 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if (srcclk == RCC_UART5CLKSOURCE_SYSCLK)
 8004e4e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004e50:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8004e54:	d104      	bne.n	8004e60 <HAL_RCCEx_GetPeriphCLKFreq+0x634>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8004e56:	f7fe f921 	bl	800309c <HAL_RCC_GetSysClockFreq>
 8004e5a:	6378      	str	r0, [r7, #52]	; 0x34
 8004e5c:	f000 be8e 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART5CLKSOURCE_HSI))
 8004e60:	4b7a      	ldr	r3, [pc, #488]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8004e62:	681b      	ldr	r3, [r3, #0]
 8004e64:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8004e68:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8004e6c:	d107      	bne.n	8004e7e <HAL_RCCEx_GetPeriphCLKFreq+0x652>
 8004e6e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004e70:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8004e74:	d103      	bne.n	8004e7e <HAL_RCCEx_GetPeriphCLKFreq+0x652>
    {
      frequency = HSI_VALUE;
 8004e76:	4b76      	ldr	r3, [pc, #472]	; (8005050 <HAL_RCCEx_GetPeriphCLKFreq+0x824>)
 8004e78:	637b      	str	r3, [r7, #52]	; 0x34
 8004e7a:	f000 be7f 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART5CLKSOURCE_LSE))
 8004e7e:	4b73      	ldr	r3, [pc, #460]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8004e80:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8004e84:	f003 0302 	and.w	r3, r3, #2
 8004e88:	2b02      	cmp	r3, #2
 8004e8a:	d108      	bne.n	8004e9e <HAL_RCCEx_GetPeriphCLKFreq+0x672>
 8004e8c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004e8e:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8004e92:	d104      	bne.n	8004e9e <HAL_RCCEx_GetPeriphCLKFreq+0x672>
    {
      frequency = LSE_VALUE;
 8004e94:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8004e98:	637b      	str	r3, [r7, #52]	; 0x34
 8004e9a:	f000 be6f 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    /* Clock not enabled for UART5 */
    else
    {
      frequency = 0U;
 8004e9e:	2300      	movs	r3, #0
 8004ea0:	637b      	str	r3, [r7, #52]	; 0x34
 8004ea2:	f000 be6b 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    {
      frequency = 0U;
    }
  }
#endif /* USART6 */
  else if (PeriphClk == RCC_PERIPHCLK_LPUART1)
 8004ea6:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004eaa:	f1a2 0120 	sub.w	r1, r2, #32
 8004eae:	430b      	orrs	r3, r1
 8004eb0:	d158      	bne.n	8004f64 <HAL_RCCEx_GetPeriphCLKFreq+0x738>
  {
    /* Get the current LPUART1 source */
    srcclk = __HAL_RCC_GET_LPUART1_SOURCE();
 8004eb2:	4b66      	ldr	r3, [pc, #408]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8004eb4:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8004eb8:	f003 0307 	and.w	r3, r3, #7
 8004ebc:	633b      	str	r3, [r7, #48]	; 0x30

    if (srcclk == RCC_LPUART1CLKSOURCE_PCLK3)
 8004ebe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004ec0:	2b00      	cmp	r3, #0
 8004ec2:	d104      	bne.n	8004ece <HAL_RCCEx_GetPeriphCLKFreq+0x6a2>
    {
      frequency = HAL_RCC_GetPCLK3Freq();
 8004ec4:	f7fe fa2e 	bl	8003324 <HAL_RCC_GetPCLK3Freq>
 8004ec8:	6378      	str	r0, [r7, #52]	; 0x34
 8004eca:	f000 be57 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if (srcclk == RCC_LPUART1CLKSOURCE_SYSCLK)
 8004ece:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004ed0:	2b01      	cmp	r3, #1
 8004ed2:	d104      	bne.n	8004ede <HAL_RCCEx_GetPeriphCLKFreq+0x6b2>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8004ed4:	f7fe f8e2 	bl	800309c <HAL_RCC_GetSysClockFreq>
 8004ed8:	6378      	str	r0, [r7, #52]	; 0x34
 8004eda:	f000 be4f 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPUART1CLKSOURCE_HSI))
 8004ede:	4b5b      	ldr	r3, [pc, #364]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8004ee0:	681b      	ldr	r3, [r3, #0]
 8004ee2:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8004ee6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8004eea:	d106      	bne.n	8004efa <HAL_RCCEx_GetPeriphCLKFreq+0x6ce>
 8004eec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004eee:	2b02      	cmp	r3, #2
 8004ef0:	d103      	bne.n	8004efa <HAL_RCCEx_GetPeriphCLKFreq+0x6ce>
    {
      frequency = HSI_VALUE;
 8004ef2:	4b57      	ldr	r3, [pc, #348]	; (8005050 <HAL_RCCEx_GetPeriphCLKFreq+0x824>)
 8004ef4:	637b      	str	r3, [r7, #52]	; 0x34
 8004ef6:	f000 be41 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPUART1CLKSOURCE_LSE))
 8004efa:	4b54      	ldr	r3, [pc, #336]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8004efc:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8004f00:	f003 0302 	and.w	r3, r3, #2
 8004f04:	2b02      	cmp	r3, #2
 8004f06:	d107      	bne.n	8004f18 <HAL_RCCEx_GetPeriphCLKFreq+0x6ec>
 8004f08:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004f0a:	2b03      	cmp	r3, #3
 8004f0c:	d104      	bne.n	8004f18 <HAL_RCCEx_GetPeriphCLKFreq+0x6ec>
    {
      frequency = LSE_VALUE;
 8004f0e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8004f12:	637b      	str	r3, [r7, #52]	; 0x34
 8004f14:	f000 be32 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_LPUART1CLKSOURCE_MSIK))
 8004f18:	4b4c      	ldr	r3, [pc, #304]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8004f1a:	681b      	ldr	r3, [r3, #0]
 8004f1c:	f003 0320 	and.w	r3, r3, #32
 8004f20:	2b20      	cmp	r3, #32
 8004f22:	d11b      	bne.n	8004f5c <HAL_RCCEx_GetPeriphCLKFreq+0x730>
 8004f24:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004f26:	2b04      	cmp	r3, #4
 8004f28:	d118      	bne.n	8004f5c <HAL_RCCEx_GetPeriphCLKFreq+0x730>
    {
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8004f2a:	4b48      	ldr	r3, [pc, #288]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8004f2c:	689b      	ldr	r3, [r3, #8]
 8004f2e:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8004f32:	2b00      	cmp	r3, #0
 8004f34:	d005      	beq.n	8004f42 <HAL_RCCEx_GetPeriphCLKFreq+0x716>
 8004f36:	4b45      	ldr	r3, [pc, #276]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8004f38:	689b      	ldr	r3, [r3, #8]
 8004f3a:	0e1b      	lsrs	r3, r3, #24
 8004f3c:	f003 030f 	and.w	r3, r3, #15
 8004f40:	e006      	b.n	8004f50 <HAL_RCCEx_GetPeriphCLKFreq+0x724>
 8004f42:	4b42      	ldr	r3, [pc, #264]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8004f44:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8004f48:	041b      	lsls	r3, r3, #16
 8004f4a:	0e1b      	lsrs	r3, r3, #24
 8004f4c:	f003 030f 	and.w	r3, r3, #15
 8004f50:	4a40      	ldr	r2, [pc, #256]	; (8005054 <HAL_RCCEx_GetPeriphCLKFreq+0x828>)
 8004f52:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004f56:	637b      	str	r3, [r7, #52]	; 0x34
 8004f58:	f000 be10 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    /* Clock not enabled for LPUART1 */
    else
    {
      frequency = 0U;
 8004f5c:	2300      	movs	r3, #0
 8004f5e:	637b      	str	r3, [r7, #52]	; 0x34
 8004f60:	f000 be0c 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_ADCDAC)
 8004f64:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004f68:	f5a2 4100 	sub.w	r1, r2, #32768	; 0x8000
 8004f6c:	430b      	orrs	r3, r1
 8004f6e:	d173      	bne.n	8005058 <HAL_RCCEx_GetPeriphCLKFreq+0x82c>
  {
    srcclk = __HAL_RCC_GET_ADCDAC_SOURCE();
 8004f70:	4b36      	ldr	r3, [pc, #216]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8004f72:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8004f76:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
 8004f7a:	633b      	str	r3, [r7, #48]	; 0x30

    if (srcclk == RCC_ADCDACCLKSOURCE_SYSCLK)
 8004f7c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004f7e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8004f82:	d104      	bne.n	8004f8e <HAL_RCCEx_GetPeriphCLKFreq+0x762>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8004f84:	f7fe f88a 	bl	800309c <HAL_RCC_GetSysClockFreq>
 8004f88:	6378      	str	r0, [r7, #52]	; 0x34
 8004f8a:	f000 bdf7 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if (srcclk == RCC_ADCDACCLKSOURCE_PLL2)
 8004f8e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004f90:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8004f94:	d108      	bne.n	8004fa8 <HAL_RCCEx_GetPeriphCLKFreq+0x77c>
    {
      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8004f96:	f107 0318 	add.w	r3, r7, #24
 8004f9a:	4618      	mov	r0, r3
 8004f9c:	f7ff f992 	bl	80042c4 <HAL_RCCEx_GetPLL2ClockFreq>
      frequency = pll2_clocks.PLL2_R_Frequency;
 8004fa0:	6a3b      	ldr	r3, [r7, #32]
 8004fa2:	637b      	str	r3, [r7, #52]	; 0x34
 8004fa4:	f000 bdea 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if (srcclk == RCC_ADCDACCLKSOURCE_HCLK)
 8004fa8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004faa:	2b00      	cmp	r3, #0
 8004fac:	d104      	bne.n	8004fb8 <HAL_RCCEx_GetPeriphCLKFreq+0x78c>
    {
      frequency = HAL_RCC_GetHCLKFreq();
 8004fae:	f7fe f977 	bl	80032a0 <HAL_RCC_GetHCLKFreq>
 8004fb2:	6378      	str	r0, [r7, #52]	; 0x34
 8004fb4:	f000 bde2 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if (srcclk == RCC_ADCDACCLKSOURCE_MSIK)
 8004fb8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004fba:	f5b3 4fa0 	cmp.w	r3, #20480	; 0x5000
 8004fbe:	d122      	bne.n	8005006 <HAL_RCCEx_GetPeriphCLKFreq+0x7da>
    {
      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8004fc0:	4b22      	ldr	r3, [pc, #136]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8004fc2:	681b      	ldr	r3, [r3, #0]
 8004fc4:	f003 0320 	and.w	r3, r3, #32
 8004fc8:	2b20      	cmp	r3, #32
 8004fca:	d118      	bne.n	8004ffe <HAL_RCCEx_GetPeriphCLKFreq+0x7d2>
      {
        frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8004fcc:	4b1f      	ldr	r3, [pc, #124]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8004fce:	689b      	ldr	r3, [r3, #8]
 8004fd0:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8004fd4:	2b00      	cmp	r3, #0
 8004fd6:	d005      	beq.n	8004fe4 <HAL_RCCEx_GetPeriphCLKFreq+0x7b8>
 8004fd8:	4b1c      	ldr	r3, [pc, #112]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8004fda:	689b      	ldr	r3, [r3, #8]
 8004fdc:	0e1b      	lsrs	r3, r3, #24
 8004fde:	f003 030f 	and.w	r3, r3, #15
 8004fe2:	e006      	b.n	8004ff2 <HAL_RCCEx_GetPeriphCLKFreq+0x7c6>
 8004fe4:	4b19      	ldr	r3, [pc, #100]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8004fe6:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8004fea:	041b      	lsls	r3, r3, #16
 8004fec:	0e1b      	lsrs	r3, r3, #24
 8004fee:	f003 030f 	and.w	r3, r3, #15
 8004ff2:	4a18      	ldr	r2, [pc, #96]	; (8005054 <HAL_RCCEx_GetPeriphCLKFreq+0x828>)
 8004ff4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004ff8:	637b      	str	r3, [r7, #52]	; 0x34
 8004ffa:	f000 bdbf 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
      else
      {
        frequency = 0U;
 8004ffe:	2300      	movs	r3, #0
 8005000:	637b      	str	r3, [r7, #52]	; 0x34
 8005002:	f000 bdbb 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_ADCDACCLKSOURCE_HSE))
 8005006:	4b11      	ldr	r3, [pc, #68]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8005008:	681b      	ldr	r3, [r3, #0]
 800500a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800500e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8005012:	d107      	bne.n	8005024 <HAL_RCCEx_GetPeriphCLKFreq+0x7f8>
 8005014:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005016:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 800501a:	d103      	bne.n	8005024 <HAL_RCCEx_GetPeriphCLKFreq+0x7f8>
    {
      frequency = HSE_VALUE;
 800501c:	4b0c      	ldr	r3, [pc, #48]	; (8005050 <HAL_RCCEx_GetPeriphCLKFreq+0x824>)
 800501e:	637b      	str	r3, [r7, #52]	; 0x34
 8005020:	f000 bdac 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_ADCDACCLKSOURCE_HSI))
 8005024:	4b09      	ldr	r3, [pc, #36]	; (800504c <HAL_RCCEx_GetPeriphCLKFreq+0x820>)
 8005026:	681b      	ldr	r3, [r3, #0]
 8005028:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800502c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8005030:	d107      	bne.n	8005042 <HAL_RCCEx_GetPeriphCLKFreq+0x816>
 8005032:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005034:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8005038:	d103      	bne.n	8005042 <HAL_RCCEx_GetPeriphCLKFreq+0x816>
    {
      frequency = HSI_VALUE;
 800503a:	4b05      	ldr	r3, [pc, #20]	; (8005050 <HAL_RCCEx_GetPeriphCLKFreq+0x824>)
 800503c:	637b      	str	r3, [r7, #52]	; 0x34
 800503e:	f000 bd9d 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    /* Clock not enabled for ADC */
    else
    {
      frequency = 0U;
 8005042:	2300      	movs	r3, #0
 8005044:	637b      	str	r3, [r7, #52]	; 0x34
 8005046:	f000 bd99 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
 800504a:	bf00      	nop
 800504c:	46020c00 	.word	0x46020c00
 8005050:	00f42400 	.word	0x00f42400
 8005054:	08017aac 	.word	0x08017aac
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_MDF1)
 8005058:	e9d7 2300 	ldrd	r2, r3, [r7]
 800505c:	f5a2 3180 	sub.w	r1, r2, #65536	; 0x10000
 8005060:	430b      	orrs	r3, r1
 8005062:	d158      	bne.n	8005116 <HAL_RCCEx_GetPeriphCLKFreq+0x8ea>
  {
    /* Get the current MDF1 source */
    srcclk = __HAL_RCC_GET_MDF1_SOURCE();
 8005064:	4bad      	ldr	r3, [pc, #692]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 8005066:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 800506a:	f003 0307 	and.w	r3, r3, #7
 800506e:	633b      	str	r3, [r7, #48]	; 0x30

    switch (srcclk)
 8005070:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005072:	2b04      	cmp	r3, #4
 8005074:	d84b      	bhi.n	800510e <HAL_RCCEx_GetPeriphCLKFreq+0x8e2>
 8005076:	a201      	add	r2, pc, #4	; (adr r2, 800507c <HAL_RCCEx_GetPeriphCLKFreq+0x850>)
 8005078:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800507c:	080050b5 	.word	0x080050b5
 8005080:	08005091 	.word	0x08005091
 8005084:	080050a3 	.word	0x080050a3
 8005088:	080050bf 	.word	0x080050bf
 800508c:	080050c9 	.word	0x080050c9
    {
      case RCC_MDF1CLKSOURCE_PLL1:

        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8005090:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8005094:	4618      	mov	r0, r3
 8005096:	f7fe ffbb 	bl	8004010 <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_P_Frequency;
 800509a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800509c:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 800509e:	f000 bd6d 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_MDF1CLKSOURCE_PLL3:

        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 80050a2:	f107 030c 	add.w	r3, r7, #12
 80050a6:	4618      	mov	r0, r3
 80050a8:	f7ff fa66 	bl	8004578 <HAL_RCCEx_GetPLL3ClockFreq>
        frequency = pll3_clocks.PLL3_Q_Frequency;
 80050ac:	693b      	ldr	r3, [r7, #16]
 80050ae:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 80050b0:	f000 bd64 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_MDF1CLKSOURCE_HCLK:

        frequency = HAL_RCC_GetHCLKFreq();
 80050b4:	f7fe f8f4 	bl	80032a0 <HAL_RCC_GetHCLKFreq>
 80050b8:	6378      	str	r0, [r7, #52]	; 0x34
        break;
 80050ba:	f000 bd5f 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_MDF1CLKSOURCE_PIN:

        frequency = EXTERNAL_SAI1_CLOCK_VALUE;
 80050be:	f64b 3380 	movw	r3, #48000	; 0xbb80
 80050c2:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 80050c4:	f000 bd5a 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_MDF1CLKSOURCE_MSIK:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 80050c8:	4b94      	ldr	r3, [pc, #592]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 80050ca:	681b      	ldr	r3, [r3, #0]
 80050cc:	f003 0320 	and.w	r3, r3, #32
 80050d0:	2b20      	cmp	r3, #32
 80050d2:	d118      	bne.n	8005106 <HAL_RCCEx_GetPeriphCLKFreq+0x8da>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 80050d4:	4b91      	ldr	r3, [pc, #580]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 80050d6:	689b      	ldr	r3, [r3, #8]
 80050d8:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 80050dc:	2b00      	cmp	r3, #0
 80050de:	d005      	beq.n	80050ec <HAL_RCCEx_GetPeriphCLKFreq+0x8c0>
 80050e0:	4b8e      	ldr	r3, [pc, #568]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 80050e2:	689b      	ldr	r3, [r3, #8]
 80050e4:	0e1b      	lsrs	r3, r3, #24
 80050e6:	f003 030f 	and.w	r3, r3, #15
 80050ea:	e006      	b.n	80050fa <HAL_RCCEx_GetPeriphCLKFreq+0x8ce>
 80050ec:	4b8b      	ldr	r3, [pc, #556]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 80050ee:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 80050f2:	041b      	lsls	r3, r3, #16
 80050f4:	0e1b      	lsrs	r3, r3, #24
 80050f6:	f003 030f 	and.w	r3, r3, #15
 80050fa:	4a89      	ldr	r2, [pc, #548]	; (8005320 <HAL_RCCEx_GetPeriphCLKFreq+0xaf4>)
 80050fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8005100:	637b      	str	r3, [r7, #52]	; 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8005102:	f000 bd3b 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
          frequency = 0U;
 8005106:	2300      	movs	r3, #0
 8005108:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 800510a:	f000 bd37 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      default:

        frequency = 0U;
 800510e:	2300      	movs	r3, #0
 8005110:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8005112:	f000 bd33 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_ADF1)
 8005116:	e9d7 2300 	ldrd	r2, r3, [r7]
 800511a:	f5a2 3100 	sub.w	r1, r2, #131072	; 0x20000
 800511e:	430b      	orrs	r3, r1
 8005120:	d167      	bne.n	80051f2 <HAL_RCCEx_GetPeriphCLKFreq+0x9c6>
  {
    /* Get the current ADF1 source */
    srcclk = __HAL_RCC_GET_ADF1_SOURCE();
 8005122:	4b7e      	ldr	r3, [pc, #504]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 8005124:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8005128:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
 800512c:	633b      	str	r3, [r7, #48]	; 0x30

    switch (srcclk)
 800512e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005130:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8005134:	d036      	beq.n	80051a4 <HAL_RCCEx_GetPeriphCLKFreq+0x978>
 8005136:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005138:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800513c:	d855      	bhi.n	80051ea <HAL_RCCEx_GetPeriphCLKFreq+0x9be>
 800513e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005140:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 8005144:	d029      	beq.n	800519a <HAL_RCCEx_GetPeriphCLKFreq+0x96e>
 8005146:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005148:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 800514c:	d84d      	bhi.n	80051ea <HAL_RCCEx_GetPeriphCLKFreq+0x9be>
 800514e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005150:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8005154:	d013      	beq.n	800517e <HAL_RCCEx_GetPeriphCLKFreq+0x952>
 8005156:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005158:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800515c:	d845      	bhi.n	80051ea <HAL_RCCEx_GetPeriphCLKFreq+0x9be>
 800515e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005160:	2b00      	cmp	r3, #0
 8005162:	d015      	beq.n	8005190 <HAL_RCCEx_GetPeriphCLKFreq+0x964>
 8005164:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005166:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800516a:	d13e      	bne.n	80051ea <HAL_RCCEx_GetPeriphCLKFreq+0x9be>
    {
      case RCC_ADF1CLKSOURCE_PLL1:

        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 800516c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8005170:	4618      	mov	r0, r3
 8005172:	f7fe ff4d 	bl	8004010 <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_P_Frequency;
 8005176:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005178:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 800517a:	f000 bcff 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_ADF1CLKSOURCE_PLL3:

        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800517e:	f107 030c 	add.w	r3, r7, #12
 8005182:	4618      	mov	r0, r3
 8005184:	f7ff f9f8 	bl	8004578 <HAL_RCCEx_GetPLL3ClockFreq>
        frequency = pll3_clocks.PLL3_Q_Frequency;
 8005188:	693b      	ldr	r3, [r7, #16]
 800518a:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 800518c:	f000 bcf6 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_ADF1CLKSOURCE_HCLK:

        frequency = HAL_RCC_GetHCLKFreq();
 8005190:	f7fe f886 	bl	80032a0 <HAL_RCC_GetHCLKFreq>
 8005194:	6378      	str	r0, [r7, #52]	; 0x34
        break;
 8005196:	f000 bcf1 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_ADF1CLKSOURCE_PIN:

        frequency = EXTERNAL_SAI1_CLOCK_VALUE;
 800519a:	f64b 3380 	movw	r3, #48000	; 0xbb80
 800519e:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 80051a0:	f000 bcec 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_ADF1CLKSOURCE_MSIK:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 80051a4:	4b5d      	ldr	r3, [pc, #372]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 80051a6:	681b      	ldr	r3, [r3, #0]
 80051a8:	f003 0320 	and.w	r3, r3, #32
 80051ac:	2b20      	cmp	r3, #32
 80051ae:	d118      	bne.n	80051e2 <HAL_RCCEx_GetPeriphCLKFreq+0x9b6>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 80051b0:	4b5a      	ldr	r3, [pc, #360]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 80051b2:	689b      	ldr	r3, [r3, #8]
 80051b4:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 80051b8:	2b00      	cmp	r3, #0
 80051ba:	d005      	beq.n	80051c8 <HAL_RCCEx_GetPeriphCLKFreq+0x99c>
 80051bc:	4b57      	ldr	r3, [pc, #348]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 80051be:	689b      	ldr	r3, [r3, #8]
 80051c0:	0e1b      	lsrs	r3, r3, #24
 80051c2:	f003 030f 	and.w	r3, r3, #15
 80051c6:	e006      	b.n	80051d6 <HAL_RCCEx_GetPeriphCLKFreq+0x9aa>
 80051c8:	4b54      	ldr	r3, [pc, #336]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 80051ca:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 80051ce:	041b      	lsls	r3, r3, #16
 80051d0:	0e1b      	lsrs	r3, r3, #24
 80051d2:	f003 030f 	and.w	r3, r3, #15
 80051d6:	4a52      	ldr	r2, [pc, #328]	; (8005320 <HAL_RCCEx_GetPeriphCLKFreq+0xaf4>)
 80051d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80051dc:	637b      	str	r3, [r7, #52]	; 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 80051de:	f000 bccd 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
          frequency = 0U;
 80051e2:	2300      	movs	r3, #0
 80051e4:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 80051e6:	f000 bcc9 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      default:

        frequency = 0U;
 80051ea:	2300      	movs	r3, #0
 80051ec:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 80051ee:	f000 bcc5 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_I2C1)
 80051f2:	e9d7 2300 	ldrd	r2, r3, [r7]
 80051f6:	f1a2 0140 	sub.w	r1, r2, #64	; 0x40
 80051fa:	430b      	orrs	r3, r1
 80051fc:	d14c      	bne.n	8005298 <HAL_RCCEx_GetPeriphCLKFreq+0xa6c>
  {
    /* Get the current I2C1 source */
    srcclk = __HAL_RCC_GET_I2C1_SOURCE();
 80051fe:	4b47      	ldr	r3, [pc, #284]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 8005200:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8005204:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 8005208:	633b      	str	r3, [r7, #48]	; 0x30

    if (srcclk == RCC_I2C1CLKSOURCE_PCLK1)
 800520a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800520c:	2b00      	cmp	r3, #0
 800520e:	d104      	bne.n	800521a <HAL_RCCEx_GetPeriphCLKFreq+0x9ee>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 8005210:	f7fe f860 	bl	80032d4 <HAL_RCC_GetPCLK1Freq>
 8005214:	6378      	str	r0, [r7, #52]	; 0x34
 8005216:	f000 bcb1 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if (srcclk == RCC_I2C1CLKSOURCE_SYSCLK)
 800521a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800521c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8005220:	d104      	bne.n	800522c <HAL_RCCEx_GetPeriphCLKFreq+0xa00>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8005222:	f7fd ff3b 	bl	800309c <HAL_RCC_GetSysClockFreq>
 8005226:	6378      	str	r0, [r7, #52]	; 0x34
 8005228:	f000 bca8 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C1CLKSOURCE_HSI))
 800522c:	4b3b      	ldr	r3, [pc, #236]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 800522e:	681b      	ldr	r3, [r3, #0]
 8005230:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8005234:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8005238:	d107      	bne.n	800524a <HAL_RCCEx_GetPeriphCLKFreq+0xa1e>
 800523a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800523c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8005240:	d103      	bne.n	800524a <HAL_RCCEx_GetPeriphCLKFreq+0xa1e>
    {
      frequency = HSI_VALUE;
 8005242:	4b38      	ldr	r3, [pc, #224]	; (8005324 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>)
 8005244:	637b      	str	r3, [r7, #52]	; 0x34
 8005246:	f000 bc99 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_I2C1CLKSOURCE_MSIK))
 800524a:	4b34      	ldr	r3, [pc, #208]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 800524c:	681b      	ldr	r3, [r3, #0]
 800524e:	f003 0320 	and.w	r3, r3, #32
 8005252:	2b20      	cmp	r3, #32
 8005254:	d11c      	bne.n	8005290 <HAL_RCCEx_GetPeriphCLKFreq+0xa64>
 8005256:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005258:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800525c:	d118      	bne.n	8005290 <HAL_RCCEx_GetPeriphCLKFreq+0xa64>
    {
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 800525e:	4b2f      	ldr	r3, [pc, #188]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 8005260:	689b      	ldr	r3, [r3, #8]
 8005262:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8005266:	2b00      	cmp	r3, #0
 8005268:	d005      	beq.n	8005276 <HAL_RCCEx_GetPeriphCLKFreq+0xa4a>
 800526a:	4b2c      	ldr	r3, [pc, #176]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 800526c:	689b      	ldr	r3, [r3, #8]
 800526e:	0e1b      	lsrs	r3, r3, #24
 8005270:	f003 030f 	and.w	r3, r3, #15
 8005274:	e006      	b.n	8005284 <HAL_RCCEx_GetPeriphCLKFreq+0xa58>
 8005276:	4b29      	ldr	r3, [pc, #164]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 8005278:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 800527c:	041b      	lsls	r3, r3, #16
 800527e:	0e1b      	lsrs	r3, r3, #24
 8005280:	f003 030f 	and.w	r3, r3, #15
 8005284:	4a26      	ldr	r2, [pc, #152]	; (8005320 <HAL_RCCEx_GetPeriphCLKFreq+0xaf4>)
 8005286:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800528a:	637b      	str	r3, [r7, #52]	; 0x34
 800528c:	f000 bc76 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    /* Clock not enabled for I2C1 */
    else
    {
      frequency = 0U;
 8005290:	2300      	movs	r3, #0
 8005292:	637b      	str	r3, [r7, #52]	; 0x34
 8005294:	f000 bc72 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_I2C2)
 8005298:	e9d7 2300 	ldrd	r2, r3, [r7]
 800529c:	f1a2 0180 	sub.w	r1, r2, #128	; 0x80
 80052a0:	430b      	orrs	r3, r1
 80052a2:	d152      	bne.n	800534a <HAL_RCCEx_GetPeriphCLKFreq+0xb1e>
  {
    /* Get the current I2C2 source */
    srcclk = __HAL_RCC_GET_I2C2_SOURCE();
 80052a4:	4b1d      	ldr	r3, [pc, #116]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 80052a6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80052aa:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 80052ae:	633b      	str	r3, [r7, #48]	; 0x30

    if (srcclk == RCC_I2C2CLKSOURCE_PCLK1)
 80052b0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80052b2:	2b00      	cmp	r3, #0
 80052b4:	d104      	bne.n	80052c0 <HAL_RCCEx_GetPeriphCLKFreq+0xa94>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 80052b6:	f7fe f80d 	bl	80032d4 <HAL_RCC_GetPCLK1Freq>
 80052ba:	6378      	str	r0, [r7, #52]	; 0x34
 80052bc:	f000 bc5e 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if (srcclk == RCC_I2C2CLKSOURCE_SYSCLK)
 80052c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80052c2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80052c6:	d104      	bne.n	80052d2 <HAL_RCCEx_GetPeriphCLKFreq+0xaa6>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 80052c8:	f7fd fee8 	bl	800309c <HAL_RCC_GetSysClockFreq>
 80052cc:	6378      	str	r0, [r7, #52]	; 0x34
 80052ce:	f000 bc55 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C2CLKSOURCE_HSI))
 80052d2:	4b12      	ldr	r3, [pc, #72]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 80052d4:	681b      	ldr	r3, [r3, #0]
 80052d6:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80052da:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80052de:	d107      	bne.n	80052f0 <HAL_RCCEx_GetPeriphCLKFreq+0xac4>
 80052e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80052e2:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80052e6:	d103      	bne.n	80052f0 <HAL_RCCEx_GetPeriphCLKFreq+0xac4>
    {
      frequency = HSI_VALUE;
 80052e8:	4b0e      	ldr	r3, [pc, #56]	; (8005324 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>)
 80052ea:	637b      	str	r3, [r7, #52]	; 0x34
 80052ec:	f000 bc46 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_I2C2CLKSOURCE_MSIK))
 80052f0:	4b0a      	ldr	r3, [pc, #40]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 80052f2:	681b      	ldr	r3, [r3, #0]
 80052f4:	f003 0320 	and.w	r3, r3, #32
 80052f8:	2b20      	cmp	r3, #32
 80052fa:	d122      	bne.n	8005342 <HAL_RCCEx_GetPeriphCLKFreq+0xb16>
 80052fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80052fe:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 8005302:	d11e      	bne.n	8005342 <HAL_RCCEx_GetPeriphCLKFreq+0xb16>
    {
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8005304:	4b05      	ldr	r3, [pc, #20]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 8005306:	689b      	ldr	r3, [r3, #8]
 8005308:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800530c:	2b00      	cmp	r3, #0
 800530e:	d00b      	beq.n	8005328 <HAL_RCCEx_GetPeriphCLKFreq+0xafc>
 8005310:	4b02      	ldr	r3, [pc, #8]	; (800531c <HAL_RCCEx_GetPeriphCLKFreq+0xaf0>)
 8005312:	689b      	ldr	r3, [r3, #8]
 8005314:	0e1b      	lsrs	r3, r3, #24
 8005316:	f003 030f 	and.w	r3, r3, #15
 800531a:	e00c      	b.n	8005336 <HAL_RCCEx_GetPeriphCLKFreq+0xb0a>
 800531c:	46020c00 	.word	0x46020c00
 8005320:	08017aac 	.word	0x08017aac
 8005324:	00f42400 	.word	0x00f42400
 8005328:	4ba1      	ldr	r3, [pc, #644]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 800532a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 800532e:	041b      	lsls	r3, r3, #16
 8005330:	0e1b      	lsrs	r3, r3, #24
 8005332:	f003 030f 	and.w	r3, r3, #15
 8005336:	4a9f      	ldr	r2, [pc, #636]	; (80055b4 <HAL_RCCEx_GetPeriphCLKFreq+0xd88>)
 8005338:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800533c:	637b      	str	r3, [r7, #52]	; 0x34
 800533e:	f000 bc1d 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    /* Clock not enabled for I2C2 */
    else
    {
      frequency = 0U;
 8005342:	2300      	movs	r3, #0
 8005344:	637b      	str	r3, [r7, #52]	; 0x34
 8005346:	f000 bc19 	b.w	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_I2C3)
 800534a:	e9d7 2300 	ldrd	r2, r3, [r7]
 800534e:	f5a2 7180 	sub.w	r1, r2, #256	; 0x100
 8005352:	430b      	orrs	r3, r1
 8005354:	d151      	bne.n	80053fa <HAL_RCCEx_GetPeriphCLKFreq+0xbce>
  {
    /* Get the current I2C3 source */
    srcclk = __HAL_RCC_GET_I2C3_SOURCE();
 8005356:	4b96      	ldr	r3, [pc, #600]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 8005358:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 800535c:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 8005360:	633b      	str	r3, [r7, #48]	; 0x30

    switch (srcclk)
 8005362:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005364:	2bc0      	cmp	r3, #192	; 0xc0
 8005366:	d024      	beq.n	80053b2 <HAL_RCCEx_GetPeriphCLKFreq+0xb86>
 8005368:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800536a:	2bc0      	cmp	r3, #192	; 0xc0
 800536c:	d842      	bhi.n	80053f4 <HAL_RCCEx_GetPeriphCLKFreq+0xbc8>
 800536e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005370:	2b80      	cmp	r3, #128	; 0x80
 8005372:	d00d      	beq.n	8005390 <HAL_RCCEx_GetPeriphCLKFreq+0xb64>
 8005374:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005376:	2b80      	cmp	r3, #128	; 0x80
 8005378:	d83c      	bhi.n	80053f4 <HAL_RCCEx_GetPeriphCLKFreq+0xbc8>
 800537a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800537c:	2b00      	cmp	r3, #0
 800537e:	d003      	beq.n	8005388 <HAL_RCCEx_GetPeriphCLKFreq+0xb5c>
 8005380:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005382:	2b40      	cmp	r3, #64	; 0x40
 8005384:	d011      	beq.n	80053aa <HAL_RCCEx_GetPeriphCLKFreq+0xb7e>
 8005386:	e035      	b.n	80053f4 <HAL_RCCEx_GetPeriphCLKFreq+0xbc8>
    {
      case RCC_I2C3CLKSOURCE_PCLK3:
      {
        frequency = HAL_RCC_GetPCLK3Freq();
 8005388:	f7fd ffcc 	bl	8003324 <HAL_RCC_GetPCLK3Freq>
 800538c:	6378      	str	r0, [r7, #52]	; 0x34
        break;
 800538e:	e3f5      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
      case RCC_I2C3CLKSOURCE_HSI:
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8005390:	4b87      	ldr	r3, [pc, #540]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 8005392:	681b      	ldr	r3, [r3, #0]
 8005394:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8005398:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800539c:	d102      	bne.n	80053a4 <HAL_RCCEx_GetPeriphCLKFreq+0xb78>
        {
          frequency = HSI_VALUE;
 800539e:	4b86      	ldr	r3, [pc, #536]	; (80055b8 <HAL_RCCEx_GetPeriphCLKFreq+0xd8c>)
 80053a0:	637b      	str	r3, [r7, #52]	; 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 80053a2:	e3eb      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
          frequency = 0U;
 80053a4:	2300      	movs	r3, #0
 80053a6:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 80053a8:	e3e8      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
      case RCC_I2C3CLKSOURCE_SYSCLK:
      {
        frequency = HAL_RCC_GetSysClockFreq();
 80053aa:	f7fd fe77 	bl	800309c <HAL_RCC_GetSysClockFreq>
 80053ae:	6378      	str	r0, [r7, #52]	; 0x34
        break;
 80053b0:	e3e4      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
      case RCC_I2C3CLKSOURCE_MSIK:
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 80053b2:	4b7f      	ldr	r3, [pc, #508]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 80053b4:	681b      	ldr	r3, [r3, #0]
 80053b6:	f003 0320 	and.w	r3, r3, #32
 80053ba:	2b20      	cmp	r3, #32
 80053bc:	d117      	bne.n	80053ee <HAL_RCCEx_GetPeriphCLKFreq+0xbc2>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 80053be:	4b7c      	ldr	r3, [pc, #496]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 80053c0:	689b      	ldr	r3, [r3, #8]
 80053c2:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 80053c6:	2b00      	cmp	r3, #0
 80053c8:	d005      	beq.n	80053d6 <HAL_RCCEx_GetPeriphCLKFreq+0xbaa>
 80053ca:	4b79      	ldr	r3, [pc, #484]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 80053cc:	689b      	ldr	r3, [r3, #8]
 80053ce:	0e1b      	lsrs	r3, r3, #24
 80053d0:	f003 030f 	and.w	r3, r3, #15
 80053d4:	e006      	b.n	80053e4 <HAL_RCCEx_GetPeriphCLKFreq+0xbb8>
 80053d6:	4b76      	ldr	r3, [pc, #472]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 80053d8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 80053dc:	041b      	lsls	r3, r3, #16
 80053de:	0e1b      	lsrs	r3, r3, #24
 80053e0:	f003 030f 	and.w	r3, r3, #15
 80053e4:	4a73      	ldr	r2, [pc, #460]	; (80055b4 <HAL_RCCEx_GetPeriphCLKFreq+0xd88>)
 80053e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80053ea:	637b      	str	r3, [r7, #52]	; 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 80053ec:	e3c6      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
          frequency = 0U;
 80053ee:	2300      	movs	r3, #0
 80053f0:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 80053f2:	e3c3      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
      default:
      {
        frequency = 0U;
 80053f4:	2300      	movs	r3, #0
 80053f6:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 80053f8:	e3c0      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_I2C4)
 80053fa:	e9d7 2300 	ldrd	r2, r3, [r7]
 80053fe:	f5a2 0180 	sub.w	r1, r2, #4194304	; 0x400000
 8005402:	430b      	orrs	r3, r1
 8005404:	d147      	bne.n	8005496 <HAL_RCCEx_GetPeriphCLKFreq+0xc6a>
  {
    /* Get the current I2C4 source */
    srcclk = __HAL_RCC_GET_I2C4_SOURCE();
 8005406:	4b6a      	ldr	r3, [pc, #424]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 8005408:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800540c:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8005410:	633b      	str	r3, [r7, #48]	; 0x30

    if (srcclk == RCC_I2C4CLKSOURCE_PCLK1)
 8005412:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005414:	2b00      	cmp	r3, #0
 8005416:	d103      	bne.n	8005420 <HAL_RCCEx_GetPeriphCLKFreq+0xbf4>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 8005418:	f7fd ff5c 	bl	80032d4 <HAL_RCC_GetPCLK1Freq>
 800541c:	6378      	str	r0, [r7, #52]	; 0x34
 800541e:	e3ad      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if (srcclk == RCC_I2C4CLKSOURCE_SYSCLK)
 8005420:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005422:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8005426:	d103      	bne.n	8005430 <HAL_RCCEx_GetPeriphCLKFreq+0xc04>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8005428:	f7fd fe38 	bl	800309c <HAL_RCC_GetSysClockFreq>
 800542c:	6378      	str	r0, [r7, #52]	; 0x34
 800542e:	e3a5      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C4CLKSOURCE_HSI))
 8005430:	4b5f      	ldr	r3, [pc, #380]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 8005432:	681b      	ldr	r3, [r3, #0]
 8005434:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8005438:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800543c:	d106      	bne.n	800544c <HAL_RCCEx_GetPeriphCLKFreq+0xc20>
 800543e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005440:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8005444:	d102      	bne.n	800544c <HAL_RCCEx_GetPeriphCLKFreq+0xc20>
    {
      frequency = HSI_VALUE;
 8005446:	4b5c      	ldr	r3, [pc, #368]	; (80055b8 <HAL_RCCEx_GetPeriphCLKFreq+0xd8c>)
 8005448:	637b      	str	r3, [r7, #52]	; 0x34
 800544a:	e397      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_I2C4CLKSOURCE_MSIK))
 800544c:	4b58      	ldr	r3, [pc, #352]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 800544e:	681b      	ldr	r3, [r3, #0]
 8005450:	f003 0320 	and.w	r3, r3, #32
 8005454:	2b20      	cmp	r3, #32
 8005456:	d11b      	bne.n	8005490 <HAL_RCCEx_GetPeriphCLKFreq+0xc64>
 8005458:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800545a:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 800545e:	d117      	bne.n	8005490 <HAL_RCCEx_GetPeriphCLKFreq+0xc64>
    {
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8005460:	4b53      	ldr	r3, [pc, #332]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 8005462:	689b      	ldr	r3, [r3, #8]
 8005464:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8005468:	2b00      	cmp	r3, #0
 800546a:	d005      	beq.n	8005478 <HAL_RCCEx_GetPeriphCLKFreq+0xc4c>
 800546c:	4b50      	ldr	r3, [pc, #320]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 800546e:	689b      	ldr	r3, [r3, #8]
 8005470:	0e1b      	lsrs	r3, r3, #24
 8005472:	f003 030f 	and.w	r3, r3, #15
 8005476:	e006      	b.n	8005486 <HAL_RCCEx_GetPeriphCLKFreq+0xc5a>
 8005478:	4b4d      	ldr	r3, [pc, #308]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 800547a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 800547e:	041b      	lsls	r3, r3, #16
 8005480:	0e1b      	lsrs	r3, r3, #24
 8005482:	f003 030f 	and.w	r3, r3, #15
 8005486:	4a4b      	ldr	r2, [pc, #300]	; (80055b4 <HAL_RCCEx_GetPeriphCLKFreq+0xd88>)
 8005488:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800548c:	637b      	str	r3, [r7, #52]	; 0x34
 800548e:	e375      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    /* Clock not enabled for I2C4 */
    else
    {
      frequency = 0U;
 8005490:	2300      	movs	r3, #0
 8005492:	637b      	str	r3, [r7, #52]	; 0x34
 8005494:	e372      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    {
      frequency = 0U;
    }
  }
#endif /* I2C6 */
  else if (PeriphClk == RCC_PERIPHCLK_LPTIM34)
 8005496:	e9d7 2300 	ldrd	r2, r3, [r7]
 800549a:	f5a2 6100 	sub.w	r1, r2, #2048	; 0x800
 800549e:	430b      	orrs	r3, r1
 80054a0:	d164      	bne.n	800556c <HAL_RCCEx_GetPeriphCLKFreq+0xd40>
  {
    /* Get the current LPTIM34 source */
    srcclk = __HAL_RCC_GET_LPTIM34_SOURCE();
 80054a2:	4b43      	ldr	r3, [pc, #268]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 80054a4:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 80054a8:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80054ac:	633b      	str	r3, [r7, #48]	; 0x30

    if (srcclk == RCC_LPTIM34CLKSOURCE_MSIK)
 80054ae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80054b0:	2b00      	cmp	r3, #0
 80054b2:	d120      	bne.n	80054f6 <HAL_RCCEx_GetPeriphCLKFreq+0xcca>
    {
      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 80054b4:	4b3e      	ldr	r3, [pc, #248]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 80054b6:	681b      	ldr	r3, [r3, #0]
 80054b8:	f003 0320 	and.w	r3, r3, #32
 80054bc:	2b20      	cmp	r3, #32
 80054be:	d117      	bne.n	80054f0 <HAL_RCCEx_GetPeriphCLKFreq+0xcc4>
      {
        frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 80054c0:	4b3b      	ldr	r3, [pc, #236]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 80054c2:	689b      	ldr	r3, [r3, #8]
 80054c4:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 80054c8:	2b00      	cmp	r3, #0
 80054ca:	d005      	beq.n	80054d8 <HAL_RCCEx_GetPeriphCLKFreq+0xcac>
 80054cc:	4b38      	ldr	r3, [pc, #224]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 80054ce:	689b      	ldr	r3, [r3, #8]
 80054d0:	0e1b      	lsrs	r3, r3, #24
 80054d2:	f003 030f 	and.w	r3, r3, #15
 80054d6:	e006      	b.n	80054e6 <HAL_RCCEx_GetPeriphCLKFreq+0xcba>
 80054d8:	4b35      	ldr	r3, [pc, #212]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 80054da:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 80054de:	041b      	lsls	r3, r3, #16
 80054e0:	0e1b      	lsrs	r3, r3, #24
 80054e2:	f003 030f 	and.w	r3, r3, #15
 80054e6:	4a33      	ldr	r2, [pc, #204]	; (80055b4 <HAL_RCCEx_GetPeriphCLKFreq+0xd88>)
 80054e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80054ec:	637b      	str	r3, [r7, #52]	; 0x34
 80054ee:	e345      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
      else
      {
        frequency = 0U;
 80054f0:	2300      	movs	r3, #0
 80054f2:	637b      	str	r3, [r7, #52]	; 0x34
 80054f4:	e342      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_LPTIM34CLKSOURCE_LSI))
 80054f6:	4b2e      	ldr	r3, [pc, #184]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 80054f8:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80054fc:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8005500:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8005504:	d112      	bne.n	800552c <HAL_RCCEx_GetPeriphCLKFreq+0xd00>
 8005506:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005508:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800550c:	d10e      	bne.n	800552c <HAL_RCCEx_GetPeriphCLKFreq+0xd00>
    {
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 800550e:	4b28      	ldr	r3, [pc, #160]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 8005510:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8005514:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8005518:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800551c:	d102      	bne.n	8005524 <HAL_RCCEx_GetPeriphCLKFreq+0xcf8>
      {
        frequency = LSI_VALUE / 128U;
 800551e:	23fa      	movs	r3, #250	; 0xfa
 8005520:	637b      	str	r3, [r7, #52]	; 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8005522:	e32b      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
      else
      {
        frequency = LSI_VALUE;
 8005524:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
 8005528:	637b      	str	r3, [r7, #52]	; 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 800552a:	e327      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPTIM34CLKSOURCE_HSI))
 800552c:	4b20      	ldr	r3, [pc, #128]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 800552e:	681b      	ldr	r3, [r3, #0]
 8005530:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8005534:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8005538:	d106      	bne.n	8005548 <HAL_RCCEx_GetPeriphCLKFreq+0xd1c>
 800553a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800553c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8005540:	d102      	bne.n	8005548 <HAL_RCCEx_GetPeriphCLKFreq+0xd1c>
    {
      frequency = HSI_VALUE;
 8005542:	4b1d      	ldr	r3, [pc, #116]	; (80055b8 <HAL_RCCEx_GetPeriphCLKFreq+0xd8c>)
 8005544:	637b      	str	r3, [r7, #52]	; 0x34
 8005546:	e319      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPTIM34CLKSOURCE_LSE))
 8005548:	4b19      	ldr	r3, [pc, #100]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 800554a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 800554e:	f003 0302 	and.w	r3, r3, #2
 8005552:	2b02      	cmp	r3, #2
 8005554:	d107      	bne.n	8005566 <HAL_RCCEx_GetPeriphCLKFreq+0xd3a>
 8005556:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005558:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800555c:	d103      	bne.n	8005566 <HAL_RCCEx_GetPeriphCLKFreq+0xd3a>
    {
      frequency = LSE_VALUE;
 800555e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8005562:	637b      	str	r3, [r7, #52]	; 0x34
 8005564:	e30a      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    /* Clock not enabled for LPTIM34 */
    else
    {
      frequency = 0U;
 8005566:	2300      	movs	r3, #0
 8005568:	637b      	str	r3, [r7, #52]	; 0x34
 800556a:	e307      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_LPTIM1)
 800556c:	e9d7 2300 	ldrd	r2, r3, [r7]
 8005570:	f5a2 7100 	sub.w	r1, r2, #512	; 0x200
 8005574:	430b      	orrs	r3, r1
 8005576:	d16b      	bne.n	8005650 <HAL_RCCEx_GetPeriphCLKFreq+0xe24>
  {
    /* Get the current LPTIM1 source */
    srcclk = __HAL_RCC_GET_LPTIM1_SOURCE();
 8005578:	4b0d      	ldr	r3, [pc, #52]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 800557a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 800557e:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 8005582:	633b      	str	r3, [r7, #48]	; 0x30

    if (srcclk == RCC_LPTIM1CLKSOURCE_MSIK)
 8005584:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005586:	2b00      	cmp	r3, #0
 8005588:	d127      	bne.n	80055da <HAL_RCCEx_GetPeriphCLKFreq+0xdae>
    {
      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 800558a:	4b09      	ldr	r3, [pc, #36]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 800558c:	681b      	ldr	r3, [r3, #0]
 800558e:	f003 0320 	and.w	r3, r3, #32
 8005592:	2b20      	cmp	r3, #32
 8005594:	d11e      	bne.n	80055d4 <HAL_RCCEx_GetPeriphCLKFreq+0xda8>
      {
        frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8005596:	4b06      	ldr	r3, [pc, #24]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 8005598:	689b      	ldr	r3, [r3, #8]
 800559a:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800559e:	2b00      	cmp	r3, #0
 80055a0:	d00c      	beq.n	80055bc <HAL_RCCEx_GetPeriphCLKFreq+0xd90>
 80055a2:	4b03      	ldr	r3, [pc, #12]	; (80055b0 <HAL_RCCEx_GetPeriphCLKFreq+0xd84>)
 80055a4:	689b      	ldr	r3, [r3, #8]
 80055a6:	0e1b      	lsrs	r3, r3, #24
 80055a8:	f003 030f 	and.w	r3, r3, #15
 80055ac:	e00d      	b.n	80055ca <HAL_RCCEx_GetPeriphCLKFreq+0xd9e>
 80055ae:	bf00      	nop
 80055b0:	46020c00 	.word	0x46020c00
 80055b4:	08017aac 	.word	0x08017aac
 80055b8:	00f42400 	.word	0x00f42400
 80055bc:	4b94      	ldr	r3, [pc, #592]	; (8005810 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>)
 80055be:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 80055c2:	041b      	lsls	r3, r3, #16
 80055c4:	0e1b      	lsrs	r3, r3, #24
 80055c6:	f003 030f 	and.w	r3, r3, #15
 80055ca:	4a92      	ldr	r2, [pc, #584]	; (8005814 <HAL_RCCEx_GetPeriphCLKFreq+0xfe8>)
 80055cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80055d0:	637b      	str	r3, [r7, #52]	; 0x34
 80055d2:	e2d3      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
      else
      {
        frequency = 0U;
 80055d4:	2300      	movs	r3, #0
 80055d6:	637b      	str	r3, [r7, #52]	; 0x34
 80055d8:	e2d0      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_LPTIM1CLKSOURCE_LSI))
 80055da:	4b8d      	ldr	r3, [pc, #564]	; (8005810 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>)
 80055dc:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80055e0:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80055e4:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 80055e8:	d112      	bne.n	8005610 <HAL_RCCEx_GetPeriphCLKFreq+0xde4>
 80055ea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80055ec:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80055f0:	d10e      	bne.n	8005610 <HAL_RCCEx_GetPeriphCLKFreq+0xde4>
    {
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 80055f2:	4b87      	ldr	r3, [pc, #540]	; (8005810 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>)
 80055f4:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80055f8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80055fc:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8005600:	d102      	bne.n	8005608 <HAL_RCCEx_GetPeriphCLKFreq+0xddc>
      {
        frequency = LSI_VALUE / 128U;
 8005602:	23fa      	movs	r3, #250	; 0xfa
 8005604:	637b      	str	r3, [r7, #52]	; 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8005606:	e2b9      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
      else
      {
        frequency = LSI_VALUE;
 8005608:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
 800560c:	637b      	str	r3, [r7, #52]	; 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 800560e:	e2b5      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPTIM1CLKSOURCE_HSI))
 8005610:	4b7f      	ldr	r3, [pc, #508]	; (8005810 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>)
 8005612:	681b      	ldr	r3, [r3, #0]
 8005614:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8005618:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800561c:	d106      	bne.n	800562c <HAL_RCCEx_GetPeriphCLKFreq+0xe00>
 800561e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005620:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8005624:	d102      	bne.n	800562c <HAL_RCCEx_GetPeriphCLKFreq+0xe00>
    {
      frequency = HSI_VALUE;
 8005626:	4b7c      	ldr	r3, [pc, #496]	; (8005818 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 8005628:	637b      	str	r3, [r7, #52]	; 0x34
 800562a:	e2a7      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPTIM1CLKSOURCE_LSE))
 800562c:	4b78      	ldr	r3, [pc, #480]	; (8005810 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>)
 800562e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8005632:	f003 0302 	and.w	r3, r3, #2
 8005636:	2b02      	cmp	r3, #2
 8005638:	d107      	bne.n	800564a <HAL_RCCEx_GetPeriphCLKFreq+0xe1e>
 800563a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800563c:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8005640:	d103      	bne.n	800564a <HAL_RCCEx_GetPeriphCLKFreq+0xe1e>
    {
      frequency = LSE_VALUE;
 8005642:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8005646:	637b      	str	r3, [r7, #52]	; 0x34
 8005648:	e298      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    /* Clock not enabled for LPTIM1 */
    else
    {
      frequency = 0U;
 800564a:	2300      	movs	r3, #0
 800564c:	637b      	str	r3, [r7, #52]	; 0x34
 800564e:	e295      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_LPTIM2)
 8005650:	e9d7 2300 	ldrd	r2, r3, [r7]
 8005654:	f5a2 6180 	sub.w	r1, r2, #1024	; 0x400
 8005658:	430b      	orrs	r3, r1
 800565a:	d147      	bne.n	80056ec <HAL_RCCEx_GetPeriphCLKFreq+0xec0>
  {
    /* Get the current LPTIM2 source */
    srcclk = __HAL_RCC_GET_LPTIM2_SOURCE();
 800565c:	4b6c      	ldr	r3, [pc, #432]	; (8005810 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>)
 800565e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8005662:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8005666:	633b      	str	r3, [r7, #48]	; 0x30

    if (srcclk == RCC_LPTIM2CLKSOURCE_PCLK1)
 8005668:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800566a:	2b00      	cmp	r3, #0
 800566c:	d103      	bne.n	8005676 <HAL_RCCEx_GetPeriphCLKFreq+0xe4a>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 800566e:	f7fd fe31 	bl	80032d4 <HAL_RCC_GetPCLK1Freq>
 8005672:	6378      	str	r0, [r7, #52]	; 0x34
 8005674:	e282      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_LPTIM2CLKSOURCE_LSI))
 8005676:	4b66      	ldr	r3, [pc, #408]	; (8005810 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>)
 8005678:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 800567c:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8005680:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8005684:	d112      	bne.n	80056ac <HAL_RCCEx_GetPeriphCLKFreq+0xe80>
 8005686:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005688:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800568c:	d10e      	bne.n	80056ac <HAL_RCCEx_GetPeriphCLKFreq+0xe80>
    {
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 800568e:	4b60      	ldr	r3, [pc, #384]	; (8005810 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>)
 8005690:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8005694:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8005698:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800569c:	d102      	bne.n	80056a4 <HAL_RCCEx_GetPeriphCLKFreq+0xe78>
      {
        frequency = LSI_VALUE / 128U;
 800569e:	23fa      	movs	r3, #250	; 0xfa
 80056a0:	637b      	str	r3, [r7, #52]	; 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 80056a2:	e26b      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
      else
      {
        frequency = LSI_VALUE;
 80056a4:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
 80056a8:	637b      	str	r3, [r7, #52]	; 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 80056aa:	e267      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPTIM2CLKSOURCE_HSI))
 80056ac:	4b58      	ldr	r3, [pc, #352]	; (8005810 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>)
 80056ae:	681b      	ldr	r3, [r3, #0]
 80056b0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80056b4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80056b8:	d106      	bne.n	80056c8 <HAL_RCCEx_GetPeriphCLKFreq+0xe9c>
 80056ba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80056bc:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 80056c0:	d102      	bne.n	80056c8 <HAL_RCCEx_GetPeriphCLKFreq+0xe9c>
    {
      frequency = HSI_VALUE;
 80056c2:	4b55      	ldr	r3, [pc, #340]	; (8005818 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 80056c4:	637b      	str	r3, [r7, #52]	; 0x34
 80056c6:	e259      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPTIM2CLKSOURCE_LSE))
 80056c8:	4b51      	ldr	r3, [pc, #324]	; (8005810 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>)
 80056ca:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80056ce:	f003 0302 	and.w	r3, r3, #2
 80056d2:	2b02      	cmp	r3, #2
 80056d4:	d107      	bne.n	80056e6 <HAL_RCCEx_GetPeriphCLKFreq+0xeba>
 80056d6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80056d8:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 80056dc:	d103      	bne.n	80056e6 <HAL_RCCEx_GetPeriphCLKFreq+0xeba>
    {
      frequency = LSE_VALUE;
 80056de:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80056e2:	637b      	str	r3, [r7, #52]	; 0x34
 80056e4:	e24a      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    /* Clock not enabled for LPTIM2 */
    else
    {
      frequency = 0U;
 80056e6:	2300      	movs	r3, #0
 80056e8:	637b      	str	r3, [r7, #52]	; 0x34
 80056ea:	e247      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_FDCAN1)
 80056ec:	e9d7 2300 	ldrd	r2, r3, [r7]
 80056f0:	f102 4178 	add.w	r1, r2, #4160749568	; 0xf8000000
 80056f4:	430b      	orrs	r3, r1
 80056f6:	d12d      	bne.n	8005754 <HAL_RCCEx_GetPeriphCLKFreq+0xf28>
  {
    /* Get the current FDCAN1 kernel source */
    srcclk = __HAL_RCC_GET_FDCAN1_SOURCE();
 80056f8:	4b45      	ldr	r3, [pc, #276]	; (8005810 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>)
 80056fa:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80056fe:	f003 7340 	and.w	r3, r3, #50331648	; 0x3000000
 8005702:	633b      	str	r3, [r7, #48]	; 0x30

    if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_FDCAN1CLKSOURCE_HSE))
 8005704:	4b42      	ldr	r3, [pc, #264]	; (8005810 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>)
 8005706:	681b      	ldr	r3, [r3, #0]
 8005708:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800570c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8005710:	d105      	bne.n	800571e <HAL_RCCEx_GetPeriphCLKFreq+0xef2>
 8005712:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005714:	2b00      	cmp	r3, #0
 8005716:	d102      	bne.n	800571e <HAL_RCCEx_GetPeriphCLKFreq+0xef2>
    {
      frequency = HSE_VALUE;
 8005718:	4b3f      	ldr	r3, [pc, #252]	; (8005818 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 800571a:	637b      	str	r3, [r7, #52]	; 0x34
 800571c:	e22e      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if (srcclk == RCC_FDCAN1CLKSOURCE_PLL1) /* PLL1 ? */
 800571e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005720:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8005724:	d107      	bne.n	8005736 <HAL_RCCEx_GetPeriphCLKFreq+0xf0a>
    {
      HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8005726:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800572a:	4618      	mov	r0, r3
 800572c:	f7fe fc70 	bl	8004010 <HAL_RCCEx_GetPLL1ClockFreq>
      frequency = pll1_clocks.PLL1_Q_Frequency;
 8005730:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005732:	637b      	str	r3, [r7, #52]	; 0x34
 8005734:	e222      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    else if (srcclk == RCC_FDCAN1CLKSOURCE_PLL2) /* PLL2 ? */
 8005736:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005738:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 800573c:	d107      	bne.n	800574e <HAL_RCCEx_GetPeriphCLKFreq+0xf22>
    {
      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800573e:	f107 0318 	add.w	r3, r7, #24
 8005742:	4618      	mov	r0, r3
 8005744:	f7fe fdbe 	bl	80042c4 <HAL_RCCEx_GetPLL2ClockFreq>
      frequency = pll2_clocks.PLL2_P_Frequency;
 8005748:	69bb      	ldr	r3, [r7, #24]
 800574a:	637b      	str	r3, [r7, #52]	; 0x34
 800574c:	e216      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    /* Clock not enabled for FDCAN1 */
    else
    {
      frequency = 0U;
 800574e:	2300      	movs	r3, #0
 8005750:	637b      	str	r3, [r7, #52]	; 0x34
 8005752:	e213      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI1)
 8005754:	e9d7 2300 	ldrd	r2, r3, [r7]
 8005758:	f5a2 0100 	sub.w	r1, r2, #8388608	; 0x800000
 800575c:	430b      	orrs	r3, r1
 800575e:	d15d      	bne.n	800581c <HAL_RCCEx_GetPeriphCLKFreq+0xff0>
  {
    /* Get the current SPI1 kernel source */
    srcclk = __HAL_RCC_GET_SPI1_SOURCE();
 8005760:	4b2b      	ldr	r3, [pc, #172]	; (8005810 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>)
 8005762:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8005766:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 800576a:	633b      	str	r3, [r7, #48]	; 0x30
    switch (srcclk)
 800576c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800576e:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 8005772:	d028      	beq.n	80057c6 <HAL_RCCEx_GetPeriphCLKFreq+0xf9a>
 8005774:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005776:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 800577a:	d845      	bhi.n	8005808 <HAL_RCCEx_GetPeriphCLKFreq+0xfdc>
 800577c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800577e:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8005782:	d013      	beq.n	80057ac <HAL_RCCEx_GetPeriphCLKFreq+0xf80>
 8005784:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005786:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 800578a:	d83d      	bhi.n	8005808 <HAL_RCCEx_GetPeriphCLKFreq+0xfdc>
 800578c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800578e:	2b00      	cmp	r3, #0
 8005790:	d004      	beq.n	800579c <HAL_RCCEx_GetPeriphCLKFreq+0xf70>
 8005792:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005794:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8005798:	d004      	beq.n	80057a4 <HAL_RCCEx_GetPeriphCLKFreq+0xf78>
 800579a:	e035      	b.n	8005808 <HAL_RCCEx_GetPeriphCLKFreq+0xfdc>
    {
      case RCC_SPI1CLKSOURCE_PCLK2:

        frequency = HAL_RCC_GetPCLK2Freq();
 800579c:	f7fd fdae 	bl	80032fc <HAL_RCC_GetPCLK2Freq>
 80057a0:	6378      	str	r0, [r7, #52]	; 0x34
        break;
 80057a2:	e1eb      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_SPI1CLKSOURCE_SYSCLK:

        frequency = HAL_RCC_GetSysClockFreq();
 80057a4:	f7fd fc7a 	bl	800309c <HAL_RCC_GetSysClockFreq>
 80057a8:	6378      	str	r0, [r7, #52]	; 0x34
        break;
 80057aa:	e1e7      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_SPI1CLKSOURCE_HSI:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 80057ac:	4b18      	ldr	r3, [pc, #96]	; (8005810 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>)
 80057ae:	681b      	ldr	r3, [r3, #0]
 80057b0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80057b4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80057b8:	d102      	bne.n	80057c0 <HAL_RCCEx_GetPeriphCLKFreq+0xf94>
        {
          frequency = HSI_VALUE;
 80057ba:	4b17      	ldr	r3, [pc, #92]	; (8005818 <HAL_RCCEx_GetPeriphCLKFreq+0xfec>)
 80057bc:	637b      	str	r3, [r7, #52]	; 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 80057be:	e1dd      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
          frequency = 0U;
 80057c0:	2300      	movs	r3, #0
 80057c2:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 80057c4:	e1da      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_SPI1CLKSOURCE_MSIK:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 80057c6:	4b12      	ldr	r3, [pc, #72]	; (8005810 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>)
 80057c8:	681b      	ldr	r3, [r3, #0]
 80057ca:	f003 0320 	and.w	r3, r3, #32
 80057ce:	2b20      	cmp	r3, #32
 80057d0:	d117      	bne.n	8005802 <HAL_RCCEx_GetPeriphCLKFreq+0xfd6>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 80057d2:	4b0f      	ldr	r3, [pc, #60]	; (8005810 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>)
 80057d4:	689b      	ldr	r3, [r3, #8]
 80057d6:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 80057da:	2b00      	cmp	r3, #0
 80057dc:	d005      	beq.n	80057ea <HAL_RCCEx_GetPeriphCLKFreq+0xfbe>
 80057de:	4b0c      	ldr	r3, [pc, #48]	; (8005810 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>)
 80057e0:	689b      	ldr	r3, [r3, #8]
 80057e2:	0e1b      	lsrs	r3, r3, #24
 80057e4:	f003 030f 	and.w	r3, r3, #15
 80057e8:	e006      	b.n	80057f8 <HAL_RCCEx_GetPeriphCLKFreq+0xfcc>
 80057ea:	4b09      	ldr	r3, [pc, #36]	; (8005810 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>)
 80057ec:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 80057f0:	041b      	lsls	r3, r3, #16
 80057f2:	0e1b      	lsrs	r3, r3, #24
 80057f4:	f003 030f 	and.w	r3, r3, #15
 80057f8:	4a06      	ldr	r2, [pc, #24]	; (8005814 <HAL_RCCEx_GetPeriphCLKFreq+0xfe8>)
 80057fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80057fe:	637b      	str	r3, [r7, #52]	; 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8005800:	e1bc      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
          frequency = 0U;
 8005802:	2300      	movs	r3, #0
 8005804:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8005806:	e1b9      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      default:

        frequency = 0U;
 8005808:	2300      	movs	r3, #0
 800580a:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 800580c:	e1b6      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
 800580e:	bf00      	nop
 8005810:	46020c00 	.word	0x46020c00
 8005814:	08017aac 	.word	0x08017aac
 8005818:	00f42400 	.word	0x00f42400
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI2)
 800581c:	e9d7 2300 	ldrd	r2, r3, [r7]
 8005820:	f102 417f 	add.w	r1, r2, #4278190080	; 0xff000000
 8005824:	430b      	orrs	r3, r1
 8005826:	d156      	bne.n	80058d6 <HAL_RCCEx_GetPeriphCLKFreq+0x10aa>
  {
    /* Get the current SPI2 kernel source */
    srcclk = __HAL_RCC_GET_SPI2_SOURCE();
 8005828:	4ba5      	ldr	r3, [pc, #660]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 800582a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800582e:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8005832:	633b      	str	r3, [r7, #48]	; 0x30
    switch (srcclk)
 8005834:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005836:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 800583a:	d028      	beq.n	800588e <HAL_RCCEx_GetPeriphCLKFreq+0x1062>
 800583c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800583e:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 8005842:	d845      	bhi.n	80058d0 <HAL_RCCEx_GetPeriphCLKFreq+0x10a4>
 8005844:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005846:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800584a:	d013      	beq.n	8005874 <HAL_RCCEx_GetPeriphCLKFreq+0x1048>
 800584c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800584e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8005852:	d83d      	bhi.n	80058d0 <HAL_RCCEx_GetPeriphCLKFreq+0x10a4>
 8005854:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005856:	2b00      	cmp	r3, #0
 8005858:	d004      	beq.n	8005864 <HAL_RCCEx_GetPeriphCLKFreq+0x1038>
 800585a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800585c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8005860:	d004      	beq.n	800586c <HAL_RCCEx_GetPeriphCLKFreq+0x1040>
 8005862:	e035      	b.n	80058d0 <HAL_RCCEx_GetPeriphCLKFreq+0x10a4>
    {
      case RCC_SPI2CLKSOURCE_PCLK1:

        frequency = HAL_RCC_GetPCLK1Freq();
 8005864:	f7fd fd36 	bl	80032d4 <HAL_RCC_GetPCLK1Freq>
 8005868:	6378      	str	r0, [r7, #52]	; 0x34
        break;
 800586a:	e187      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_SPI2CLKSOURCE_SYSCLK:

        frequency = HAL_RCC_GetSysClockFreq();
 800586c:	f7fd fc16 	bl	800309c <HAL_RCC_GetSysClockFreq>
 8005870:	6378      	str	r0, [r7, #52]	; 0x34
        break;
 8005872:	e183      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_SPI2CLKSOURCE_HSI:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8005874:	4b92      	ldr	r3, [pc, #584]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 8005876:	681b      	ldr	r3, [r3, #0]
 8005878:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800587c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8005880:	d102      	bne.n	8005888 <HAL_RCCEx_GetPeriphCLKFreq+0x105c>
        {
          frequency = HSI_VALUE;
 8005882:	4b90      	ldr	r3, [pc, #576]	; (8005ac4 <HAL_RCCEx_GetPeriphCLKFreq+0x1298>)
 8005884:	637b      	str	r3, [r7, #52]	; 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8005886:	e179      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
          frequency = 0U;
 8005888:	2300      	movs	r3, #0
 800588a:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 800588c:	e176      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_SPI2CLKSOURCE_MSIK:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 800588e:	4b8c      	ldr	r3, [pc, #560]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 8005890:	681b      	ldr	r3, [r3, #0]
 8005892:	f003 0320 	and.w	r3, r3, #32
 8005896:	2b20      	cmp	r3, #32
 8005898:	d117      	bne.n	80058ca <HAL_RCCEx_GetPeriphCLKFreq+0x109e>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 800589a:	4b89      	ldr	r3, [pc, #548]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 800589c:	689b      	ldr	r3, [r3, #8]
 800589e:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 80058a2:	2b00      	cmp	r3, #0
 80058a4:	d005      	beq.n	80058b2 <HAL_RCCEx_GetPeriphCLKFreq+0x1086>
 80058a6:	4b86      	ldr	r3, [pc, #536]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 80058a8:	689b      	ldr	r3, [r3, #8]
 80058aa:	0e1b      	lsrs	r3, r3, #24
 80058ac:	f003 030f 	and.w	r3, r3, #15
 80058b0:	e006      	b.n	80058c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1094>
 80058b2:	4b83      	ldr	r3, [pc, #524]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 80058b4:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 80058b8:	041b      	lsls	r3, r3, #16
 80058ba:	0e1b      	lsrs	r3, r3, #24
 80058bc:	f003 030f 	and.w	r3, r3, #15
 80058c0:	4a81      	ldr	r2, [pc, #516]	; (8005ac8 <HAL_RCCEx_GetPeriphCLKFreq+0x129c>)
 80058c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80058c6:	637b      	str	r3, [r7, #52]	; 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 80058c8:	e158      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
          frequency = 0U;
 80058ca:	2300      	movs	r3, #0
 80058cc:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 80058ce:	e155      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      default:

        frequency = 0U;
 80058d0:	2300      	movs	r3, #0
 80058d2:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 80058d4:	e152      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI3)
 80058d6:	e9d7 2300 	ldrd	r2, r3, [r7]
 80058da:	f102 417e 	add.w	r1, r2, #4261412864	; 0xfe000000
 80058de:	430b      	orrs	r3, r1
 80058e0:	d177      	bne.n	80059d2 <HAL_RCCEx_GetPeriphCLKFreq+0x11a6>
  {
    /* Get the current SPI3 kernel source */
    srcclk = __HAL_RCC_GET_SPI3_SOURCE();
 80058e2:	4b77      	ldr	r3, [pc, #476]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 80058e4:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 80058e8:	f003 0318 	and.w	r3, r3, #24
 80058ec:	633b      	str	r3, [r7, #48]	; 0x30
    switch (srcclk)
 80058ee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80058f0:	2b18      	cmp	r3, #24
 80058f2:	d86b      	bhi.n	80059cc <HAL_RCCEx_GetPeriphCLKFreq+0x11a0>
 80058f4:	a201      	add	r2, pc, #4	; (adr r2, 80058fc <HAL_RCCEx_GetPeriphCLKFreq+0x10d0>)
 80058f6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80058fa:	bf00      	nop
 80058fc:	08005961 	.word	0x08005961
 8005900:	080059cd 	.word	0x080059cd
 8005904:	080059cd 	.word	0x080059cd
 8005908:	080059cd 	.word	0x080059cd
 800590c:	080059cd 	.word	0x080059cd
 8005910:	080059cd 	.word	0x080059cd
 8005914:	080059cd 	.word	0x080059cd
 8005918:	080059cd 	.word	0x080059cd
 800591c:	08005969 	.word	0x08005969
 8005920:	080059cd 	.word	0x080059cd
 8005924:	080059cd 	.word	0x080059cd
 8005928:	080059cd 	.word	0x080059cd
 800592c:	080059cd 	.word	0x080059cd
 8005930:	080059cd 	.word	0x080059cd
 8005934:	080059cd 	.word	0x080059cd
 8005938:	080059cd 	.word	0x080059cd
 800593c:	08005971 	.word	0x08005971
 8005940:	080059cd 	.word	0x080059cd
 8005944:	080059cd 	.word	0x080059cd
 8005948:	080059cd 	.word	0x080059cd
 800594c:	080059cd 	.word	0x080059cd
 8005950:	080059cd 	.word	0x080059cd
 8005954:	080059cd 	.word	0x080059cd
 8005958:	080059cd 	.word	0x080059cd
 800595c:	0800598b 	.word	0x0800598b
    {
      case RCC_SPI3CLKSOURCE_PCLK3:

        frequency = HAL_RCC_GetPCLK3Freq();
 8005960:	f7fd fce0 	bl	8003324 <HAL_RCC_GetPCLK3Freq>
 8005964:	6378      	str	r0, [r7, #52]	; 0x34
        break;
 8005966:	e109      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_SPI3CLKSOURCE_SYSCLK:

        frequency = HAL_RCC_GetSysClockFreq();
 8005968:	f7fd fb98 	bl	800309c <HAL_RCC_GetSysClockFreq>
 800596c:	6378      	str	r0, [r7, #52]	; 0x34
        break;
 800596e:	e105      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_SPI3CLKSOURCE_HSI:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8005970:	4b53      	ldr	r3, [pc, #332]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 8005972:	681b      	ldr	r3, [r3, #0]
 8005974:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8005978:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800597c:	d102      	bne.n	8005984 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>
        {
          frequency = HSI_VALUE;
 800597e:	4b51      	ldr	r3, [pc, #324]	; (8005ac4 <HAL_RCCEx_GetPeriphCLKFreq+0x1298>)
 8005980:	637b      	str	r3, [r7, #52]	; 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8005982:	e0fb      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
          frequency = 0U;
 8005984:	2300      	movs	r3, #0
 8005986:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8005988:	e0f8      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_SPI3CLKSOURCE_MSIK:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 800598a:	4b4d      	ldr	r3, [pc, #308]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 800598c:	681b      	ldr	r3, [r3, #0]
 800598e:	f003 0320 	and.w	r3, r3, #32
 8005992:	2b20      	cmp	r3, #32
 8005994:	d117      	bne.n	80059c6 <HAL_RCCEx_GetPeriphCLKFreq+0x119a>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8005996:	4b4a      	ldr	r3, [pc, #296]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 8005998:	689b      	ldr	r3, [r3, #8]
 800599a:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800599e:	2b00      	cmp	r3, #0
 80059a0:	d005      	beq.n	80059ae <HAL_RCCEx_GetPeriphCLKFreq+0x1182>
 80059a2:	4b47      	ldr	r3, [pc, #284]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 80059a4:	689b      	ldr	r3, [r3, #8]
 80059a6:	0e1b      	lsrs	r3, r3, #24
 80059a8:	f003 030f 	and.w	r3, r3, #15
 80059ac:	e006      	b.n	80059bc <HAL_RCCEx_GetPeriphCLKFreq+0x1190>
 80059ae:	4b44      	ldr	r3, [pc, #272]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 80059b0:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 80059b4:	041b      	lsls	r3, r3, #16
 80059b6:	0e1b      	lsrs	r3, r3, #24
 80059b8:	f003 030f 	and.w	r3, r3, #15
 80059bc:	4a42      	ldr	r2, [pc, #264]	; (8005ac8 <HAL_RCCEx_GetPeriphCLKFreq+0x129c>)
 80059be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80059c2:	637b      	str	r3, [r7, #52]	; 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 80059c4:	e0da      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
          frequency = 0U;
 80059c6:	2300      	movs	r3, #0
 80059c8:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 80059ca:	e0d7      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      default:

        frequency = 0U;
 80059cc:	2300      	movs	r3, #0
 80059ce:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 80059d0:	e0d4      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_OSPI)
 80059d2:	e9d7 2300 	ldrd	r2, r3, [r7]
 80059d6:	f102 417c 	add.w	r1, r2, #4227858432	; 0xfc000000
 80059da:	430b      	orrs	r3, r1
 80059dc:	d155      	bne.n	8005a8a <HAL_RCCEx_GetPeriphCLKFreq+0x125e>
  {
    /* Get the current OSPI kernel source */
    srcclk = __HAL_RCC_GET_OSPI_SOURCE();
 80059de:	4b38      	ldr	r3, [pc, #224]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 80059e0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 80059e4:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 80059e8:	633b      	str	r3, [r7, #48]	; 0x30

    switch (srcclk)
 80059ea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80059ec:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 80059f0:	d013      	beq.n	8005a1a <HAL_RCCEx_GetPeriphCLKFreq+0x11ee>
 80059f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80059f4:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 80059f8:	d844      	bhi.n	8005a84 <HAL_RCCEx_GetPeriphCLKFreq+0x1258>
 80059fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80059fc:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8005a00:	d013      	beq.n	8005a2a <HAL_RCCEx_GetPeriphCLKFreq+0x11fe>
 8005a02:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005a04:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8005a08:	d83c      	bhi.n	8005a84 <HAL_RCCEx_GetPeriphCLKFreq+0x1258>
 8005a0a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005a0c:	2b00      	cmp	r3, #0
 8005a0e:	d014      	beq.n	8005a3a <HAL_RCCEx_GetPeriphCLKFreq+0x120e>
 8005a10:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005a12:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8005a16:	d014      	beq.n	8005a42 <HAL_RCCEx_GetPeriphCLKFreq+0x1216>
 8005a18:	e034      	b.n	8005a84 <HAL_RCCEx_GetPeriphCLKFreq+0x1258>
    {
      case RCC_OSPICLKSOURCE_PLL2:

        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8005a1a:	f107 0318 	add.w	r3, r7, #24
 8005a1e:	4618      	mov	r0, r3
 8005a20:	f7fe fc50 	bl	80042c4 <HAL_RCCEx_GetPLL2ClockFreq>
        frequency = pll2_clocks.PLL2_Q_Frequency;
 8005a24:	69fb      	ldr	r3, [r7, #28]
 8005a26:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8005a28:	e0a8      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_OSPICLKSOURCE_PLL1:

        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8005a2a:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8005a2e:	4618      	mov	r0, r3
 8005a30:	f7fe faee 	bl	8004010 <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_Q_Frequency;
 8005a34:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005a36:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8005a38:	e0a0      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_OSPICLKSOURCE_SYSCLK:

        frequency = HAL_RCC_GetSysClockFreq();
 8005a3a:	f7fd fb2f 	bl	800309c <HAL_RCC_GetSysClockFreq>
 8005a3e:	6378      	str	r0, [r7, #52]	; 0x34
        break;
 8005a40:	e09c      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      case RCC_OSPICLKSOURCE_MSIK:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8005a42:	4b1f      	ldr	r3, [pc, #124]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 8005a44:	681b      	ldr	r3, [r3, #0]
 8005a46:	f003 0320 	and.w	r3, r3, #32
 8005a4a:	2b20      	cmp	r3, #32
 8005a4c:	d117      	bne.n	8005a7e <HAL_RCCEx_GetPeriphCLKFreq+0x1252>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8005a4e:	4b1c      	ldr	r3, [pc, #112]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 8005a50:	689b      	ldr	r3, [r3, #8]
 8005a52:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8005a56:	2b00      	cmp	r3, #0
 8005a58:	d005      	beq.n	8005a66 <HAL_RCCEx_GetPeriphCLKFreq+0x123a>
 8005a5a:	4b19      	ldr	r3, [pc, #100]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 8005a5c:	689b      	ldr	r3, [r3, #8]
 8005a5e:	0e1b      	lsrs	r3, r3, #24
 8005a60:	f003 030f 	and.w	r3, r3, #15
 8005a64:	e006      	b.n	8005a74 <HAL_RCCEx_GetPeriphCLKFreq+0x1248>
 8005a66:	4b16      	ldr	r3, [pc, #88]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 8005a68:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8005a6c:	041b      	lsls	r3, r3, #16
 8005a6e:	0e1b      	lsrs	r3, r3, #24
 8005a70:	f003 030f 	and.w	r3, r3, #15
 8005a74:	4a14      	ldr	r2, [pc, #80]	; (8005ac8 <HAL_RCCEx_GetPeriphCLKFreq+0x129c>)
 8005a76:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8005a7a:	637b      	str	r3, [r7, #52]	; 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8005a7c:	e07e      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
          frequency = 0U;
 8005a7e:	2300      	movs	r3, #0
 8005a80:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8005a82:	e07b      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>

      default:

        frequency = 0U;
 8005a84:	2300      	movs	r3, #0
 8005a86:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 8005a88:	e078      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
        frequency = 0U;
        break;
    }
  }
#endif /* defined(HSPI1) */
  else if (PeriphClk == RCC_PERIPHCLK_DAC1)
 8005a8a:	e9d7 2300 	ldrd	r2, r3, [r7]
 8005a8e:	f102 4170 	add.w	r1, r2, #4026531840	; 0xf0000000
 8005a92:	430b      	orrs	r3, r1
 8005a94:	d138      	bne.n	8005b08 <HAL_RCCEx_GetPeriphCLKFreq+0x12dc>
  {
    /* Get the current DAC1 kernel source */
    srcclk = __HAL_RCC_GET_DAC1_SOURCE();
 8005a96:	4b0a      	ldr	r3, [pc, #40]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 8005a98:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8005a9c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8005aa0:	633b      	str	r3, [r7, #48]	; 0x30

    /* Check if LSE is ready and if DAC1 clock selection is LSE */
    if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_DAC1CLKSOURCE_LSE))
 8005aa2:	4b07      	ldr	r3, [pc, #28]	; (8005ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1294>)
 8005aa4:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8005aa8:	f003 0302 	and.w	r3, r3, #2
 8005aac:	2b02      	cmp	r3, #2
 8005aae:	d10d      	bne.n	8005acc <HAL_RCCEx_GetPeriphCLKFreq+0x12a0>
 8005ab0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005ab2:	2b00      	cmp	r3, #0
 8005ab4:	d10a      	bne.n	8005acc <HAL_RCCEx_GetPeriphCLKFreq+0x12a0>
    {
      frequency = LSE_VALUE;
 8005ab6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8005aba:	637b      	str	r3, [r7, #52]	; 0x34
 8005abc:	e05e      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
 8005abe:	bf00      	nop
 8005ac0:	46020c00 	.word	0x46020c00
 8005ac4:	00f42400 	.word	0x00f42400
 8005ac8:	08017aac 	.word	0x08017aac
    }
    /* Check if LSI is ready and if DAC1 clock selection is LSI */
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_DAC1CLKSOURCE_LSI))
 8005acc:	4b2e      	ldr	r3, [pc, #184]	; (8005b88 <HAL_RCCEx_GetPeriphCLKFreq+0x135c>)
 8005ace:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8005ad2:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8005ad6:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8005ada:	d112      	bne.n	8005b02 <HAL_RCCEx_GetPeriphCLKFreq+0x12d6>
 8005adc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005ade:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8005ae2:	d10e      	bne.n	8005b02 <HAL_RCCEx_GetPeriphCLKFreq+0x12d6>
    {
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8005ae4:	4b28      	ldr	r3, [pc, #160]	; (8005b88 <HAL_RCCEx_GetPeriphCLKFreq+0x135c>)
 8005ae6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8005aea:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8005aee:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8005af2:	d102      	bne.n	8005afa <HAL_RCCEx_GetPeriphCLKFreq+0x12ce>
      {
        frequency = LSI_VALUE / 128U;
 8005af4:	23fa      	movs	r3, #250	; 0xfa
 8005af6:	637b      	str	r3, [r7, #52]	; 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8005af8:	e040      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
      else
      {
        frequency = LSI_VALUE;
 8005afa:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
 8005afe:	637b      	str	r3, [r7, #52]	; 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8005b00:	e03c      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
      }
    }
    /* Clock not enabled for DAC1*/
    else
    {
      frequency = 0U;
 8005b02:	2300      	movs	r3, #0
 8005b04:	637b      	str	r3, [r7, #52]	; 0x34
 8005b06:	e039      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }

  }
  else if (PeriphClk == RCC_PERIPHCLK_RNG)
 8005b08:	e9d7 2300 	ldrd	r2, r3, [r7]
 8005b0c:	f5a2 2100 	sub.w	r1, r2, #524288	; 0x80000
 8005b10:	430b      	orrs	r3, r1
 8005b12:	d131      	bne.n	8005b78 <HAL_RCCEx_GetPeriphCLKFreq+0x134c>
  {
    /* Get the current RNG kernel source */
    srcclk = __HAL_RCC_GET_RNG_SOURCE();
 8005b14:	4b1c      	ldr	r3, [pc, #112]	; (8005b88 <HAL_RCCEx_GetPeriphCLKFreq+0x135c>)
 8005b16:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 8005b1a:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 8005b1e:	633b      	str	r3, [r7, #48]	; 0x30

    /* Check if HSI48 is ready and if RNG clock selection is HSI48 */
    if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI48))
 8005b20:	4b19      	ldr	r3, [pc, #100]	; (8005b88 <HAL_RCCEx_GetPeriphCLKFreq+0x135c>)
 8005b22:	681b      	ldr	r3, [r3, #0]
 8005b24:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8005b28:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8005b2c:	d105      	bne.n	8005b3a <HAL_RCCEx_GetPeriphCLKFreq+0x130e>
 8005b2e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005b30:	2b00      	cmp	r3, #0
 8005b32:	d102      	bne.n	8005b3a <HAL_RCCEx_GetPeriphCLKFreq+0x130e>
    {
      frequency = HSI48_VALUE;
 8005b34:	4b15      	ldr	r3, [pc, #84]	; (8005b8c <HAL_RCCEx_GetPeriphCLKFreq+0x1360>)
 8005b36:	637b      	str	r3, [r7, #52]	; 0x34
 8005b38:	e020      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }

    /* Check if HSI48 is ready and if RNG clock selection is HSI48_DIV2 */
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI48_DIV2))
 8005b3a:	4b13      	ldr	r3, [pc, #76]	; (8005b88 <HAL_RCCEx_GetPeriphCLKFreq+0x135c>)
 8005b3c:	681b      	ldr	r3, [r3, #0]
 8005b3e:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8005b42:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8005b46:	d106      	bne.n	8005b56 <HAL_RCCEx_GetPeriphCLKFreq+0x132a>
 8005b48:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005b4a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8005b4e:	d102      	bne.n	8005b56 <HAL_RCCEx_GetPeriphCLKFreq+0x132a>
    {
      frequency = HSI48_VALUE >> 1U ;
 8005b50:	4b0f      	ldr	r3, [pc, #60]	; (8005b90 <HAL_RCCEx_GetPeriphCLKFreq+0x1364>)
 8005b52:	637b      	str	r3, [r7, #52]	; 0x34
 8005b54:	e012      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }

    /* Check if HSI is ready and if RNG clock selection is HSI */
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI))
 8005b56:	4b0c      	ldr	r3, [pc, #48]	; (8005b88 <HAL_RCCEx_GetPeriphCLKFreq+0x135c>)
 8005b58:	681b      	ldr	r3, [r3, #0]
 8005b5a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8005b5e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8005b62:	d106      	bne.n	8005b72 <HAL_RCCEx_GetPeriphCLKFreq+0x1346>
 8005b64:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005b66:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8005b6a:	d102      	bne.n	8005b72 <HAL_RCCEx_GetPeriphCLKFreq+0x1346>
    {
      frequency = HSI_VALUE;
 8005b6c:	4b09      	ldr	r3, [pc, #36]	; (8005b94 <HAL_RCCEx_GetPeriphCLKFreq+0x1368>)
 8005b6e:	637b      	str	r3, [r7, #52]	; 0x34
 8005b70:	e004      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
    }
    /* Clock not enabled for RNG */
    else
    {
      frequency = 0U;
 8005b72:	2300      	movs	r3, #0
 8005b74:	637b      	str	r3, [r7, #52]	; 0x34
 8005b76:	e001      	b.n	8005b7c <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
  }
#endif /* defined(USB_OTG_HS) */

  else
  {
    frequency = 0;
 8005b78:	2300      	movs	r3, #0
 8005b7a:	637b      	str	r3, [r7, #52]	; 0x34
  }
  return (frequency);
 8005b7c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 8005b7e:	4618      	mov	r0, r3
 8005b80:	3738      	adds	r7, #56	; 0x38
 8005b82:	46bd      	mov	sp, r7
 8005b84:	bd80      	pop	{r7, pc}
 8005b86:	bf00      	nop
 8005b88:	46020c00 	.word	0x46020c00
 8005b8c:	02dc6c00 	.word	0x02dc6c00
 8005b90:	016e3600 	.word	0x016e3600
 8005b94:	00f42400 	.word	0x00f42400

08005b98 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(const RCC_PLL2InitTypeDef *pll2)
{
 8005b98:	b580      	push	{r7, lr}
 8005b9a:	b084      	sub	sp, #16
 8005b9c:	af00      	add	r7, sp, #0
 8005b9e:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_PLLP_VALUE(pll2->PLL2P));
  assert_param(IS_RCC_PLLQ_VALUE(pll2->PLL2Q));
  assert_param(IS_RCC_PLLR_VALUE(pll2->PLL2R));

  /* Disable  PLL2 */
  __HAL_RCC_PLL2_DISABLE();
 8005ba0:	4b47      	ldr	r3, [pc, #284]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005ba2:	681b      	ldr	r3, [r3, #0]
 8005ba4:	4a46      	ldr	r2, [pc, #280]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005ba6:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8005baa:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8005bac:	f7fb fd72 	bl	8001694 <HAL_GetTick>
 8005bb0:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 8005bb2:	e008      	b.n	8005bc6 <RCCEx_PLL2_Config+0x2e>
  {
    if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 8005bb4:	f7fb fd6e 	bl	8001694 <HAL_GetTick>
 8005bb8:	4602      	mov	r2, r0
 8005bba:	68fb      	ldr	r3, [r7, #12]
 8005bbc:	1ad3      	subs	r3, r2, r3
 8005bbe:	2b02      	cmp	r3, #2
 8005bc0:	d901      	bls.n	8005bc6 <RCCEx_PLL2_Config+0x2e>
    {
      return HAL_TIMEOUT;
 8005bc2:	2303      	movs	r3, #3
 8005bc4:	e077      	b.n	8005cb6 <RCCEx_PLL2_Config+0x11e>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 8005bc6:	4b3e      	ldr	r3, [pc, #248]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005bc8:	681b      	ldr	r3, [r3, #0]
 8005bca:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8005bce:	2b00      	cmp	r3, #0
 8005bd0:	d1f0      	bne.n	8005bb4 <RCCEx_PLL2_Config+0x1c>
    }
  }

  /* Configure PLL2 multiplication and division factors */
  __HAL_RCC_PLL2_CONFIG(pll2->PLL2Source,
 8005bd2:	4b3b      	ldr	r3, [pc, #236]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005bd4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005bd6:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8005bda:	f023 0303 	bic.w	r3, r3, #3
 8005bde:	687a      	ldr	r2, [r7, #4]
 8005be0:	6811      	ldr	r1, [r2, #0]
 8005be2:	687a      	ldr	r2, [r7, #4]
 8005be4:	6852      	ldr	r2, [r2, #4]
 8005be6:	3a01      	subs	r2, #1
 8005be8:	0212      	lsls	r2, r2, #8
 8005bea:	430a      	orrs	r2, r1
 8005bec:	4934      	ldr	r1, [pc, #208]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005bee:	4313      	orrs	r3, r2
 8005bf0:	62cb      	str	r3, [r1, #44]	; 0x2c
 8005bf2:	4b33      	ldr	r3, [pc, #204]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005bf4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8005bf6:	4b33      	ldr	r3, [pc, #204]	; (8005cc4 <RCCEx_PLL2_Config+0x12c>)
 8005bf8:	4013      	ands	r3, r2
 8005bfa:	687a      	ldr	r2, [r7, #4]
 8005bfc:	6892      	ldr	r2, [r2, #8]
 8005bfe:	3a01      	subs	r2, #1
 8005c00:	f3c2 0108 	ubfx	r1, r2, #0, #9
 8005c04:	687a      	ldr	r2, [r7, #4]
 8005c06:	68d2      	ldr	r2, [r2, #12]
 8005c08:	3a01      	subs	r2, #1
 8005c0a:	0252      	lsls	r2, r2, #9
 8005c0c:	b292      	uxth	r2, r2
 8005c0e:	4311      	orrs	r1, r2
 8005c10:	687a      	ldr	r2, [r7, #4]
 8005c12:	6912      	ldr	r2, [r2, #16]
 8005c14:	3a01      	subs	r2, #1
 8005c16:	0412      	lsls	r2, r2, #16
 8005c18:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
 8005c1c:	4311      	orrs	r1, r2
 8005c1e:	687a      	ldr	r2, [r7, #4]
 8005c20:	6952      	ldr	r2, [r2, #20]
 8005c22:	3a01      	subs	r2, #1
 8005c24:	0612      	lsls	r2, r2, #24
 8005c26:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
 8005c2a:	430a      	orrs	r2, r1
 8005c2c:	4924      	ldr	r1, [pc, #144]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005c2e:	4313      	orrs	r3, r2
 8005c30:	63cb      	str	r3, [r1, #60]	; 0x3c
                        pll2->PLL2P,
                        pll2->PLL2Q,
                        pll2->PLL2R);

  /* Select PLL2 input reference frequency range: VCI */
  __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE);
 8005c32:	4b23      	ldr	r3, [pc, #140]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005c34:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005c36:	f023 020c 	bic.w	r2, r3, #12
 8005c3a:	687b      	ldr	r3, [r7, #4]
 8005c3c:	699b      	ldr	r3, [r3, #24]
 8005c3e:	4920      	ldr	r1, [pc, #128]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005c40:	4313      	orrs	r3, r2
 8005c42:	62cb      	str	r3, [r1, #44]	; 0x2c

  /* Configure the PLL2 Clock output(s) */
  __HAL_RCC_PLL2CLKOUT_ENABLE(pll2->PLL2ClockOut);
 8005c44:	4b1e      	ldr	r3, [pc, #120]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005c46:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005c48:	687b      	ldr	r3, [r7, #4]
 8005c4a:	6a1b      	ldr	r3, [r3, #32]
 8005c4c:	491c      	ldr	r1, [pc, #112]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005c4e:	4313      	orrs	r3, r2
 8005c50:	62cb      	str	r3, [r1, #44]	; 0x2c

  /* Disable PLL2FRACN  */
  __HAL_RCC_PLL2FRACN_DISABLE();
 8005c52:	4b1b      	ldr	r3, [pc, #108]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005c54:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005c56:	4a1a      	ldr	r2, [pc, #104]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005c58:	f023 0310 	bic.w	r3, r3, #16
 8005c5c:	62d3      	str	r3, [r2, #44]	; 0x2c

  /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
  __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 8005c5e:	4b18      	ldr	r3, [pc, #96]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005c60:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005c62:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8005c66:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8005c6a:	687a      	ldr	r2, [r7, #4]
 8005c6c:	69d2      	ldr	r2, [r2, #28]
 8005c6e:	00d2      	lsls	r2, r2, #3
 8005c70:	4913      	ldr	r1, [pc, #76]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005c72:	4313      	orrs	r3, r2
 8005c74:	640b      	str	r3, [r1, #64]	; 0x40

  /* Enable PLL2FRACN  */
  __HAL_RCC_PLL2FRACN_ENABLE();
 8005c76:	4b12      	ldr	r3, [pc, #72]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005c78:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005c7a:	4a11      	ldr	r2, [pc, #68]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005c7c:	f043 0310 	orr.w	r3, r3, #16
 8005c80:	62d3      	str	r3, [r2, #44]	; 0x2c

  /* Enable  PLL2 */
  __HAL_RCC_PLL2_ENABLE();
 8005c82:	4b0f      	ldr	r3, [pc, #60]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005c84:	681b      	ldr	r3, [r3, #0]
 8005c86:	4a0e      	ldr	r2, [pc, #56]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005c88:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8005c8c:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8005c8e:	f7fb fd01 	bl	8001694 <HAL_GetTick>
 8005c92:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL2 is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 8005c94:	e008      	b.n	8005ca8 <RCCEx_PLL2_Config+0x110>
  {
    if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 8005c96:	f7fb fcfd 	bl	8001694 <HAL_GetTick>
 8005c9a:	4602      	mov	r2, r0
 8005c9c:	68fb      	ldr	r3, [r7, #12]
 8005c9e:	1ad3      	subs	r3, r2, r3
 8005ca0:	2b02      	cmp	r3, #2
 8005ca2:	d901      	bls.n	8005ca8 <RCCEx_PLL2_Config+0x110>
    {
      return HAL_TIMEOUT;
 8005ca4:	2303      	movs	r3, #3
 8005ca6:	e006      	b.n	8005cb6 <RCCEx_PLL2_Config+0x11e>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 8005ca8:	4b05      	ldr	r3, [pc, #20]	; (8005cc0 <RCCEx_PLL2_Config+0x128>)
 8005caa:	681b      	ldr	r3, [r3, #0]
 8005cac:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8005cb0:	2b00      	cmp	r3, #0
 8005cb2:	d0f0      	beq.n	8005c96 <RCCEx_PLL2_Config+0xfe>
    }
  }
  return HAL_OK;
 8005cb4:	2300      	movs	r3, #0

}
 8005cb6:	4618      	mov	r0, r3
 8005cb8:	3710      	adds	r7, #16
 8005cba:	46bd      	mov	sp, r7
 8005cbc:	bd80      	pop	{r7, pc}
 8005cbe:	bf00      	nop
 8005cc0:	46020c00 	.word	0x46020c00
 8005cc4:	80800000 	.word	0x80800000

08005cc8 <RCCEx_PLL3_Config>:
  *         contains the configuration parameters as well as VCI clock ranges.
  * @note   PLL3 is temporary disabled to apply new parameters
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(const RCC_PLL3InitTypeDef *pll3)
{
 8005cc8:	b580      	push	{r7, lr}
 8005cca:	b084      	sub	sp, #16
 8005ccc:	af00      	add	r7, sp, #0
 8005cce:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_PLLP_VALUE(pll3->PLL3P));
  assert_param(IS_RCC_PLLQ_VALUE(pll3->PLL3Q));
  assert_param(IS_RCC_PLLR_VALUE(pll3->PLL3R));

  /* Disable  PLL3 */
  __HAL_RCC_PLL3_DISABLE();
 8005cd0:	4b47      	ldr	r3, [pc, #284]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005cd2:	681b      	ldr	r3, [r3, #0]
 8005cd4:	4a46      	ldr	r2, [pc, #280]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005cd6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8005cda:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8005cdc:	f7fb fcda 	bl	8001694 <HAL_GetTick>
 8005ce0:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 8005ce2:	e008      	b.n	8005cf6 <RCCEx_PLL3_Config+0x2e>
  {
    if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 8005ce4:	f7fb fcd6 	bl	8001694 <HAL_GetTick>
 8005ce8:	4602      	mov	r2, r0
 8005cea:	68fb      	ldr	r3, [r7, #12]
 8005cec:	1ad3      	subs	r3, r2, r3
 8005cee:	2b02      	cmp	r3, #2
 8005cf0:	d901      	bls.n	8005cf6 <RCCEx_PLL3_Config+0x2e>
    {
      return HAL_TIMEOUT;
 8005cf2:	2303      	movs	r3, #3
 8005cf4:	e077      	b.n	8005de6 <RCCEx_PLL3_Config+0x11e>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 8005cf6:	4b3e      	ldr	r3, [pc, #248]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005cf8:	681b      	ldr	r3, [r3, #0]
 8005cfa:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8005cfe:	2b00      	cmp	r3, #0
 8005d00:	d1f0      	bne.n	8005ce4 <RCCEx_PLL3_Config+0x1c>
    }
  }

  /* Configure PLL3 multiplication and division factors */
  __HAL_RCC_PLL3_CONFIG(pll3->PLL3Source,
 8005d02:	4b3b      	ldr	r3, [pc, #236]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005d04:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005d06:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8005d0a:	f023 0303 	bic.w	r3, r3, #3
 8005d0e:	687a      	ldr	r2, [r7, #4]
 8005d10:	6811      	ldr	r1, [r2, #0]
 8005d12:	687a      	ldr	r2, [r7, #4]
 8005d14:	6852      	ldr	r2, [r2, #4]
 8005d16:	3a01      	subs	r2, #1
 8005d18:	0212      	lsls	r2, r2, #8
 8005d1a:	430a      	orrs	r2, r1
 8005d1c:	4934      	ldr	r1, [pc, #208]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005d1e:	4313      	orrs	r3, r2
 8005d20:	630b      	str	r3, [r1, #48]	; 0x30
 8005d22:	4b33      	ldr	r3, [pc, #204]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005d24:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8005d26:	4b33      	ldr	r3, [pc, #204]	; (8005df4 <RCCEx_PLL3_Config+0x12c>)
 8005d28:	4013      	ands	r3, r2
 8005d2a:	687a      	ldr	r2, [r7, #4]
 8005d2c:	6892      	ldr	r2, [r2, #8]
 8005d2e:	3a01      	subs	r2, #1
 8005d30:	f3c2 0108 	ubfx	r1, r2, #0, #9
 8005d34:	687a      	ldr	r2, [r7, #4]
 8005d36:	68d2      	ldr	r2, [r2, #12]
 8005d38:	3a01      	subs	r2, #1
 8005d3a:	0252      	lsls	r2, r2, #9
 8005d3c:	b292      	uxth	r2, r2
 8005d3e:	4311      	orrs	r1, r2
 8005d40:	687a      	ldr	r2, [r7, #4]
 8005d42:	6912      	ldr	r2, [r2, #16]
 8005d44:	3a01      	subs	r2, #1
 8005d46:	0412      	lsls	r2, r2, #16
 8005d48:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
 8005d4c:	4311      	orrs	r1, r2
 8005d4e:	687a      	ldr	r2, [r7, #4]
 8005d50:	6952      	ldr	r2, [r2, #20]
 8005d52:	3a01      	subs	r2, #1
 8005d54:	0612      	lsls	r2, r2, #24
 8005d56:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
 8005d5a:	430a      	orrs	r2, r1
 8005d5c:	4924      	ldr	r1, [pc, #144]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005d5e:	4313      	orrs	r3, r2
 8005d60:	644b      	str	r3, [r1, #68]	; 0x44
                        pll3->PLL3P,
                        pll3->PLL3Q,
                        pll3->PLL3R);

  /* Select PLL3 input reference frequency range: VCI */
  __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE);
 8005d62:	4b23      	ldr	r3, [pc, #140]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005d64:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005d66:	f023 020c 	bic.w	r2, r3, #12
 8005d6a:	687b      	ldr	r3, [r7, #4]
 8005d6c:	699b      	ldr	r3, [r3, #24]
 8005d6e:	4920      	ldr	r1, [pc, #128]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005d70:	4313      	orrs	r3, r2
 8005d72:	630b      	str	r3, [r1, #48]	; 0x30

  /* Configure the PLL3 Clock output(s) */
  __HAL_RCC_PLL3CLKOUT_ENABLE(pll3->PLL3ClockOut);
 8005d74:	4b1e      	ldr	r3, [pc, #120]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005d76:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005d78:	687b      	ldr	r3, [r7, #4]
 8005d7a:	6a1b      	ldr	r3, [r3, #32]
 8005d7c:	491c      	ldr	r1, [pc, #112]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005d7e:	4313      	orrs	r3, r2
 8005d80:	630b      	str	r3, [r1, #48]	; 0x30

  /* Disable PLL3FRACN  */
  __HAL_RCC_PLL3FRACN_DISABLE();
 8005d82:	4b1b      	ldr	r3, [pc, #108]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005d84:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005d86:	4a1a      	ldr	r2, [pc, #104]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005d88:	f023 0310 	bic.w	r3, r3, #16
 8005d8c:	6313      	str	r3, [r2, #48]	; 0x30

  /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
  __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 8005d8e:	4b18      	ldr	r3, [pc, #96]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005d90:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8005d92:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8005d96:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8005d9a:	687a      	ldr	r2, [r7, #4]
 8005d9c:	69d2      	ldr	r2, [r2, #28]
 8005d9e:	00d2      	lsls	r2, r2, #3
 8005da0:	4913      	ldr	r1, [pc, #76]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005da2:	4313      	orrs	r3, r2
 8005da4:	648b      	str	r3, [r1, #72]	; 0x48

  /* Enable PLL3FRACN  */
  __HAL_RCC_PLL3FRACN_ENABLE();
 8005da6:	4b12      	ldr	r3, [pc, #72]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005da8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005daa:	4a11      	ldr	r2, [pc, #68]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005dac:	f043 0310 	orr.w	r3, r3, #16
 8005db0:	6313      	str	r3, [r2, #48]	; 0x30

  /* Enable  PLL3 */
  __HAL_RCC_PLL3_ENABLE();
 8005db2:	4b0f      	ldr	r3, [pc, #60]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005db4:	681b      	ldr	r3, [r3, #0]
 8005db6:	4a0e      	ldr	r2, [pc, #56]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005db8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8005dbc:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8005dbe:	f7fb fc69 	bl	8001694 <HAL_GetTick>
 8005dc2:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL3 is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 8005dc4:	e008      	b.n	8005dd8 <RCCEx_PLL3_Config+0x110>
  {
    if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 8005dc6:	f7fb fc65 	bl	8001694 <HAL_GetTick>
 8005dca:	4602      	mov	r2, r0
 8005dcc:	68fb      	ldr	r3, [r7, #12]
 8005dce:	1ad3      	subs	r3, r2, r3
 8005dd0:	2b02      	cmp	r3, #2
 8005dd2:	d901      	bls.n	8005dd8 <RCCEx_PLL3_Config+0x110>
    {
      return HAL_TIMEOUT;
 8005dd4:	2303      	movs	r3, #3
 8005dd6:	e006      	b.n	8005de6 <RCCEx_PLL3_Config+0x11e>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 8005dd8:	4b05      	ldr	r3, [pc, #20]	; (8005df0 <RCCEx_PLL3_Config+0x128>)
 8005dda:	681b      	ldr	r3, [r3, #0]
 8005ddc:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8005de0:	2b00      	cmp	r3, #0
 8005de2:	d0f0      	beq.n	8005dc6 <RCCEx_PLL3_Config+0xfe>
    }
  }
  return HAL_OK;
 8005de4:	2300      	movs	r3, #0
}
 8005de6:	4618      	mov	r0, r3
 8005de8:	3710      	adds	r7, #16
 8005dea:	46bd      	mov	sp, r7
 8005dec:	bd80      	pop	{r7, pc}
 8005dee:	bf00      	nop
 8005df0:	46020c00 	.word	0x46020c00
 8005df4:	80800000 	.word	0x80800000

08005df8 <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 8005df8:	b580      	push	{r7, lr}
 8005dfa:	b082      	sub	sp, #8
 8005dfc:	af00      	add	r7, sp, #0
 8005dfe:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 8005e00:	687b      	ldr	r3, [r7, #4]
 8005e02:	2b00      	cmp	r3, #0
 8005e04:	d101      	bne.n	8005e0a <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 8005e06:	2301      	movs	r3, #1
 8005e08:	e049      	b.n	8005e9e <HAL_TIM_Base_Init+0xa6>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 8005e0a:	687b      	ldr	r3, [r7, #4]
 8005e0c:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8005e10:	b2db      	uxtb	r3, r3
 8005e12:	2b00      	cmp	r3, #0
 8005e14:	d106      	bne.n	8005e24 <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 8005e16:	687b      	ldr	r3, [r7, #4]
 8005e18:	2200      	movs	r2, #0
 8005e1a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 8005e1e:	6878      	ldr	r0, [r7, #4]
 8005e20:	f000 f841 	bl	8005ea6 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8005e24:	687b      	ldr	r3, [r7, #4]
 8005e26:	2202      	movs	r2, #2
 8005e28:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8005e2c:	687b      	ldr	r3, [r7, #4]
 8005e2e:	681a      	ldr	r2, [r3, #0]
 8005e30:	687b      	ldr	r3, [r7, #4]
 8005e32:	3304      	adds	r3, #4
 8005e34:	4619      	mov	r1, r3
 8005e36:	4610      	mov	r0, r2
 8005e38:	f000 fa58 	bl	80062ec <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8005e3c:	687b      	ldr	r3, [r7, #4]
 8005e3e:	2201      	movs	r2, #1
 8005e40:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8005e44:	687b      	ldr	r3, [r7, #4]
 8005e46:	2201      	movs	r2, #1
 8005e48:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 8005e4c:	687b      	ldr	r3, [r7, #4]
 8005e4e:	2201      	movs	r2, #1
 8005e50:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
 8005e54:	687b      	ldr	r3, [r7, #4]
 8005e56:	2201      	movs	r2, #1
 8005e58:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 8005e5c:	687b      	ldr	r3, [r7, #4]
 8005e5e:	2201      	movs	r2, #1
 8005e60:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
 8005e64:	687b      	ldr	r3, [r7, #4]
 8005e66:	2201      	movs	r2, #1
 8005e68:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 8005e6c:	687b      	ldr	r3, [r7, #4]
 8005e6e:	2201      	movs	r2, #1
 8005e70:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8005e74:	687b      	ldr	r3, [r7, #4]
 8005e76:	2201      	movs	r2, #1
 8005e78:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 8005e7c:	687b      	ldr	r3, [r7, #4]
 8005e7e:	2201      	movs	r2, #1
 8005e80:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 8005e84:	687b      	ldr	r3, [r7, #4]
 8005e86:	2201      	movs	r2, #1
 8005e88:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
 8005e8c:	687b      	ldr	r3, [r7, #4]
 8005e8e:	2201      	movs	r2, #1
 8005e90:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 8005e94:	687b      	ldr	r3, [r7, #4]
 8005e96:	2201      	movs	r2, #1
 8005e98:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 8005e9c:	2300      	movs	r3, #0
}
 8005e9e:	4618      	mov	r0, r3
 8005ea0:	3708      	adds	r7, #8
 8005ea2:	46bd      	mov	sp, r7
 8005ea4:	bd80      	pop	{r7, pc}

08005ea6 <HAL_TIM_Base_MspInit>:
  * @brief  Initializes the TIM Base MSP.
  * @param  htim TIM Base handle
  * @retval None
  */
__weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
{
 8005ea6:	b480      	push	{r7}
 8005ea8:	b083      	sub	sp, #12
 8005eaa:	af00      	add	r7, sp, #0
 8005eac:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 8005eae:	bf00      	nop
 8005eb0:	370c      	adds	r7, #12
 8005eb2:	46bd      	mov	sp, r7
 8005eb4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005eb8:	4770      	bx	lr
	...

08005ebc <HAL_TIM_Base_Start_IT>:
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
{
 8005ebc:	b480      	push	{r7}
 8005ebe:	b085      	sub	sp, #20
 8005ec0:	af00      	add	r7, sp, #0
 8005ec2:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 8005ec4:	687b      	ldr	r3, [r7, #4]
 8005ec6:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8005eca:	b2db      	uxtb	r3, r3
 8005ecc:	2b01      	cmp	r3, #1
 8005ece:	d001      	beq.n	8005ed4 <HAL_TIM_Base_Start_IT+0x18>
  {
    return HAL_ERROR;
 8005ed0:	2301      	movs	r3, #1
 8005ed2:	e072      	b.n	8005fba <HAL_TIM_Base_Start_IT+0xfe>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8005ed4:	687b      	ldr	r3, [r7, #4]
 8005ed6:	2202      	movs	r2, #2
 8005ed8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8005edc:	687b      	ldr	r3, [r7, #4]
 8005ede:	681b      	ldr	r3, [r3, #0]
 8005ee0:	68da      	ldr	r2, [r3, #12]
 8005ee2:	687b      	ldr	r3, [r7, #4]
 8005ee4:	681b      	ldr	r3, [r3, #0]
 8005ee6:	f042 0201 	orr.w	r2, r2, #1
 8005eea:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8005eec:	687b      	ldr	r3, [r7, #4]
 8005eee:	681b      	ldr	r3, [r3, #0]
 8005ef0:	4a35      	ldr	r2, [pc, #212]	; (8005fc8 <HAL_TIM_Base_Start_IT+0x10c>)
 8005ef2:	4293      	cmp	r3, r2
 8005ef4:	d040      	beq.n	8005f78 <HAL_TIM_Base_Start_IT+0xbc>
 8005ef6:	687b      	ldr	r3, [r7, #4]
 8005ef8:	681b      	ldr	r3, [r3, #0]
 8005efa:	4a34      	ldr	r2, [pc, #208]	; (8005fcc <HAL_TIM_Base_Start_IT+0x110>)
 8005efc:	4293      	cmp	r3, r2
 8005efe:	d03b      	beq.n	8005f78 <HAL_TIM_Base_Start_IT+0xbc>
 8005f00:	687b      	ldr	r3, [r7, #4]
 8005f02:	681b      	ldr	r3, [r3, #0]
 8005f04:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8005f08:	d036      	beq.n	8005f78 <HAL_TIM_Base_Start_IT+0xbc>
 8005f0a:	687b      	ldr	r3, [r7, #4]
 8005f0c:	681b      	ldr	r3, [r3, #0]
 8005f0e:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8005f12:	d031      	beq.n	8005f78 <HAL_TIM_Base_Start_IT+0xbc>
 8005f14:	687b      	ldr	r3, [r7, #4]
 8005f16:	681b      	ldr	r3, [r3, #0]
 8005f18:	4a2d      	ldr	r2, [pc, #180]	; (8005fd0 <HAL_TIM_Base_Start_IT+0x114>)
 8005f1a:	4293      	cmp	r3, r2
 8005f1c:	d02c      	beq.n	8005f78 <HAL_TIM_Base_Start_IT+0xbc>
 8005f1e:	687b      	ldr	r3, [r7, #4]
 8005f20:	681b      	ldr	r3, [r3, #0]
 8005f22:	4a2c      	ldr	r2, [pc, #176]	; (8005fd4 <HAL_TIM_Base_Start_IT+0x118>)
 8005f24:	4293      	cmp	r3, r2
 8005f26:	d027      	beq.n	8005f78 <HAL_TIM_Base_Start_IT+0xbc>
 8005f28:	687b      	ldr	r3, [r7, #4]
 8005f2a:	681b      	ldr	r3, [r3, #0]
 8005f2c:	4a2a      	ldr	r2, [pc, #168]	; (8005fd8 <HAL_TIM_Base_Start_IT+0x11c>)
 8005f2e:	4293      	cmp	r3, r2
 8005f30:	d022      	beq.n	8005f78 <HAL_TIM_Base_Start_IT+0xbc>
 8005f32:	687b      	ldr	r3, [r7, #4]
 8005f34:	681b      	ldr	r3, [r3, #0]
 8005f36:	4a29      	ldr	r2, [pc, #164]	; (8005fdc <HAL_TIM_Base_Start_IT+0x120>)
 8005f38:	4293      	cmp	r3, r2
 8005f3a:	d01d      	beq.n	8005f78 <HAL_TIM_Base_Start_IT+0xbc>
 8005f3c:	687b      	ldr	r3, [r7, #4]
 8005f3e:	681b      	ldr	r3, [r3, #0]
 8005f40:	4a27      	ldr	r2, [pc, #156]	; (8005fe0 <HAL_TIM_Base_Start_IT+0x124>)
 8005f42:	4293      	cmp	r3, r2
 8005f44:	d018      	beq.n	8005f78 <HAL_TIM_Base_Start_IT+0xbc>
 8005f46:	687b      	ldr	r3, [r7, #4]
 8005f48:	681b      	ldr	r3, [r3, #0]
 8005f4a:	4a26      	ldr	r2, [pc, #152]	; (8005fe4 <HAL_TIM_Base_Start_IT+0x128>)
 8005f4c:	4293      	cmp	r3, r2
 8005f4e:	d013      	beq.n	8005f78 <HAL_TIM_Base_Start_IT+0xbc>
 8005f50:	687b      	ldr	r3, [r7, #4]
 8005f52:	681b      	ldr	r3, [r3, #0]
 8005f54:	4a24      	ldr	r2, [pc, #144]	; (8005fe8 <HAL_TIM_Base_Start_IT+0x12c>)
 8005f56:	4293      	cmp	r3, r2
 8005f58:	d00e      	beq.n	8005f78 <HAL_TIM_Base_Start_IT+0xbc>
 8005f5a:	687b      	ldr	r3, [r7, #4]
 8005f5c:	681b      	ldr	r3, [r3, #0]
 8005f5e:	4a23      	ldr	r2, [pc, #140]	; (8005fec <HAL_TIM_Base_Start_IT+0x130>)
 8005f60:	4293      	cmp	r3, r2
 8005f62:	d009      	beq.n	8005f78 <HAL_TIM_Base_Start_IT+0xbc>
 8005f64:	687b      	ldr	r3, [r7, #4]
 8005f66:	681b      	ldr	r3, [r3, #0]
 8005f68:	4a21      	ldr	r2, [pc, #132]	; (8005ff0 <HAL_TIM_Base_Start_IT+0x134>)
 8005f6a:	4293      	cmp	r3, r2
 8005f6c:	d004      	beq.n	8005f78 <HAL_TIM_Base_Start_IT+0xbc>
 8005f6e:	687b      	ldr	r3, [r7, #4]
 8005f70:	681b      	ldr	r3, [r3, #0]
 8005f72:	4a20      	ldr	r2, [pc, #128]	; (8005ff4 <HAL_TIM_Base_Start_IT+0x138>)
 8005f74:	4293      	cmp	r3, r2
 8005f76:	d115      	bne.n	8005fa4 <HAL_TIM_Base_Start_IT+0xe8>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8005f78:	687b      	ldr	r3, [r7, #4]
 8005f7a:	681b      	ldr	r3, [r3, #0]
 8005f7c:	689a      	ldr	r2, [r3, #8]
 8005f7e:	4b1e      	ldr	r3, [pc, #120]	; (8005ff8 <HAL_TIM_Base_Start_IT+0x13c>)
 8005f80:	4013      	ands	r3, r2
 8005f82:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8005f84:	68fb      	ldr	r3, [r7, #12]
 8005f86:	2b06      	cmp	r3, #6
 8005f88:	d015      	beq.n	8005fb6 <HAL_TIM_Base_Start_IT+0xfa>
 8005f8a:	68fb      	ldr	r3, [r7, #12]
 8005f8c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8005f90:	d011      	beq.n	8005fb6 <HAL_TIM_Base_Start_IT+0xfa>
    {
      __HAL_TIM_ENABLE(htim);
 8005f92:	687b      	ldr	r3, [r7, #4]
 8005f94:	681b      	ldr	r3, [r3, #0]
 8005f96:	681a      	ldr	r2, [r3, #0]
 8005f98:	687b      	ldr	r3, [r7, #4]
 8005f9a:	681b      	ldr	r3, [r3, #0]
 8005f9c:	f042 0201 	orr.w	r2, r2, #1
 8005fa0:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8005fa2:	e008      	b.n	8005fb6 <HAL_TIM_Base_Start_IT+0xfa>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 8005fa4:	687b      	ldr	r3, [r7, #4]
 8005fa6:	681b      	ldr	r3, [r3, #0]
 8005fa8:	681a      	ldr	r2, [r3, #0]
 8005faa:	687b      	ldr	r3, [r7, #4]
 8005fac:	681b      	ldr	r3, [r3, #0]
 8005fae:	f042 0201 	orr.w	r2, r2, #1
 8005fb2:	601a      	str	r2, [r3, #0]
 8005fb4:	e000      	b.n	8005fb8 <HAL_TIM_Base_Start_IT+0xfc>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8005fb6:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
 8005fb8:	2300      	movs	r3, #0
}
 8005fba:	4618      	mov	r0, r3
 8005fbc:	3714      	adds	r7, #20
 8005fbe:	46bd      	mov	sp, r7
 8005fc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005fc4:	4770      	bx	lr
 8005fc6:	bf00      	nop
 8005fc8:	40012c00 	.word	0x40012c00
 8005fcc:	50012c00 	.word	0x50012c00
 8005fd0:	40000400 	.word	0x40000400
 8005fd4:	50000400 	.word	0x50000400
 8005fd8:	40000800 	.word	0x40000800
 8005fdc:	50000800 	.word	0x50000800
 8005fe0:	40000c00 	.word	0x40000c00
 8005fe4:	50000c00 	.word	0x50000c00
 8005fe8:	40013400 	.word	0x40013400
 8005fec:	50013400 	.word	0x50013400
 8005ff0:	40014000 	.word	0x40014000
 8005ff4:	50014000 	.word	0x50014000
 8005ff8:	00010007 	.word	0x00010007

08005ffc <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 8005ffc:	b580      	push	{r7, lr}
 8005ffe:	b084      	sub	sp, #16
 8006000:	af00      	add	r7, sp, #0
 8006002:	6078      	str	r0, [r7, #4]
  uint32_t itsource = htim->Instance->DIER;
 8006004:	687b      	ldr	r3, [r7, #4]
 8006006:	681b      	ldr	r3, [r3, #0]
 8006008:	68db      	ldr	r3, [r3, #12]
 800600a:	60fb      	str	r3, [r7, #12]
  uint32_t itflag   = htim->Instance->SR;
 800600c:	687b      	ldr	r3, [r7, #4]
 800600e:	681b      	ldr	r3, [r3, #0]
 8006010:	691b      	ldr	r3, [r3, #16]
 8006012:	60bb      	str	r3, [r7, #8]

  /* Capture compare 1 event */
  if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
 8006014:	68bb      	ldr	r3, [r7, #8]
 8006016:	f003 0302 	and.w	r3, r3, #2
 800601a:	2b00      	cmp	r3, #0
 800601c:	d020      	beq.n	8006060 <HAL_TIM_IRQHandler+0x64>
  {
    if ((itsource & (TIM_IT_CC1)) == (TIM_IT_CC1))
 800601e:	68fb      	ldr	r3, [r7, #12]
 8006020:	f003 0302 	and.w	r3, r3, #2
 8006024:	2b00      	cmp	r3, #0
 8006026:	d01b      	beq.n	8006060 <HAL_TIM_IRQHandler+0x64>
    {
      {
        __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC1);
 8006028:	687b      	ldr	r3, [r7, #4]
 800602a:	681b      	ldr	r3, [r3, #0]
 800602c:	f06f 0202 	mvn.w	r2, #2
 8006030:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8006032:	687b      	ldr	r3, [r7, #4]
 8006034:	2201      	movs	r2, #1
 8006036:	771a      	strb	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8006038:	687b      	ldr	r3, [r7, #4]
 800603a:	681b      	ldr	r3, [r3, #0]
 800603c:	699b      	ldr	r3, [r3, #24]
 800603e:	f003 0303 	and.w	r3, r3, #3
 8006042:	2b00      	cmp	r3, #0
 8006044:	d003      	beq.n	800604e <HAL_TIM_IRQHandler+0x52>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 8006046:	6878      	ldr	r0, [r7, #4]
 8006048:	f000 f931 	bl	80062ae <HAL_TIM_IC_CaptureCallback>
 800604c:	e005      	b.n	800605a <HAL_TIM_IRQHandler+0x5e>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800604e:	6878      	ldr	r0, [r7, #4]
 8006050:	f000 f923 	bl	800629a <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8006054:	6878      	ldr	r0, [r7, #4]
 8006056:	f000 f934 	bl	80062c2 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800605a:	687b      	ldr	r3, [r7, #4]
 800605c:	2200      	movs	r2, #0
 800605e:	771a      	strb	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if ((itflag & (TIM_FLAG_CC2)) == (TIM_FLAG_CC2))
 8006060:	68bb      	ldr	r3, [r7, #8]
 8006062:	f003 0304 	and.w	r3, r3, #4
 8006066:	2b00      	cmp	r3, #0
 8006068:	d020      	beq.n	80060ac <HAL_TIM_IRQHandler+0xb0>
  {
    if ((itsource & (TIM_IT_CC2)) == (TIM_IT_CC2))
 800606a:	68fb      	ldr	r3, [r7, #12]
 800606c:	f003 0304 	and.w	r3, r3, #4
 8006070:	2b00      	cmp	r3, #0
 8006072:	d01b      	beq.n	80060ac <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
 8006074:	687b      	ldr	r3, [r7, #4]
 8006076:	681b      	ldr	r3, [r3, #0]
 8006078:	f06f 0204 	mvn.w	r2, #4
 800607c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800607e:	687b      	ldr	r3, [r7, #4]
 8006080:	2202      	movs	r2, #2
 8006082:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8006084:	687b      	ldr	r3, [r7, #4]
 8006086:	681b      	ldr	r3, [r3, #0]
 8006088:	699b      	ldr	r3, [r3, #24]
 800608a:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800608e:	2b00      	cmp	r3, #0
 8006090:	d003      	beq.n	800609a <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8006092:	6878      	ldr	r0, [r7, #4]
 8006094:	f000 f90b 	bl	80062ae <HAL_TIM_IC_CaptureCallback>
 8006098:	e005      	b.n	80060a6 <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800609a:	6878      	ldr	r0, [r7, #4]
 800609c:	f000 f8fd 	bl	800629a <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80060a0:	6878      	ldr	r0, [r7, #4]
 80060a2:	f000 f90e 	bl	80062c2 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80060a6:	687b      	ldr	r3, [r7, #4]
 80060a8:	2200      	movs	r2, #0
 80060aa:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if ((itflag & (TIM_FLAG_CC3)) == (TIM_FLAG_CC3))
 80060ac:	68bb      	ldr	r3, [r7, #8]
 80060ae:	f003 0308 	and.w	r3, r3, #8
 80060b2:	2b00      	cmp	r3, #0
 80060b4:	d020      	beq.n	80060f8 <HAL_TIM_IRQHandler+0xfc>
  {
    if ((itsource & (TIM_IT_CC3)) == (TIM_IT_CC3))
 80060b6:	68fb      	ldr	r3, [r7, #12]
 80060b8:	f003 0308 	and.w	r3, r3, #8
 80060bc:	2b00      	cmp	r3, #0
 80060be:	d01b      	beq.n	80060f8 <HAL_TIM_IRQHandler+0xfc>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
 80060c0:	687b      	ldr	r3, [r7, #4]
 80060c2:	681b      	ldr	r3, [r3, #0]
 80060c4:	f06f 0208 	mvn.w	r2, #8
 80060c8:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 80060ca:	687b      	ldr	r3, [r7, #4]
 80060cc:	2204      	movs	r2, #4
 80060ce:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 80060d0:	687b      	ldr	r3, [r7, #4]
 80060d2:	681b      	ldr	r3, [r3, #0]
 80060d4:	69db      	ldr	r3, [r3, #28]
 80060d6:	f003 0303 	and.w	r3, r3, #3
 80060da:	2b00      	cmp	r3, #0
 80060dc:	d003      	beq.n	80060e6 <HAL_TIM_IRQHandler+0xea>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 80060de:	6878      	ldr	r0, [r7, #4]
 80060e0:	f000 f8e5 	bl	80062ae <HAL_TIM_IC_CaptureCallback>
 80060e4:	e005      	b.n	80060f2 <HAL_TIM_IRQHandler+0xf6>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80060e6:	6878      	ldr	r0, [r7, #4]
 80060e8:	f000 f8d7 	bl	800629a <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80060ec:	6878      	ldr	r0, [r7, #4]
 80060ee:	f000 f8e8 	bl	80062c2 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80060f2:	687b      	ldr	r3, [r7, #4]
 80060f4:	2200      	movs	r2, #0
 80060f6:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if ((itflag & (TIM_FLAG_CC4)) == (TIM_FLAG_CC4))
 80060f8:	68bb      	ldr	r3, [r7, #8]
 80060fa:	f003 0310 	and.w	r3, r3, #16
 80060fe:	2b00      	cmp	r3, #0
 8006100:	d020      	beq.n	8006144 <HAL_TIM_IRQHandler+0x148>
  {
    if ((itsource & (TIM_IT_CC4)) == (TIM_IT_CC4))
 8006102:	68fb      	ldr	r3, [r7, #12]
 8006104:	f003 0310 	and.w	r3, r3, #16
 8006108:	2b00      	cmp	r3, #0
 800610a:	d01b      	beq.n	8006144 <HAL_TIM_IRQHandler+0x148>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
 800610c:	687b      	ldr	r3, [r7, #4]
 800610e:	681b      	ldr	r3, [r3, #0]
 8006110:	f06f 0210 	mvn.w	r2, #16
 8006114:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8006116:	687b      	ldr	r3, [r7, #4]
 8006118:	2208      	movs	r2, #8
 800611a:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800611c:	687b      	ldr	r3, [r7, #4]
 800611e:	681b      	ldr	r3, [r3, #0]
 8006120:	69db      	ldr	r3, [r3, #28]
 8006122:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8006126:	2b00      	cmp	r3, #0
 8006128:	d003      	beq.n	8006132 <HAL_TIM_IRQHandler+0x136>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800612a:	6878      	ldr	r0, [r7, #4]
 800612c:	f000 f8bf 	bl	80062ae <HAL_TIM_IC_CaptureCallback>
 8006130:	e005      	b.n	800613e <HAL_TIM_IRQHandler+0x142>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8006132:	6878      	ldr	r0, [r7, #4]
 8006134:	f000 f8b1 	bl	800629a <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8006138:	6878      	ldr	r0, [r7, #4]
 800613a:	f000 f8c2 	bl	80062c2 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800613e:	687b      	ldr	r3, [r7, #4]
 8006140:	2200      	movs	r2, #0
 8006142:	771a      	strb	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if ((itflag & (TIM_FLAG_UPDATE)) == (TIM_FLAG_UPDATE))
 8006144:	68bb      	ldr	r3, [r7, #8]
 8006146:	f003 0301 	and.w	r3, r3, #1
 800614a:	2b00      	cmp	r3, #0
 800614c:	d00c      	beq.n	8006168 <HAL_TIM_IRQHandler+0x16c>
  {
    if ((itsource & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE))
 800614e:	68fb      	ldr	r3, [r7, #12]
 8006150:	f003 0301 	and.w	r3, r3, #1
 8006154:	2b00      	cmp	r3, #0
 8006156:	d007      	beq.n	8006168 <HAL_TIM_IRQHandler+0x16c>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
 8006158:	687b      	ldr	r3, [r7, #4]
 800615a:	681b      	ldr	r3, [r3, #0]
 800615c:	f06f 0201 	mvn.w	r2, #1
 8006160:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 8006162:	6878      	ldr	r0, [r7, #4]
 8006164:	f7fb f840 	bl	80011e8 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 8006168:	68bb      	ldr	r3, [r7, #8]
 800616a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800616e:	2b00      	cmp	r3, #0
 8006170:	d104      	bne.n	800617c <HAL_TIM_IRQHandler+0x180>
      ((itflag & (TIM_FLAG_SYSTEM_BREAK)) == (TIM_FLAG_SYSTEM_BREAK)))
 8006172:	68bb      	ldr	r3, [r7, #8]
 8006174:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 8006178:	2b00      	cmp	r3, #0
 800617a:	d00c      	beq.n	8006196 <HAL_TIM_IRQHandler+0x19a>
  {
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 800617c:	68fb      	ldr	r3, [r7, #12]
 800617e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006182:	2b00      	cmp	r3, #0
 8006184:	d007      	beq.n	8006196 <HAL_TIM_IRQHandler+0x19a>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK | TIM_FLAG_SYSTEM_BREAK);
 8006186:	687b      	ldr	r3, [r7, #4]
 8006188:	681b      	ldr	r3, [r3, #0]
 800618a:	f46f 5202 	mvn.w	r2, #8320	; 0x2080
 800618e:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 8006190:	6878      	ldr	r0, [r7, #4]
 8006192:	f000 f9af 	bl	80064f4 <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if ((itflag & (TIM_FLAG_BREAK2)) == (TIM_FLAG_BREAK2))
 8006196:	68bb      	ldr	r3, [r7, #8]
 8006198:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800619c:	2b00      	cmp	r3, #0
 800619e:	d00c      	beq.n	80061ba <HAL_TIM_IRQHandler+0x1be>
  {
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 80061a0:	68fb      	ldr	r3, [r7, #12]
 80061a2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80061a6:	2b00      	cmp	r3, #0
 80061a8:	d007      	beq.n	80061ba <HAL_TIM_IRQHandler+0x1be>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 80061aa:	687b      	ldr	r3, [r7, #4]
 80061ac:	681b      	ldr	r3, [r3, #0]
 80061ae:	f46f 7280 	mvn.w	r2, #256	; 0x100
 80061b2:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
 80061b4:	6878      	ldr	r0, [r7, #4]
 80061b6:	f000 f9a7 	bl	8006508 <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if ((itflag & (TIM_FLAG_TRIGGER)) == (TIM_FLAG_TRIGGER))
 80061ba:	68bb      	ldr	r3, [r7, #8]
 80061bc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80061c0:	2b00      	cmp	r3, #0
 80061c2:	d00c      	beq.n	80061de <HAL_TIM_IRQHandler+0x1e2>
  {
    if ((itsource & (TIM_IT_TRIGGER)) == (TIM_IT_TRIGGER))
 80061c4:	68fb      	ldr	r3, [r7, #12]
 80061c6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80061ca:	2b00      	cmp	r3, #0
 80061cc:	d007      	beq.n	80061de <HAL_TIM_IRQHandler+0x1e2>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
 80061ce:	687b      	ldr	r3, [r7, #4]
 80061d0:	681b      	ldr	r3, [r3, #0]
 80061d2:	f06f 0240 	mvn.w	r2, #64	; 0x40
 80061d6:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 80061d8:	6878      	ldr	r0, [r7, #4]
 80061da:	f000 f87c 	bl	80062d6 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if ((itflag & (TIM_FLAG_COM)) == (TIM_FLAG_COM))
 80061de:	68bb      	ldr	r3, [r7, #8]
 80061e0:	f003 0320 	and.w	r3, r3, #32
 80061e4:	2b00      	cmp	r3, #0
 80061e6:	d00c      	beq.n	8006202 <HAL_TIM_IRQHandler+0x206>
  {
    if ((itsource & (TIM_IT_COM)) == (TIM_IT_COM))
 80061e8:	68fb      	ldr	r3, [r7, #12]
 80061ea:	f003 0320 	and.w	r3, r3, #32
 80061ee:	2b00      	cmp	r3, #0
 80061f0:	d007      	beq.n	8006202 <HAL_TIM_IRQHandler+0x206>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
 80061f2:	687b      	ldr	r3, [r7, #4]
 80061f4:	681b      	ldr	r3, [r3, #0]
 80061f6:	f06f 0220 	mvn.w	r2, #32
 80061fa:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 80061fc:	6878      	ldr	r0, [r7, #4]
 80061fe:	f000 f96f 	bl	80064e0 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Encoder index event */
  if ((itflag & (TIM_FLAG_IDX)) == (TIM_FLAG_IDX))
 8006202:	68bb      	ldr	r3, [r7, #8]
 8006204:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8006208:	2b00      	cmp	r3, #0
 800620a:	d00c      	beq.n	8006226 <HAL_TIM_IRQHandler+0x22a>
  {
    if ((itsource & (TIM_IT_IDX)) == (TIM_IT_IDX))
 800620c:	68fb      	ldr	r3, [r7, #12]
 800620e:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8006212:	2b00      	cmp	r3, #0
 8006214:	d007      	beq.n	8006226 <HAL_TIM_IRQHandler+0x22a>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_IDX);
 8006216:	687b      	ldr	r3, [r7, #4]
 8006218:	681b      	ldr	r3, [r3, #0]
 800621a:	f46f 1280 	mvn.w	r2, #1048576	; 0x100000
 800621e:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->EncoderIndexCallback(htim);
#else
      HAL_TIMEx_EncoderIndexCallback(htim);
 8006220:	6878      	ldr	r0, [r7, #4]
 8006222:	f000 f97b 	bl	800651c <HAL_TIMEx_EncoderIndexCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Direction change event */
  if ((itflag & (TIM_FLAG_DIR)) == (TIM_FLAG_DIR))
 8006226:	68bb      	ldr	r3, [r7, #8]
 8006228:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800622c:	2b00      	cmp	r3, #0
 800622e:	d00c      	beq.n	800624a <HAL_TIM_IRQHandler+0x24e>
  {
    if ((itsource & (TIM_IT_DIR)) == (TIM_IT_DIR))
 8006230:	68fb      	ldr	r3, [r7, #12]
 8006232:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8006236:	2b00      	cmp	r3, #0
 8006238:	d007      	beq.n	800624a <HAL_TIM_IRQHandler+0x24e>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_DIR);
 800623a:	687b      	ldr	r3, [r7, #4]
 800623c:	681b      	ldr	r3, [r3, #0]
 800623e:	f46f 1200 	mvn.w	r2, #2097152	; 0x200000
 8006242:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->DirectionChangeCallback(htim);
#else
      HAL_TIMEx_DirectionChangeCallback(htim);
 8006244:	6878      	ldr	r0, [r7, #4]
 8006246:	f000 f973 	bl	8006530 <HAL_TIMEx_DirectionChangeCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Index error event */
  if ((itflag & (TIM_FLAG_IERR)) == (TIM_FLAG_IERR))
 800624a:	68bb      	ldr	r3, [r7, #8]
 800624c:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8006250:	2b00      	cmp	r3, #0
 8006252:	d00c      	beq.n	800626e <HAL_TIM_IRQHandler+0x272>
  {
    if ((itsource & (TIM_IT_IERR)) == (TIM_IT_IERR))
 8006254:	68fb      	ldr	r3, [r7, #12]
 8006256:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800625a:	2b00      	cmp	r3, #0
 800625c:	d007      	beq.n	800626e <HAL_TIM_IRQHandler+0x272>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_IERR);
 800625e:	687b      	ldr	r3, [r7, #4]
 8006260:	681b      	ldr	r3, [r3, #0]
 8006262:	f46f 0280 	mvn.w	r2, #4194304	; 0x400000
 8006266:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->IndexErrorCallback(htim);
#else
      HAL_TIMEx_IndexErrorCallback(htim);
 8006268:	6878      	ldr	r0, [r7, #4]
 800626a:	f000 f96b 	bl	8006544 <HAL_TIMEx_IndexErrorCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Transition error event */
  if ((itflag & (TIM_FLAG_TERR)) == (TIM_FLAG_TERR))
 800626e:	68bb      	ldr	r3, [r7, #8]
 8006270:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8006274:	2b00      	cmp	r3, #0
 8006276:	d00c      	beq.n	8006292 <HAL_TIM_IRQHandler+0x296>
  {
    if ((itsource & (TIM_IT_TERR)) == (TIM_IT_TERR))
 8006278:	68fb      	ldr	r3, [r7, #12]
 800627a:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800627e:	2b00      	cmp	r3, #0
 8006280:	d007      	beq.n	8006292 <HAL_TIM_IRQHandler+0x296>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TERR);
 8006282:	687b      	ldr	r3, [r7, #4]
 8006284:	681b      	ldr	r3, [r3, #0]
 8006286:	f46f 0200 	mvn.w	r2, #8388608	; 0x800000
 800628a:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TransitionErrorCallback(htim);
#else
      HAL_TIMEx_TransitionErrorCallback(htim);
 800628c:	6878      	ldr	r0, [r7, #4]
 800628e:	f000 f963 	bl	8006558 <HAL_TIMEx_TransitionErrorCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 8006292:	bf00      	nop
 8006294:	3710      	adds	r7, #16
 8006296:	46bd      	mov	sp, r7
 8006298:	bd80      	pop	{r7, pc}

0800629a <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 800629a:	b480      	push	{r7}
 800629c:	b083      	sub	sp, #12
 800629e:	af00      	add	r7, sp, #0
 80062a0:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 80062a2:	bf00      	nop
 80062a4:	370c      	adds	r7, #12
 80062a6:	46bd      	mov	sp, r7
 80062a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80062ac:	4770      	bx	lr

080062ae <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 80062ae:	b480      	push	{r7}
 80062b0:	b083      	sub	sp, #12
 80062b2:	af00      	add	r7, sp, #0
 80062b4:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 80062b6:	bf00      	nop
 80062b8:	370c      	adds	r7, #12
 80062ba:	46bd      	mov	sp, r7
 80062bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80062c0:	4770      	bx	lr

080062c2 <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 80062c2:	b480      	push	{r7}
 80062c4:	b083      	sub	sp, #12
 80062c6:	af00      	add	r7, sp, #0
 80062c8:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 80062ca:	bf00      	nop
 80062cc:	370c      	adds	r7, #12
 80062ce:	46bd      	mov	sp, r7
 80062d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80062d4:	4770      	bx	lr

080062d6 <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 80062d6:	b480      	push	{r7}
 80062d8:	b083      	sub	sp, #12
 80062da:	af00      	add	r7, sp, #0
 80062dc:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 80062de:	bf00      	nop
 80062e0:	370c      	adds	r7, #12
 80062e2:	46bd      	mov	sp, r7
 80062e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80062e8:	4770      	bx	lr
	...

080062ec <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, const TIM_Base_InitTypeDef *Structure)
{
 80062ec:	b480      	push	{r7}
 80062ee:	b085      	sub	sp, #20
 80062f0:	af00      	add	r7, sp, #0
 80062f2:	6078      	str	r0, [r7, #4]
 80062f4:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 80062f6:	687b      	ldr	r3, [r7, #4]
 80062f8:	681b      	ldr	r3, [r3, #0]
 80062fa:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80062fc:	687b      	ldr	r3, [r7, #4]
 80062fe:	4a68      	ldr	r2, [pc, #416]	; (80064a0 <TIM_Base_SetConfig+0x1b4>)
 8006300:	4293      	cmp	r3, r2
 8006302:	d02b      	beq.n	800635c <TIM_Base_SetConfig+0x70>
 8006304:	687b      	ldr	r3, [r7, #4]
 8006306:	4a67      	ldr	r2, [pc, #412]	; (80064a4 <TIM_Base_SetConfig+0x1b8>)
 8006308:	4293      	cmp	r3, r2
 800630a:	d027      	beq.n	800635c <TIM_Base_SetConfig+0x70>
 800630c:	687b      	ldr	r3, [r7, #4]
 800630e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8006312:	d023      	beq.n	800635c <TIM_Base_SetConfig+0x70>
 8006314:	687b      	ldr	r3, [r7, #4]
 8006316:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 800631a:	d01f      	beq.n	800635c <TIM_Base_SetConfig+0x70>
 800631c:	687b      	ldr	r3, [r7, #4]
 800631e:	4a62      	ldr	r2, [pc, #392]	; (80064a8 <TIM_Base_SetConfig+0x1bc>)
 8006320:	4293      	cmp	r3, r2
 8006322:	d01b      	beq.n	800635c <TIM_Base_SetConfig+0x70>
 8006324:	687b      	ldr	r3, [r7, #4]
 8006326:	4a61      	ldr	r2, [pc, #388]	; (80064ac <TIM_Base_SetConfig+0x1c0>)
 8006328:	4293      	cmp	r3, r2
 800632a:	d017      	beq.n	800635c <TIM_Base_SetConfig+0x70>
 800632c:	687b      	ldr	r3, [r7, #4]
 800632e:	4a60      	ldr	r2, [pc, #384]	; (80064b0 <TIM_Base_SetConfig+0x1c4>)
 8006330:	4293      	cmp	r3, r2
 8006332:	d013      	beq.n	800635c <TIM_Base_SetConfig+0x70>
 8006334:	687b      	ldr	r3, [r7, #4]
 8006336:	4a5f      	ldr	r2, [pc, #380]	; (80064b4 <TIM_Base_SetConfig+0x1c8>)
 8006338:	4293      	cmp	r3, r2
 800633a:	d00f      	beq.n	800635c <TIM_Base_SetConfig+0x70>
 800633c:	687b      	ldr	r3, [r7, #4]
 800633e:	4a5e      	ldr	r2, [pc, #376]	; (80064b8 <TIM_Base_SetConfig+0x1cc>)
 8006340:	4293      	cmp	r3, r2
 8006342:	d00b      	beq.n	800635c <TIM_Base_SetConfig+0x70>
 8006344:	687b      	ldr	r3, [r7, #4]
 8006346:	4a5d      	ldr	r2, [pc, #372]	; (80064bc <TIM_Base_SetConfig+0x1d0>)
 8006348:	4293      	cmp	r3, r2
 800634a:	d007      	beq.n	800635c <TIM_Base_SetConfig+0x70>
 800634c:	687b      	ldr	r3, [r7, #4]
 800634e:	4a5c      	ldr	r2, [pc, #368]	; (80064c0 <TIM_Base_SetConfig+0x1d4>)
 8006350:	4293      	cmp	r3, r2
 8006352:	d003      	beq.n	800635c <TIM_Base_SetConfig+0x70>
 8006354:	687b      	ldr	r3, [r7, #4]
 8006356:	4a5b      	ldr	r2, [pc, #364]	; (80064c4 <TIM_Base_SetConfig+0x1d8>)
 8006358:	4293      	cmp	r3, r2
 800635a:	d108      	bne.n	800636e <TIM_Base_SetConfig+0x82>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800635c:	68fb      	ldr	r3, [r7, #12]
 800635e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8006362:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 8006364:	683b      	ldr	r3, [r7, #0]
 8006366:	685b      	ldr	r3, [r3, #4]
 8006368:	68fa      	ldr	r2, [r7, #12]
 800636a:	4313      	orrs	r3, r2
 800636c:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800636e:	687b      	ldr	r3, [r7, #4]
 8006370:	4a4b      	ldr	r2, [pc, #300]	; (80064a0 <TIM_Base_SetConfig+0x1b4>)
 8006372:	4293      	cmp	r3, r2
 8006374:	d043      	beq.n	80063fe <TIM_Base_SetConfig+0x112>
 8006376:	687b      	ldr	r3, [r7, #4]
 8006378:	4a4a      	ldr	r2, [pc, #296]	; (80064a4 <TIM_Base_SetConfig+0x1b8>)
 800637a:	4293      	cmp	r3, r2
 800637c:	d03f      	beq.n	80063fe <TIM_Base_SetConfig+0x112>
 800637e:	687b      	ldr	r3, [r7, #4]
 8006380:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8006384:	d03b      	beq.n	80063fe <TIM_Base_SetConfig+0x112>
 8006386:	687b      	ldr	r3, [r7, #4]
 8006388:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 800638c:	d037      	beq.n	80063fe <TIM_Base_SetConfig+0x112>
 800638e:	687b      	ldr	r3, [r7, #4]
 8006390:	4a45      	ldr	r2, [pc, #276]	; (80064a8 <TIM_Base_SetConfig+0x1bc>)
 8006392:	4293      	cmp	r3, r2
 8006394:	d033      	beq.n	80063fe <TIM_Base_SetConfig+0x112>
 8006396:	687b      	ldr	r3, [r7, #4]
 8006398:	4a44      	ldr	r2, [pc, #272]	; (80064ac <TIM_Base_SetConfig+0x1c0>)
 800639a:	4293      	cmp	r3, r2
 800639c:	d02f      	beq.n	80063fe <TIM_Base_SetConfig+0x112>
 800639e:	687b      	ldr	r3, [r7, #4]
 80063a0:	4a43      	ldr	r2, [pc, #268]	; (80064b0 <TIM_Base_SetConfig+0x1c4>)
 80063a2:	4293      	cmp	r3, r2
 80063a4:	d02b      	beq.n	80063fe <TIM_Base_SetConfig+0x112>
 80063a6:	687b      	ldr	r3, [r7, #4]
 80063a8:	4a42      	ldr	r2, [pc, #264]	; (80064b4 <TIM_Base_SetConfig+0x1c8>)
 80063aa:	4293      	cmp	r3, r2
 80063ac:	d027      	beq.n	80063fe <TIM_Base_SetConfig+0x112>
 80063ae:	687b      	ldr	r3, [r7, #4]
 80063b0:	4a41      	ldr	r2, [pc, #260]	; (80064b8 <TIM_Base_SetConfig+0x1cc>)
 80063b2:	4293      	cmp	r3, r2
 80063b4:	d023      	beq.n	80063fe <TIM_Base_SetConfig+0x112>
 80063b6:	687b      	ldr	r3, [r7, #4]
 80063b8:	4a40      	ldr	r2, [pc, #256]	; (80064bc <TIM_Base_SetConfig+0x1d0>)
 80063ba:	4293      	cmp	r3, r2
 80063bc:	d01f      	beq.n	80063fe <TIM_Base_SetConfig+0x112>
 80063be:	687b      	ldr	r3, [r7, #4]
 80063c0:	4a3f      	ldr	r2, [pc, #252]	; (80064c0 <TIM_Base_SetConfig+0x1d4>)
 80063c2:	4293      	cmp	r3, r2
 80063c4:	d01b      	beq.n	80063fe <TIM_Base_SetConfig+0x112>
 80063c6:	687b      	ldr	r3, [r7, #4]
 80063c8:	4a3e      	ldr	r2, [pc, #248]	; (80064c4 <TIM_Base_SetConfig+0x1d8>)
 80063ca:	4293      	cmp	r3, r2
 80063cc:	d017      	beq.n	80063fe <TIM_Base_SetConfig+0x112>
 80063ce:	687b      	ldr	r3, [r7, #4]
 80063d0:	4a3d      	ldr	r2, [pc, #244]	; (80064c8 <TIM_Base_SetConfig+0x1dc>)
 80063d2:	4293      	cmp	r3, r2
 80063d4:	d013      	beq.n	80063fe <TIM_Base_SetConfig+0x112>
 80063d6:	687b      	ldr	r3, [r7, #4]
 80063d8:	4a3c      	ldr	r2, [pc, #240]	; (80064cc <TIM_Base_SetConfig+0x1e0>)
 80063da:	4293      	cmp	r3, r2
 80063dc:	d00f      	beq.n	80063fe <TIM_Base_SetConfig+0x112>
 80063de:	687b      	ldr	r3, [r7, #4]
 80063e0:	4a3b      	ldr	r2, [pc, #236]	; (80064d0 <TIM_Base_SetConfig+0x1e4>)
 80063e2:	4293      	cmp	r3, r2
 80063e4:	d00b      	beq.n	80063fe <TIM_Base_SetConfig+0x112>
 80063e6:	687b      	ldr	r3, [r7, #4]
 80063e8:	4a3a      	ldr	r2, [pc, #232]	; (80064d4 <TIM_Base_SetConfig+0x1e8>)
 80063ea:	4293      	cmp	r3, r2
 80063ec:	d007      	beq.n	80063fe <TIM_Base_SetConfig+0x112>
 80063ee:	687b      	ldr	r3, [r7, #4]
 80063f0:	4a39      	ldr	r2, [pc, #228]	; (80064d8 <TIM_Base_SetConfig+0x1ec>)
 80063f2:	4293      	cmp	r3, r2
 80063f4:	d003      	beq.n	80063fe <TIM_Base_SetConfig+0x112>
 80063f6:	687b      	ldr	r3, [r7, #4]
 80063f8:	4a38      	ldr	r2, [pc, #224]	; (80064dc <TIM_Base_SetConfig+0x1f0>)
 80063fa:	4293      	cmp	r3, r2
 80063fc:	d108      	bne.n	8006410 <TIM_Base_SetConfig+0x124>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 80063fe:	68fb      	ldr	r3, [r7, #12]
 8006400:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8006404:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8006406:	683b      	ldr	r3, [r7, #0]
 8006408:	68db      	ldr	r3, [r3, #12]
 800640a:	68fa      	ldr	r2, [r7, #12]
 800640c:	4313      	orrs	r3, r2
 800640e:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8006410:	68fb      	ldr	r3, [r7, #12]
 8006412:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8006416:	683b      	ldr	r3, [r7, #0]
 8006418:	695b      	ldr	r3, [r3, #20]
 800641a:	4313      	orrs	r3, r2
 800641c:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 800641e:	687b      	ldr	r3, [r7, #4]
 8006420:	68fa      	ldr	r2, [r7, #12]
 8006422:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8006424:	683b      	ldr	r3, [r7, #0]
 8006426:	689a      	ldr	r2, [r3, #8]
 8006428:	687b      	ldr	r3, [r7, #4]
 800642a:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 800642c:	683b      	ldr	r3, [r7, #0]
 800642e:	681a      	ldr	r2, [r3, #0]
 8006430:	687b      	ldr	r3, [r7, #4]
 8006432:	629a      	str	r2, [r3, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8006434:	687b      	ldr	r3, [r7, #4]
 8006436:	4a1a      	ldr	r2, [pc, #104]	; (80064a0 <TIM_Base_SetConfig+0x1b4>)
 8006438:	4293      	cmp	r3, r2
 800643a:	d023      	beq.n	8006484 <TIM_Base_SetConfig+0x198>
 800643c:	687b      	ldr	r3, [r7, #4]
 800643e:	4a19      	ldr	r2, [pc, #100]	; (80064a4 <TIM_Base_SetConfig+0x1b8>)
 8006440:	4293      	cmp	r3, r2
 8006442:	d01f      	beq.n	8006484 <TIM_Base_SetConfig+0x198>
 8006444:	687b      	ldr	r3, [r7, #4]
 8006446:	4a1e      	ldr	r2, [pc, #120]	; (80064c0 <TIM_Base_SetConfig+0x1d4>)
 8006448:	4293      	cmp	r3, r2
 800644a:	d01b      	beq.n	8006484 <TIM_Base_SetConfig+0x198>
 800644c:	687b      	ldr	r3, [r7, #4]
 800644e:	4a1d      	ldr	r2, [pc, #116]	; (80064c4 <TIM_Base_SetConfig+0x1d8>)
 8006450:	4293      	cmp	r3, r2
 8006452:	d017      	beq.n	8006484 <TIM_Base_SetConfig+0x198>
 8006454:	687b      	ldr	r3, [r7, #4]
 8006456:	4a1c      	ldr	r2, [pc, #112]	; (80064c8 <TIM_Base_SetConfig+0x1dc>)
 8006458:	4293      	cmp	r3, r2
 800645a:	d013      	beq.n	8006484 <TIM_Base_SetConfig+0x198>
 800645c:	687b      	ldr	r3, [r7, #4]
 800645e:	4a1b      	ldr	r2, [pc, #108]	; (80064cc <TIM_Base_SetConfig+0x1e0>)
 8006460:	4293      	cmp	r3, r2
 8006462:	d00f      	beq.n	8006484 <TIM_Base_SetConfig+0x198>
 8006464:	687b      	ldr	r3, [r7, #4]
 8006466:	4a1a      	ldr	r2, [pc, #104]	; (80064d0 <TIM_Base_SetConfig+0x1e4>)
 8006468:	4293      	cmp	r3, r2
 800646a:	d00b      	beq.n	8006484 <TIM_Base_SetConfig+0x198>
 800646c:	687b      	ldr	r3, [r7, #4]
 800646e:	4a19      	ldr	r2, [pc, #100]	; (80064d4 <TIM_Base_SetConfig+0x1e8>)
 8006470:	4293      	cmp	r3, r2
 8006472:	d007      	beq.n	8006484 <TIM_Base_SetConfig+0x198>
 8006474:	687b      	ldr	r3, [r7, #4]
 8006476:	4a18      	ldr	r2, [pc, #96]	; (80064d8 <TIM_Base_SetConfig+0x1ec>)
 8006478:	4293      	cmp	r3, r2
 800647a:	d003      	beq.n	8006484 <TIM_Base_SetConfig+0x198>
 800647c:	687b      	ldr	r3, [r7, #4]
 800647e:	4a17      	ldr	r2, [pc, #92]	; (80064dc <TIM_Base_SetConfig+0x1f0>)
 8006480:	4293      	cmp	r3, r2
 8006482:	d103      	bne.n	800648c <TIM_Base_SetConfig+0x1a0>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8006484:	683b      	ldr	r3, [r7, #0]
 8006486:	691a      	ldr	r2, [r3, #16]
 8006488:	687b      	ldr	r3, [r7, #4]
 800648a:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 800648c:	687b      	ldr	r3, [r7, #4]
 800648e:	2201      	movs	r2, #1
 8006490:	615a      	str	r2, [r3, #20]
}
 8006492:	bf00      	nop
 8006494:	3714      	adds	r7, #20
 8006496:	46bd      	mov	sp, r7
 8006498:	f85d 7b04 	ldr.w	r7, [sp], #4
 800649c:	4770      	bx	lr
 800649e:	bf00      	nop
 80064a0:	40012c00 	.word	0x40012c00
 80064a4:	50012c00 	.word	0x50012c00
 80064a8:	40000400 	.word	0x40000400
 80064ac:	50000400 	.word	0x50000400
 80064b0:	40000800 	.word	0x40000800
 80064b4:	50000800 	.word	0x50000800
 80064b8:	40000c00 	.word	0x40000c00
 80064bc:	50000c00 	.word	0x50000c00
 80064c0:	40013400 	.word	0x40013400
 80064c4:	50013400 	.word	0x50013400
 80064c8:	40014000 	.word	0x40014000
 80064cc:	50014000 	.word	0x50014000
 80064d0:	40014400 	.word	0x40014400
 80064d4:	50014400 	.word	0x50014400
 80064d8:	40014800 	.word	0x40014800
 80064dc:	50014800 	.word	0x50014800

080064e0 <HAL_TIMEx_CommutCallback>:
  * @brief  Hall commutation changed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
 80064e0:	b480      	push	{r7}
 80064e2:	b083      	sub	sp, #12
 80064e4:	af00      	add	r7, sp, #0
 80064e6:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 80064e8:	bf00      	nop
 80064ea:	370c      	adds	r7, #12
 80064ec:	46bd      	mov	sp, r7
 80064ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80064f2:	4770      	bx	lr

080064f4 <HAL_TIMEx_BreakCallback>:
  * @brief  Hall Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 80064f4:	b480      	push	{r7}
 80064f6:	b083      	sub	sp, #12
 80064f8:	af00      	add	r7, sp, #0
 80064fa:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 80064fc:	bf00      	nop
 80064fe:	370c      	adds	r7, #12
 8006500:	46bd      	mov	sp, r7
 8006502:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006506:	4770      	bx	lr

08006508 <HAL_TIMEx_Break2Callback>:
  * @brief  Hall Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
 8006508:	b480      	push	{r7}
 800650a:	b083      	sub	sp, #12
 800650c:	af00      	add	r7, sp, #0
 800650e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 8006510:	bf00      	nop
 8006512:	370c      	adds	r7, #12
 8006514:	46bd      	mov	sp, r7
 8006516:	f85d 7b04 	ldr.w	r7, [sp], #4
 800651a:	4770      	bx	lr

0800651c <HAL_TIMEx_EncoderIndexCallback>:
  * @brief  Encoder index callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_EncoderIndexCallback(TIM_HandleTypeDef *htim)
{
 800651c:	b480      	push	{r7}
 800651e:	b083      	sub	sp, #12
 8006520:	af00      	add	r7, sp, #0
 8006522:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_EncoderIndexCallback could be implemented in the user file
   */
}
 8006524:	bf00      	nop
 8006526:	370c      	adds	r7, #12
 8006528:	46bd      	mov	sp, r7
 800652a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800652e:	4770      	bx	lr

08006530 <HAL_TIMEx_DirectionChangeCallback>:
  * @brief  Direction change callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_DirectionChangeCallback(TIM_HandleTypeDef *htim)
{
 8006530:	b480      	push	{r7}
 8006532:	b083      	sub	sp, #12
 8006534:	af00      	add	r7, sp, #0
 8006536:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_DirectionChangeCallback could be implemented in the user file
   */
}
 8006538:	bf00      	nop
 800653a:	370c      	adds	r7, #12
 800653c:	46bd      	mov	sp, r7
 800653e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006542:	4770      	bx	lr

08006544 <HAL_TIMEx_IndexErrorCallback>:
  * @brief  Index error callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_IndexErrorCallback(TIM_HandleTypeDef *htim)
{
 8006544:	b480      	push	{r7}
 8006546:	b083      	sub	sp, #12
 8006548:	af00      	add	r7, sp, #0
 800654a:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_IndexErrorCallback could be implemented in the user file
   */
}
 800654c:	bf00      	nop
 800654e:	370c      	adds	r7, #12
 8006550:	46bd      	mov	sp, r7
 8006552:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006556:	4770      	bx	lr

08006558 <HAL_TIMEx_TransitionErrorCallback>:
  * @brief  Transition error callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_TransitionErrorCallback(TIM_HandleTypeDef *htim)
{
 8006558:	b480      	push	{r7}
 800655a:	b083      	sub	sp, #12
 800655c:	af00      	add	r7, sp, #0
 800655e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_TransitionErrorCallback could be implemented in the user file
   */
}
 8006560:	bf00      	nop
 8006562:	370c      	adds	r7, #12
 8006564:	46bd      	mov	sp, r7
 8006566:	f85d 7b04 	ldr.w	r7, [sp], #4
 800656a:	4770      	bx	lr

0800656c <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 800656c:	b580      	push	{r7, lr}
 800656e:	b082      	sub	sp, #8
 8006570:	af00      	add	r7, sp, #0
 8006572:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 8006574:	687b      	ldr	r3, [r7, #4]
 8006576:	2b00      	cmp	r3, #0
 8006578:	d101      	bne.n	800657e <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 800657a:	2301      	movs	r3, #1
 800657c:	e042      	b.n	8006604 <HAL_UART_Init+0x98>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 800657e:	687b      	ldr	r3, [r7, #4]
 8006580:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8006584:	2b00      	cmp	r3, #0
 8006586:	d106      	bne.n	8006596 <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8006588:	687b      	ldr	r3, [r7, #4]
 800658a:	2200      	movs	r2, #0
 800658c:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 8006590:	6878      	ldr	r0, [r7, #4]
 8006592:	f7fa fe6f 	bl	8001274 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 8006596:	687b      	ldr	r3, [r7, #4]
 8006598:	2224      	movs	r2, #36	; 0x24
 800659a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  __HAL_UART_DISABLE(huart);
 800659e:	687b      	ldr	r3, [r7, #4]
 80065a0:	681b      	ldr	r3, [r3, #0]
 80065a2:	681a      	ldr	r2, [r3, #0]
 80065a4:	687b      	ldr	r3, [r7, #4]
 80065a6:	681b      	ldr	r3, [r3, #0]
 80065a8:	f022 0201 	bic.w	r2, r2, #1
 80065ac:	601a      	str	r2, [r3, #0]

  /* Perform advanced settings configuration */
  /* For some items, configuration requires to be done prior TE and RE bits are set */
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 80065ae:	687b      	ldr	r3, [r7, #4]
 80065b0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80065b2:	2b00      	cmp	r3, #0
 80065b4:	d002      	beq.n	80065bc <HAL_UART_Init+0x50>
  {
    UART_AdvFeatureConfig(huart);
 80065b6:	6878      	ldr	r0, [r7, #4]
 80065b8:	f000 fa68 	bl	8006a8c <UART_AdvFeatureConfig>
  }

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 80065bc:	6878      	ldr	r0, [r7, #4]
 80065be:	f000 f8c3 	bl	8006748 <UART_SetConfig>
 80065c2:	4603      	mov	r3, r0
 80065c4:	2b01      	cmp	r3, #1
 80065c6:	d101      	bne.n	80065cc <HAL_UART_Init+0x60>
  {
    return HAL_ERROR;
 80065c8:	2301      	movs	r3, #1
 80065ca:	e01b      	b.n	8006604 <HAL_UART_Init+0x98>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80065cc:	687b      	ldr	r3, [r7, #4]
 80065ce:	681b      	ldr	r3, [r3, #0]
 80065d0:	685a      	ldr	r2, [r3, #4]
 80065d2:	687b      	ldr	r3, [r7, #4]
 80065d4:	681b      	ldr	r3, [r3, #0]
 80065d6:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 80065da:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80065dc:	687b      	ldr	r3, [r7, #4]
 80065de:	681b      	ldr	r3, [r3, #0]
 80065e0:	689a      	ldr	r2, [r3, #8]
 80065e2:	687b      	ldr	r3, [r7, #4]
 80065e4:	681b      	ldr	r3, [r3, #0]
 80065e6:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 80065ea:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
 80065ec:	687b      	ldr	r3, [r7, #4]
 80065ee:	681b      	ldr	r3, [r3, #0]
 80065f0:	681a      	ldr	r2, [r3, #0]
 80065f2:	687b      	ldr	r3, [r7, #4]
 80065f4:	681b      	ldr	r3, [r3, #0]
 80065f6:	f042 0201 	orr.w	r2, r2, #1
 80065fa:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 80065fc:	6878      	ldr	r0, [r7, #4]
 80065fe:	f000 fae7 	bl	8006bd0 <UART_CheckIdleState>
 8006602:	4603      	mov	r3, r0
}
 8006604:	4618      	mov	r0, r3
 8006606:	3708      	adds	r7, #8
 8006608:	46bd      	mov	sp, r7
 800660a:	bd80      	pop	{r7, pc}

0800660c <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800660c:	b580      	push	{r7, lr}
 800660e:	b08a      	sub	sp, #40	; 0x28
 8006610:	af02      	add	r7, sp, #8
 8006612:	60f8      	str	r0, [r7, #12]
 8006614:	60b9      	str	r1, [r7, #8]
 8006616:	603b      	str	r3, [r7, #0]
 8006618:	4613      	mov	r3, r2
 800661a:	80fb      	strh	r3, [r7, #6]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 800661c:	68fb      	ldr	r3, [r7, #12]
 800661e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8006622:	2b20      	cmp	r3, #32
 8006624:	f040 808b 	bne.w	800673e <HAL_UART_Transmit+0x132>
  {
    if ((pData == NULL) || (Size == 0U))
 8006628:	68bb      	ldr	r3, [r7, #8]
 800662a:	2b00      	cmp	r3, #0
 800662c:	d002      	beq.n	8006634 <HAL_UART_Transmit+0x28>
 800662e:	88fb      	ldrh	r3, [r7, #6]
 8006630:	2b00      	cmp	r3, #0
 8006632:	d101      	bne.n	8006638 <HAL_UART_Transmit+0x2c>
    {
      return  HAL_ERROR;
 8006634:	2301      	movs	r3, #1
 8006636:	e083      	b.n	8006740 <HAL_UART_Transmit+0x134>
    }

#if defined(USART_DMAREQUESTS_SW_WA)
    /* Disable the UART DMA Tx request if enabled */
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
 8006638:	68fb      	ldr	r3, [r7, #12]
 800663a:	681b      	ldr	r3, [r3, #0]
 800663c:	689b      	ldr	r3, [r3, #8]
 800663e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006642:	2b80      	cmp	r3, #128	; 0x80
 8006644:	d107      	bne.n	8006656 <HAL_UART_Transmit+0x4a>
    {
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8006646:	68fb      	ldr	r3, [r7, #12]
 8006648:	681b      	ldr	r3, [r3, #0]
 800664a:	689a      	ldr	r2, [r3, #8]
 800664c:	68fb      	ldr	r3, [r7, #12]
 800664e:	681b      	ldr	r3, [r3, #0]
 8006650:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8006654:	609a      	str	r2, [r3, #8]
    }

#endif /* USART_DMAREQUESTS_SW_WA */
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8006656:	68fb      	ldr	r3, [r7, #12]
 8006658:	2200      	movs	r2, #0
 800665a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800665e:	68fb      	ldr	r3, [r7, #12]
 8006660:	2221      	movs	r2, #33	; 0x21
 8006662:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 8006666:	f7fb f815 	bl	8001694 <HAL_GetTick>
 800666a:	6178      	str	r0, [r7, #20]

    huart->TxXferSize  = Size;
 800666c:	68fb      	ldr	r3, [r7, #12]
 800666e:	88fa      	ldrh	r2, [r7, #6]
 8006670:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
    huart->TxXferCount = Size;
 8006674:	68fb      	ldr	r3, [r7, #12]
 8006676:	88fa      	ldrh	r2, [r7, #6]
 8006678:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800667c:	68fb      	ldr	r3, [r7, #12]
 800667e:	689b      	ldr	r3, [r3, #8]
 8006680:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8006684:	d108      	bne.n	8006698 <HAL_UART_Transmit+0x8c>
 8006686:	68fb      	ldr	r3, [r7, #12]
 8006688:	691b      	ldr	r3, [r3, #16]
 800668a:	2b00      	cmp	r3, #0
 800668c:	d104      	bne.n	8006698 <HAL_UART_Transmit+0x8c>
    {
      pdata8bits  = NULL;
 800668e:	2300      	movs	r3, #0
 8006690:	61fb      	str	r3, [r7, #28]
      pdata16bits = (const uint16_t *) pData;
 8006692:	68bb      	ldr	r3, [r7, #8]
 8006694:	61bb      	str	r3, [r7, #24]
 8006696:	e003      	b.n	80066a0 <HAL_UART_Transmit+0x94>
    }
    else
    {
      pdata8bits  = pData;
 8006698:	68bb      	ldr	r3, [r7, #8]
 800669a:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 800669c:	2300      	movs	r3, #0
 800669e:	61bb      	str	r3, [r7, #24]
    }

    while (huart->TxXferCount > 0U)
 80066a0:	e030      	b.n	8006704 <HAL_UART_Transmit+0xf8>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 80066a2:	683b      	ldr	r3, [r7, #0]
 80066a4:	9300      	str	r3, [sp, #0]
 80066a6:	697b      	ldr	r3, [r7, #20]
 80066a8:	2200      	movs	r2, #0
 80066aa:	2180      	movs	r1, #128	; 0x80
 80066ac:	68f8      	ldr	r0, [r7, #12]
 80066ae:	f000 fb39 	bl	8006d24 <UART_WaitOnFlagUntilTimeout>
 80066b2:	4603      	mov	r3, r0
 80066b4:	2b00      	cmp	r3, #0
 80066b6:	d005      	beq.n	80066c4 <HAL_UART_Transmit+0xb8>
      {

        huart->gState = HAL_UART_STATE_READY;
 80066b8:	68fb      	ldr	r3, [r7, #12]
 80066ba:	2220      	movs	r2, #32
 80066bc:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

        return HAL_TIMEOUT;
 80066c0:	2303      	movs	r3, #3
 80066c2:	e03d      	b.n	8006740 <HAL_UART_Transmit+0x134>
      }
      if (pdata8bits == NULL)
 80066c4:	69fb      	ldr	r3, [r7, #28]
 80066c6:	2b00      	cmp	r3, #0
 80066c8:	d10b      	bne.n	80066e2 <HAL_UART_Transmit+0xd6>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 80066ca:	69bb      	ldr	r3, [r7, #24]
 80066cc:	881b      	ldrh	r3, [r3, #0]
 80066ce:	461a      	mov	r2, r3
 80066d0:	68fb      	ldr	r3, [r7, #12]
 80066d2:	681b      	ldr	r3, [r3, #0]
 80066d4:	f3c2 0208 	ubfx	r2, r2, #0, #9
 80066d8:	629a      	str	r2, [r3, #40]	; 0x28
        pdata16bits++;
 80066da:	69bb      	ldr	r3, [r7, #24]
 80066dc:	3302      	adds	r3, #2
 80066de:	61bb      	str	r3, [r7, #24]
 80066e0:	e007      	b.n	80066f2 <HAL_UART_Transmit+0xe6>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 80066e2:	69fb      	ldr	r3, [r7, #28]
 80066e4:	781a      	ldrb	r2, [r3, #0]
 80066e6:	68fb      	ldr	r3, [r7, #12]
 80066e8:	681b      	ldr	r3, [r3, #0]
 80066ea:	629a      	str	r2, [r3, #40]	; 0x28
        pdata8bits++;
 80066ec:	69fb      	ldr	r3, [r7, #28]
 80066ee:	3301      	adds	r3, #1
 80066f0:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 80066f2:	68fb      	ldr	r3, [r7, #12]
 80066f4:	f8b3 3056 	ldrh.w	r3, [r3, #86]	; 0x56
 80066f8:	b29b      	uxth	r3, r3
 80066fa:	3b01      	subs	r3, #1
 80066fc:	b29a      	uxth	r2, r3
 80066fe:	68fb      	ldr	r3, [r7, #12]
 8006700:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56
    while (huart->TxXferCount > 0U)
 8006704:	68fb      	ldr	r3, [r7, #12]
 8006706:	f8b3 3056 	ldrh.w	r3, [r3, #86]	; 0x56
 800670a:	b29b      	uxth	r3, r3
 800670c:	2b00      	cmp	r3, #0
 800670e:	d1c8      	bne.n	80066a2 <HAL_UART_Transmit+0x96>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8006710:	683b      	ldr	r3, [r7, #0]
 8006712:	9300      	str	r3, [sp, #0]
 8006714:	697b      	ldr	r3, [r7, #20]
 8006716:	2200      	movs	r2, #0
 8006718:	2140      	movs	r1, #64	; 0x40
 800671a:	68f8      	ldr	r0, [r7, #12]
 800671c:	f000 fb02 	bl	8006d24 <UART_WaitOnFlagUntilTimeout>
 8006720:	4603      	mov	r3, r0
 8006722:	2b00      	cmp	r3, #0
 8006724:	d005      	beq.n	8006732 <HAL_UART_Transmit+0x126>
    {
      huart->gState = HAL_UART_STATE_READY;
 8006726:	68fb      	ldr	r3, [r7, #12]
 8006728:	2220      	movs	r2, #32
 800672a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

      return HAL_TIMEOUT;
 800672e:	2303      	movs	r3, #3
 8006730:	e006      	b.n	8006740 <HAL_UART_Transmit+0x134>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 8006732:	68fb      	ldr	r3, [r7, #12]
 8006734:	2220      	movs	r2, #32
 8006736:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

    return HAL_OK;
 800673a:	2300      	movs	r3, #0
 800673c:	e000      	b.n	8006740 <HAL_UART_Transmit+0x134>
  }
  else
  {
    return HAL_BUSY;
 800673e:	2302      	movs	r3, #2
  }
}
 8006740:	4618      	mov	r0, r3
 8006742:	3720      	adds	r7, #32
 8006744:	46bd      	mov	sp, r7
 8006746:	bd80      	pop	{r7, pc}

08006748 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8006748:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800674c:	b094      	sub	sp, #80	; 0x50
 800674e:	af00      	add	r7, sp, #0
 8006750:	62f8      	str	r0, [r7, #44]	; 0x2c
  uint32_t tmpreg;
  uint16_t brrtemp;
  uint32_t clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 8006752:	2300      	movs	r3, #0
 8006754:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
  uint32_t pclk;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  if (UART_INSTANCE_LOWPOWER(huart))
 8006758:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800675a:	681a      	ldr	r2, [r3, #0]
 800675c:	4b7e      	ldr	r3, [pc, #504]	; (8006958 <UART_SetConfig+0x210>)
 800675e:	429a      	cmp	r2, r3
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8006760:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006762:	689a      	ldr	r2, [r3, #8]
 8006764:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006766:	691b      	ldr	r3, [r3, #16]
 8006768:	431a      	orrs	r2, r3
 800676a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800676c:	695b      	ldr	r3, [r3, #20]
 800676e:	431a      	orrs	r2, r3
 8006770:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006772:	69db      	ldr	r3, [r3, #28]
 8006774:	4313      	orrs	r3, r2
 8006776:	64fb      	str	r3, [r7, #76]	; 0x4c
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8006778:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800677a:	681b      	ldr	r3, [r3, #0]
 800677c:	681b      	ldr	r3, [r3, #0]
 800677e:	4977      	ldr	r1, [pc, #476]	; (800695c <UART_SetConfig+0x214>)
 8006780:	4019      	ands	r1, r3
 8006782:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006784:	681a      	ldr	r2, [r3, #0]
 8006786:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006788:	430b      	orrs	r3, r1
 800678a:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800678c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800678e:	681b      	ldr	r3, [r3, #0]
 8006790:	685b      	ldr	r3, [r3, #4]
 8006792:	f423 5040 	bic.w	r0, r3, #12288	; 0x3000
 8006796:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006798:	68d9      	ldr	r1, [r3, #12]
 800679a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800679c:	681a      	ldr	r2, [r3, #0]
 800679e:	ea40 0301 	orr.w	r3, r0, r1
 80067a2:	6053      	str	r3, [r2, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 80067a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80067a6:	699b      	ldr	r3, [r3, #24]
 80067a8:	64fb      	str	r3, [r7, #76]	; 0x4c

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80067aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80067ac:	681a      	ldr	r2, [r3, #0]
 80067ae:	4b6a      	ldr	r3, [pc, #424]	; (8006958 <UART_SetConfig+0x210>)
 80067b0:	429a      	cmp	r2, r3
 80067b2:	d009      	beq.n	80067c8 <UART_SetConfig+0x80>
 80067b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80067b6:	681a      	ldr	r2, [r3, #0]
 80067b8:	4b69      	ldr	r3, [pc, #420]	; (8006960 <UART_SetConfig+0x218>)
 80067ba:	429a      	cmp	r2, r3
 80067bc:	d004      	beq.n	80067c8 <UART_SetConfig+0x80>
  {
    tmpreg |= huart->Init.OneBitSampling;
 80067be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80067c0:	6a1a      	ldr	r2, [r3, #32]
 80067c2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80067c4:	4313      	orrs	r3, r2
 80067c6:	64fb      	str	r3, [r7, #76]	; 0x4c
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80067c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80067ca:	681b      	ldr	r3, [r3, #0]
 80067cc:	689b      	ldr	r3, [r3, #8]
 80067ce:	f023 416e 	bic.w	r1, r3, #3992977408	; 0xee000000
 80067d2:	f421 6130 	bic.w	r1, r1, #2816	; 0xb00
 80067d6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80067d8:	681a      	ldr	r2, [r3, #0]
 80067da:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80067dc:	430b      	orrs	r3, r1
 80067de:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 80067e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80067e2:	681b      	ldr	r3, [r3, #0]
 80067e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80067e6:	f023 000f 	bic.w	r0, r3, #15
 80067ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80067ec:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80067ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80067f0:	681a      	ldr	r2, [r3, #0]
 80067f2:	ea40 0301 	orr.w	r3, r0, r1
 80067f6:	62d3      	str	r3, [r2, #44]	; 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 80067f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80067fa:	681a      	ldr	r2, [r3, #0]
 80067fc:	4b59      	ldr	r3, [pc, #356]	; (8006964 <UART_SetConfig+0x21c>)
 80067fe:	429a      	cmp	r2, r3
 8006800:	d102      	bne.n	8006808 <UART_SetConfig+0xc0>
 8006802:	2301      	movs	r3, #1
 8006804:	64bb      	str	r3, [r7, #72]	; 0x48
 8006806:	e029      	b.n	800685c <UART_SetConfig+0x114>
 8006808:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800680a:	681a      	ldr	r2, [r3, #0]
 800680c:	4b56      	ldr	r3, [pc, #344]	; (8006968 <UART_SetConfig+0x220>)
 800680e:	429a      	cmp	r2, r3
 8006810:	d102      	bne.n	8006818 <UART_SetConfig+0xd0>
 8006812:	2302      	movs	r3, #2
 8006814:	64bb      	str	r3, [r7, #72]	; 0x48
 8006816:	e021      	b.n	800685c <UART_SetConfig+0x114>
 8006818:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800681a:	681a      	ldr	r2, [r3, #0]
 800681c:	4b53      	ldr	r3, [pc, #332]	; (800696c <UART_SetConfig+0x224>)
 800681e:	429a      	cmp	r2, r3
 8006820:	d102      	bne.n	8006828 <UART_SetConfig+0xe0>
 8006822:	2304      	movs	r3, #4
 8006824:	64bb      	str	r3, [r7, #72]	; 0x48
 8006826:	e019      	b.n	800685c <UART_SetConfig+0x114>
 8006828:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800682a:	681a      	ldr	r2, [r3, #0]
 800682c:	4b50      	ldr	r3, [pc, #320]	; (8006970 <UART_SetConfig+0x228>)
 800682e:	429a      	cmp	r2, r3
 8006830:	d102      	bne.n	8006838 <UART_SetConfig+0xf0>
 8006832:	2308      	movs	r3, #8
 8006834:	64bb      	str	r3, [r7, #72]	; 0x48
 8006836:	e011      	b.n	800685c <UART_SetConfig+0x114>
 8006838:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800683a:	681a      	ldr	r2, [r3, #0]
 800683c:	4b4d      	ldr	r3, [pc, #308]	; (8006974 <UART_SetConfig+0x22c>)
 800683e:	429a      	cmp	r2, r3
 8006840:	d102      	bne.n	8006848 <UART_SetConfig+0x100>
 8006842:	2310      	movs	r3, #16
 8006844:	64bb      	str	r3, [r7, #72]	; 0x48
 8006846:	e009      	b.n	800685c <UART_SetConfig+0x114>
 8006848:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800684a:	681a      	ldr	r2, [r3, #0]
 800684c:	4b42      	ldr	r3, [pc, #264]	; (8006958 <UART_SetConfig+0x210>)
 800684e:	429a      	cmp	r2, r3
 8006850:	d102      	bne.n	8006858 <UART_SetConfig+0x110>
 8006852:	2320      	movs	r3, #32
 8006854:	64bb      	str	r3, [r7, #72]	; 0x48
 8006856:	e001      	b.n	800685c <UART_SetConfig+0x114>
 8006858:	2300      	movs	r3, #0
 800685a:	64bb      	str	r3, [r7, #72]	; 0x48

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 800685c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800685e:	681a      	ldr	r2, [r3, #0]
 8006860:	4b3d      	ldr	r3, [pc, #244]	; (8006958 <UART_SetConfig+0x210>)
 8006862:	429a      	cmp	r2, r3
 8006864:	d005      	beq.n	8006872 <UART_SetConfig+0x12a>
 8006866:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006868:	681a      	ldr	r2, [r3, #0]
 800686a:	4b3d      	ldr	r3, [pc, #244]	; (8006960 <UART_SetConfig+0x218>)
 800686c:	429a      	cmp	r2, r3
 800686e:	f040 8085 	bne.w	800697c <UART_SetConfig+0x234>
  {
    /* Retrieve frequency clock */
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 8006872:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8006874:	2200      	movs	r2, #0
 8006876:	623b      	str	r3, [r7, #32]
 8006878:	627a      	str	r2, [r7, #36]	; 0x24
 800687a:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 800687e:	f7fd ffd5 	bl	800482c <HAL_RCCEx_GetPeriphCLKFreq>
 8006882:	6438      	str	r0, [r7, #64]	; 0x40

    /* If proper clock source reported */
    if (pclk != 0U)
 8006884:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8006886:	2b00      	cmp	r3, #0
 8006888:	f000 80e8 	beq.w	8006a5c <UART_SetConfig+0x314>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 800688c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800688e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006890:	4a39      	ldr	r2, [pc, #228]	; (8006978 <UART_SetConfig+0x230>)
 8006892:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8006896:	461a      	mov	r2, r3
 8006898:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800689a:	fbb3 f3f2 	udiv	r3, r3, r2
 800689e:	637b      	str	r3, [r7, #52]	; 0x34

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 80068a0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80068a2:	685a      	ldr	r2, [r3, #4]
 80068a4:	4613      	mov	r3, r2
 80068a6:	005b      	lsls	r3, r3, #1
 80068a8:	4413      	add	r3, r2
 80068aa:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80068ac:	429a      	cmp	r2, r3
 80068ae:	d305      	bcc.n	80068bc <UART_SetConfig+0x174>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
 80068b0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80068b2:	685b      	ldr	r3, [r3, #4]
 80068b4:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 80068b6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80068b8:	429a      	cmp	r2, r3
 80068ba:	d903      	bls.n	80068c4 <UART_SetConfig+0x17c>
      {
        ret = HAL_ERROR;
 80068bc:	2301      	movs	r3, #1
 80068be:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 80068c2:	e048      	b.n	8006956 <UART_SetConfig+0x20e>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80068c4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80068c6:	2200      	movs	r2, #0
 80068c8:	61bb      	str	r3, [r7, #24]
 80068ca:	61fa      	str	r2, [r7, #28]
 80068cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80068ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80068d0:	4a29      	ldr	r2, [pc, #164]	; (8006978 <UART_SetConfig+0x230>)
 80068d2:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80068d6:	b29b      	uxth	r3, r3
 80068d8:	2200      	movs	r2, #0
 80068da:	613b      	str	r3, [r7, #16]
 80068dc:	617a      	str	r2, [r7, #20]
 80068de:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 80068e2:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 80068e6:	f7f9 ff77 	bl	80007d8 <__aeabi_uldivmod>
 80068ea:	4602      	mov	r2, r0
 80068ec:	460b      	mov	r3, r1
 80068ee:	4610      	mov	r0, r2
 80068f0:	4619      	mov	r1, r3
 80068f2:	f04f 0200 	mov.w	r2, #0
 80068f6:	f04f 0300 	mov.w	r3, #0
 80068fa:	020b      	lsls	r3, r1, #8
 80068fc:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
 8006900:	0202      	lsls	r2, r0, #8
 8006902:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8006904:	6849      	ldr	r1, [r1, #4]
 8006906:	0849      	lsrs	r1, r1, #1
 8006908:	2000      	movs	r0, #0
 800690a:	460c      	mov	r4, r1
 800690c:	4605      	mov	r5, r0
 800690e:	eb12 0804 	adds.w	r8, r2, r4
 8006912:	eb43 0905 	adc.w	r9, r3, r5
 8006916:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006918:	685b      	ldr	r3, [r3, #4]
 800691a:	2200      	movs	r2, #0
 800691c:	60bb      	str	r3, [r7, #8]
 800691e:	60fa      	str	r2, [r7, #12]
 8006920:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8006924:	4640      	mov	r0, r8
 8006926:	4649      	mov	r1, r9
 8006928:	f7f9 ff56 	bl	80007d8 <__aeabi_uldivmod>
 800692c:	4602      	mov	r2, r0
 800692e:	460b      	mov	r3, r1
 8006930:	4613      	mov	r3, r2
 8006932:	63fb      	str	r3, [r7, #60]	; 0x3c
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8006934:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8006936:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800693a:	d308      	bcc.n	800694e <UART_SetConfig+0x206>
 800693c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800693e:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8006942:	d204      	bcs.n	800694e <UART_SetConfig+0x206>
        {
          huart->Instance->BRR = usartdiv;
 8006944:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006946:	681b      	ldr	r3, [r3, #0]
 8006948:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800694a:	60da      	str	r2, [r3, #12]
 800694c:	e003      	b.n	8006956 <UART_SetConfig+0x20e>
        }
        else
        {
          ret = HAL_ERROR;
 800694e:	2301      	movs	r3, #1
 8006950:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    if (pclk != 0U)
 8006954:	e082      	b.n	8006a5c <UART_SetConfig+0x314>
 8006956:	e081      	b.n	8006a5c <UART_SetConfig+0x314>
 8006958:	46002400 	.word	0x46002400
 800695c:	cfff69f3 	.word	0xcfff69f3
 8006960:	56002400 	.word	0x56002400
 8006964:	40013800 	.word	0x40013800
 8006968:	40004400 	.word	0x40004400
 800696c:	40004800 	.word	0x40004800
 8006970:	40004c00 	.word	0x40004c00
 8006974:	40005000 	.word	0x40005000
 8006978:	08017b6c 	.word	0x08017b6c
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800697c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800697e:	69db      	ldr	r3, [r3, #28]
 8006980:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8006984:	d13c      	bne.n	8006a00 <UART_SetConfig+0x2b8>
  {
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 8006986:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8006988:	2200      	movs	r2, #0
 800698a:	603b      	str	r3, [r7, #0]
 800698c:	607a      	str	r2, [r7, #4]
 800698e:	e9d7 0100 	ldrd	r0, r1, [r7]
 8006992:	f7fd ff4b 	bl	800482c <HAL_RCCEx_GetPeriphCLKFreq>
 8006996:	6438      	str	r0, [r7, #64]	; 0x40

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 8006998:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800699a:	2b00      	cmp	r3, #0
 800699c:	d05e      	beq.n	8006a5c <UART_SetConfig+0x314>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800699e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80069a0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80069a2:	4a39      	ldr	r2, [pc, #228]	; (8006a88 <UART_SetConfig+0x340>)
 80069a4:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80069a8:	461a      	mov	r2, r3
 80069aa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80069ac:	fbb3 f3f2 	udiv	r3, r3, r2
 80069b0:	005a      	lsls	r2, r3, #1
 80069b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80069b4:	685b      	ldr	r3, [r3, #4]
 80069b6:	085b      	lsrs	r3, r3, #1
 80069b8:	441a      	add	r2, r3
 80069ba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80069bc:	685b      	ldr	r3, [r3, #4]
 80069be:	fbb2 f3f3 	udiv	r3, r2, r3
 80069c2:	63fb      	str	r3, [r7, #60]	; 0x3c
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80069c4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80069c6:	2b0f      	cmp	r3, #15
 80069c8:	d916      	bls.n	80069f8 <UART_SetConfig+0x2b0>
 80069ca:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80069cc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80069d0:	d212      	bcs.n	80069f8 <UART_SetConfig+0x2b0>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 80069d2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80069d4:	b29b      	uxth	r3, r3
 80069d6:	f023 030f 	bic.w	r3, r3, #15
 80069da:	877b      	strh	r3, [r7, #58]	; 0x3a
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 80069dc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80069de:	085b      	lsrs	r3, r3, #1
 80069e0:	b29b      	uxth	r3, r3
 80069e2:	f003 0307 	and.w	r3, r3, #7
 80069e6:	b29a      	uxth	r2, r3
 80069e8:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 80069ea:	4313      	orrs	r3, r2
 80069ec:	877b      	strh	r3, [r7, #58]	; 0x3a
        huart->Instance->BRR = brrtemp;
 80069ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80069f0:	681b      	ldr	r3, [r3, #0]
 80069f2:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
 80069f4:	60da      	str	r2, [r3, #12]
 80069f6:	e031      	b.n	8006a5c <UART_SetConfig+0x314>
      }
      else
      {
        ret = HAL_ERROR;
 80069f8:	2301      	movs	r3, #1
 80069fa:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 80069fe:	e02d      	b.n	8006a5c <UART_SetConfig+0x314>
      }
    }
  }
  else
  {
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 8006a00:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8006a02:	2200      	movs	r2, #0
 8006a04:	469a      	mov	sl, r3
 8006a06:	4693      	mov	fp, r2
 8006a08:	4650      	mov	r0, sl
 8006a0a:	4659      	mov	r1, fp
 8006a0c:	f7fd ff0e 	bl	800482c <HAL_RCCEx_GetPeriphCLKFreq>
 8006a10:	6438      	str	r0, [r7, #64]	; 0x40

    if (pclk != 0U)
 8006a12:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8006a14:	2b00      	cmp	r3, #0
 8006a16:	d021      	beq.n	8006a5c <UART_SetConfig+0x314>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8006a18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006a1a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006a1c:	4a1a      	ldr	r2, [pc, #104]	; (8006a88 <UART_SetConfig+0x340>)
 8006a1e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8006a22:	461a      	mov	r2, r3
 8006a24:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8006a26:	fbb3 f2f2 	udiv	r2, r3, r2
 8006a2a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006a2c:	685b      	ldr	r3, [r3, #4]
 8006a2e:	085b      	lsrs	r3, r3, #1
 8006a30:	441a      	add	r2, r3
 8006a32:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006a34:	685b      	ldr	r3, [r3, #4]
 8006a36:	fbb2 f3f3 	udiv	r3, r2, r3
 8006a3a:	63fb      	str	r3, [r7, #60]	; 0x3c
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8006a3c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8006a3e:	2b0f      	cmp	r3, #15
 8006a40:	d909      	bls.n	8006a56 <UART_SetConfig+0x30e>
 8006a42:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8006a44:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8006a48:	d205      	bcs.n	8006a56 <UART_SetConfig+0x30e>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
 8006a4a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8006a4c:	b29a      	uxth	r2, r3
 8006a4e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006a50:	681b      	ldr	r3, [r3, #0]
 8006a52:	60da      	str	r2, [r3, #12]
 8006a54:	e002      	b.n	8006a5c <UART_SetConfig+0x314>
      }
      else
      {
        ret = HAL_ERROR;
 8006a56:	2301      	movs	r3, #1
 8006a58:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
 8006a5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006a5e:	2201      	movs	r2, #1
 8006a60:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
  huart->NbRxDataToProcess = 1;
 8006a64:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006a66:	2201      	movs	r2, #1
 8006a68:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 8006a6c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006a6e:	2200      	movs	r2, #0
 8006a70:	675a      	str	r2, [r3, #116]	; 0x74
  huart->TxISR = NULL;
 8006a72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006a74:	2200      	movs	r2, #0
 8006a76:	679a      	str	r2, [r3, #120]	; 0x78

  return ret;
 8006a78:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
}
 8006a7c:	4618      	mov	r0, r3
 8006a7e:	3750      	adds	r7, #80	; 0x50
 8006a80:	46bd      	mov	sp, r7
 8006a82:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8006a86:	bf00      	nop
 8006a88:	08017b6c 	.word	0x08017b6c

08006a8c <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 8006a8c:	b480      	push	{r7}
 8006a8e:	b083      	sub	sp, #12
 8006a90:	af00      	add	r7, sp, #0
 8006a92:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8006a94:	687b      	ldr	r3, [r7, #4]
 8006a96:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006a98:	f003 0308 	and.w	r3, r3, #8
 8006a9c:	2b00      	cmp	r3, #0
 8006a9e:	d00a      	beq.n	8006ab6 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8006aa0:	687b      	ldr	r3, [r7, #4]
 8006aa2:	681b      	ldr	r3, [r3, #0]
 8006aa4:	685b      	ldr	r3, [r3, #4]
 8006aa6:	f423 4100 	bic.w	r1, r3, #32768	; 0x8000
 8006aaa:	687b      	ldr	r3, [r7, #4]
 8006aac:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8006aae:	687b      	ldr	r3, [r7, #4]
 8006ab0:	681b      	ldr	r3, [r3, #0]
 8006ab2:	430a      	orrs	r2, r1
 8006ab4:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8006ab6:	687b      	ldr	r3, [r7, #4]
 8006ab8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006aba:	f003 0301 	and.w	r3, r3, #1
 8006abe:	2b00      	cmp	r3, #0
 8006ac0:	d00a      	beq.n	8006ad8 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8006ac2:	687b      	ldr	r3, [r7, #4]
 8006ac4:	681b      	ldr	r3, [r3, #0]
 8006ac6:	685b      	ldr	r3, [r3, #4]
 8006ac8:	f423 3100 	bic.w	r1, r3, #131072	; 0x20000
 8006acc:	687b      	ldr	r3, [r7, #4]
 8006ace:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8006ad0:	687b      	ldr	r3, [r7, #4]
 8006ad2:	681b      	ldr	r3, [r3, #0]
 8006ad4:	430a      	orrs	r2, r1
 8006ad6:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8006ad8:	687b      	ldr	r3, [r7, #4]
 8006ada:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006adc:	f003 0302 	and.w	r3, r3, #2
 8006ae0:	2b00      	cmp	r3, #0
 8006ae2:	d00a      	beq.n	8006afa <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8006ae4:	687b      	ldr	r3, [r7, #4]
 8006ae6:	681b      	ldr	r3, [r3, #0]
 8006ae8:	685b      	ldr	r3, [r3, #4]
 8006aea:	f423 3180 	bic.w	r1, r3, #65536	; 0x10000
 8006aee:	687b      	ldr	r3, [r7, #4]
 8006af0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006af2:	687b      	ldr	r3, [r7, #4]
 8006af4:	681b      	ldr	r3, [r3, #0]
 8006af6:	430a      	orrs	r2, r1
 8006af8:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8006afa:	687b      	ldr	r3, [r7, #4]
 8006afc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006afe:	f003 0304 	and.w	r3, r3, #4
 8006b02:	2b00      	cmp	r3, #0
 8006b04:	d00a      	beq.n	8006b1c <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8006b06:	687b      	ldr	r3, [r7, #4]
 8006b08:	681b      	ldr	r3, [r3, #0]
 8006b0a:	685b      	ldr	r3, [r3, #4]
 8006b0c:	f423 2180 	bic.w	r1, r3, #262144	; 0x40000
 8006b10:	687b      	ldr	r3, [r7, #4]
 8006b12:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8006b14:	687b      	ldr	r3, [r7, #4]
 8006b16:	681b      	ldr	r3, [r3, #0]
 8006b18:	430a      	orrs	r2, r1
 8006b1a:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8006b1c:	687b      	ldr	r3, [r7, #4]
 8006b1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006b20:	f003 0310 	and.w	r3, r3, #16
 8006b24:	2b00      	cmp	r3, #0
 8006b26:	d00a      	beq.n	8006b3e <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8006b28:	687b      	ldr	r3, [r7, #4]
 8006b2a:	681b      	ldr	r3, [r3, #0]
 8006b2c:	689b      	ldr	r3, [r3, #8]
 8006b2e:	f423 5180 	bic.w	r1, r3, #4096	; 0x1000
 8006b32:	687b      	ldr	r3, [r7, #4]
 8006b34:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8006b36:	687b      	ldr	r3, [r7, #4]
 8006b38:	681b      	ldr	r3, [r3, #0]
 8006b3a:	430a      	orrs	r2, r1
 8006b3c:	609a      	str	r2, [r3, #8]
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8006b3e:	687b      	ldr	r3, [r7, #4]
 8006b40:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006b42:	f003 0320 	and.w	r3, r3, #32
 8006b46:	2b00      	cmp	r3, #0
 8006b48:	d00a      	beq.n	8006b60 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8006b4a:	687b      	ldr	r3, [r7, #4]
 8006b4c:	681b      	ldr	r3, [r3, #0]
 8006b4e:	689b      	ldr	r3, [r3, #8]
 8006b50:	f423 5100 	bic.w	r1, r3, #8192	; 0x2000
 8006b54:	687b      	ldr	r3, [r7, #4]
 8006b56:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006b58:	687b      	ldr	r3, [r7, #4]
 8006b5a:	681b      	ldr	r3, [r3, #0]
 8006b5c:	430a      	orrs	r2, r1
 8006b5e:	609a      	str	r2, [r3, #8]
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8006b60:	687b      	ldr	r3, [r7, #4]
 8006b62:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006b64:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006b68:	2b00      	cmp	r3, #0
 8006b6a:	d01a      	beq.n	8006ba2 <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8006b6c:	687b      	ldr	r3, [r7, #4]
 8006b6e:	681b      	ldr	r3, [r3, #0]
 8006b70:	685b      	ldr	r3, [r3, #4]
 8006b72:	f423 1180 	bic.w	r1, r3, #1048576	; 0x100000
 8006b76:	687b      	ldr	r3, [r7, #4]
 8006b78:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006b7a:	687b      	ldr	r3, [r7, #4]
 8006b7c:	681b      	ldr	r3, [r3, #0]
 8006b7e:	430a      	orrs	r2, r1
 8006b80:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8006b82:	687b      	ldr	r3, [r7, #4]
 8006b84:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8006b86:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8006b8a:	d10a      	bne.n	8006ba2 <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8006b8c:	687b      	ldr	r3, [r7, #4]
 8006b8e:	681b      	ldr	r3, [r3, #0]
 8006b90:	685b      	ldr	r3, [r3, #4]
 8006b92:	f423 01c0 	bic.w	r1, r3, #6291456	; 0x600000
 8006b96:	687b      	ldr	r3, [r7, #4]
 8006b98:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8006b9a:	687b      	ldr	r3, [r7, #4]
 8006b9c:	681b      	ldr	r3, [r3, #0]
 8006b9e:	430a      	orrs	r2, r1
 8006ba0:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8006ba2:	687b      	ldr	r3, [r7, #4]
 8006ba4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006ba6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006baa:	2b00      	cmp	r3, #0
 8006bac:	d00a      	beq.n	8006bc4 <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8006bae:	687b      	ldr	r3, [r7, #4]
 8006bb0:	681b      	ldr	r3, [r3, #0]
 8006bb2:	685b      	ldr	r3, [r3, #4]
 8006bb4:	f423 2100 	bic.w	r1, r3, #524288	; 0x80000
 8006bb8:	687b      	ldr	r3, [r7, #4]
 8006bba:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8006bbc:	687b      	ldr	r3, [r7, #4]
 8006bbe:	681b      	ldr	r3, [r3, #0]
 8006bc0:	430a      	orrs	r2, r1
 8006bc2:	605a      	str	r2, [r3, #4]
  }
}
 8006bc4:	bf00      	nop
 8006bc6:	370c      	adds	r7, #12
 8006bc8:	46bd      	mov	sp, r7
 8006bca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006bce:	4770      	bx	lr

08006bd0 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 8006bd0:	b580      	push	{r7, lr}
 8006bd2:	b098      	sub	sp, #96	; 0x60
 8006bd4:	af02      	add	r7, sp, #8
 8006bd6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8006bd8:	687b      	ldr	r3, [r7, #4]
 8006bda:	2200      	movs	r2, #0
 8006bdc:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 8006be0:	f7fa fd58 	bl	8001694 <HAL_GetTick>
 8006be4:	6578      	str	r0, [r7, #84]	; 0x54

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8006be6:	687b      	ldr	r3, [r7, #4]
 8006be8:	681b      	ldr	r3, [r3, #0]
 8006bea:	681b      	ldr	r3, [r3, #0]
 8006bec:	f003 0308 	and.w	r3, r3, #8
 8006bf0:	2b08      	cmp	r3, #8
 8006bf2:	d12f      	bne.n	8006c54 <UART_CheckIdleState+0x84>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8006bf4:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8006bf8:	9300      	str	r3, [sp, #0]
 8006bfa:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006bfc:	2200      	movs	r2, #0
 8006bfe:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8006c02:	6878      	ldr	r0, [r7, #4]
 8006c04:	f000 f88e 	bl	8006d24 <UART_WaitOnFlagUntilTimeout>
 8006c08:	4603      	mov	r3, r0
 8006c0a:	2b00      	cmp	r3, #0
 8006c0c:	d022      	beq.n	8006c54 <UART_CheckIdleState+0x84>
    {
      /* Disable TXE interrupt for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
 8006c0e:	687b      	ldr	r3, [r7, #4]
 8006c10:	681b      	ldr	r3, [r3, #0]
 8006c12:	63bb      	str	r3, [r7, #56]	; 0x38
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006c14:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006c16:	e853 3f00 	ldrex	r3, [r3]
 8006c1a:	637b      	str	r3, [r7, #52]	; 0x34
   return(result);
 8006c1c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8006c1e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8006c22:	653b      	str	r3, [r7, #80]	; 0x50
 8006c24:	687b      	ldr	r3, [r7, #4]
 8006c26:	681b      	ldr	r3, [r3, #0]
 8006c28:	461a      	mov	r2, r3
 8006c2a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006c2c:	647b      	str	r3, [r7, #68]	; 0x44
 8006c2e:	643a      	str	r2, [r7, #64]	; 0x40
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006c30:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8006c32:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8006c34:	e841 2300 	strex	r3, r2, [r1]
 8006c38:	63fb      	str	r3, [r7, #60]	; 0x3c
   return(result);
 8006c3a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8006c3c:	2b00      	cmp	r3, #0
 8006c3e:	d1e6      	bne.n	8006c0e <UART_CheckIdleState+0x3e>

      huart->gState = HAL_UART_STATE_READY;
 8006c40:	687b      	ldr	r3, [r7, #4]
 8006c42:	2220      	movs	r2, #32
 8006c44:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

      __HAL_UNLOCK(huart);
 8006c48:	687b      	ldr	r3, [r7, #4]
 8006c4a:	2200      	movs	r2, #0
 8006c4c:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
 8006c50:	2303      	movs	r3, #3
 8006c52:	e063      	b.n	8006d1c <UART_CheckIdleState+0x14c>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8006c54:	687b      	ldr	r3, [r7, #4]
 8006c56:	681b      	ldr	r3, [r3, #0]
 8006c58:	681b      	ldr	r3, [r3, #0]
 8006c5a:	f003 0304 	and.w	r3, r3, #4
 8006c5e:	2b04      	cmp	r3, #4
 8006c60:	d149      	bne.n	8006cf6 <UART_CheckIdleState+0x126>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8006c62:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8006c66:	9300      	str	r3, [sp, #0]
 8006c68:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006c6a:	2200      	movs	r2, #0
 8006c6c:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8006c70:	6878      	ldr	r0, [r7, #4]
 8006c72:	f000 f857 	bl	8006d24 <UART_WaitOnFlagUntilTimeout>
 8006c76:	4603      	mov	r3, r0
 8006c78:	2b00      	cmp	r3, #0
 8006c7a:	d03c      	beq.n	8006cf6 <UART_CheckIdleState+0x126>
    {
      /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error)
      interrupts for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8006c7c:	687b      	ldr	r3, [r7, #4]
 8006c7e:	681b      	ldr	r3, [r3, #0]
 8006c80:	627b      	str	r3, [r7, #36]	; 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006c82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006c84:	e853 3f00 	ldrex	r3, [r3]
 8006c88:	623b      	str	r3, [r7, #32]
   return(result);
 8006c8a:	6a3b      	ldr	r3, [r7, #32]
 8006c8c:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 8006c90:	64fb      	str	r3, [r7, #76]	; 0x4c
 8006c92:	687b      	ldr	r3, [r7, #4]
 8006c94:	681b      	ldr	r3, [r3, #0]
 8006c96:	461a      	mov	r2, r3
 8006c98:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006c9a:	633b      	str	r3, [r7, #48]	; 0x30
 8006c9c:	62fa      	str	r2, [r7, #44]	; 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006c9e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8006ca0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8006ca2:	e841 2300 	strex	r3, r2, [r1]
 8006ca6:	62bb      	str	r3, [r7, #40]	; 0x28
   return(result);
 8006ca8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006caa:	2b00      	cmp	r3, #0
 8006cac:	d1e6      	bne.n	8006c7c <UART_CheckIdleState+0xac>
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8006cae:	687b      	ldr	r3, [r7, #4]
 8006cb0:	681b      	ldr	r3, [r3, #0]
 8006cb2:	3308      	adds	r3, #8
 8006cb4:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006cb6:	693b      	ldr	r3, [r7, #16]
 8006cb8:	e853 3f00 	ldrex	r3, [r3]
 8006cbc:	60fb      	str	r3, [r7, #12]
   return(result);
 8006cbe:	68fb      	ldr	r3, [r7, #12]
 8006cc0:	f023 0301 	bic.w	r3, r3, #1
 8006cc4:	64bb      	str	r3, [r7, #72]	; 0x48
 8006cc6:	687b      	ldr	r3, [r7, #4]
 8006cc8:	681b      	ldr	r3, [r3, #0]
 8006cca:	3308      	adds	r3, #8
 8006ccc:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8006cce:	61fa      	str	r2, [r7, #28]
 8006cd0:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006cd2:	69b9      	ldr	r1, [r7, #24]
 8006cd4:	69fa      	ldr	r2, [r7, #28]
 8006cd6:	e841 2300 	strex	r3, r2, [r1]
 8006cda:	617b      	str	r3, [r7, #20]
   return(result);
 8006cdc:	697b      	ldr	r3, [r7, #20]
 8006cde:	2b00      	cmp	r3, #0
 8006ce0:	d1e5      	bne.n	8006cae <UART_CheckIdleState+0xde>

      huart->RxState = HAL_UART_STATE_READY;
 8006ce2:	687b      	ldr	r3, [r7, #4]
 8006ce4:	2220      	movs	r2, #32
 8006ce6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

      __HAL_UNLOCK(huart);
 8006cea:	687b      	ldr	r3, [r7, #4]
 8006cec:	2200      	movs	r2, #0
 8006cee:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
 8006cf2:	2303      	movs	r3, #3
 8006cf4:	e012      	b.n	8006d1c <UART_CheckIdleState+0x14c>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 8006cf6:	687b      	ldr	r3, [r7, #4]
 8006cf8:	2220      	movs	r2, #32
 8006cfa:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  huart->RxState = HAL_UART_STATE_READY;
 8006cfe:	687b      	ldr	r3, [r7, #4]
 8006d00:	2220      	movs	r2, #32
 8006d02:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8006d06:	687b      	ldr	r3, [r7, #4]
 8006d08:	2200      	movs	r2, #0
 8006d0a:	66da      	str	r2, [r3, #108]	; 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 8006d0c:	687b      	ldr	r3, [r7, #4]
 8006d0e:	2200      	movs	r2, #0
 8006d10:	671a      	str	r2, [r3, #112]	; 0x70

  __HAL_UNLOCK(huart);
 8006d12:	687b      	ldr	r3, [r7, #4]
 8006d14:	2200      	movs	r2, #0
 8006d16:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

  return HAL_OK;
 8006d1a:	2300      	movs	r3, #0
}
 8006d1c:	4618      	mov	r0, r3
 8006d1e:	3758      	adds	r7, #88	; 0x58
 8006d20:	46bd      	mov	sp, r7
 8006d22:	bd80      	pop	{r7, pc}

08006d24 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 8006d24:	b580      	push	{r7, lr}
 8006d26:	b084      	sub	sp, #16
 8006d28:	af00      	add	r7, sp, #0
 8006d2a:	60f8      	str	r0, [r7, #12]
 8006d2c:	60b9      	str	r1, [r7, #8]
 8006d2e:	603b      	str	r3, [r7, #0]
 8006d30:	4613      	mov	r3, r2
 8006d32:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8006d34:	e049      	b.n	8006dca <UART_WaitOnFlagUntilTimeout+0xa6>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8006d36:	69bb      	ldr	r3, [r7, #24]
 8006d38:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8006d3c:	d045      	beq.n	8006dca <UART_WaitOnFlagUntilTimeout+0xa6>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8006d3e:	f7fa fca9 	bl	8001694 <HAL_GetTick>
 8006d42:	4602      	mov	r2, r0
 8006d44:	683b      	ldr	r3, [r7, #0]
 8006d46:	1ad3      	subs	r3, r2, r3
 8006d48:	69ba      	ldr	r2, [r7, #24]
 8006d4a:	429a      	cmp	r2, r3
 8006d4c:	d302      	bcc.n	8006d54 <UART_WaitOnFlagUntilTimeout+0x30>
 8006d4e:	69bb      	ldr	r3, [r7, #24]
 8006d50:	2b00      	cmp	r3, #0
 8006d52:	d101      	bne.n	8006d58 <UART_WaitOnFlagUntilTimeout+0x34>
      {

        return HAL_TIMEOUT;
 8006d54:	2303      	movs	r3, #3
 8006d56:	e048      	b.n	8006dea <UART_WaitOnFlagUntilTimeout+0xc6>
      }

      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 8006d58:	68fb      	ldr	r3, [r7, #12]
 8006d5a:	681b      	ldr	r3, [r3, #0]
 8006d5c:	681b      	ldr	r3, [r3, #0]
 8006d5e:	f003 0304 	and.w	r3, r3, #4
 8006d62:	2b00      	cmp	r3, #0
 8006d64:	d031      	beq.n	8006dca <UART_WaitOnFlagUntilTimeout+0xa6>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 8006d66:	68fb      	ldr	r3, [r7, #12]
 8006d68:	681b      	ldr	r3, [r3, #0]
 8006d6a:	69db      	ldr	r3, [r3, #28]
 8006d6c:	f003 0308 	and.w	r3, r3, #8
 8006d70:	2b08      	cmp	r3, #8
 8006d72:	d110      	bne.n	8006d96 <UART_WaitOnFlagUntilTimeout+0x72>
        {
          /* Clear Overrun Error flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 8006d74:	68fb      	ldr	r3, [r7, #12]
 8006d76:	681b      	ldr	r3, [r3, #0]
 8006d78:	2208      	movs	r2, #8
 8006d7a:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
 8006d7c:	68f8      	ldr	r0, [r7, #12]
 8006d7e:	f000 f838 	bl	8006df2 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_ORE;
 8006d82:	68fb      	ldr	r3, [r7, #12]
 8006d84:	2208      	movs	r2, #8
 8006d86:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 8006d8a:	68fb      	ldr	r3, [r7, #12]
 8006d8c:	2200      	movs	r2, #0
 8006d8e:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

          return HAL_ERROR;
 8006d92:	2301      	movs	r3, #1
 8006d94:	e029      	b.n	8006dea <UART_WaitOnFlagUntilTimeout+0xc6>
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 8006d96:	68fb      	ldr	r3, [r7, #12]
 8006d98:	681b      	ldr	r3, [r3, #0]
 8006d9a:	69db      	ldr	r3, [r3, #28]
 8006d9c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8006da0:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8006da4:	d111      	bne.n	8006dca <UART_WaitOnFlagUntilTimeout+0xa6>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8006da6:	68fb      	ldr	r3, [r7, #12]
 8006da8:	681b      	ldr	r3, [r3, #0]
 8006daa:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8006dae:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
 8006db0:	68f8      	ldr	r0, [r7, #12]
 8006db2:	f000 f81e 	bl	8006df2 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8006db6:	68fb      	ldr	r3, [r7, #12]
 8006db8:	2220      	movs	r2, #32
 8006dba:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 8006dbe:	68fb      	ldr	r3, [r7, #12]
 8006dc0:	2200      	movs	r2, #0
 8006dc2:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

          return HAL_TIMEOUT;
 8006dc6:	2303      	movs	r3, #3
 8006dc8:	e00f      	b.n	8006dea <UART_WaitOnFlagUntilTimeout+0xc6>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8006dca:	68fb      	ldr	r3, [r7, #12]
 8006dcc:	681b      	ldr	r3, [r3, #0]
 8006dce:	69da      	ldr	r2, [r3, #28]
 8006dd0:	68bb      	ldr	r3, [r7, #8]
 8006dd2:	4013      	ands	r3, r2
 8006dd4:	68ba      	ldr	r2, [r7, #8]
 8006dd6:	429a      	cmp	r2, r3
 8006dd8:	bf0c      	ite	eq
 8006dda:	2301      	moveq	r3, #1
 8006ddc:	2300      	movne	r3, #0
 8006dde:	b2db      	uxtb	r3, r3
 8006de0:	461a      	mov	r2, r3
 8006de2:	79fb      	ldrb	r3, [r7, #7]
 8006de4:	429a      	cmp	r2, r3
 8006de6:	d0a6      	beq.n	8006d36 <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 8006de8:	2300      	movs	r3, #0
}
 8006dea:	4618      	mov	r0, r3
 8006dec:	3710      	adds	r7, #16
 8006dee:	46bd      	mov	sp, r7
 8006df0:	bd80      	pop	{r7, pc}

08006df2 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 8006df2:	b480      	push	{r7}
 8006df4:	b095      	sub	sp, #84	; 0x54
 8006df6:	af00      	add	r7, sp, #0
 8006df8:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8006dfa:	687b      	ldr	r3, [r7, #4]
 8006dfc:	681b      	ldr	r3, [r3, #0]
 8006dfe:	637b      	str	r3, [r7, #52]	; 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006e00:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8006e02:	e853 3f00 	ldrex	r3, [r3]
 8006e06:	633b      	str	r3, [r7, #48]	; 0x30
   return(result);
 8006e08:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8006e0a:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 8006e0e:	64fb      	str	r3, [r7, #76]	; 0x4c
 8006e10:	687b      	ldr	r3, [r7, #4]
 8006e12:	681b      	ldr	r3, [r3, #0]
 8006e14:	461a      	mov	r2, r3
 8006e16:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006e18:	643b      	str	r3, [r7, #64]	; 0x40
 8006e1a:	63fa      	str	r2, [r7, #60]	; 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006e1c:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8006e1e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8006e20:	e841 2300 	strex	r3, r2, [r1]
 8006e24:	63bb      	str	r3, [r7, #56]	; 0x38
   return(result);
 8006e26:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006e28:	2b00      	cmp	r3, #0
 8006e2a:	d1e6      	bne.n	8006dfa <UART_EndRxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8006e2c:	687b      	ldr	r3, [r7, #4]
 8006e2e:	681b      	ldr	r3, [r3, #0]
 8006e30:	3308      	adds	r3, #8
 8006e32:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006e34:	6a3b      	ldr	r3, [r7, #32]
 8006e36:	e853 3f00 	ldrex	r3, [r3]
 8006e3a:	61fb      	str	r3, [r7, #28]
   return(result);
 8006e3c:	69fb      	ldr	r3, [r7, #28]
 8006e3e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8006e42:	f023 0301 	bic.w	r3, r3, #1
 8006e46:	64bb      	str	r3, [r7, #72]	; 0x48
 8006e48:	687b      	ldr	r3, [r7, #4]
 8006e4a:	681b      	ldr	r3, [r3, #0]
 8006e4c:	3308      	adds	r3, #8
 8006e4e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8006e50:	62fa      	str	r2, [r7, #44]	; 0x2c
 8006e52:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006e54:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8006e56:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8006e58:	e841 2300 	strex	r3, r2, [r1]
 8006e5c:	627b      	str	r3, [r7, #36]	; 0x24
   return(result);
 8006e5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006e60:	2b00      	cmp	r3, #0
 8006e62:	d1e3      	bne.n	8006e2c <UART_EndRxTransfer+0x3a>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8006e64:	687b      	ldr	r3, [r7, #4]
 8006e66:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8006e68:	2b01      	cmp	r3, #1
 8006e6a:	d118      	bne.n	8006e9e <UART_EndRxTransfer+0xac>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8006e6c:	687b      	ldr	r3, [r7, #4]
 8006e6e:	681b      	ldr	r3, [r3, #0]
 8006e70:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006e72:	68fb      	ldr	r3, [r7, #12]
 8006e74:	e853 3f00 	ldrex	r3, [r3]
 8006e78:	60bb      	str	r3, [r7, #8]
   return(result);
 8006e7a:	68bb      	ldr	r3, [r7, #8]
 8006e7c:	f023 0310 	bic.w	r3, r3, #16
 8006e80:	647b      	str	r3, [r7, #68]	; 0x44
 8006e82:	687b      	ldr	r3, [r7, #4]
 8006e84:	681b      	ldr	r3, [r3, #0]
 8006e86:	461a      	mov	r2, r3
 8006e88:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006e8a:	61bb      	str	r3, [r7, #24]
 8006e8c:	617a      	str	r2, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006e8e:	6979      	ldr	r1, [r7, #20]
 8006e90:	69ba      	ldr	r2, [r7, #24]
 8006e92:	e841 2300 	strex	r3, r2, [r1]
 8006e96:	613b      	str	r3, [r7, #16]
   return(result);
 8006e98:	693b      	ldr	r3, [r7, #16]
 8006e9a:	2b00      	cmp	r3, #0
 8006e9c:	d1e6      	bne.n	8006e6c <UART_EndRxTransfer+0x7a>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8006e9e:	687b      	ldr	r3, [r7, #4]
 8006ea0:	2220      	movs	r2, #32
 8006ea2:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8006ea6:	687b      	ldr	r3, [r7, #4]
 8006ea8:	2200      	movs	r2, #0
 8006eaa:	66da      	str	r2, [r3, #108]	; 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 8006eac:	687b      	ldr	r3, [r7, #4]
 8006eae:	2200      	movs	r2, #0
 8006eb0:	675a      	str	r2, [r3, #116]	; 0x74
}
 8006eb2:	bf00      	nop
 8006eb4:	3754      	adds	r7, #84	; 0x54
 8006eb6:	46bd      	mov	sp, r7
 8006eb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006ebc:	4770      	bx	lr

08006ebe <HAL_UARTEx_DisableFifoMode>:
  * @brief  Disable the FIFO mode.
  * @param huart      UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_DisableFifoMode(UART_HandleTypeDef *huart)
{
 8006ebe:	b480      	push	{r7}
 8006ec0:	b085      	sub	sp, #20
 8006ec2:	af00      	add	r7, sp, #0
 8006ec4:	6078      	str	r0, [r7, #4]

  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));

  /* Process Locked */
  __HAL_LOCK(huart);
 8006ec6:	687b      	ldr	r3, [r7, #4]
 8006ec8:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
 8006ecc:	2b01      	cmp	r3, #1
 8006ece:	d101      	bne.n	8006ed4 <HAL_UARTEx_DisableFifoMode+0x16>
 8006ed0:	2302      	movs	r3, #2
 8006ed2:	e027      	b.n	8006f24 <HAL_UARTEx_DisableFifoMode+0x66>
 8006ed4:	687b      	ldr	r3, [r7, #4]
 8006ed6:	2201      	movs	r2, #1
 8006ed8:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

  huart->gState = HAL_UART_STATE_BUSY;
 8006edc:	687b      	ldr	r3, [r7, #4]
 8006ede:	2224      	movs	r2, #36	; 0x24
 8006ee0:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8006ee4:	687b      	ldr	r3, [r7, #4]
 8006ee6:	681b      	ldr	r3, [r3, #0]
 8006ee8:	681b      	ldr	r3, [r3, #0]
 8006eea:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 8006eec:	687b      	ldr	r3, [r7, #4]
 8006eee:	681b      	ldr	r3, [r3, #0]
 8006ef0:	681a      	ldr	r2, [r3, #0]
 8006ef2:	687b      	ldr	r3, [r7, #4]
 8006ef4:	681b      	ldr	r3, [r3, #0]
 8006ef6:	f022 0201 	bic.w	r2, r2, #1
 8006efa:	601a      	str	r2, [r3, #0]

  /* Enable FIFO mode */
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
 8006efc:	68fb      	ldr	r3, [r7, #12]
 8006efe:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
 8006f02:	60fb      	str	r3, [r7, #12]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 8006f04:	687b      	ldr	r3, [r7, #4]
 8006f06:	2200      	movs	r2, #0
 8006f08:	665a      	str	r2, [r3, #100]	; 0x64

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8006f0a:	687b      	ldr	r3, [r7, #4]
 8006f0c:	681b      	ldr	r3, [r3, #0]
 8006f0e:	68fa      	ldr	r2, [r7, #12]
 8006f10:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 8006f12:	687b      	ldr	r3, [r7, #4]
 8006f14:	2220      	movs	r2, #32
 8006f16:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8006f1a:	687b      	ldr	r3, [r7, #4]
 8006f1c:	2200      	movs	r2, #0
 8006f1e:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

  return HAL_OK;
 8006f22:	2300      	movs	r3, #0
}
 8006f24:	4618      	mov	r0, r3
 8006f26:	3714      	adds	r7, #20
 8006f28:	46bd      	mov	sp, r7
 8006f2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006f2e:	4770      	bx	lr

08006f30 <HAL_UARTEx_SetTxFifoThreshold>:
  *            @arg @ref UART_TXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_TXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetTxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
 8006f30:	b580      	push	{r7, lr}
 8006f32:	b084      	sub	sp, #16
 8006f34:	af00      	add	r7, sp, #0
 8006f36:	6078      	str	r0, [r7, #4]
 8006f38:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 8006f3a:	687b      	ldr	r3, [r7, #4]
 8006f3c:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
 8006f40:	2b01      	cmp	r3, #1
 8006f42:	d101      	bne.n	8006f48 <HAL_UARTEx_SetTxFifoThreshold+0x18>
 8006f44:	2302      	movs	r3, #2
 8006f46:	e02d      	b.n	8006fa4 <HAL_UARTEx_SetTxFifoThreshold+0x74>
 8006f48:	687b      	ldr	r3, [r7, #4]
 8006f4a:	2201      	movs	r2, #1
 8006f4c:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

  huart->gState = HAL_UART_STATE_BUSY;
 8006f50:	687b      	ldr	r3, [r7, #4]
 8006f52:	2224      	movs	r2, #36	; 0x24
 8006f54:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8006f58:	687b      	ldr	r3, [r7, #4]
 8006f5a:	681b      	ldr	r3, [r3, #0]
 8006f5c:	681b      	ldr	r3, [r3, #0]
 8006f5e:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 8006f60:	687b      	ldr	r3, [r7, #4]
 8006f62:	681b      	ldr	r3, [r3, #0]
 8006f64:	681a      	ldr	r2, [r3, #0]
 8006f66:	687b      	ldr	r3, [r7, #4]
 8006f68:	681b      	ldr	r3, [r3, #0]
 8006f6a:	f022 0201 	bic.w	r2, r2, #1
 8006f6e:	601a      	str	r2, [r3, #0]

  /* Update TX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 8006f70:	687b      	ldr	r3, [r7, #4]
 8006f72:	681b      	ldr	r3, [r3, #0]
 8006f74:	689b      	ldr	r3, [r3, #8]
 8006f76:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 8006f7a:	687b      	ldr	r3, [r7, #4]
 8006f7c:	681b      	ldr	r3, [r3, #0]
 8006f7e:	683a      	ldr	r2, [r7, #0]
 8006f80:	430a      	orrs	r2, r1
 8006f82:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
 8006f84:	6878      	ldr	r0, [r7, #4]
 8006f86:	f000 f84f 	bl	8007028 <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8006f8a:	687b      	ldr	r3, [r7, #4]
 8006f8c:	681b      	ldr	r3, [r3, #0]
 8006f8e:	68fa      	ldr	r2, [r7, #12]
 8006f90:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 8006f92:	687b      	ldr	r3, [r7, #4]
 8006f94:	2220      	movs	r2, #32
 8006f96:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8006f9a:	687b      	ldr	r3, [r7, #4]
 8006f9c:	2200      	movs	r2, #0
 8006f9e:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

  return HAL_OK;
 8006fa2:	2300      	movs	r3, #0
}
 8006fa4:	4618      	mov	r0, r3
 8006fa6:	3710      	adds	r7, #16
 8006fa8:	46bd      	mov	sp, r7
 8006faa:	bd80      	pop	{r7, pc}

08006fac <HAL_UARTEx_SetRxFifoThreshold>:
  *            @arg @ref UART_RXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_RXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetRxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
 8006fac:	b580      	push	{r7, lr}
 8006fae:	b084      	sub	sp, #16
 8006fb0:	af00      	add	r7, sp, #0
 8006fb2:	6078      	str	r0, [r7, #4]
 8006fb4:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_RXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 8006fb6:	687b      	ldr	r3, [r7, #4]
 8006fb8:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
 8006fbc:	2b01      	cmp	r3, #1
 8006fbe:	d101      	bne.n	8006fc4 <HAL_UARTEx_SetRxFifoThreshold+0x18>
 8006fc0:	2302      	movs	r3, #2
 8006fc2:	e02d      	b.n	8007020 <HAL_UARTEx_SetRxFifoThreshold+0x74>
 8006fc4:	687b      	ldr	r3, [r7, #4]
 8006fc6:	2201      	movs	r2, #1
 8006fc8:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

  huart->gState = HAL_UART_STATE_BUSY;
 8006fcc:	687b      	ldr	r3, [r7, #4]
 8006fce:	2224      	movs	r2, #36	; 0x24
 8006fd0:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8006fd4:	687b      	ldr	r3, [r7, #4]
 8006fd6:	681b      	ldr	r3, [r3, #0]
 8006fd8:	681b      	ldr	r3, [r3, #0]
 8006fda:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 8006fdc:	687b      	ldr	r3, [r7, #4]
 8006fde:	681b      	ldr	r3, [r3, #0]
 8006fe0:	681a      	ldr	r2, [r3, #0]
 8006fe2:	687b      	ldr	r3, [r7, #4]
 8006fe4:	681b      	ldr	r3, [r3, #0]
 8006fe6:	f022 0201 	bic.w	r2, r2, #1
 8006fea:	601a      	str	r2, [r3, #0]

  /* Update RX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8006fec:	687b      	ldr	r3, [r7, #4]
 8006fee:	681b      	ldr	r3, [r3, #0]
 8006ff0:	689b      	ldr	r3, [r3, #8]
 8006ff2:	f023 6160 	bic.w	r1, r3, #234881024	; 0xe000000
 8006ff6:	687b      	ldr	r3, [r7, #4]
 8006ff8:	681b      	ldr	r3, [r3, #0]
 8006ffa:	683a      	ldr	r2, [r7, #0]
 8006ffc:	430a      	orrs	r2, r1
 8006ffe:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
 8007000:	6878      	ldr	r0, [r7, #4]
 8007002:	f000 f811 	bl	8007028 <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8007006:	687b      	ldr	r3, [r7, #4]
 8007008:	681b      	ldr	r3, [r3, #0]
 800700a:	68fa      	ldr	r2, [r7, #12]
 800700c:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 800700e:	687b      	ldr	r3, [r7, #4]
 8007010:	2220      	movs	r2, #32
 8007012:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8007016:	687b      	ldr	r3, [r7, #4]
 8007018:	2200      	movs	r2, #0
 800701a:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

  return HAL_OK;
 800701e:	2300      	movs	r3, #0
}
 8007020:	4618      	mov	r0, r3
 8007022:	3710      	adds	r7, #16
 8007024:	46bd      	mov	sp, r7
 8007026:	bd80      	pop	{r7, pc}

08007028 <UARTEx_SetNbDataToProcess>:
  *       the UART configuration registers.
  * @param huart UART handle.
  * @retval None
  */
static void UARTEx_SetNbDataToProcess(UART_HandleTypeDef *huart)
{
 8007028:	b480      	push	{r7}
 800702a:	b085      	sub	sp, #20
 800702c:	af00      	add	r7, sp, #0
 800702e:	6078      	str	r0, [r7, #4]
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8007030:	687b      	ldr	r3, [r7, #4]
 8007032:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8007034:	2b00      	cmp	r3, #0
 8007036:	d108      	bne.n	800704a <UARTEx_SetNbDataToProcess+0x22>
  {
    huart->NbTxDataToProcess = 1U;
 8007038:	687b      	ldr	r3, [r7, #4]
 800703a:	2201      	movs	r2, #1
 800703c:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
    huart->NbRxDataToProcess = 1U;
 8007040:	687b      	ldr	r3, [r7, #4]
 8007042:	2201      	movs	r2, #1
 8007044:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                               (uint16_t)denominator[rx_fifo_threshold];
  }
}
 8007048:	e031      	b.n	80070ae <UARTEx_SetNbDataToProcess+0x86>
    rx_fifo_depth = RX_FIFO_DEPTH;
 800704a:	2308      	movs	r3, #8
 800704c:	73fb      	strb	r3, [r7, #15]
    tx_fifo_depth = TX_FIFO_DEPTH;
 800704e:	2308      	movs	r3, #8
 8007050:	73bb      	strb	r3, [r7, #14]
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 8007052:	687b      	ldr	r3, [r7, #4]
 8007054:	681b      	ldr	r3, [r3, #0]
 8007056:	689b      	ldr	r3, [r3, #8]
 8007058:	0e5b      	lsrs	r3, r3, #25
 800705a:	b2db      	uxtb	r3, r3
 800705c:	f003 0307 	and.w	r3, r3, #7
 8007060:	737b      	strb	r3, [r7, #13]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8007062:	687b      	ldr	r3, [r7, #4]
 8007064:	681b      	ldr	r3, [r3, #0]
 8007066:	689b      	ldr	r3, [r3, #8]
 8007068:	0f5b      	lsrs	r3, r3, #29
 800706a:	b2db      	uxtb	r3, r3
 800706c:	f003 0307 	and.w	r3, r3, #7
 8007070:	733b      	strb	r3, [r7, #12]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8007072:	7bbb      	ldrb	r3, [r7, #14]
 8007074:	7b3a      	ldrb	r2, [r7, #12]
 8007076:	4911      	ldr	r1, [pc, #68]	; (80070bc <UARTEx_SetNbDataToProcess+0x94>)
 8007078:	5c8a      	ldrb	r2, [r1, r2]
 800707a:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[tx_fifo_threshold];
 800707e:	7b3a      	ldrb	r2, [r7, #12]
 8007080:	490f      	ldr	r1, [pc, #60]	; (80070c0 <UARTEx_SetNbDataToProcess+0x98>)
 8007082:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8007084:	fb93 f3f2 	sdiv	r3, r3, r2
 8007088:	b29a      	uxth	r2, r3
 800708a:	687b      	ldr	r3, [r7, #4]
 800708c:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8007090:	7bfb      	ldrb	r3, [r7, #15]
 8007092:	7b7a      	ldrb	r2, [r7, #13]
 8007094:	4909      	ldr	r1, [pc, #36]	; (80070bc <UARTEx_SetNbDataToProcess+0x94>)
 8007096:	5c8a      	ldrb	r2, [r1, r2]
 8007098:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[rx_fifo_threshold];
 800709c:	7b7a      	ldrb	r2, [r7, #13]
 800709e:	4908      	ldr	r1, [pc, #32]	; (80070c0 <UARTEx_SetNbDataToProcess+0x98>)
 80070a0:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80070a2:	fb93 f3f2 	sdiv	r3, r3, r2
 80070a6:	b29a      	uxth	r2, r3
 80070a8:	687b      	ldr	r3, [r7, #4]
 80070aa:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
}
 80070ae:	bf00      	nop
 80070b0:	3714      	adds	r7, #20
 80070b2:	46bd      	mov	sp, r7
 80070b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80070b8:	4770      	bx	lr
 80070ba:	bf00      	nop
 80070bc:	08017b84 	.word	0x08017b84
 80070c0:	08017b8c 	.word	0x08017b8c

080070c4 <_tx_block_allocate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_block_allocate(TX_BLOCK_POOL *pool_ptr, VOID **block_ptr, ULONG wait_option)
{
 80070c4:	b580      	push	{r7, lr}
 80070c6:	b094      	sub	sp, #80	; 0x50
 80070c8:	af00      	add	r7, sp, #0
 80070ca:	60f8      	str	r0, [r7, #12]
 80070cc:	60b9      	str	r1, [r7, #8]
 80070ce:	607a      	str	r2, [r7, #4]
{
UINT posture;
#ifdef TX_PORT_USE_BASEPRI
    __asm__ volatile ("MRS  %0, BASEPRI ": "=r" (posture));
#else
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80070d0:	f3ef 8310 	mrs	r3, PRIMASK
 80070d4:	627b      	str	r3, [r7, #36]	; 0x24
#endif
    return(posture);
 80070d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24

__attribute__( ( always_inline ) ) static inline UINT __disable_interrupts(void)
{
UINT int_posture;

    int_posture = __get_interrupt_posture();
 80070d8:	623b      	str	r3, [r7, #32]

#ifdef TX_PORT_USE_BASEPRI
    __set_basepri_value(TX_PORT_BASEPRI);
#else
    __asm__ volatile ("CPSID i" : : : "memory");
 80070da:	b672      	cpsid	i
#endif
    return(int_posture);
 80070dc:	6a3b      	ldr	r3, [r7, #32]
ULONG                       lower_tbu;
#endif


    /* Disable interrupts to get a block from the pool.  */
    TX_DISABLE
 80070de:	64bb      	str	r3, [r7, #72]	; 0x48
    lower_tbu =  *((ULONG *) (log_entry_ptr + TX_EL_EVENT_TIME_LOWER_OFFSET));
    upper_tbu =  *((ULONG *) (log_entry_ptr + TX_EL_EVENT_TIME_UPPER_OFFSET));
#endif

    /* Determine if there is an available block.  */
    if (pool_ptr -> tx_block_pool_available != ((UINT) 0))
 80070e0:	68fb      	ldr	r3, [r7, #12]
 80070e2:	689b      	ldr	r3, [r3, #8]
 80070e4:	2b00      	cmp	r3, #0
 80070e6:	d022      	beq.n	800712e <_tx_block_allocate+0x6a>
    {

        /* Yes, a block is available.  Decrement the available count.  */
        pool_ptr -> tx_block_pool_available--;
 80070e8:	68fb      	ldr	r3, [r7, #12]
 80070ea:	689b      	ldr	r3, [r3, #8]
 80070ec:	1e5a      	subs	r2, r3, #1
 80070ee:	68fb      	ldr	r3, [r7, #12]
 80070f0:	609a      	str	r2, [r3, #8]

        /* Pickup the current block pointer.  */
        work_ptr =  pool_ptr -> tx_block_pool_available_list;
 80070f2:	68fb      	ldr	r3, [r7, #12]
 80070f4:	691b      	ldr	r3, [r3, #16]
 80070f6:	633b      	str	r3, [r7, #48]	; 0x30

        /* Return the first available block to the caller.  */
        temp_ptr =  TX_UCHAR_POINTER_ADD(work_ptr, (sizeof(UCHAR *)));
 80070f8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80070fa:	3304      	adds	r3, #4
 80070fc:	62fb      	str	r3, [r7, #44]	; 0x2c
        return_ptr =  TX_INDIRECT_VOID_TO_UCHAR_POINTER_CONVERT(block_ptr);
 80070fe:	68bb      	ldr	r3, [r7, #8]
 8007100:	647b      	str	r3, [r7, #68]	; 0x44
        *return_ptr =  temp_ptr;
 8007102:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007104:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8007106:	601a      	str	r2, [r3, #0]

        /* Modify the available list to point at the next block in the pool. */
        next_block_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
 8007108:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800710a:	62bb      	str	r3, [r7, #40]	; 0x28
        pool_ptr -> tx_block_pool_available_list =  *next_block_ptr;
 800710c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800710e:	681a      	ldr	r2, [r3, #0]
 8007110:	68fb      	ldr	r3, [r7, #12]
 8007112:	611a      	str	r2, [r3, #16]

        /* Save the pool's address in the block for when it is released!  */
        temp_ptr =  TX_BLOCK_POOL_TO_UCHAR_POINTER_CONVERT(pool_ptr);
 8007114:	68fb      	ldr	r3, [r7, #12]
 8007116:	62fb      	str	r3, [r7, #44]	; 0x2c
        *next_block_ptr =  temp_ptr;
 8007118:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800711a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800711c:	601a      	str	r2, [r3, #0]
        /* Store the address of the allocated block.  */
        *((ULONG *) (log_entry_ptr + TX_EL_EVENT_INFO_3_OFFSET)) =  (ULONG) *block_ptr;
#endif

        /* Set status to success.  */
        status =  TX_SUCCESS;
 800711e:	2300      	movs	r3, #0
 8007120:	64fb      	str	r3, [r7, #76]	; 0x4c
 8007122:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007124:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007126:	69fb      	ldr	r3, [r7, #28]
 8007128:	f383 8810 	msr	PRIMASK, r3
}
 800712c:	e071      	b.n	8007212 <_tx_block_allocate+0x14e>
    }
    else
    {

        /* Default the return pointer to NULL.  */
        return_ptr =   TX_INDIRECT_VOID_TO_UCHAR_POINTER_CONVERT(block_ptr);
 800712e:	68bb      	ldr	r3, [r7, #8]
 8007130:	647b      	str	r3, [r7, #68]	; 0x44
        *return_ptr =  TX_NULL;
 8007132:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007134:	2200      	movs	r2, #0
 8007136:	601a      	str	r2, [r3, #0]

        /* Determine if the request specifies suspension.  */
        if (wait_option != TX_NO_WAIT)
 8007138:	687b      	ldr	r3, [r7, #4]
 800713a:	2b00      	cmp	r3, #0
 800713c:	d061      	beq.n	8007202 <_tx_block_allocate+0x13e>
        {

            /* Determine if the preempt disable flag is non-zero.  */
            if (_tx_thread_preempt_disable != ((UINT) 0))
 800713e:	4b37      	ldr	r3, [pc, #220]	; (800721c <_tx_block_allocate+0x158>)
 8007140:	681b      	ldr	r3, [r3, #0]
 8007142:	2b00      	cmp	r3, #0
 8007144:	d007      	beq.n	8007156 <_tx_block_allocate+0x92>
            {

                /* Suspension is not allowed if the preempt disable flag is non-zero at this point, return error completion.  */
                status =  TX_NO_MEMORY;
 8007146:	2310      	movs	r3, #16
 8007148:	64fb      	str	r3, [r7, #76]	; 0x4c
 800714a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800714c:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800714e:	69bb      	ldr	r3, [r7, #24]
 8007150:	f383 8810 	msr	PRIMASK, r3
}
 8007154:	e05d      	b.n	8007212 <_tx_block_allocate+0x14e>
                /* Increment the number of suspensions on this pool.  */
                pool_ptr -> tx_block_pool_performance_suspension_count++;
#endif

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(thread_ptr)
 8007156:	4b32      	ldr	r3, [pc, #200]	; (8007220 <_tx_block_allocate+0x15c>)
 8007158:	681b      	ldr	r3, [r3, #0]
 800715a:	643b      	str	r3, [r7, #64]	; 0x40

                /* Setup cleanup routine pointer.  */
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_block_pool_cleanup);
 800715c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800715e:	4a31      	ldr	r2, [pc, #196]	; (8007224 <_tx_block_allocate+0x160>)
 8007160:	669a      	str	r2, [r3, #104]	; 0x68

                /* Setup cleanup information, i.e. this pool control
                   block.  */
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) pool_ptr;
 8007162:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8007164:	68fa      	ldr	r2, [r7, #12]
 8007166:	66da      	str	r2, [r3, #108]	; 0x6c

                /* Save the return block pointer address as well.  */
                thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) block_ptr;
 8007168:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800716a:	68ba      	ldr	r2, [r7, #8]
 800716c:	67da      	str	r2, [r3, #124]	; 0x7c

#ifndef TX_NOT_INTERRUPTABLE

                /* Increment the suspension sequence number, which is used to identify
                   this suspension event.  */
                thread_ptr -> tx_thread_suspension_sequence++;
 800716e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8007170:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 8007174:	1c5a      	adds	r2, r3, #1
 8007176:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8007178:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
#endif

                /* Pickup the number of suspended threads.  */
                suspended_count =  (pool_ptr -> tx_block_pool_suspended_count);
 800717c:	68fb      	ldr	r3, [r7, #12]
 800717e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007180:	63fb      	str	r3, [r7, #60]	; 0x3c

                /* Increment the number of suspended threads.  */
                (pool_ptr -> tx_block_pool_suspended_count)++;
 8007182:	68fb      	ldr	r3, [r7, #12]
 8007184:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007186:	1c5a      	adds	r2, r3, #1
 8007188:	68fb      	ldr	r3, [r7, #12]
 800718a:	625a      	str	r2, [r3, #36]	; 0x24

                /* Setup suspension list.  */
                if (suspended_count == TX_NO_SUSPENSIONS)
 800718c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800718e:	2b00      	cmp	r3, #0
 8007190:	d109      	bne.n	80071a6 <_tx_block_allocate+0xe2>
                {

                    /* No other threads are suspended.  Setup the head pointer and
                       just setup this threads pointers to itself.  */
                    pool_ptr -> tx_block_pool_suspension_list =     thread_ptr;
 8007192:	68fb      	ldr	r3, [r7, #12]
 8007194:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8007196:	621a      	str	r2, [r3, #32]
                    thread_ptr -> tx_thread_suspended_next =        thread_ptr;
 8007198:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800719a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800719c:	671a      	str	r2, [r3, #112]	; 0x70
                    thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
 800719e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80071a0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80071a2:	675a      	str	r2, [r3, #116]	; 0x74
 80071a4:	e011      	b.n	80071ca <_tx_block_allocate+0x106>
                }
                else
                {

                    /* This list is not NULL, add current thread to the end. */
                    next_thread =                                   pool_ptr -> tx_block_pool_suspension_list;
 80071a6:	68fb      	ldr	r3, [r7, #12]
 80071a8:	6a1b      	ldr	r3, [r3, #32]
 80071aa:	63bb      	str	r3, [r7, #56]	; 0x38
                    thread_ptr -> tx_thread_suspended_next =        next_thread;
 80071ac:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80071ae:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80071b0:	671a      	str	r2, [r3, #112]	; 0x70
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
 80071b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80071b4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80071b6:	637b      	str	r3, [r7, #52]	; 0x34
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 80071b8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80071ba:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80071bc:	675a      	str	r2, [r3, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
 80071be:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80071c0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80071c2:	671a      	str	r2, [r3, #112]	; 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
 80071c4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80071c6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80071c8:	675a      	str	r2, [r3, #116]	; 0x74
                }

                /* Set the state to suspended.  */
                thread_ptr -> tx_thread_state =       TX_BLOCK_MEMORY;
 80071ca:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80071cc:	2208      	movs	r2, #8
 80071ce:	631a      	str	r2, [r3, #48]	; 0x30
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Set the suspending flag.  */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
 80071d0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80071d2:	2201      	movs	r2, #1
 80071d4:	639a      	str	r2, [r3, #56]	; 0x38

                /* Setup the timeout period.  */
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 80071d6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80071d8:	687a      	ldr	r2, [r7, #4]
 80071da:	64da      	str	r2, [r3, #76]	; 0x4c

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
 80071dc:	4b0f      	ldr	r3, [pc, #60]	; (800721c <_tx_block_allocate+0x158>)
 80071de:	681b      	ldr	r3, [r3, #0]
 80071e0:	3301      	adds	r3, #1
 80071e2:	4a0e      	ldr	r2, [pc, #56]	; (800721c <_tx_block_allocate+0x158>)
 80071e4:	6013      	str	r3, [r2, #0]
 80071e6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80071e8:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80071ea:	697b      	ldr	r3, [r7, #20]
 80071ec:	f383 8810 	msr	PRIMASK, r3
}
 80071f0:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
 80071f2:	6c38      	ldr	r0, [r7, #64]	; 0x40
 80071f4:	f005 fa2e 	bl	800c654 <_tx_thread_system_suspend>
                    *((ULONG *) (log_entry_ptr + TX_EL_EVENT_INFO_3_OFFSET)) =  (ULONG) *block_ptr;
                }
#endif

                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
 80071f8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80071fa:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80071fe:	64fb      	str	r3, [r7, #76]	; 0x4c
 8007200:	e007      	b.n	8007212 <_tx_block_allocate+0x14e>
        }
        else
        {

            /* Immediate return, return error completion.  */
            status =  TX_NO_MEMORY;
 8007202:	2310      	movs	r3, #16
 8007204:	64fb      	str	r3, [r7, #76]	; 0x4c
 8007206:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007208:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800720a:	693b      	ldr	r3, [r7, #16]
 800720c:	f383 8810 	msr	PRIMASK, r3
}
 8007210:	bf00      	nop
            TX_RESTORE
        }
    }

    /* Return completion status.  */
    return(status);
 8007212:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
}
 8007214:	4618      	mov	r0, r3
 8007216:	3750      	adds	r7, #80	; 0x50
 8007218:	46bd      	mov	sp, r7
 800721a:	bd80      	pop	{r7, pc}
 800721c:	2000f054 	.word	0x2000f054
 8007220:	2000efb8 	.word	0x2000efb8
 8007224:	08007229 	.word	0x08007229

08007228 <_tx_block_pool_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_block_pool_cleanup(TX_THREAD *thread_ptr, ULONG suspension_sequence)
{
 8007228:	b580      	push	{r7, lr}
 800722a:	b08e      	sub	sp, #56	; 0x38
 800722c:	af00      	add	r7, sp, #0
 800722e:	6078      	str	r0, [r7, #4]
 8007230:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8007232:	f3ef 8310 	mrs	r3, PRIMASK
 8007236:	623b      	str	r3, [r7, #32]
    return(posture);
 8007238:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 800723a:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 800723c:	b672      	cpsid	i
    return(int_posture);
 800723e:	69fb      	ldr	r3, [r7, #28]


#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the block pool.  */
    TX_DISABLE
 8007240:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_block_pool_cleanup))
 8007242:	687b      	ldr	r3, [r7, #4]
 8007244:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8007246:	4a33      	ldr	r2, [pc, #204]	; (8007314 <_tx_block_pool_cleanup+0xec>)
 8007248:	4293      	cmp	r3, r2
 800724a:	d158      	bne.n	80072fe <_tx_block_pool_cleanup+0xd6>
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
 800724c:	687b      	ldr	r3, [r7, #4]
 800724e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 8007252:	683a      	ldr	r2, [r7, #0]
 8007254:	429a      	cmp	r2, r3
 8007256:	d152      	bne.n	80072fe <_tx_block_pool_cleanup+0xd6>
        {

            /* Setup pointer to block pool control block.  */
            pool_ptr =  TX_VOID_TO_BLOCK_POOL_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
 8007258:	687b      	ldr	r3, [r7, #4]
 800725a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800725c:	633b      	str	r3, [r7, #48]	; 0x30

            /* Check for a NULL byte pool pointer.  */
            if (pool_ptr != TX_NULL)
 800725e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007260:	2b00      	cmp	r3, #0
 8007262:	d04c      	beq.n	80072fe <_tx_block_pool_cleanup+0xd6>
            {

                /* Check for valid pool ID.  */
                if (pool_ptr -> tx_block_pool_id == TX_BLOCK_POOL_ID)
 8007264:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007266:	681b      	ldr	r3, [r3, #0]
 8007268:	4a2b      	ldr	r2, [pc, #172]	; (8007318 <_tx_block_pool_cleanup+0xf0>)
 800726a:	4293      	cmp	r3, r2
 800726c:	d147      	bne.n	80072fe <_tx_block_pool_cleanup+0xd6>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (pool_ptr -> tx_block_pool_suspended_count != TX_NO_SUSPENSIONS)
 800726e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007270:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007272:	2b00      	cmp	r3, #0
 8007274:	d043      	beq.n	80072fe <_tx_block_pool_cleanup+0xd6>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8007276:	687b      	ldr	r3, [r7, #4]
 8007278:	2200      	movs	r2, #0
 800727a:	669a      	str	r2, [r3, #104]	; 0x68

                        /* Decrement the suspended count.  */
                        pool_ptr -> tx_block_pool_suspended_count--;
 800727c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800727e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007280:	1e5a      	subs	r2, r3, #1
 8007282:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007284:	625a      	str	r2, [r3, #36]	; 0x24

                        /* Pickup the suspended count.  */
                        suspended_count =  pool_ptr -> tx_block_pool_suspended_count;
 8007286:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007288:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800728a:	62fb      	str	r3, [r7, #44]	; 0x2c

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
 800728c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800728e:	2b00      	cmp	r3, #0
 8007290:	d103      	bne.n	800729a <_tx_block_pool_cleanup+0x72>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            pool_ptr -> tx_block_pool_suspension_list =  TX_NULL;
 8007292:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007294:	2200      	movs	r2, #0
 8007296:	621a      	str	r2, [r3, #32]
 8007298:	e013      	b.n	80072c2 <_tx_block_pool_cleanup+0x9a>
                        {

                            /* At least one more thread is on the same suspension list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
 800729a:	687b      	ldr	r3, [r7, #4]
 800729c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800729e:	62bb      	str	r3, [r7, #40]	; 0x28
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 80072a0:	687b      	ldr	r3, [r7, #4]
 80072a2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80072a4:	627b      	str	r3, [r7, #36]	; 0x24
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
 80072a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80072a8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80072aa:	675a      	str	r2, [r3, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
 80072ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80072ae:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80072b0:	671a      	str	r2, [r3, #112]	; 0x70

                            /* Determine if we need to update the head pointer.  */
                            if (pool_ptr -> tx_block_pool_suspension_list == thread_ptr)
 80072b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80072b4:	6a1b      	ldr	r3, [r3, #32]
 80072b6:	687a      	ldr	r2, [r7, #4]
 80072b8:	429a      	cmp	r2, r3
 80072ba:	d102      	bne.n	80072c2 <_tx_block_pool_cleanup+0x9a>
                            {

                                /* Update the list head pointer.  */
                                pool_ptr -> tx_block_pool_suspension_list =     next_thread;
 80072bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80072be:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80072c0:	621a      	str	r2, [r3, #32]
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_BLOCK_MEMORY)
 80072c2:	687b      	ldr	r3, [r7, #4]
 80072c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80072c6:	2b08      	cmp	r3, #8
 80072c8:	d119      	bne.n	80072fe <_tx_block_pool_cleanup+0xd6>
                            /* Increment the number of timeouts on this block pool.  */
                            pool_ptr -> tx_block_pool_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_MEMORY;
 80072ca:	687b      	ldr	r3, [r7, #4]
 80072cc:	2210      	movs	r2, #16
 80072ce:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else
                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 80072d2:	4b12      	ldr	r3, [pc, #72]	; (800731c <_tx_block_pool_cleanup+0xf4>)
 80072d4:	681b      	ldr	r3, [r3, #0]
 80072d6:	3301      	adds	r3, #1
 80072d8:	4a10      	ldr	r2, [pc, #64]	; (800731c <_tx_block_pool_cleanup+0xf4>)
 80072da:	6013      	str	r3, [r2, #0]
 80072dc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80072de:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80072e0:	693b      	ldr	r3, [r7, #16]
 80072e2:	f383 8810 	msr	PRIMASK, r3
}
 80072e6:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
 80072e8:	6878      	ldr	r0, [r7, #4]
 80072ea:	f005 f89f 	bl	800c42c <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80072ee:	f3ef 8310 	mrs	r3, PRIMASK
 80072f2:	61bb      	str	r3, [r7, #24]
    return(posture);
 80072f4:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 80072f6:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 80072f8:	b672      	cpsid	i
    return(int_posture);
 80072fa:	697b      	ldr	r3, [r7, #20]

                            /* Disable interrupts.  */
                            TX_DISABLE
 80072fc:	637b      	str	r3, [r7, #52]	; 0x34
 80072fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007300:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007302:	68fb      	ldr	r3, [r7, #12]
 8007304:	f383 8810 	msr	PRIMASK, r3
}
 8007308:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 800730a:	bf00      	nop
 800730c:	3738      	adds	r7, #56	; 0x38
 800730e:	46bd      	mov	sp, r7
 8007310:	bd80      	pop	{r7, pc}
 8007312:	bf00      	nop
 8007314:	08007229 	.word	0x08007229
 8007318:	424c4f43 	.word	0x424c4f43
 800731c:	2000f054 	.word	0x2000f054

08007320 <_tx_block_pool_create>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_block_pool_create(TX_BLOCK_POOL *pool_ptr, CHAR *name_ptr, ULONG block_size,
                    VOID *pool_start, ULONG pool_size)
{
 8007320:	b580      	push	{r7, lr}
 8007322:	b090      	sub	sp, #64	; 0x40
 8007324:	af00      	add	r7, sp, #0
 8007326:	60f8      	str	r0, [r7, #12]
 8007328:	60b9      	str	r1, [r7, #8]
 800732a:	607a      	str	r2, [r7, #4]
 800732c:	603b      	str	r3, [r7, #0]
TX_BLOCK_POOL       *next_pool;
TX_BLOCK_POOL       *previous_pool;


    /* Initialize block pool control block to all zeros.  */
    TX_MEMSET(pool_ptr, 0, (sizeof(TX_BLOCK_POOL)));
 800732e:	2230      	movs	r2, #48	; 0x30
 8007330:	2100      	movs	r1, #0
 8007332:	68f8      	ldr	r0, [r7, #12]
 8007334:	f00f fb56 	bl	80169e4 <memset>

    /* Round the block size up to something that is evenly divisible by
       an ALIGN_TYPE (typically this is a 32-bit ULONG). This helps guarantee proper alignment.  */
    block_size =  (((block_size + (sizeof(ALIGN_TYPE))) - ((ALIGN_TYPE) 1))/(sizeof(ALIGN_TYPE))) * (sizeof(ALIGN_TYPE));
 8007338:	687b      	ldr	r3, [r7, #4]
 800733a:	3303      	adds	r3, #3
 800733c:	f023 0303 	bic.w	r3, r3, #3
 8007340:	607b      	str	r3, [r7, #4]

    /* Round the pool size down to something that is evenly divisible by
       an ALIGN_TYPE (typically this is a 32-bit ULONG).  */
    pool_size =   (pool_size/(sizeof(ALIGN_TYPE))) * (sizeof(ALIGN_TYPE));
 8007342:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007344:	f023 0303 	bic.w	r3, r3, #3
 8007348:	64bb      	str	r3, [r7, #72]	; 0x48

    /* Setup the basic block pool fields.  */
    pool_ptr -> tx_block_pool_name =             name_ptr;
 800734a:	68fb      	ldr	r3, [r7, #12]
 800734c:	68ba      	ldr	r2, [r7, #8]
 800734e:	605a      	str	r2, [r3, #4]
    pool_ptr -> tx_block_pool_start =            TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 8007350:	68fb      	ldr	r3, [r7, #12]
 8007352:	683a      	ldr	r2, [r7, #0]
 8007354:	615a      	str	r2, [r3, #20]
    pool_ptr -> tx_block_pool_size =             pool_size;
 8007356:	68fb      	ldr	r3, [r7, #12]
 8007358:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800735a:	619a      	str	r2, [r3, #24]
    pool_ptr -> tx_block_pool_block_size =       (UINT) block_size;
 800735c:	68fb      	ldr	r3, [r7, #12]
 800735e:	687a      	ldr	r2, [r7, #4]
 8007360:	61da      	str	r2, [r3, #28]

    /* Calculate the total number of blocks.  */
    total_blocks =  pool_size/(block_size + (sizeof(UCHAR *)));
 8007362:	687b      	ldr	r3, [r7, #4]
 8007364:	3304      	adds	r3, #4
 8007366:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8007368:	fbb2 f3f3 	udiv	r3, r2, r3
 800736c:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Walk through the pool area, setting up the available block list.  */
    blocks =            ((UINT) 0);
 800736e:	2300      	movs	r3, #0
 8007370:	63fb      	str	r3, [r7, #60]	; 0x3c
    block_ptr =         TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 8007372:	683b      	ldr	r3, [r7, #0]
 8007374:	637b      	str	r3, [r7, #52]	; 0x34
    next_block_ptr =    TX_UCHAR_POINTER_ADD(block_ptr, (block_size + (sizeof(UCHAR *))));
 8007376:	687b      	ldr	r3, [r7, #4]
 8007378:	3304      	adds	r3, #4
 800737a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800737c:	4413      	add	r3, r2
 800737e:	633b      	str	r3, [r7, #48]	; 0x30
    while(blocks < (UINT) total_blocks)
 8007380:	e00e      	b.n	80073a0 <_tx_block_pool_create+0x80>
    {

        /* Yes, we have another block.  Increment the block count.  */
        blocks++;
 8007382:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007384:	3301      	adds	r3, #1
 8007386:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Setup the link to the next block.  */
        block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(block_ptr);
 8007388:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800738a:	62bb      	str	r3, [r7, #40]	; 0x28
        *block_link_ptr =  next_block_ptr;
 800738c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800738e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8007390:	601a      	str	r2, [r3, #0]

        /* Advance to the next block.  */
        block_ptr =   next_block_ptr;
 8007392:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007394:	637b      	str	r3, [r7, #52]	; 0x34

        /* Update the next block pointer.  */
        next_block_ptr =  TX_UCHAR_POINTER_ADD(block_ptr, (block_size + (sizeof(UCHAR *))));
 8007396:	687b      	ldr	r3, [r7, #4]
 8007398:	3304      	adds	r3, #4
 800739a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800739c:	4413      	add	r3, r2
 800739e:	633b      	str	r3, [r7, #48]	; 0x30
    while(blocks < (UINT) total_blocks)
 80073a0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80073a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80073a4:	429a      	cmp	r2, r3
 80073a6:	d3ec      	bcc.n	8007382 <_tx_block_pool_create+0x62>
    }

    /* Save the remaining information in the pool control block.  */
    pool_ptr -> tx_block_pool_available =  blocks;
 80073a8:	68fb      	ldr	r3, [r7, #12]
 80073aa:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80073ac:	609a      	str	r2, [r3, #8]
    pool_ptr -> tx_block_pool_total =      blocks;
 80073ae:	68fb      	ldr	r3, [r7, #12]
 80073b0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80073b2:	60da      	str	r2, [r3, #12]

    /* Quickly check to make sure at least one block is in the pool.  */
    if (blocks != ((UINT) 0))
 80073b4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80073b6:	2b00      	cmp	r3, #0
 80073b8:	d047      	beq.n	800744a <_tx_block_pool_create+0x12a>
    {

        /* Backup to the last block in the pool.  */
        block_ptr =  TX_UCHAR_POINTER_SUB(block_ptr,(block_size + (sizeof(UCHAR *))));
 80073ba:	687a      	ldr	r2, [r7, #4]
 80073bc:	f06f 0303 	mvn.w	r3, #3
 80073c0:	1a9b      	subs	r3, r3, r2
 80073c2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80073c4:	4413      	add	r3, r2
 80073c6:	637b      	str	r3, [r7, #52]	; 0x34

        /* Set the last block's forward pointer to NULL.  */
        block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(block_ptr);
 80073c8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80073ca:	62bb      	str	r3, [r7, #40]	; 0x28
        *block_link_ptr =  TX_NULL;
 80073cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80073ce:	2200      	movs	r2, #0
 80073d0:	601a      	str	r2, [r3, #0]

        /* Setup the starting pool address.  */
        pool_ptr -> tx_block_pool_available_list =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 80073d2:	68fb      	ldr	r3, [r7, #12]
 80073d4:	683a      	ldr	r2, [r7, #0]
 80073d6:	611a      	str	r2, [r3, #16]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80073d8:	f3ef 8310 	mrs	r3, PRIMASK
 80073dc:	61bb      	str	r3, [r7, #24]
    return(posture);
 80073de:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 80073e0:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 80073e2:	b672      	cpsid	i
    return(int_posture);
 80073e4:	697b      	ldr	r3, [r7, #20]

        /* Disable interrupts to place the block pool on the created list.  */
        TX_DISABLE
 80073e6:	627b      	str	r3, [r7, #36]	; 0x24

        /* Setup the block pool ID to make it valid.  */
        pool_ptr -> tx_block_pool_id =  TX_BLOCK_POOL_ID;
 80073e8:	68fb      	ldr	r3, [r7, #12]
 80073ea:	4a1b      	ldr	r2, [pc, #108]	; (8007458 <_tx_block_pool_create+0x138>)
 80073ec:	601a      	str	r2, [r3, #0]

        /* Place the block pool on the list of created block pools.  First,
           check for an empty list.  */
        if (_tx_block_pool_created_count == TX_EMPTY)
 80073ee:	4b1b      	ldr	r3, [pc, #108]	; (800745c <_tx_block_pool_create+0x13c>)
 80073f0:	681b      	ldr	r3, [r3, #0]
 80073f2:	2b00      	cmp	r3, #0
 80073f4:	d109      	bne.n	800740a <_tx_block_pool_create+0xea>
        {

            /* The created block pool list is empty.  Add block pool to empty list.  */
            _tx_block_pool_created_ptr =                  pool_ptr;
 80073f6:	4a1a      	ldr	r2, [pc, #104]	; (8007460 <_tx_block_pool_create+0x140>)
 80073f8:	68fb      	ldr	r3, [r7, #12]
 80073fa:	6013      	str	r3, [r2, #0]
            pool_ptr -> tx_block_pool_created_next =      pool_ptr;
 80073fc:	68fb      	ldr	r3, [r7, #12]
 80073fe:	68fa      	ldr	r2, [r7, #12]
 8007400:	629a      	str	r2, [r3, #40]	; 0x28
            pool_ptr -> tx_block_pool_created_previous =  pool_ptr;
 8007402:	68fb      	ldr	r3, [r7, #12]
 8007404:	68fa      	ldr	r2, [r7, #12]
 8007406:	62da      	str	r2, [r3, #44]	; 0x2c
 8007408:	e011      	b.n	800742e <_tx_block_pool_create+0x10e>
        }
        else
        {

            /* This list is not NULL, add to the end of the list.  */
            next_pool =      _tx_block_pool_created_ptr;
 800740a:	4b15      	ldr	r3, [pc, #84]	; (8007460 <_tx_block_pool_create+0x140>)
 800740c:	681b      	ldr	r3, [r3, #0]
 800740e:	623b      	str	r3, [r7, #32]
            previous_pool =  next_pool -> tx_block_pool_created_previous;
 8007410:	6a3b      	ldr	r3, [r7, #32]
 8007412:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007414:	61fb      	str	r3, [r7, #28]

            /* Place the new block pool in the list.  */
            next_pool -> tx_block_pool_created_previous =  pool_ptr;
 8007416:	6a3b      	ldr	r3, [r7, #32]
 8007418:	68fa      	ldr	r2, [r7, #12]
 800741a:	62da      	str	r2, [r3, #44]	; 0x2c
            previous_pool -> tx_block_pool_created_next =  pool_ptr;
 800741c:	69fb      	ldr	r3, [r7, #28]
 800741e:	68fa      	ldr	r2, [r7, #12]
 8007420:	629a      	str	r2, [r3, #40]	; 0x28

            /* Setup this block pool's created links.  */
            pool_ptr -> tx_block_pool_created_previous =  previous_pool;
 8007422:	68fb      	ldr	r3, [r7, #12]
 8007424:	69fa      	ldr	r2, [r7, #28]
 8007426:	62da      	str	r2, [r3, #44]	; 0x2c
            pool_ptr -> tx_block_pool_created_next =      next_pool;
 8007428:	68fb      	ldr	r3, [r7, #12]
 800742a:	6a3a      	ldr	r2, [r7, #32]
 800742c:	629a      	str	r2, [r3, #40]	; 0x28
        }

        /* Increment the created count.  */
        _tx_block_pool_created_count++;
 800742e:	4b0b      	ldr	r3, [pc, #44]	; (800745c <_tx_block_pool_create+0x13c>)
 8007430:	681b      	ldr	r3, [r3, #0]
 8007432:	3301      	adds	r3, #1
 8007434:	4a09      	ldr	r2, [pc, #36]	; (800745c <_tx_block_pool_create+0x13c>)
 8007436:	6013      	str	r3, [r2, #0]
 8007438:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800743a:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800743c:	693b      	ldr	r3, [r7, #16]
 800743e:	f383 8810 	msr	PRIMASK, r3
}
 8007442:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return successful status.  */
        status =  TX_SUCCESS;
 8007444:	2300      	movs	r3, #0
 8007446:	63bb      	str	r3, [r7, #56]	; 0x38
 8007448:	e001      	b.n	800744e <_tx_block_pool_create+0x12e>
    }
    else
    {

        /* Not enough memory for one block, return appropriate error.  */
        status =  TX_SIZE_ERROR;
 800744a:	2305      	movs	r3, #5
 800744c:	63bb      	str	r3, [r7, #56]	; 0x38
    }

    /* Return completion status.  */
    return(status);
 800744e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
}
 8007450:	4618      	mov	r0, r3
 8007452:	3740      	adds	r7, #64	; 0x40
 8007454:	46bd      	mov	sp, r7
 8007456:	bd80      	pop	{r7, pc}
 8007458:	424c4f43 	.word	0x424c4f43
 800745c:	2000efa4 	.word	0x2000efa4
 8007460:	2000efa0 	.word	0x2000efa0

08007464 <_tx_block_pool_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_block_pool_delete(TX_BLOCK_POOL *pool_ptr)
{
 8007464:	b580      	push	{r7, lr}
 8007466:	b092      	sub	sp, #72	; 0x48
 8007468:	af00      	add	r7, sp, #0
 800746a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800746c:	f3ef 8310 	mrs	r3, PRIMASK
 8007470:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 8007472:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 8007474:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 8007476:	b672      	cpsid	i
    return(int_posture);
 8007478:	6abb      	ldr	r3, [r7, #40]	; 0x28
TX_BLOCK_POOL   *next_pool;
TX_BLOCK_POOL   *previous_pool;


    /* Disable interrupts to remove the block pool from the created list.  */
    TX_DISABLE
 800747a:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* If trace is enabled, unregister this object.  */
    TX_TRACE_OBJECT_UNREGISTER(pool_ptr)

    /* Clear the block pool ID to make it invalid.  */
    pool_ptr -> tx_block_pool_id =  TX_CLEAR_ID;
 800747c:	687b      	ldr	r3, [r7, #4]
 800747e:	2200      	movs	r2, #0
 8007480:	601a      	str	r2, [r3, #0]

    /* Decrement the number of block pools.  */
    _tx_block_pool_created_count--;
 8007482:	4b3d      	ldr	r3, [pc, #244]	; (8007578 <_tx_block_pool_delete+0x114>)
 8007484:	681b      	ldr	r3, [r3, #0]
 8007486:	3b01      	subs	r3, #1
 8007488:	4a3b      	ldr	r2, [pc, #236]	; (8007578 <_tx_block_pool_delete+0x114>)
 800748a:	6013      	str	r3, [r2, #0]

    /* See if the block pool is the only one on the list.  */
    if (_tx_block_pool_created_count == TX_EMPTY)
 800748c:	4b3a      	ldr	r3, [pc, #232]	; (8007578 <_tx_block_pool_delete+0x114>)
 800748e:	681b      	ldr	r3, [r3, #0]
 8007490:	2b00      	cmp	r3, #0
 8007492:	d103      	bne.n	800749c <_tx_block_pool_delete+0x38>
    {

        /* Only created block pool, just set the created list to NULL.  */
        _tx_block_pool_created_ptr =  TX_NULL;
 8007494:	4b39      	ldr	r3, [pc, #228]	; (800757c <_tx_block_pool_delete+0x118>)
 8007496:	2200      	movs	r2, #0
 8007498:	601a      	str	r2, [r3, #0]
 800749a:	e013      	b.n	80074c4 <_tx_block_pool_delete+0x60>
    }
    else
    {

        /* Link-up the neighbors.  */
        next_pool =                                    pool_ptr -> tx_block_pool_created_next;
 800749c:	687b      	ldr	r3, [r7, #4]
 800749e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80074a0:	63bb      	str	r3, [r7, #56]	; 0x38
        previous_pool =                                pool_ptr -> tx_block_pool_created_previous;
 80074a2:	687b      	ldr	r3, [r7, #4]
 80074a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80074a6:	637b      	str	r3, [r7, #52]	; 0x34
        next_pool -> tx_block_pool_created_previous =  previous_pool;
 80074a8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80074aa:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80074ac:	62da      	str	r2, [r3, #44]	; 0x2c
        previous_pool -> tx_block_pool_created_next =  next_pool;
 80074ae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80074b0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80074b2:	629a      	str	r2, [r3, #40]	; 0x28

        /* See if we have to update the created list head pointer.  */
        if (_tx_block_pool_created_ptr == pool_ptr)
 80074b4:	4b31      	ldr	r3, [pc, #196]	; (800757c <_tx_block_pool_delete+0x118>)
 80074b6:	681b      	ldr	r3, [r3, #0]
 80074b8:	687a      	ldr	r2, [r7, #4]
 80074ba:	429a      	cmp	r2, r3
 80074bc:	d102      	bne.n	80074c4 <_tx_block_pool_delete+0x60>
        {

            /* Yes, move the head pointer to the next link. */
            _tx_block_pool_created_ptr =  next_pool;
 80074be:	4a2f      	ldr	r2, [pc, #188]	; (800757c <_tx_block_pool_delete+0x118>)
 80074c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80074c2:	6013      	str	r3, [r2, #0]
        }
    }

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 80074c4:	4b2e      	ldr	r3, [pc, #184]	; (8007580 <_tx_block_pool_delete+0x11c>)
 80074c6:	681b      	ldr	r3, [r3, #0]
 80074c8:	3301      	adds	r3, #1
 80074ca:	4a2d      	ldr	r2, [pc, #180]	; (8007580 <_tx_block_pool_delete+0x11c>)
 80074cc:	6013      	str	r3, [r2, #0]

    /* Pickup the suspension information.  */
    thread_ptr =                                 pool_ptr -> tx_block_pool_suspension_list;
 80074ce:	687b      	ldr	r3, [r7, #4]
 80074d0:	6a1b      	ldr	r3, [r3, #32]
 80074d2:	647b      	str	r3, [r7, #68]	; 0x44
    pool_ptr -> tx_block_pool_suspension_list =  TX_NULL;
 80074d4:	687b      	ldr	r3, [r7, #4]
 80074d6:	2200      	movs	r2, #0
 80074d8:	621a      	str	r2, [r3, #32]
    suspended_count =                            pool_ptr -> tx_block_pool_suspended_count;
 80074da:	687b      	ldr	r3, [r7, #4]
 80074dc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80074de:	643b      	str	r3, [r7, #64]	; 0x40
    pool_ptr -> tx_block_pool_suspended_count =  TX_NO_SUSPENSIONS;
 80074e0:	687b      	ldr	r3, [r7, #4]
 80074e2:	2200      	movs	r2, #0
 80074e4:	625a      	str	r2, [r3, #36]	; 0x24
 80074e6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80074e8:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80074ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80074ec:	f383 8810 	msr	PRIMASK, r3
}
 80074f0:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the block pool suspension list to resume any and all threads suspended
       on this block pool.  */
    while (suspended_count != TX_NO_SUSPENSIONS)
 80074f2:	e024      	b.n	800753e <_tx_block_pool_delete+0xda>
    {

        /* Decrement the suspension count.  */
        suspended_count--;
 80074f4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80074f6:	3b01      	subs	r3, #1
 80074f8:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80074fa:	f3ef 8310 	mrs	r3, PRIMASK
 80074fe:	61fb      	str	r3, [r7, #28]
    return(posture);
 8007500:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 8007502:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8007504:	b672      	cpsid	i
    return(int_posture);
 8007506:	69bb      	ldr	r3, [r7, #24]

        /* Lockout interrupts.  */
        TX_DISABLE
 8007508:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Clear the cleanup pointer, this prevents the timeout from doing
           anything.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800750a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800750c:	2200      	movs	r2, #0
 800750e:	669a      	str	r2, [r3, #104]	; 0x68

        /* Set the return status in the thread to TX_DELETED.  */
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
 8007510:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007512:	2201      	movs	r2, #1
 8007514:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Move the thread pointer ahead.  */
        next_thread =  thread_ptr -> tx_thread_suspended_next;
 8007518:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800751a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800751c:	633b      	str	r3, [r7, #48]	; 0x30
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption again.  */
        _tx_thread_preempt_disable++;
 800751e:	4b18      	ldr	r3, [pc, #96]	; (8007580 <_tx_block_pool_delete+0x11c>)
 8007520:	681b      	ldr	r3, [r3, #0]
 8007522:	3301      	adds	r3, #1
 8007524:	4a16      	ldr	r2, [pc, #88]	; (8007580 <_tx_block_pool_delete+0x11c>)
 8007526:	6013      	str	r3, [r2, #0]
 8007528:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800752a:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800752c:	6a3b      	ldr	r3, [r7, #32]
 800752e:	f383 8810 	msr	PRIMASK, r3
}
 8007532:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
 8007534:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8007536:	f004 ff79 	bl	800c42c <_tx_thread_system_resume>
#endif

        /* Move to next thread.  */
        thread_ptr =  next_thread;
 800753a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800753c:	647b      	str	r3, [r7, #68]	; 0x44
    while (suspended_count != TX_NO_SUSPENSIONS)
 800753e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8007540:	2b00      	cmp	r3, #0
 8007542:	d1d7      	bne.n	80074f4 <_tx_block_pool_delete+0x90>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8007544:	f3ef 8310 	mrs	r3, PRIMASK
 8007548:	613b      	str	r3, [r7, #16]
    return(posture);
 800754a:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 800754c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 800754e:	b672      	cpsid	i
    return(int_posture);
 8007550:	68fb      	ldr	r3, [r7, #12]

    /* Execute Port-Specific completion processing. If needed, it is typically defined in tx_port.h.  */
    TX_BLOCK_POOL_DELETE_PORT_COMPLETION(pool_ptr)

    /* Disable interrupts.  */
    TX_DISABLE
 8007552:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Release previous preempt disable.  */
    _tx_thread_preempt_disable--;
 8007554:	4b0a      	ldr	r3, [pc, #40]	; (8007580 <_tx_block_pool_delete+0x11c>)
 8007556:	681b      	ldr	r3, [r3, #0]
 8007558:	3b01      	subs	r3, #1
 800755a:	4a09      	ldr	r2, [pc, #36]	; (8007580 <_tx_block_pool_delete+0x11c>)
 800755c:	6013      	str	r3, [r2, #0]
 800755e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007560:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007562:	697b      	ldr	r3, [r7, #20]
 8007564:	f383 8810 	msr	PRIMASK, r3
}
 8007568:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 800756a:	f004 ff25 	bl	800c3b8 <_tx_thread_system_preempt_check>

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800756e:	2300      	movs	r3, #0
}
 8007570:	4618      	mov	r0, r3
 8007572:	3748      	adds	r7, #72	; 0x48
 8007574:	46bd      	mov	sp, r7
 8007576:	bd80      	pop	{r7, pc}
 8007578:	2000efa4 	.word	0x2000efa4
 800757c:	2000efa0 	.word	0x2000efa0
 8007580:	2000f054 	.word	0x2000f054

08007584 <_tx_block_pool_info_get>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_block_pool_info_get(TX_BLOCK_POOL *pool_ptr, CHAR **name, ULONG *available_blocks,
                    ULONG *total_blocks, TX_THREAD **first_suspended,
                    ULONG *suspended_count, TX_BLOCK_POOL **next_pool)
{
 8007584:	b480      	push	{r7}
 8007586:	b089      	sub	sp, #36	; 0x24
 8007588:	af00      	add	r7, sp, #0
 800758a:	60f8      	str	r0, [r7, #12]
 800758c:	60b9      	str	r1, [r7, #8]
 800758e:	607a      	str	r2, [r7, #4]
 8007590:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8007592:	f3ef 8310 	mrs	r3, PRIMASK
 8007596:	61bb      	str	r3, [r7, #24]
    return(posture);
 8007598:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800759a:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800759c:	b672      	cpsid	i
    return(int_posture);
 800759e:	697b      	ldr	r3, [r7, #20]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts.  */
    TX_DISABLE
 80075a0:	61fb      	str	r3, [r7, #28]

    /* Retrieve all the pertinent information and return it in the supplied
       destinations.  */

    /* Retrieve the name of the block pool.  */
    if (name != TX_NULL)
 80075a2:	68bb      	ldr	r3, [r7, #8]
 80075a4:	2b00      	cmp	r3, #0
 80075a6:	d003      	beq.n	80075b0 <_tx_block_pool_info_get+0x2c>
    {

        *name =  pool_ptr -> tx_block_pool_name;
 80075a8:	68fb      	ldr	r3, [r7, #12]
 80075aa:	685a      	ldr	r2, [r3, #4]
 80075ac:	68bb      	ldr	r3, [r7, #8]
 80075ae:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the number of available blocks in the block pool.  */
    if (available_blocks != TX_NULL)
 80075b0:	687b      	ldr	r3, [r7, #4]
 80075b2:	2b00      	cmp	r3, #0
 80075b4:	d003      	beq.n	80075be <_tx_block_pool_info_get+0x3a>
    {

        *available_blocks =  (ULONG) pool_ptr -> tx_block_pool_available;
 80075b6:	68fb      	ldr	r3, [r7, #12]
 80075b8:	689a      	ldr	r2, [r3, #8]
 80075ba:	687b      	ldr	r3, [r7, #4]
 80075bc:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the total number of blocks in the block pool.  */
    if (total_blocks != TX_NULL)
 80075be:	683b      	ldr	r3, [r7, #0]
 80075c0:	2b00      	cmp	r3, #0
 80075c2:	d003      	beq.n	80075cc <_tx_block_pool_info_get+0x48>
    {

        *total_blocks =  (ULONG) pool_ptr -> tx_block_pool_total;
 80075c4:	68fb      	ldr	r3, [r7, #12]
 80075c6:	68da      	ldr	r2, [r3, #12]
 80075c8:	683b      	ldr	r3, [r7, #0]
 80075ca:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the first thread suspended on this block pool.  */
    if (first_suspended != TX_NULL)
 80075cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80075ce:	2b00      	cmp	r3, #0
 80075d0:	d003      	beq.n	80075da <_tx_block_pool_info_get+0x56>
    {

        *first_suspended =  pool_ptr -> tx_block_pool_suspension_list;
 80075d2:	68fb      	ldr	r3, [r7, #12]
 80075d4:	6a1a      	ldr	r2, [r3, #32]
 80075d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80075d8:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the number of threads suspended on this block pool.  */
    if (suspended_count != TX_NULL)
 80075da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80075dc:	2b00      	cmp	r3, #0
 80075de:	d003      	beq.n	80075e8 <_tx_block_pool_info_get+0x64>
    {

        *suspended_count =  (ULONG) pool_ptr -> tx_block_pool_suspended_count;
 80075e0:	68fb      	ldr	r3, [r7, #12]
 80075e2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80075e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80075e6:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the pointer to the next block pool created.  */
    if (next_pool != TX_NULL)
 80075e8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80075ea:	2b00      	cmp	r3, #0
 80075ec:	d003      	beq.n	80075f6 <_tx_block_pool_info_get+0x72>
    {

        *next_pool =  pool_ptr -> tx_block_pool_created_next;
 80075ee:	68fb      	ldr	r3, [r7, #12]
 80075f0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80075f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80075f4:	601a      	str	r2, [r3, #0]
 80075f6:	69fb      	ldr	r3, [r7, #28]
 80075f8:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80075fa:	693b      	ldr	r3, [r7, #16]
 80075fc:	f383 8810 	msr	PRIMASK, r3
}
 8007600:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(TX_SUCCESS);
 8007602:	2300      	movs	r3, #0
}
 8007604:	4618      	mov	r0, r3
 8007606:	3724      	adds	r7, #36	; 0x24
 8007608:	46bd      	mov	sp, r7
 800760a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800760e:	4770      	bx	lr

08007610 <_tx_block_pool_performance_info_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_block_pool_performance_info_get(TX_BLOCK_POOL *pool_ptr, ULONG *allocates, ULONG *releases,
                    ULONG *suspensions, ULONG *timeouts)
{
 8007610:	b480      	push	{r7}
 8007612:	b087      	sub	sp, #28
 8007614:	af00      	add	r7, sp, #0
 8007616:	60f8      	str	r0, [r7, #12]
 8007618:	60b9      	str	r1, [r7, #8]
 800761a:	607a      	str	r2, [r7, #4]
 800761c:	603b      	str	r3, [r7, #0]
#else
UINT                    status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (pool_ptr != TX_NULL)
 800761e:	68fb      	ldr	r3, [r7, #12]
 8007620:	2b00      	cmp	r3, #0
 8007622:	d002      	beq.n	800762a <_tx_block_pool_performance_info_get+0x1a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007624:	23ff      	movs	r3, #255	; 0xff
 8007626:	617b      	str	r3, [r7, #20]
 8007628:	e019      	b.n	800765e <_tx_block_pool_performance_info_get+0x4e>
    }
    else if (allocates != TX_NULL)
 800762a:	68bb      	ldr	r3, [r7, #8]
 800762c:	2b00      	cmp	r3, #0
 800762e:	d002      	beq.n	8007636 <_tx_block_pool_performance_info_get+0x26>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007630:	23ff      	movs	r3, #255	; 0xff
 8007632:	617b      	str	r3, [r7, #20]
 8007634:	e013      	b.n	800765e <_tx_block_pool_performance_info_get+0x4e>
    }
    else if (releases != TX_NULL)
 8007636:	687b      	ldr	r3, [r7, #4]
 8007638:	2b00      	cmp	r3, #0
 800763a:	d002      	beq.n	8007642 <_tx_block_pool_performance_info_get+0x32>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800763c:	23ff      	movs	r3, #255	; 0xff
 800763e:	617b      	str	r3, [r7, #20]
 8007640:	e00d      	b.n	800765e <_tx_block_pool_performance_info_get+0x4e>
    }
    else if (suspensions != TX_NULL)
 8007642:	683b      	ldr	r3, [r7, #0]
 8007644:	2b00      	cmp	r3, #0
 8007646:	d002      	beq.n	800764e <_tx_block_pool_performance_info_get+0x3e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007648:	23ff      	movs	r3, #255	; 0xff
 800764a:	617b      	str	r3, [r7, #20]
 800764c:	e007      	b.n	800765e <_tx_block_pool_performance_info_get+0x4e>
    }
    else if (timeouts != TX_NULL)
 800764e:	6a3b      	ldr	r3, [r7, #32]
 8007650:	2b00      	cmp	r3, #0
 8007652:	d002      	beq.n	800765a <_tx_block_pool_performance_info_get+0x4a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007654:	23ff      	movs	r3, #255	; 0xff
 8007656:	617b      	str	r3, [r7, #20]
 8007658:	e001      	b.n	800765e <_tx_block_pool_performance_info_get+0x4e>
    }
    else
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800765a:	23ff      	movs	r3, #255	; 0xff
 800765c:	617b      	str	r3, [r7, #20]
    }
#endif

    /* Return completion status.  */
    return(status);
 800765e:	697b      	ldr	r3, [r7, #20]
}
 8007660:	4618      	mov	r0, r3
 8007662:	371c      	adds	r7, #28
 8007664:	46bd      	mov	sp, r7
 8007666:	f85d 7b04 	ldr.w	r7, [sp], #4
 800766a:	4770      	bx	lr

0800766c <_tx_block_pool_performance_system_info_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_block_pool_performance_system_info_get(ULONG *allocates, ULONG *releases, ULONG *suspensions, ULONG *timeouts)
{
 800766c:	b480      	push	{r7}
 800766e:	b087      	sub	sp, #28
 8007670:	af00      	add	r7, sp, #0
 8007672:	60f8      	str	r0, [r7, #12]
 8007674:	60b9      	str	r1, [r7, #8]
 8007676:	607a      	str	r2, [r7, #4]
 8007678:	603b      	str	r3, [r7, #0]

UINT        status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (allocates != TX_NULL)
 800767a:	68fb      	ldr	r3, [r7, #12]
 800767c:	2b00      	cmp	r3, #0
 800767e:	d002      	beq.n	8007686 <_tx_block_pool_performance_system_info_get+0x1a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007680:	23ff      	movs	r3, #255	; 0xff
 8007682:	617b      	str	r3, [r7, #20]
 8007684:	e013      	b.n	80076ae <_tx_block_pool_performance_system_info_get+0x42>
    }
    else if (releases != TX_NULL)
 8007686:	68bb      	ldr	r3, [r7, #8]
 8007688:	2b00      	cmp	r3, #0
 800768a:	d002      	beq.n	8007692 <_tx_block_pool_performance_system_info_get+0x26>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800768c:	23ff      	movs	r3, #255	; 0xff
 800768e:	617b      	str	r3, [r7, #20]
 8007690:	e00d      	b.n	80076ae <_tx_block_pool_performance_system_info_get+0x42>
    }
    else if (suspensions != TX_NULL)
 8007692:	687b      	ldr	r3, [r7, #4]
 8007694:	2b00      	cmp	r3, #0
 8007696:	d002      	beq.n	800769e <_tx_block_pool_performance_system_info_get+0x32>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007698:	23ff      	movs	r3, #255	; 0xff
 800769a:	617b      	str	r3, [r7, #20]
 800769c:	e007      	b.n	80076ae <_tx_block_pool_performance_system_info_get+0x42>
    }
    else if (timeouts != TX_NULL)
 800769e:	683b      	ldr	r3, [r7, #0]
 80076a0:	2b00      	cmp	r3, #0
 80076a2:	d002      	beq.n	80076aa <_tx_block_pool_performance_system_info_get+0x3e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 80076a4:	23ff      	movs	r3, #255	; 0xff
 80076a6:	617b      	str	r3, [r7, #20]
 80076a8:	e001      	b.n	80076ae <_tx_block_pool_performance_system_info_get+0x42>
    }
    else
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 80076aa:	23ff      	movs	r3, #255	; 0xff
 80076ac:	617b      	str	r3, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 80076ae:	697b      	ldr	r3, [r7, #20]
#endif
}
 80076b0:	4618      	mov	r0, r3
 80076b2:	371c      	adds	r7, #28
 80076b4:	46bd      	mov	sp, r7
 80076b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80076ba:	4770      	bx	lr

080076bc <_tx_block_pool_prioritize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_block_pool_prioritize(TX_BLOCK_POOL *pool_ptr)
{
 80076bc:	b580      	push	{r7, lr}
 80076be:	b092      	sub	sp, #72	; 0x48
 80076c0:	af00      	add	r7, sp, #0
 80076c2:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80076c4:	f3ef 8310 	mrs	r3, PRIMASK
 80076c8:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 80076ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 80076cc:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 80076ce:	b672      	cpsid	i
    return(int_posture);
 80076d0:	6a3b      	ldr	r3, [r7, #32]
TX_THREAD       *previous_thread;
UINT            list_changed;


    /* Disable interrupts.  */
    TX_DISABLE
 80076d2:	647b      	str	r3, [r7, #68]	; 0x44

    /* Log this kernel call.  */
    TX_EL_BLOCK_POOL_PRIORITIZE_INSERT

    /* Pickup the suspended count.  */
    suspended_count =  pool_ptr -> tx_block_pool_suspended_count;
 80076d4:	687b      	ldr	r3, [r7, #4]
 80076d6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80076d8:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if there are fewer than 2 suspended threads.  */
    if (suspended_count < ((UINT) 2))
 80076da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80076dc:	2b01      	cmp	r3, #1
 80076de:	d805      	bhi.n	80076ec <_tx_block_pool_prioritize+0x30>
 80076e0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80076e2:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80076e4:	69fb      	ldr	r3, [r7, #28]
 80076e6:	f383 8810 	msr	PRIMASK, r3
}
 80076ea:	e092      	b.n	8007812 <_tx_block_pool_prioritize+0x156>
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Determine if there how many threads are suspended on this block memory pool.  */
    else if (suspended_count == ((UINT) 2))
 80076ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80076ee:	2b02      	cmp	r3, #2
 80076f0:	d114      	bne.n	800771c <_tx_block_pool_prioritize+0x60>
    {

        /* Pickup the head pointer and the next pointer.  */
        head_ptr =  pool_ptr -> tx_block_pool_suspension_list;
 80076f2:	687b      	ldr	r3, [r7, #4]
 80076f4:	6a1b      	ldr	r3, [r3, #32]
 80076f6:	63bb      	str	r3, [r7, #56]	; 0x38
        next_thread =  head_ptr -> tx_thread_suspended_next;
 80076f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80076fa:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80076fc:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Determine if the next suspended thread has a higher priority.  */
        if ((next_thread -> tx_thread_priority) < (head_ptr -> tx_thread_priority))
 80076fe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007700:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8007702:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007704:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007706:	429a      	cmp	r2, r3
 8007708:	d202      	bcs.n	8007710 <_tx_block_pool_prioritize+0x54>
        {

            /* Yes, move the list head to the next thread.  */
            pool_ptr -> tx_block_pool_suspension_list =  next_thread;
 800770a:	687b      	ldr	r3, [r7, #4]
 800770c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800770e:	621a      	str	r2, [r3, #32]
 8007710:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007712:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007714:	69bb      	ldr	r3, [r7, #24]
 8007716:	f383 8810 	msr	PRIMASK, r3
}
 800771a:	e07a      	b.n	8007812 <_tx_block_pool_prioritize+0x156>
    }
    else
    {

        /* Remember the suspension count and head pointer.  */
        head_ptr =   pool_ptr -> tx_block_pool_suspension_list;
 800771c:	687b      	ldr	r3, [r7, #4]
 800771e:	6a1b      	ldr	r3, [r3, #32]
 8007720:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Default the highest priority thread to the thread at the front of the list.  */
        priority_thread_ptr =  head_ptr;
 8007722:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007724:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Setup search pointer.  */
        thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
 8007726:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007728:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800772a:	643b      	str	r3, [r7, #64]	; 0x40

        /* Disable preemption.  */
        _tx_thread_preempt_disable++;
 800772c:	4b3b      	ldr	r3, [pc, #236]	; (800781c <_tx_block_pool_prioritize+0x160>)
 800772e:	681b      	ldr	r3, [r3, #0]
 8007730:	3301      	adds	r3, #1
 8007732:	4a3a      	ldr	r2, [pc, #232]	; (800781c <_tx_block_pool_prioritize+0x160>)
 8007734:	6013      	str	r3, [r2, #0]

        /* Set the list changed flag to false.  */
        list_changed =  TX_FALSE;
 8007736:	2300      	movs	r3, #0
 8007738:	633b      	str	r3, [r7, #48]	; 0x30
        /* Search through the list to find the highest priority thread.  */
        do
        {

            /* Is the current thread higher priority?  */
            if (thread_ptr -> tx_thread_priority < priority_thread_ptr -> tx_thread_priority)
 800773a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800773c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800773e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007740:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007742:	429a      	cmp	r2, r3
 8007744:	d201      	bcs.n	800774a <_tx_block_pool_prioritize+0x8e>
            {

                /* Yes, remember that this thread is the highest priority.  */
                priority_thread_ptr =  thread_ptr;
 8007746:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8007748:	63fb      	str	r3, [r7, #60]	; 0x3c
 800774a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800774c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800774e:	68fb      	ldr	r3, [r7, #12]
 8007750:	f383 8810 	msr	PRIMASK, r3
}
 8007754:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8007756:	f3ef 8310 	mrs	r3, PRIMASK
 800775a:	617b      	str	r3, [r7, #20]
    return(posture);
 800775c:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800775e:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 8007760:	b672      	cpsid	i
    return(int_posture);
 8007762:	693b      	ldr	r3, [r7, #16]

            /* Restore interrupts temporarily.  */
            TX_RESTORE

            /* Disable interrupts again.  */
            TX_DISABLE
 8007764:	647b      	str	r3, [r7, #68]	; 0x44

            /* Determine if any changes to the list have occurred while
               interrupts were enabled.  */

            /* Is the list head the same?  */
            if (head_ptr != pool_ptr -> tx_block_pool_suspension_list)
 8007766:	687b      	ldr	r3, [r7, #4]
 8007768:	6a1b      	ldr	r3, [r3, #32]
 800776a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800776c:	429a      	cmp	r2, r3
 800776e:	d002      	beq.n	8007776 <_tx_block_pool_prioritize+0xba>
            {

                /* The list head has changed, set the list changed flag.  */
                list_changed =  TX_TRUE;
 8007770:	2301      	movs	r3, #1
 8007772:	633b      	str	r3, [r7, #48]	; 0x30
 8007774:	e006      	b.n	8007784 <_tx_block_pool_prioritize+0xc8>
            }
            else
            {

                /* Is the suspended count the same?  */
                if (suspended_count != pool_ptr -> tx_block_pool_suspended_count)
 8007776:	687b      	ldr	r3, [r7, #4]
 8007778:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800777a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800777c:	429a      	cmp	r2, r3
 800777e:	d001      	beq.n	8007784 <_tx_block_pool_prioritize+0xc8>
                {

                    /* The list head has changed, set the list changed flag.  */
                    list_changed =  TX_TRUE;
 8007780:	2301      	movs	r3, #1
 8007782:	633b      	str	r3, [r7, #48]	; 0x30
                }
            }

            /* Determine if the list has changed.  */
            if (list_changed == TX_FALSE)
 8007784:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007786:	2b00      	cmp	r3, #0
 8007788:	d103      	bne.n	8007792 <_tx_block_pool_prioritize+0xd6>
            {

                /* Move the thread pointer to the next thread.  */
                thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 800778a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800778c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800778e:	643b      	str	r3, [r7, #64]	; 0x40
 8007790:	e00c      	b.n	80077ac <_tx_block_pool_prioritize+0xf0>
            }
            else
            {

                /* Remember the suspension count and head pointer.  */
                head_ptr =   pool_ptr -> tx_block_pool_suspension_list;
 8007792:	687b      	ldr	r3, [r7, #4]
 8007794:	6a1b      	ldr	r3, [r3, #32]
 8007796:	63bb      	str	r3, [r7, #56]	; 0x38
                suspended_count =  pool_ptr -> tx_block_pool_suspended_count;
 8007798:	687b      	ldr	r3, [r7, #4]
 800779a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800779c:	637b      	str	r3, [r7, #52]	; 0x34

                /* Default the highest priority thread to the thread at the front of the list.  */
                priority_thread_ptr =  head_ptr;
 800779e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80077a0:	63fb      	str	r3, [r7, #60]	; 0x3c

                /* Setup search pointer.  */
                thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
 80077a2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80077a4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80077a6:	643b      	str	r3, [r7, #64]	; 0x40

                /* Reset the list changed flag.  */
                list_changed =  TX_FALSE;
 80077a8:	2300      	movs	r3, #0
 80077aa:	633b      	str	r3, [r7, #48]	; 0x30
            }

        } while (thread_ptr != head_ptr);
 80077ac:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80077ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80077b0:	429a      	cmp	r2, r3
 80077b2:	d1c2      	bne.n	800773a <_tx_block_pool_prioritize+0x7e>

        /* Release preemption.  */
        _tx_thread_preempt_disable--;
 80077b4:	4b19      	ldr	r3, [pc, #100]	; (800781c <_tx_block_pool_prioritize+0x160>)
 80077b6:	681b      	ldr	r3, [r3, #0]
 80077b8:	3b01      	subs	r3, #1
 80077ba:	4a18      	ldr	r2, [pc, #96]	; (800781c <_tx_block_pool_prioritize+0x160>)
 80077bc:	6013      	str	r3, [r2, #0]

        /* Now determine if the highest priority thread is at the front
           of the list.  */
        if (priority_thread_ptr != head_ptr)
 80077be:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80077c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80077c2:	429a      	cmp	r2, r3
 80077c4:	d01d      	beq.n	8007802 <_tx_block_pool_prioritize+0x146>
            /* No, we need to move the highest priority suspended thread to the
               front of the list.  */

            /* First, remove the highest priority thread by updating the
               adjacent suspended threads.  */
            next_thread =                                  priority_thread_ptr -> tx_thread_suspended_next;
 80077c6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80077c8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80077ca:	62fb      	str	r3, [r7, #44]	; 0x2c
            previous_thread =                              priority_thread_ptr -> tx_thread_suspended_previous;
 80077cc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80077ce:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80077d0:	62bb      	str	r3, [r7, #40]	; 0x28
            next_thread -> tx_thread_suspended_previous =  previous_thread;
 80077d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80077d4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80077d6:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =  next_thread;
 80077d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80077da:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80077dc:	671a      	str	r2, [r3, #112]	; 0x70

            /* Now, link the highest priority thread at the front of the list.  */
            previous_thread =                                      head_ptr -> tx_thread_suspended_previous;
 80077de:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80077e0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80077e2:	62bb      	str	r3, [r7, #40]	; 0x28
            priority_thread_ptr -> tx_thread_suspended_next =      head_ptr;
 80077e4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80077e6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80077e8:	671a      	str	r2, [r3, #112]	; 0x70
            priority_thread_ptr -> tx_thread_suspended_previous =  previous_thread;
 80077ea:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80077ec:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80077ee:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =          priority_thread_ptr;
 80077f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80077f2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80077f4:	671a      	str	r2, [r3, #112]	; 0x70
            head_ptr -> tx_thread_suspended_previous =             priority_thread_ptr;
 80077f6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80077f8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80077fa:	675a      	str	r2, [r3, #116]	; 0x74

            /* Move the list head pointer to the highest priority suspended thread.  */
            pool_ptr -> tx_block_pool_suspension_list =  priority_thread_ptr;
 80077fc:	687b      	ldr	r3, [r7, #4]
 80077fe:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8007800:	621a      	str	r2, [r3, #32]
 8007802:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007804:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007806:	68bb      	ldr	r3, [r7, #8]
 8007808:	f383 8810 	msr	PRIMASK, r3
}
 800780c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 800780e:	f004 fdd3 	bl	800c3b8 <_tx_thread_system_preempt_check>
    }

    /* Return successful status.  */
    return(TX_SUCCESS);
 8007812:	2300      	movs	r3, #0
}
 8007814:	4618      	mov	r0, r3
 8007816:	3748      	adds	r7, #72	; 0x48
 8007818:	46bd      	mov	sp, r7
 800781a:	bd80      	pop	{r7, pc}
 800781c:	2000f054 	.word	0x2000f054

08007820 <_tx_block_release>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_block_release(VOID *block_ptr)
{
 8007820:	b580      	push	{r7, lr}
 8007822:	b090      	sub	sp, #64	; 0x40
 8007824:	af00      	add	r7, sp, #0
 8007826:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8007828:	f3ef 8310 	mrs	r3, PRIMASK
 800782c:	61bb      	str	r3, [r7, #24]
    return(posture);
 800782e:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8007830:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8007832:	b672      	cpsid	i
    return(int_posture);
 8007834:	697b      	ldr	r3, [r7, #20]
TX_THREAD           *next_thread;
TX_THREAD           *previous_thread;


    /* Disable interrupts to put this block back in the pool.  */
    TX_DISABLE
 8007836:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Pickup the pool pointer which is just previous to the starting
       address of the block that the caller sees.  */
    work_ptr =        TX_VOID_TO_UCHAR_POINTER_CONVERT(block_ptr);
 8007838:	687b      	ldr	r3, [r7, #4]
 800783a:	63bb      	str	r3, [r7, #56]	; 0x38
    work_ptr =        TX_UCHAR_POINTER_SUB(work_ptr, (sizeof(UCHAR *)));
 800783c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800783e:	3b04      	subs	r3, #4
 8007840:	63bb      	str	r3, [r7, #56]	; 0x38
    next_block_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
 8007842:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007844:	637b      	str	r3, [r7, #52]	; 0x34
    pool_ptr =        TX_UCHAR_TO_BLOCK_POOL_POINTER_CONVERT((*next_block_ptr));
 8007846:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007848:	681b      	ldr	r3, [r3, #0]
 800784a:	633b      	str	r3, [r7, #48]	; 0x30

    /* Log this kernel call.  */
    TX_EL_BLOCK_RELEASE_INSERT

    /* Determine if there are any threads suspended on the block pool.  */
    thread_ptr =  pool_ptr -> tx_block_pool_suspension_list;
 800784c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800784e:	6a1b      	ldr	r3, [r3, #32]
 8007850:	62fb      	str	r3, [r7, #44]	; 0x2c
    if (thread_ptr != TX_NULL)
 8007852:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007854:	2b00      	cmp	r3, #0
 8007856:	d03b      	beq.n	80078d0 <_tx_block_release+0xb0>
    {

        /* Remove the suspended thread from the list.  */

        /* Decrement the number of threads suspended.  */
        (pool_ptr -> tx_block_pool_suspended_count)--;
 8007858:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800785a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800785c:	1e5a      	subs	r2, r3, #1
 800785e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007860:	625a      	str	r2, [r3, #36]	; 0x24

        /* Pickup the suspended count.  */
        suspended_count =  (pool_ptr -> tx_block_pool_suspended_count);
 8007862:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007864:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007866:	62bb      	str	r3, [r7, #40]	; 0x28

        /* See if this is the only suspended thread on the list.  */
        if (suspended_count == TX_NO_SUSPENSIONS)
 8007868:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800786a:	2b00      	cmp	r3, #0
 800786c:	d103      	bne.n	8007876 <_tx_block_release+0x56>
        {

            /* Yes, the only suspended thread.  */

            /* Update the head pointer.  */
            pool_ptr -> tx_block_pool_suspension_list =  TX_NULL;
 800786e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007870:	2200      	movs	r2, #0
 8007872:	621a      	str	r2, [r3, #32]
 8007874:	e00e      	b.n	8007894 <_tx_block_release+0x74>
        {

            /* At least one more thread is on the same expiration list.  */

            /* Update the list head pointer.  */
            next_thread =                                thread_ptr -> tx_thread_suspended_next;
 8007876:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007878:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800787a:	627b      	str	r3, [r7, #36]	; 0x24
            pool_ptr -> tx_block_pool_suspension_list =  next_thread;
 800787c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800787e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007880:	621a      	str	r2, [r3, #32]

            /* Update the links of the adjacent threads.  */
            previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
 8007882:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007884:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8007886:	623b      	str	r3, [r7, #32]
            next_thread -> tx_thread_suspended_previous =  previous_thread;
 8007888:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800788a:	6a3a      	ldr	r2, [r7, #32]
 800788c:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =  next_thread;
 800788e:	6a3b      	ldr	r3, [r7, #32]
 8007890:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007892:	671a      	str	r2, [r3, #112]	; 0x70
        }

        /* Prepare for resumption of the first thread.  */

        /* Clear cleanup routine to avoid timeout.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8007894:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007896:	2200      	movs	r2, #0
 8007898:	669a      	str	r2, [r3, #104]	; 0x68

        /* Return this block pointer to the suspended thread waiting for
           a block.  */
        return_block_ptr =  TX_VOID_TO_INDIRECT_UCHAR_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
 800789a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800789c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800789e:	61fb      	str	r3, [r7, #28]
        work_ptr =          TX_VOID_TO_UCHAR_POINTER_CONVERT(block_ptr);
 80078a0:	687b      	ldr	r3, [r7, #4]
 80078a2:	63bb      	str	r3, [r7, #56]	; 0x38
        *return_block_ptr =  work_ptr;
 80078a4:	69fb      	ldr	r3, [r7, #28]
 80078a6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80078a8:	601a      	str	r2, [r3, #0]

        /* Put return status into the thread control block.  */
        thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 80078aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80078ac:	2200      	movs	r2, #0
 80078ae:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption.  */
        _tx_thread_preempt_disable++;
 80078b2:	4b13      	ldr	r3, [pc, #76]	; (8007900 <_tx_block_release+0xe0>)
 80078b4:	681b      	ldr	r3, [r3, #0]
 80078b6:	3301      	adds	r3, #1
 80078b8:	4a11      	ldr	r2, [pc, #68]	; (8007900 <_tx_block_release+0xe0>)
 80078ba:	6013      	str	r3, [r2, #0]
 80078bc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80078be:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80078c0:	693b      	ldr	r3, [r7, #16]
 80078c2:	f383 8810 	msr	PRIMASK, r3
}
 80078c6:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume thread.  */
        _tx_thread_system_resume(thread_ptr);
 80078c8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80078ca:	f004 fdaf 	bl	800c42c <_tx_thread_system_resume>
 80078ce:	e011      	b.n	80078f4 <_tx_block_release+0xd4>
    {

        /* No thread is suspended for a memory block.  */

        /* Put the block back in the available list.  */
        *next_block_ptr =  pool_ptr -> tx_block_pool_available_list;
 80078d0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80078d2:	691a      	ldr	r2, [r3, #16]
 80078d4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80078d6:	601a      	str	r2, [r3, #0]

        /* Adjust the head pointer.  */
        pool_ptr -> tx_block_pool_available_list =  work_ptr;
 80078d8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80078da:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80078dc:	611a      	str	r2, [r3, #16]

        /* Increment the count of available blocks.  */
        pool_ptr -> tx_block_pool_available++;
 80078de:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80078e0:	689b      	ldr	r3, [r3, #8]
 80078e2:	1c5a      	adds	r2, r3, #1
 80078e4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80078e6:	609a      	str	r2, [r3, #8]
 80078e8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80078ea:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80078ec:	68fb      	ldr	r3, [r7, #12]
 80078ee:	f383 8810 	msr	PRIMASK, r3
}
 80078f2:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Return successful completion status.  */
    return(TX_SUCCESS);
 80078f4:	2300      	movs	r3, #0
}
 80078f6:	4618      	mov	r0, r3
 80078f8:	3740      	adds	r7, #64	; 0x40
 80078fa:	46bd      	mov	sp, r7
 80078fc:	bd80      	pop	{r7, pc}
 80078fe:	bf00      	nop
 8007900:	2000f054 	.word	0x2000f054

08007904 <_tx_byte_allocate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_byte_allocate(TX_BYTE_POOL *pool_ptr, VOID **memory_ptr, ULONG memory_size,  ULONG wait_option)
{
 8007904:	b580      	push	{r7, lr}
 8007906:	b096      	sub	sp, #88	; 0x58
 8007908:	af00      	add	r7, sp, #0
 800790a:	60f8      	str	r0, [r7, #12]
 800790c:	60b9      	str	r1, [r7, #8]
 800790e:	607a      	str	r2, [r7, #4]
 8007910:	603b      	str	r3, [r7, #0]
#endif


    /* Round the memory size up to the next size that is evenly divisible by
       an ALIGN_TYPE (this is typically a 32-bit ULONG).  This guarantees proper alignment.  */
    memory_size = (((memory_size + (sizeof(ALIGN_TYPE)))-((ALIGN_TYPE) 1))/(sizeof(ALIGN_TYPE))) * (sizeof(ALIGN_TYPE));
 8007912:	687b      	ldr	r3, [r7, #4]
 8007914:	3303      	adds	r3, #3
 8007916:	f023 0303 	bic.w	r3, r3, #3
 800791a:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800791c:	f3ef 8310 	mrs	r3, PRIMASK
 8007920:	637b      	str	r3, [r7, #52]	; 0x34
    return(posture);
 8007922:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    int_posture = __get_interrupt_posture();
 8007924:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("CPSID i" : : : "memory");
 8007926:	b672      	cpsid	i
    return(int_posture);
 8007928:	6b3b      	ldr	r3, [r7, #48]	; 0x30

    /* Disable interrupts.  */
    TX_DISABLE
 800792a:	657b      	str	r3, [r7, #84]	; 0x54

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800792c:	4b55      	ldr	r3, [pc, #340]	; (8007a84 <_tx_byte_allocate+0x180>)
 800792e:	681b      	ldr	r3, [r3, #0]
 8007930:	64bb      	str	r3, [r7, #72]	; 0x48
    lower_tbu =  *((ULONG *) (log_entry_ptr + TX_EL_EVENT_TIME_LOWER_OFFSET));
    upper_tbu =  *((ULONG *) (log_entry_ptr + TX_EL_EVENT_TIME_UPPER_OFFSET));
#endif

    /* Set the search finished flag to false.  */
    finished =  TX_FALSE;
 8007932:	2300      	movs	r3, #0
 8007934:	64fb      	str	r3, [r7, #76]	; 0x4c
    /* Loop to handle cases where the owner of the pool changed.  */
    do
    {

        /* Indicate that this thread is the current owner.  */
        pool_ptr -> tx_byte_pool_owner =  thread_ptr;
 8007936:	68fb      	ldr	r3, [r7, #12]
 8007938:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800793a:	621a      	str	r2, [r3, #32]
 800793c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800793e:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007940:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007942:	f383 8810 	msr	PRIMASK, r3
}
 8007946:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE

        /* At this point, the executing thread owns the pool and can perform a search
           for free memory.  */
        work_ptr =  _tx_byte_pool_search(pool_ptr, memory_size);
 8007948:	6879      	ldr	r1, [r7, #4]
 800794a:	68f8      	ldr	r0, [r7, #12]
 800794c:	f000 fbb4 	bl	80080b8 <_tx_byte_pool_search>
 8007950:	6478      	str	r0, [r7, #68]	; 0x44
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8007952:	f3ef 8310 	mrs	r3, PRIMASK
 8007956:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 8007958:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800795a:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800795c:	b672      	cpsid	i
    return(int_posture);
 800795e:	6abb      	ldr	r3, [r7, #40]	; 0x28

        /* Optional processing extension.  */
        TX_BYTE_ALLOCATE_EXTENSION

        /* Lockout interrupts.  */
        TX_DISABLE
 8007960:	657b      	str	r3, [r7, #84]	; 0x54

        /* Determine if we are finished.  */
        if (work_ptr != TX_NULL)
 8007962:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007964:	2b00      	cmp	r3, #0
 8007966:	d002      	beq.n	800796e <_tx_byte_allocate+0x6a>
        {

            /* Yes, we have found a block the search is finished.  */
            finished =  TX_TRUE;
 8007968:	2301      	movs	r3, #1
 800796a:	64fb      	str	r3, [r7, #76]	; 0x4c
 800796c:	e006      	b.n	800797c <_tx_byte_allocate+0x78>
        }
        else
        {

            /* No block was found, does this thread still own the pool?  */
            if (pool_ptr -> tx_byte_pool_owner == thread_ptr)
 800796e:	68fb      	ldr	r3, [r7, #12]
 8007970:	6a1b      	ldr	r3, [r3, #32]
 8007972:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8007974:	429a      	cmp	r2, r3
 8007976:	d101      	bne.n	800797c <_tx_byte_allocate+0x78>
            {

                /* Yes, then we have looked through the entire pool and haven't found the memory.  */
                finished =  TX_TRUE;
 8007978:	2301      	movs	r3, #1
 800797a:	64fb      	str	r3, [r7, #76]	; 0x4c
            }
        }

    } while (finished == TX_FALSE);
 800797c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800797e:	2b00      	cmp	r3, #0
 8007980:	d0d9      	beq.n	8007936 <_tx_byte_allocate+0x32>

    /* Copy the pointer into the return destination.  */
    *memory_ptr =  (VOID *) work_ptr;
 8007982:	68bb      	ldr	r3, [r7, #8]
 8007984:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8007986:	601a      	str	r2, [r3, #0]

    /* Determine if memory was found.  */
    if (work_ptr != TX_NULL)
 8007988:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800798a:	2b00      	cmp	r3, #0
 800798c:	d008      	beq.n	80079a0 <_tx_byte_allocate+0x9c>
 800798e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8007990:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007992:	6a3b      	ldr	r3, [r7, #32]
 8007994:	f383 8810 	msr	PRIMASK, r3
}
 8007998:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Set the status to success.  */
        status =  TX_SUCCESS;
 800799a:	2300      	movs	r3, #0
 800799c:	653b      	str	r3, [r7, #80]	; 0x50
 800799e:	e06c      	b.n	8007a7a <_tx_byte_allocate+0x176>
    {

        /* No memory of sufficient size was found...  */

        /* Determine if the request specifies suspension.  */
        if (wait_option != TX_NO_WAIT)
 80079a0:	683b      	ldr	r3, [r7, #0]
 80079a2:	2b00      	cmp	r3, #0
 80079a4:	d061      	beq.n	8007a6a <_tx_byte_allocate+0x166>
        {

            /* Determine if the preempt disable flag is non-zero.  */
            if (_tx_thread_preempt_disable != ((UINT) 0))
 80079a6:	4b38      	ldr	r3, [pc, #224]	; (8007a88 <_tx_byte_allocate+0x184>)
 80079a8:	681b      	ldr	r3, [r3, #0]
 80079aa:	2b00      	cmp	r3, #0
 80079ac:	d007      	beq.n	80079be <_tx_byte_allocate+0xba>
            {

                /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
                status =  TX_NO_MEMORY;
 80079ae:	2310      	movs	r3, #16
 80079b0:	653b      	str	r3, [r7, #80]	; 0x50
 80079b2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80079b4:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80079b6:	69fb      	ldr	r3, [r7, #28]
 80079b8:	f383 8810 	msr	PRIMASK, r3
}
 80079bc:	e05d      	b.n	8007a7a <_tx_byte_allocate+0x176>
                /* Increment the number of suspensions on this pool.  */
                pool_ptr -> tx_byte_pool_performance_suspension_count++;
#endif

                /* Setup cleanup routine pointer.  */
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_byte_pool_cleanup);
 80079be:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80079c0:	4a32      	ldr	r2, [pc, #200]	; (8007a8c <_tx_byte_allocate+0x188>)
 80079c2:	669a      	str	r2, [r3, #104]	; 0x68

                /* Setup cleanup information, i.e. this pool control
                   block.  */
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) pool_ptr;
 80079c4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80079c6:	68fa      	ldr	r2, [r7, #12]
 80079c8:	66da      	str	r2, [r3, #108]	; 0x6c

                /* Save the return memory pointer address as well.  */
                thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) memory_ptr;
 80079ca:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80079cc:	68ba      	ldr	r2, [r7, #8]
 80079ce:	67da      	str	r2, [r3, #124]	; 0x7c

                /* Save the byte size requested.  */
                thread_ptr -> tx_thread_suspend_info =  memory_size;
 80079d0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80079d2:	687a      	ldr	r2, [r7, #4]
 80079d4:	679a      	str	r2, [r3, #120]	; 0x78

#ifndef TX_NOT_INTERRUPTABLE

                /* Increment the suspension sequence number, which is used to identify
                   this suspension event.  */
                thread_ptr -> tx_thread_suspension_sequence++;
 80079d6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80079d8:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 80079dc:	1c5a      	adds	r2, r3, #1
 80079de:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80079e0:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
#endif

                /* Pickup the number of suspended threads.  */
                suspended_count =  pool_ptr -> tx_byte_pool_suspended_count;
 80079e4:	68fb      	ldr	r3, [r7, #12]
 80079e6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80079e8:	643b      	str	r3, [r7, #64]	; 0x40

                /* Increment the suspension count.  */
                (pool_ptr -> tx_byte_pool_suspended_count)++;
 80079ea:	68fb      	ldr	r3, [r7, #12]
 80079ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80079ee:	1c5a      	adds	r2, r3, #1
 80079f0:	68fb      	ldr	r3, [r7, #12]
 80079f2:	629a      	str	r2, [r3, #40]	; 0x28

                /* Setup suspension list.  */
                if (suspended_count == TX_NO_SUSPENSIONS)
 80079f4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80079f6:	2b00      	cmp	r3, #0
 80079f8:	d109      	bne.n	8007a0e <_tx_byte_allocate+0x10a>
                {

                    /* No other threads are suspended.  Setup the head pointer and
                       just setup this threads pointers to itself.  */
                    pool_ptr -> tx_byte_pool_suspension_list =      thread_ptr;
 80079fa:	68fb      	ldr	r3, [r7, #12]
 80079fc:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80079fe:	625a      	str	r2, [r3, #36]	; 0x24
                    thread_ptr -> tx_thread_suspended_next =        thread_ptr;
 8007a00:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007a02:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8007a04:	671a      	str	r2, [r3, #112]	; 0x70
                    thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
 8007a06:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007a08:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8007a0a:	675a      	str	r2, [r3, #116]	; 0x74
 8007a0c:	e011      	b.n	8007a32 <_tx_byte_allocate+0x12e>
                }
                else
                {

                    /* This list is not NULL, add current thread to the end. */
                    next_thread =                                   pool_ptr -> tx_byte_pool_suspension_list;
 8007a0e:	68fb      	ldr	r3, [r7, #12]
 8007a10:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007a12:	63fb      	str	r3, [r7, #60]	; 0x3c
                    thread_ptr -> tx_thread_suspended_next =        next_thread;
 8007a14:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007a16:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8007a18:	671a      	str	r2, [r3, #112]	; 0x70
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
 8007a1a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007a1c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8007a1e:	63bb      	str	r3, [r7, #56]	; 0x38
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 8007a20:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007a22:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8007a24:	675a      	str	r2, [r3, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
 8007a26:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007a28:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8007a2a:	671a      	str	r2, [r3, #112]	; 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
 8007a2c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007a2e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8007a30:	675a      	str	r2, [r3, #116]	; 0x74
                }

                /* Set the state to suspended.  */
                thread_ptr -> tx_thread_state =       TX_BYTE_MEMORY;
 8007a32:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007a34:	2209      	movs	r2, #9
 8007a36:	631a      	str	r2, [r3, #48]	; 0x30
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Set the suspending flag.  */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
 8007a38:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007a3a:	2201      	movs	r2, #1
 8007a3c:	639a      	str	r2, [r3, #56]	; 0x38

                /* Setup the timeout period.  */
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 8007a3e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007a40:	683a      	ldr	r2, [r7, #0]
 8007a42:	64da      	str	r2, [r3, #76]	; 0x4c

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
 8007a44:	4b10      	ldr	r3, [pc, #64]	; (8007a88 <_tx_byte_allocate+0x184>)
 8007a46:	681b      	ldr	r3, [r3, #0]
 8007a48:	3301      	adds	r3, #1
 8007a4a:	4a0f      	ldr	r2, [pc, #60]	; (8007a88 <_tx_byte_allocate+0x184>)
 8007a4c:	6013      	str	r3, [r2, #0]
 8007a4e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8007a50:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007a52:	69bb      	ldr	r3, [r7, #24]
 8007a54:	f383 8810 	msr	PRIMASK, r3
}
 8007a58:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
 8007a5a:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8007a5c:	f004 fdfa 	bl	800c654 <_tx_thread_system_suspend>
                    *((ULONG *) (log_entry_ptr + TX_EL_EVENT_INFO_4_OFFSET)) =  (ULONG) *memory_ptr;
                }
#endif

                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
 8007a60:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007a62:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8007a66:	653b      	str	r3, [r7, #80]	; 0x50
 8007a68:	e007      	b.n	8007a7a <_tx_byte_allocate+0x176>
 8007a6a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8007a6c:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007a6e:	697b      	ldr	r3, [r7, #20]
 8007a70:	f383 8810 	msr	PRIMASK, r3
}
 8007a74:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Immediate return, return error completion.  */
            status =  TX_NO_MEMORY;
 8007a76:	2310      	movs	r3, #16
 8007a78:	653b      	str	r3, [r7, #80]	; 0x50
        }
    }

    /* Return completion status.  */
    return(status);
 8007a7a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
}
 8007a7c:	4618      	mov	r0, r3
 8007a7e:	3758      	adds	r7, #88	; 0x58
 8007a80:	46bd      	mov	sp, r7
 8007a82:	bd80      	pop	{r7, pc}
 8007a84:	2000efb8 	.word	0x2000efb8
 8007a88:	2000f054 	.word	0x2000f054
 8007a8c:	08007a91 	.word	0x08007a91

08007a90 <_tx_byte_pool_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_byte_pool_cleanup(TX_THREAD *thread_ptr, ULONG suspension_sequence)
{
 8007a90:	b580      	push	{r7, lr}
 8007a92:	b08e      	sub	sp, #56	; 0x38
 8007a94:	af00      	add	r7, sp, #0
 8007a96:	6078      	str	r0, [r7, #4]
 8007a98:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8007a9a:	f3ef 8310 	mrs	r3, PRIMASK
 8007a9e:	623b      	str	r3, [r7, #32]
    return(posture);
 8007aa0:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 8007aa2:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 8007aa4:	b672      	cpsid	i
    return(int_posture);
 8007aa6:	69fb      	ldr	r3, [r7, #28]


#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the byte pool.  */
    TX_DISABLE
 8007aa8:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_byte_pool_cleanup))
 8007aaa:	687b      	ldr	r3, [r7, #4]
 8007aac:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8007aae:	4a33      	ldr	r2, [pc, #204]	; (8007b7c <_tx_byte_pool_cleanup+0xec>)
 8007ab0:	4293      	cmp	r3, r2
 8007ab2:	d158      	bne.n	8007b66 <_tx_byte_pool_cleanup+0xd6>
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
 8007ab4:	687b      	ldr	r3, [r7, #4]
 8007ab6:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 8007aba:	683a      	ldr	r2, [r7, #0]
 8007abc:	429a      	cmp	r2, r3
 8007abe:	d152      	bne.n	8007b66 <_tx_byte_pool_cleanup+0xd6>
        {

            /* Setup pointer to byte pool control block.  */
            pool_ptr =  TX_VOID_TO_BYTE_POOL_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
 8007ac0:	687b      	ldr	r3, [r7, #4]
 8007ac2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8007ac4:	633b      	str	r3, [r7, #48]	; 0x30

            /* Check for a NULL byte pool pointer.  */
            if (pool_ptr != TX_NULL)
 8007ac6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007ac8:	2b00      	cmp	r3, #0
 8007aca:	d04c      	beq.n	8007b66 <_tx_byte_pool_cleanup+0xd6>
            {

                /* Check for valid pool ID.  */
                if (pool_ptr -> tx_byte_pool_id == TX_BYTE_POOL_ID)
 8007acc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007ace:	681b      	ldr	r3, [r3, #0]
 8007ad0:	4a2b      	ldr	r2, [pc, #172]	; (8007b80 <_tx_byte_pool_cleanup+0xf0>)
 8007ad2:	4293      	cmp	r3, r2
 8007ad4:	d147      	bne.n	8007b66 <_tx_byte_pool_cleanup+0xd6>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (pool_ptr -> tx_byte_pool_suspended_count != TX_NO_SUSPENSIONS)
 8007ad6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007ad8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007ada:	2b00      	cmp	r3, #0
 8007adc:	d043      	beq.n	8007b66 <_tx_byte_pool_cleanup+0xd6>
                        /* Setup pointer to byte pool control block.  */
                        pool_ptr =  TX_VOID_TO_BYTE_POOL_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
#endif

                        /* Thread suspended for memory... Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8007ade:	687b      	ldr	r3, [r7, #4]
 8007ae0:	2200      	movs	r2, #0
 8007ae2:	669a      	str	r2, [r3, #104]	; 0x68

                        /* Decrement the suspension count.  */
                        pool_ptr -> tx_byte_pool_suspended_count--;
 8007ae4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007ae6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007ae8:	1e5a      	subs	r2, r3, #1
 8007aea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007aec:	629a      	str	r2, [r3, #40]	; 0x28

                        /* Pickup the suspended count.  */
                        suspended_count =  pool_ptr -> tx_byte_pool_suspended_count;
 8007aee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007af0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007af2:	62fb      	str	r3, [r7, #44]	; 0x2c

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
 8007af4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007af6:	2b00      	cmp	r3, #0
 8007af8:	d103      	bne.n	8007b02 <_tx_byte_pool_cleanup+0x72>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            pool_ptr -> tx_byte_pool_suspension_list =  TX_NULL;
 8007afa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007afc:	2200      	movs	r2, #0
 8007afe:	625a      	str	r2, [r3, #36]	; 0x24
 8007b00:	e013      	b.n	8007b2a <_tx_byte_pool_cleanup+0x9a>
                        {

                            /* At least one more thread is on the same suspension list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
 8007b02:	687b      	ldr	r3, [r7, #4]
 8007b04:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8007b06:	62bb      	str	r3, [r7, #40]	; 0x28
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 8007b08:	687b      	ldr	r3, [r7, #4]
 8007b0a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8007b0c:	627b      	str	r3, [r7, #36]	; 0x24
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
 8007b0e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007b10:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007b12:	675a      	str	r2, [r3, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
 8007b14:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007b16:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007b18:	671a      	str	r2, [r3, #112]	; 0x70

                            /* Determine if we need to update the head pointer.  */
                            if (pool_ptr -> tx_byte_pool_suspension_list == thread_ptr)
 8007b1a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007b1c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007b1e:	687a      	ldr	r2, [r7, #4]
 8007b20:	429a      	cmp	r2, r3
 8007b22:	d102      	bne.n	8007b2a <_tx_byte_pool_cleanup+0x9a>
                            {

                                /* Update the list head pointer.  */
                                pool_ptr -> tx_byte_pool_suspension_list =      next_thread;
 8007b24:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007b26:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007b28:	625a      	str	r2, [r3, #36]	; 0x24
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_BYTE_MEMORY)
 8007b2a:	687b      	ldr	r3, [r7, #4]
 8007b2c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007b2e:	2b09      	cmp	r3, #9
 8007b30:	d119      	bne.n	8007b66 <_tx_byte_pool_cleanup+0xd6>
                            /* Increment the number of timeouts on this byte pool.  */
                            pool_ptr -> tx_byte_pool_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_MEMORY;
 8007b32:	687b      	ldr	r3, [r7, #4]
 8007b34:	2210      	movs	r2, #16
 8007b36:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 8007b3a:	4b12      	ldr	r3, [pc, #72]	; (8007b84 <_tx_byte_pool_cleanup+0xf4>)
 8007b3c:	681b      	ldr	r3, [r3, #0]
 8007b3e:	3301      	adds	r3, #1
 8007b40:	4a10      	ldr	r2, [pc, #64]	; (8007b84 <_tx_byte_pool_cleanup+0xf4>)
 8007b42:	6013      	str	r3, [r2, #0]
 8007b44:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007b46:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007b48:	693b      	ldr	r3, [r7, #16]
 8007b4a:	f383 8810 	msr	PRIMASK, r3
}
 8007b4e:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
 8007b50:	6878      	ldr	r0, [r7, #4]
 8007b52:	f004 fc6b 	bl	800c42c <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8007b56:	f3ef 8310 	mrs	r3, PRIMASK
 8007b5a:	61bb      	str	r3, [r7, #24]
    return(posture);
 8007b5c:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8007b5e:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8007b60:	b672      	cpsid	i
    return(int_posture);
 8007b62:	697b      	ldr	r3, [r7, #20]

                            /* Disable interrupts.  */
                            TX_DISABLE
 8007b64:	637b      	str	r3, [r7, #52]	; 0x34
 8007b66:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007b68:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007b6a:	68fb      	ldr	r3, [r7, #12]
 8007b6c:	f383 8810 	msr	PRIMASK, r3
}
 8007b70:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 8007b72:	bf00      	nop
 8007b74:	3738      	adds	r7, #56	; 0x38
 8007b76:	46bd      	mov	sp, r7
 8007b78:	bd80      	pop	{r7, pc}
 8007b7a:	bf00      	nop
 8007b7c:	08007a91 	.word	0x08007a91
 8007b80:	42595445 	.word	0x42595445
 8007b84:	2000f054 	.word	0x2000f054

08007b88 <_tx_byte_pool_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_byte_pool_create(TX_BYTE_POOL *pool_ptr, CHAR *name_ptr, VOID *pool_start, ULONG pool_size)
{
 8007b88:	b580      	push	{r7, lr}
 8007b8a:	b08e      	sub	sp, #56	; 0x38
 8007b8c:	af00      	add	r7, sp, #0
 8007b8e:	60f8      	str	r0, [r7, #12]
 8007b90:	60b9      	str	r1, [r7, #8]
 8007b92:	607a      	str	r2, [r7, #4]
 8007b94:	603b      	str	r3, [r7, #0]
TX_BYTE_POOL        *previous_pool;
ALIGN_TYPE          *free_ptr;


    /* Initialize the byte pool control block to all zeros.  */
    TX_MEMSET(pool_ptr, 0, (sizeof(TX_BYTE_POOL)));
 8007b96:	2234      	movs	r2, #52	; 0x34
 8007b98:	2100      	movs	r1, #0
 8007b9a:	68f8      	ldr	r0, [r7, #12]
 8007b9c:	f00e ff22 	bl	80169e4 <memset>

    /* Round the pool size down to something that is evenly divisible by
       an ULONG.  */
    pool_size =   (pool_size/(sizeof(ALIGN_TYPE))) * (sizeof(ALIGN_TYPE));
 8007ba0:	683b      	ldr	r3, [r7, #0]
 8007ba2:	f023 0303 	bic.w	r3, r3, #3
 8007ba6:	603b      	str	r3, [r7, #0]

    /* Setup the basic byte pool fields.  */
    pool_ptr -> tx_byte_pool_name =              name_ptr;
 8007ba8:	68fb      	ldr	r3, [r7, #12]
 8007baa:	68ba      	ldr	r2, [r7, #8]
 8007bac:	605a      	str	r2, [r3, #4]

    /* Save the start and size of the pool.  */
    pool_ptr -> tx_byte_pool_start =   TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 8007bae:	68fb      	ldr	r3, [r7, #12]
 8007bb0:	687a      	ldr	r2, [r7, #4]
 8007bb2:	619a      	str	r2, [r3, #24]
    pool_ptr -> tx_byte_pool_size =    pool_size;
 8007bb4:	68fb      	ldr	r3, [r7, #12]
 8007bb6:	683a      	ldr	r2, [r7, #0]
 8007bb8:	61da      	str	r2, [r3, #28]

    /* Setup memory list to the beginning as well as the search pointer.  */
    pool_ptr -> tx_byte_pool_list =    TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 8007bba:	68fb      	ldr	r3, [r7, #12]
 8007bbc:	687a      	ldr	r2, [r7, #4]
 8007bbe:	611a      	str	r2, [r3, #16]
    pool_ptr -> tx_byte_pool_search =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 8007bc0:	68fb      	ldr	r3, [r7, #12]
 8007bc2:	687a      	ldr	r2, [r7, #4]
 8007bc4:	615a      	str	r2, [r3, #20]

    /* Initially, the pool will have two blocks.  One large block at the
       beginning that is available and a small allocated block at the end
       of the pool that is there just for the algorithm.  Be sure to count
       the available block's header in the available bytes count.  */
    pool_ptr -> tx_byte_pool_available =   pool_size - ((sizeof(VOID *)) + (sizeof(ALIGN_TYPE)));
 8007bc6:	683b      	ldr	r3, [r7, #0]
 8007bc8:	f1a3 0208 	sub.w	r2, r3, #8
 8007bcc:	68fb      	ldr	r3, [r7, #12]
 8007bce:	609a      	str	r2, [r3, #8]
    pool_ptr -> tx_byte_pool_fragments =   ((UINT) 2);
 8007bd0:	68fb      	ldr	r3, [r7, #12]
 8007bd2:	2202      	movs	r2, #2
 8007bd4:	60da      	str	r2, [r3, #12]
    /* Each block contains a "next" pointer that points to the next block in the pool followed by a ALIGN_TYPE
       field that contains either the constant TX_BYTE_BLOCK_FREE (if the block is free) or a pointer to the
       owning pool (if the block is allocated).  */

    /* Calculate the end of the pool's memory area.  */
    block_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 8007bd6:	687b      	ldr	r3, [r7, #4]
 8007bd8:	637b      	str	r3, [r7, #52]	; 0x34
    block_ptr =  TX_UCHAR_POINTER_ADD(block_ptr, pool_size);
 8007bda:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8007bdc:	683b      	ldr	r3, [r7, #0]
 8007bde:	4413      	add	r3, r2
 8007be0:	637b      	str	r3, [r7, #52]	; 0x34

    /* Backup the end of the pool pointer and build the pre-allocated block.  */
    block_ptr =  TX_UCHAR_POINTER_SUB(block_ptr, (sizeof(ALIGN_TYPE)));
 8007be2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007be4:	3b04      	subs	r3, #4
 8007be6:	637b      	str	r3, [r7, #52]	; 0x34

    /* Cast the pool pointer into a ULONG.  */
    temp_ptr =             TX_BYTE_POOL_TO_UCHAR_POINTER_CONVERT(pool_ptr);
 8007be8:	68fb      	ldr	r3, [r7, #12]
 8007bea:	633b      	str	r3, [r7, #48]	; 0x30
    block_indirect_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(block_ptr);
 8007bec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007bee:	62fb      	str	r3, [r7, #44]	; 0x2c
    *block_indirect_ptr =  temp_ptr;
 8007bf0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007bf2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8007bf4:	601a      	str	r2, [r3, #0]

    block_ptr =            TX_UCHAR_POINTER_SUB(block_ptr, (sizeof(UCHAR *)));
 8007bf6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007bf8:	3b04      	subs	r3, #4
 8007bfa:	637b      	str	r3, [r7, #52]	; 0x34
    block_indirect_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(block_ptr);
 8007bfc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007bfe:	62fb      	str	r3, [r7, #44]	; 0x2c
    *block_indirect_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 8007c00:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007c02:	687a      	ldr	r2, [r7, #4]
 8007c04:	601a      	str	r2, [r3, #0]

    /* Now setup the large available block in the pool.  */
    temp_ptr =             TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 8007c06:	687b      	ldr	r3, [r7, #4]
 8007c08:	633b      	str	r3, [r7, #48]	; 0x30
    block_indirect_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(temp_ptr);
 8007c0a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007c0c:	62fb      	str	r3, [r7, #44]	; 0x2c
    *block_indirect_ptr =  block_ptr;
 8007c0e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007c10:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8007c12:	601a      	str	r2, [r3, #0]
    block_ptr =            TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 8007c14:	687b      	ldr	r3, [r7, #4]
 8007c16:	637b      	str	r3, [r7, #52]	; 0x34
    block_ptr =            TX_UCHAR_POINTER_ADD(block_ptr, (sizeof(UCHAR *)));
 8007c18:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007c1a:	3304      	adds	r3, #4
 8007c1c:	637b      	str	r3, [r7, #52]	; 0x34
    free_ptr =             TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(block_ptr);
 8007c1e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007c20:	62bb      	str	r3, [r7, #40]	; 0x28
    *free_ptr =            TX_BYTE_BLOCK_FREE;
 8007c22:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007c24:	4a1f      	ldr	r2, [pc, #124]	; (8007ca4 <_tx_byte_pool_create+0x11c>)
 8007c26:	601a      	str	r2, [r3, #0]

    /* Clear the owner id.  */
    pool_ptr -> tx_byte_pool_owner =  TX_NULL;
 8007c28:	68fb      	ldr	r3, [r7, #12]
 8007c2a:	2200      	movs	r2, #0
 8007c2c:	621a      	str	r2, [r3, #32]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8007c2e:	f3ef 8310 	mrs	r3, PRIMASK
 8007c32:	61bb      	str	r3, [r7, #24]
    return(posture);
 8007c34:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8007c36:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8007c38:	b672      	cpsid	i
    return(int_posture);
 8007c3a:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to place the byte pool on the created list.  */
    TX_DISABLE
 8007c3c:	627b      	str	r3, [r7, #36]	; 0x24

    /* Setup the byte pool ID to make it valid.  */
    pool_ptr -> tx_byte_pool_id =  TX_BYTE_POOL_ID;
 8007c3e:	68fb      	ldr	r3, [r7, #12]
 8007c40:	4a19      	ldr	r2, [pc, #100]	; (8007ca8 <_tx_byte_pool_create+0x120>)
 8007c42:	601a      	str	r2, [r3, #0]

    /* Place the byte pool on the list of created byte pools.  First,
       check for an empty list.  */
    if (_tx_byte_pool_created_count == TX_EMPTY)
 8007c44:	4b19      	ldr	r3, [pc, #100]	; (8007cac <_tx_byte_pool_create+0x124>)
 8007c46:	681b      	ldr	r3, [r3, #0]
 8007c48:	2b00      	cmp	r3, #0
 8007c4a:	d109      	bne.n	8007c60 <_tx_byte_pool_create+0xd8>
    {

        /* The created byte pool list is empty.  Add byte pool to empty list.  */
        _tx_byte_pool_created_ptr =                  pool_ptr;
 8007c4c:	4a18      	ldr	r2, [pc, #96]	; (8007cb0 <_tx_byte_pool_create+0x128>)
 8007c4e:	68fb      	ldr	r3, [r7, #12]
 8007c50:	6013      	str	r3, [r2, #0]
        pool_ptr -> tx_byte_pool_created_next =      pool_ptr;
 8007c52:	68fb      	ldr	r3, [r7, #12]
 8007c54:	68fa      	ldr	r2, [r7, #12]
 8007c56:	62da      	str	r2, [r3, #44]	; 0x2c
        pool_ptr -> tx_byte_pool_created_previous =  pool_ptr;
 8007c58:	68fb      	ldr	r3, [r7, #12]
 8007c5a:	68fa      	ldr	r2, [r7, #12]
 8007c5c:	631a      	str	r2, [r3, #48]	; 0x30
 8007c5e:	e011      	b.n	8007c84 <_tx_byte_pool_create+0xfc>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_pool =      _tx_byte_pool_created_ptr;
 8007c60:	4b13      	ldr	r3, [pc, #76]	; (8007cb0 <_tx_byte_pool_create+0x128>)
 8007c62:	681b      	ldr	r3, [r3, #0]
 8007c64:	623b      	str	r3, [r7, #32]
        previous_pool =  next_pool -> tx_byte_pool_created_previous;
 8007c66:	6a3b      	ldr	r3, [r7, #32]
 8007c68:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007c6a:	61fb      	str	r3, [r7, #28]

        /* Place the new byte pool in the list.  */
        next_pool -> tx_byte_pool_created_previous =  pool_ptr;
 8007c6c:	6a3b      	ldr	r3, [r7, #32]
 8007c6e:	68fa      	ldr	r2, [r7, #12]
 8007c70:	631a      	str	r2, [r3, #48]	; 0x30
        previous_pool -> tx_byte_pool_created_next =  pool_ptr;
 8007c72:	69fb      	ldr	r3, [r7, #28]
 8007c74:	68fa      	ldr	r2, [r7, #12]
 8007c76:	62da      	str	r2, [r3, #44]	; 0x2c

        /* Setup this byte pool's created links.  */
        pool_ptr -> tx_byte_pool_created_previous =  previous_pool;
 8007c78:	68fb      	ldr	r3, [r7, #12]
 8007c7a:	69fa      	ldr	r2, [r7, #28]
 8007c7c:	631a      	str	r2, [r3, #48]	; 0x30
        pool_ptr -> tx_byte_pool_created_next =      next_pool;
 8007c7e:	68fb      	ldr	r3, [r7, #12]
 8007c80:	6a3a      	ldr	r2, [r7, #32]
 8007c82:	62da      	str	r2, [r3, #44]	; 0x2c
    }

    /* Increment the number of created byte pools.  */
    _tx_byte_pool_created_count++;
 8007c84:	4b09      	ldr	r3, [pc, #36]	; (8007cac <_tx_byte_pool_create+0x124>)
 8007c86:	681b      	ldr	r3, [r3, #0]
 8007c88:	3301      	adds	r3, #1
 8007c8a:	4a08      	ldr	r2, [pc, #32]	; (8007cac <_tx_byte_pool_create+0x124>)
 8007c8c:	6013      	str	r3, [r2, #0]
 8007c8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007c90:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007c92:	693b      	ldr	r3, [r7, #16]
 8007c94:	f383 8810 	msr	PRIMASK, r3
}
 8007c98:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 8007c9a:	2300      	movs	r3, #0
}
 8007c9c:	4618      	mov	r0, r3
 8007c9e:	3738      	adds	r7, #56	; 0x38
 8007ca0:	46bd      	mov	sp, r7
 8007ca2:	bd80      	pop	{r7, pc}
 8007ca4:	ffffeeee 	.word	0xffffeeee
 8007ca8:	42595445 	.word	0x42595445
 8007cac:	2000efac 	.word	0x2000efac
 8007cb0:	2000efa8 	.word	0x2000efa8

08007cb4 <_tx_byte_pool_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_byte_pool_delete(TX_BYTE_POOL *pool_ptr)
{
 8007cb4:	b580      	push	{r7, lr}
 8007cb6:	b092      	sub	sp, #72	; 0x48
 8007cb8:	af00      	add	r7, sp, #0
 8007cba:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8007cbc:	f3ef 8310 	mrs	r3, PRIMASK
 8007cc0:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 8007cc2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 8007cc4:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 8007cc6:	b672      	cpsid	i
    return(int_posture);
 8007cc8:	6abb      	ldr	r3, [r7, #40]	; 0x28
TX_BYTE_POOL    *next_pool;
TX_BYTE_POOL    *previous_pool;


    /* Disable interrupts to remove the byte pool from the created list.  */
    TX_DISABLE
 8007cca:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Log this kernel call.  */
    TX_EL_BYTE_POOL_DELETE_INSERT

    /* Clear the byte pool ID to make it invalid.  */
    pool_ptr -> tx_byte_pool_id =  TX_CLEAR_ID;
 8007ccc:	687b      	ldr	r3, [r7, #4]
 8007cce:	2200      	movs	r2, #0
 8007cd0:	601a      	str	r2, [r3, #0]

    /* Decrement the number of byte pools created.  */
    _tx_byte_pool_created_count--;
 8007cd2:	4b3d      	ldr	r3, [pc, #244]	; (8007dc8 <_tx_byte_pool_delete+0x114>)
 8007cd4:	681b      	ldr	r3, [r3, #0]
 8007cd6:	3b01      	subs	r3, #1
 8007cd8:	4a3b      	ldr	r2, [pc, #236]	; (8007dc8 <_tx_byte_pool_delete+0x114>)
 8007cda:	6013      	str	r3, [r2, #0]

    /* See if the byte pool is the only one on the list.  */
    if (_tx_byte_pool_created_count == TX_EMPTY)
 8007cdc:	4b3a      	ldr	r3, [pc, #232]	; (8007dc8 <_tx_byte_pool_delete+0x114>)
 8007cde:	681b      	ldr	r3, [r3, #0]
 8007ce0:	2b00      	cmp	r3, #0
 8007ce2:	d103      	bne.n	8007cec <_tx_byte_pool_delete+0x38>
    {

        /* Only created byte pool, just set the created list to NULL.  */
        _tx_byte_pool_created_ptr =  TX_NULL;
 8007ce4:	4b39      	ldr	r3, [pc, #228]	; (8007dcc <_tx_byte_pool_delete+0x118>)
 8007ce6:	2200      	movs	r2, #0
 8007ce8:	601a      	str	r2, [r3, #0]
 8007cea:	e013      	b.n	8007d14 <_tx_byte_pool_delete+0x60>
    }
    else
    {

        /* Link-up the neighbors.  */
        next_pool =                                   pool_ptr -> tx_byte_pool_created_next;
 8007cec:	687b      	ldr	r3, [r7, #4]
 8007cee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007cf0:	63bb      	str	r3, [r7, #56]	; 0x38
        previous_pool =                               pool_ptr -> tx_byte_pool_created_previous;
 8007cf2:	687b      	ldr	r3, [r7, #4]
 8007cf4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007cf6:	637b      	str	r3, [r7, #52]	; 0x34
        next_pool -> tx_byte_pool_created_previous =  previous_pool;
 8007cf8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007cfa:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8007cfc:	631a      	str	r2, [r3, #48]	; 0x30
        previous_pool -> tx_byte_pool_created_next =  next_pool;
 8007cfe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007d00:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8007d02:	62da      	str	r2, [r3, #44]	; 0x2c

        /* See if we have to update the created list head pointer.  */
        if (_tx_byte_pool_created_ptr == pool_ptr)
 8007d04:	4b31      	ldr	r3, [pc, #196]	; (8007dcc <_tx_byte_pool_delete+0x118>)
 8007d06:	681b      	ldr	r3, [r3, #0]
 8007d08:	687a      	ldr	r2, [r7, #4]
 8007d0a:	429a      	cmp	r2, r3
 8007d0c:	d102      	bne.n	8007d14 <_tx_byte_pool_delete+0x60>
        {

            /* Yes, move the head pointer to the next link. */
            _tx_byte_pool_created_ptr =  next_pool;
 8007d0e:	4a2f      	ldr	r2, [pc, #188]	; (8007dcc <_tx_byte_pool_delete+0x118>)
 8007d10:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007d12:	6013      	str	r3, [r2, #0]
        }
    }

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 8007d14:	4b2e      	ldr	r3, [pc, #184]	; (8007dd0 <_tx_byte_pool_delete+0x11c>)
 8007d16:	681b      	ldr	r3, [r3, #0]
 8007d18:	3301      	adds	r3, #1
 8007d1a:	4a2d      	ldr	r2, [pc, #180]	; (8007dd0 <_tx_byte_pool_delete+0x11c>)
 8007d1c:	6013      	str	r3, [r2, #0]

    /* Pickup the suspension information.  */
    thread_ptr =                                pool_ptr -> tx_byte_pool_suspension_list;
 8007d1e:	687b      	ldr	r3, [r7, #4]
 8007d20:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007d22:	647b      	str	r3, [r7, #68]	; 0x44
    pool_ptr -> tx_byte_pool_suspension_list =  TX_NULL;
 8007d24:	687b      	ldr	r3, [r7, #4]
 8007d26:	2200      	movs	r2, #0
 8007d28:	625a      	str	r2, [r3, #36]	; 0x24
    suspended_count =                           pool_ptr -> tx_byte_pool_suspended_count;
 8007d2a:	687b      	ldr	r3, [r7, #4]
 8007d2c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007d2e:	643b      	str	r3, [r7, #64]	; 0x40
    pool_ptr -> tx_byte_pool_suspended_count =  TX_NO_SUSPENSIONS;
 8007d30:	687b      	ldr	r3, [r7, #4]
 8007d32:	2200      	movs	r2, #0
 8007d34:	629a      	str	r2, [r3, #40]	; 0x28
 8007d36:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007d38:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007d3a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007d3c:	f383 8810 	msr	PRIMASK, r3
}
 8007d40:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the byte pool list to resume any and all threads suspended
       on this byte pool.  */
    while (suspended_count != TX_NO_SUSPENSIONS)
 8007d42:	e024      	b.n	8007d8e <_tx_byte_pool_delete+0xda>
    {

        /* Decrement the suspension count.  */
        suspended_count--;
 8007d44:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8007d46:	3b01      	subs	r3, #1
 8007d48:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8007d4a:	f3ef 8310 	mrs	r3, PRIMASK
 8007d4e:	61fb      	str	r3, [r7, #28]
    return(posture);
 8007d50:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 8007d52:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8007d54:	b672      	cpsid	i
    return(int_posture);
 8007d56:	69bb      	ldr	r3, [r7, #24]

        /* Lockout interrupts.  */
        TX_DISABLE
 8007d58:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Clear the cleanup pointer, this prevents the timeout from doing
           anything.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8007d5a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007d5c:	2200      	movs	r2, #0
 8007d5e:	669a      	str	r2, [r3, #104]	; 0x68

        /* Set the return status in the thread to TX_DELETED.  */
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
 8007d60:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007d62:	2201      	movs	r2, #1
 8007d64:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Move the thread pointer ahead.  */
        next_thread =  thread_ptr -> tx_thread_suspended_next;
 8007d68:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007d6a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8007d6c:	633b      	str	r3, [r7, #48]	; 0x30
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption again.  */
        _tx_thread_preempt_disable++;
 8007d6e:	4b18      	ldr	r3, [pc, #96]	; (8007dd0 <_tx_byte_pool_delete+0x11c>)
 8007d70:	681b      	ldr	r3, [r3, #0]
 8007d72:	3301      	adds	r3, #1
 8007d74:	4a16      	ldr	r2, [pc, #88]	; (8007dd0 <_tx_byte_pool_delete+0x11c>)
 8007d76:	6013      	str	r3, [r2, #0]
 8007d78:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007d7a:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007d7c:	6a3b      	ldr	r3, [r7, #32]
 8007d7e:	f383 8810 	msr	PRIMASK, r3
}
 8007d82:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
 8007d84:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8007d86:	f004 fb51 	bl	800c42c <_tx_thread_system_resume>
#endif

        /* Move to next thread.  */
        thread_ptr =  next_thread;
 8007d8a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007d8c:	647b      	str	r3, [r7, #68]	; 0x44
    while (suspended_count != TX_NO_SUSPENSIONS)
 8007d8e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8007d90:	2b00      	cmp	r3, #0
 8007d92:	d1d7      	bne.n	8007d44 <_tx_byte_pool_delete+0x90>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8007d94:	f3ef 8310 	mrs	r3, PRIMASK
 8007d98:	613b      	str	r3, [r7, #16]
    return(posture);
 8007d9a:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 8007d9c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 8007d9e:	b672      	cpsid	i
    return(int_posture);
 8007da0:	68fb      	ldr	r3, [r7, #12]

    /* Execute Port-Specific completion processing. If needed, it is typically defined in tx_port.h.  */
    TX_BYTE_POOL_DELETE_PORT_COMPLETION(pool_ptr)

    /* Disable interrupts.  */
    TX_DISABLE
 8007da2:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Release previous preempt disable.  */
    _tx_thread_preempt_disable--;
 8007da4:	4b0a      	ldr	r3, [pc, #40]	; (8007dd0 <_tx_byte_pool_delete+0x11c>)
 8007da6:	681b      	ldr	r3, [r3, #0]
 8007da8:	3b01      	subs	r3, #1
 8007daa:	4a09      	ldr	r2, [pc, #36]	; (8007dd0 <_tx_byte_pool_delete+0x11c>)
 8007dac:	6013      	str	r3, [r2, #0]
 8007dae:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007db0:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007db2:	697b      	ldr	r3, [r7, #20]
 8007db4:	f383 8810 	msr	PRIMASK, r3
}
 8007db8:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 8007dba:	f004 fafd 	bl	800c3b8 <_tx_thread_system_preempt_check>

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 8007dbe:	2300      	movs	r3, #0
}
 8007dc0:	4618      	mov	r0, r3
 8007dc2:	3748      	adds	r7, #72	; 0x48
 8007dc4:	46bd      	mov	sp, r7
 8007dc6:	bd80      	pop	{r7, pc}
 8007dc8:	2000efac 	.word	0x2000efac
 8007dcc:	2000efa8 	.word	0x2000efa8
 8007dd0:	2000f054 	.word	0x2000f054

08007dd4 <_tx_byte_pool_info_get>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_byte_pool_info_get(TX_BYTE_POOL *pool_ptr, CHAR **name, ULONG *available_bytes,
                    ULONG *fragments, TX_THREAD **first_suspended,
                    ULONG *suspended_count, TX_BYTE_POOL **next_pool)
{
 8007dd4:	b480      	push	{r7}
 8007dd6:	b089      	sub	sp, #36	; 0x24
 8007dd8:	af00      	add	r7, sp, #0
 8007dda:	60f8      	str	r0, [r7, #12]
 8007ddc:	60b9      	str	r1, [r7, #8]
 8007dde:	607a      	str	r2, [r7, #4]
 8007de0:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8007de2:	f3ef 8310 	mrs	r3, PRIMASK
 8007de6:	61bb      	str	r3, [r7, #24]
    return(posture);
 8007de8:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8007dea:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8007dec:	b672      	cpsid	i
    return(int_posture);
 8007dee:	697b      	ldr	r3, [r7, #20]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts.  */
    TX_DISABLE
 8007df0:	61fb      	str	r3, [r7, #28]

    /* Retrieve all the pertinent information and return it in the supplied
       destinations.  */

    /* Retrieve the name of the byte pool.  */
    if (name != TX_NULL)
 8007df2:	68bb      	ldr	r3, [r7, #8]
 8007df4:	2b00      	cmp	r3, #0
 8007df6:	d003      	beq.n	8007e00 <_tx_byte_pool_info_get+0x2c>
    {

        *name =  pool_ptr -> tx_byte_pool_name;
 8007df8:	68fb      	ldr	r3, [r7, #12]
 8007dfa:	685a      	ldr	r2, [r3, #4]
 8007dfc:	68bb      	ldr	r3, [r7, #8]
 8007dfe:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the number of available bytes in the byte pool.  */
    if (available_bytes != TX_NULL)
 8007e00:	687b      	ldr	r3, [r7, #4]
 8007e02:	2b00      	cmp	r3, #0
 8007e04:	d003      	beq.n	8007e0e <_tx_byte_pool_info_get+0x3a>
    {

        *available_bytes =  pool_ptr -> tx_byte_pool_available;
 8007e06:	68fb      	ldr	r3, [r7, #12]
 8007e08:	689a      	ldr	r2, [r3, #8]
 8007e0a:	687b      	ldr	r3, [r7, #4]
 8007e0c:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the total number of bytes in the byte pool.  */
    if (fragments != TX_NULL)
 8007e0e:	683b      	ldr	r3, [r7, #0]
 8007e10:	2b00      	cmp	r3, #0
 8007e12:	d003      	beq.n	8007e1c <_tx_byte_pool_info_get+0x48>
    {

        *fragments =  (ULONG) pool_ptr -> tx_byte_pool_fragments;
 8007e14:	68fb      	ldr	r3, [r7, #12]
 8007e16:	68da      	ldr	r2, [r3, #12]
 8007e18:	683b      	ldr	r3, [r7, #0]
 8007e1a:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the first thread suspended on this byte pool.  */
    if (first_suspended != TX_NULL)
 8007e1c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007e1e:	2b00      	cmp	r3, #0
 8007e20:	d003      	beq.n	8007e2a <_tx_byte_pool_info_get+0x56>
    {

        *first_suspended =  pool_ptr -> tx_byte_pool_suspension_list;
 8007e22:	68fb      	ldr	r3, [r7, #12]
 8007e24:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8007e26:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007e28:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the number of threads suspended on this byte pool.  */
    if (suspended_count != TX_NULL)
 8007e2a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007e2c:	2b00      	cmp	r3, #0
 8007e2e:	d003      	beq.n	8007e38 <_tx_byte_pool_info_get+0x64>
    {

        *suspended_count =  (ULONG) pool_ptr -> tx_byte_pool_suspended_count;
 8007e30:	68fb      	ldr	r3, [r7, #12]
 8007e32:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8007e34:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007e36:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the pointer to the next byte pool created.  */
    if (next_pool != TX_NULL)
 8007e38:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007e3a:	2b00      	cmp	r3, #0
 8007e3c:	d003      	beq.n	8007e46 <_tx_byte_pool_info_get+0x72>
    {

        *next_pool =  pool_ptr -> tx_byte_pool_created_next;
 8007e3e:	68fb      	ldr	r3, [r7, #12]
 8007e40:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8007e42:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007e44:	601a      	str	r2, [r3, #0]
 8007e46:	69fb      	ldr	r3, [r7, #28]
 8007e48:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007e4a:	693b      	ldr	r3, [r7, #16]
 8007e4c:	f383 8810 	msr	PRIMASK, r3
}
 8007e50:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(TX_SUCCESS);
 8007e52:	2300      	movs	r3, #0
}
 8007e54:	4618      	mov	r0, r3
 8007e56:	3724      	adds	r7, #36	; 0x24
 8007e58:	46bd      	mov	sp, r7
 8007e5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007e5e:	4770      	bx	lr

08007e60 <_tx_byte_pool_performance_info_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_byte_pool_performance_info_get(TX_BYTE_POOL *pool_ptr, ULONG *allocates, ULONG *releases,
                    ULONG *fragments_searched, ULONG *merges, ULONG *splits, ULONG *suspensions, ULONG *timeouts)
{
 8007e60:	b480      	push	{r7}
 8007e62:	b087      	sub	sp, #28
 8007e64:	af00      	add	r7, sp, #0
 8007e66:	60f8      	str	r0, [r7, #12]
 8007e68:	60b9      	str	r1, [r7, #8]
 8007e6a:	607a      	str	r2, [r7, #4]
 8007e6c:	603b      	str	r3, [r7, #0]

UINT        status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (pool_ptr != TX_NULL)
 8007e6e:	68fb      	ldr	r3, [r7, #12]
 8007e70:	2b00      	cmp	r3, #0
 8007e72:	d002      	beq.n	8007e7a <_tx_byte_pool_performance_info_get+0x1a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007e74:	23ff      	movs	r3, #255	; 0xff
 8007e76:	617b      	str	r3, [r7, #20]
 8007e78:	e02b      	b.n	8007ed2 <_tx_byte_pool_performance_info_get+0x72>
    }
    else if (allocates != TX_NULL)
 8007e7a:	68bb      	ldr	r3, [r7, #8]
 8007e7c:	2b00      	cmp	r3, #0
 8007e7e:	d002      	beq.n	8007e86 <_tx_byte_pool_performance_info_get+0x26>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007e80:	23ff      	movs	r3, #255	; 0xff
 8007e82:	617b      	str	r3, [r7, #20]
 8007e84:	e025      	b.n	8007ed2 <_tx_byte_pool_performance_info_get+0x72>
    }
    else if (releases != TX_NULL)
 8007e86:	687b      	ldr	r3, [r7, #4]
 8007e88:	2b00      	cmp	r3, #0
 8007e8a:	d002      	beq.n	8007e92 <_tx_byte_pool_performance_info_get+0x32>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007e8c:	23ff      	movs	r3, #255	; 0xff
 8007e8e:	617b      	str	r3, [r7, #20]
 8007e90:	e01f      	b.n	8007ed2 <_tx_byte_pool_performance_info_get+0x72>
    }
    else if (fragments_searched != TX_NULL)
 8007e92:	683b      	ldr	r3, [r7, #0]
 8007e94:	2b00      	cmp	r3, #0
 8007e96:	d002      	beq.n	8007e9e <_tx_byte_pool_performance_info_get+0x3e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007e98:	23ff      	movs	r3, #255	; 0xff
 8007e9a:	617b      	str	r3, [r7, #20]
 8007e9c:	e019      	b.n	8007ed2 <_tx_byte_pool_performance_info_get+0x72>
    }
    else if (merges != TX_NULL)
 8007e9e:	6a3b      	ldr	r3, [r7, #32]
 8007ea0:	2b00      	cmp	r3, #0
 8007ea2:	d002      	beq.n	8007eaa <_tx_byte_pool_performance_info_get+0x4a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007ea4:	23ff      	movs	r3, #255	; 0xff
 8007ea6:	617b      	str	r3, [r7, #20]
 8007ea8:	e013      	b.n	8007ed2 <_tx_byte_pool_performance_info_get+0x72>
    }
    else if (splits != TX_NULL)
 8007eaa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007eac:	2b00      	cmp	r3, #0
 8007eae:	d002      	beq.n	8007eb6 <_tx_byte_pool_performance_info_get+0x56>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007eb0:	23ff      	movs	r3, #255	; 0xff
 8007eb2:	617b      	str	r3, [r7, #20]
 8007eb4:	e00d      	b.n	8007ed2 <_tx_byte_pool_performance_info_get+0x72>
    }
    else if (suspensions != TX_NULL)
 8007eb6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007eb8:	2b00      	cmp	r3, #0
 8007eba:	d002      	beq.n	8007ec2 <_tx_byte_pool_performance_info_get+0x62>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007ebc:	23ff      	movs	r3, #255	; 0xff
 8007ebe:	617b      	str	r3, [r7, #20]
 8007ec0:	e007      	b.n	8007ed2 <_tx_byte_pool_performance_info_get+0x72>
    }
    else if (timeouts != TX_NULL)
 8007ec2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007ec4:	2b00      	cmp	r3, #0
 8007ec6:	d002      	beq.n	8007ece <_tx_byte_pool_performance_info_get+0x6e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007ec8:	23ff      	movs	r3, #255	; 0xff
 8007eca:	617b      	str	r3, [r7, #20]
 8007ecc:	e001      	b.n	8007ed2 <_tx_byte_pool_performance_info_get+0x72>
    }
    else
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007ece:	23ff      	movs	r3, #255	; 0xff
 8007ed0:	617b      	str	r3, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 8007ed2:	697b      	ldr	r3, [r7, #20]
#endif
}
 8007ed4:	4618      	mov	r0, r3
 8007ed6:	371c      	adds	r7, #28
 8007ed8:	46bd      	mov	sp, r7
 8007eda:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007ede:	4770      	bx	lr

08007ee0 <_tx_byte_pool_performance_system_info_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_byte_pool_performance_system_info_get(ULONG *allocates, ULONG *releases,
                    ULONG *fragments_searched, ULONG *merges, ULONG *splits, ULONG *suspensions, ULONG *timeouts)
{
 8007ee0:	b480      	push	{r7}
 8007ee2:	b087      	sub	sp, #28
 8007ee4:	af00      	add	r7, sp, #0
 8007ee6:	60f8      	str	r0, [r7, #12]
 8007ee8:	60b9      	str	r1, [r7, #8]
 8007eea:	607a      	str	r2, [r7, #4]
 8007eec:	603b      	str	r3, [r7, #0]

UINT        status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (allocates != TX_NULL)
 8007eee:	68fb      	ldr	r3, [r7, #12]
 8007ef0:	2b00      	cmp	r3, #0
 8007ef2:	d002      	beq.n	8007efa <_tx_byte_pool_performance_system_info_get+0x1a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007ef4:	23ff      	movs	r3, #255	; 0xff
 8007ef6:	617b      	str	r3, [r7, #20]
 8007ef8:	e025      	b.n	8007f46 <_tx_byte_pool_performance_system_info_get+0x66>
    }
    else if (releases != TX_NULL)
 8007efa:	68bb      	ldr	r3, [r7, #8]
 8007efc:	2b00      	cmp	r3, #0
 8007efe:	d002      	beq.n	8007f06 <_tx_byte_pool_performance_system_info_get+0x26>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007f00:	23ff      	movs	r3, #255	; 0xff
 8007f02:	617b      	str	r3, [r7, #20]
 8007f04:	e01f      	b.n	8007f46 <_tx_byte_pool_performance_system_info_get+0x66>
    }
    else if (fragments_searched != TX_NULL)
 8007f06:	687b      	ldr	r3, [r7, #4]
 8007f08:	2b00      	cmp	r3, #0
 8007f0a:	d002      	beq.n	8007f12 <_tx_byte_pool_performance_system_info_get+0x32>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007f0c:	23ff      	movs	r3, #255	; 0xff
 8007f0e:	617b      	str	r3, [r7, #20]
 8007f10:	e019      	b.n	8007f46 <_tx_byte_pool_performance_system_info_get+0x66>
    }
    else if (merges != TX_NULL)
 8007f12:	683b      	ldr	r3, [r7, #0]
 8007f14:	2b00      	cmp	r3, #0
 8007f16:	d002      	beq.n	8007f1e <_tx_byte_pool_performance_system_info_get+0x3e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007f18:	23ff      	movs	r3, #255	; 0xff
 8007f1a:	617b      	str	r3, [r7, #20]
 8007f1c:	e013      	b.n	8007f46 <_tx_byte_pool_performance_system_info_get+0x66>
    }
    else if (splits != TX_NULL)
 8007f1e:	6a3b      	ldr	r3, [r7, #32]
 8007f20:	2b00      	cmp	r3, #0
 8007f22:	d002      	beq.n	8007f2a <_tx_byte_pool_performance_system_info_get+0x4a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007f24:	23ff      	movs	r3, #255	; 0xff
 8007f26:	617b      	str	r3, [r7, #20]
 8007f28:	e00d      	b.n	8007f46 <_tx_byte_pool_performance_system_info_get+0x66>
    }
    else if (suspensions != TX_NULL)
 8007f2a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007f2c:	2b00      	cmp	r3, #0
 8007f2e:	d002      	beq.n	8007f36 <_tx_byte_pool_performance_system_info_get+0x56>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007f30:	23ff      	movs	r3, #255	; 0xff
 8007f32:	617b      	str	r3, [r7, #20]
 8007f34:	e007      	b.n	8007f46 <_tx_byte_pool_performance_system_info_get+0x66>
    }
    else if (timeouts != TX_NULL)
 8007f36:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007f38:	2b00      	cmp	r3, #0
 8007f3a:	d002      	beq.n	8007f42 <_tx_byte_pool_performance_system_info_get+0x62>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007f3c:	23ff      	movs	r3, #255	; 0xff
 8007f3e:	617b      	str	r3, [r7, #20]
 8007f40:	e001      	b.n	8007f46 <_tx_byte_pool_performance_system_info_get+0x66>
    }
    else
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8007f42:	23ff      	movs	r3, #255	; 0xff
 8007f44:	617b      	str	r3, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 8007f46:	697b      	ldr	r3, [r7, #20]
#endif
}
 8007f48:	4618      	mov	r0, r3
 8007f4a:	371c      	adds	r7, #28
 8007f4c:	46bd      	mov	sp, r7
 8007f4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f52:	4770      	bx	lr

08007f54 <_tx_byte_pool_prioritize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_byte_pool_prioritize(TX_BYTE_POOL *pool_ptr)
{
 8007f54:	b580      	push	{r7, lr}
 8007f56:	b092      	sub	sp, #72	; 0x48
 8007f58:	af00      	add	r7, sp, #0
 8007f5a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8007f5c:	f3ef 8310 	mrs	r3, PRIMASK
 8007f60:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 8007f62:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 8007f64:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 8007f66:	b672      	cpsid	i
    return(int_posture);
 8007f68:	6a3b      	ldr	r3, [r7, #32]
TX_THREAD       *previous_thread;
UINT            list_changed;


    /* Disable interrupts.  */
    TX_DISABLE
 8007f6a:	647b      	str	r3, [r7, #68]	; 0x44

    /* Log this kernel call.  */
    TX_EL_BYTE_POOL_PRIORITIZE_INSERT

    /* Pickup the suspended count.  */
    suspended_count =  pool_ptr -> tx_byte_pool_suspended_count;
 8007f6c:	687b      	ldr	r3, [r7, #4]
 8007f6e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007f70:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if there are fewer than 2 suspended threads.  */
    if (suspended_count < ((UINT) 2))
 8007f72:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007f74:	2b01      	cmp	r3, #1
 8007f76:	d805      	bhi.n	8007f84 <_tx_byte_pool_prioritize+0x30>
 8007f78:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007f7a:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007f7c:	69fb      	ldr	r3, [r7, #28]
 8007f7e:	f383 8810 	msr	PRIMASK, r3
}
 8007f82:	e092      	b.n	80080aa <_tx_byte_pool_prioritize+0x156>
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Determine if there how many threads are suspended on this byte memory pool.  */
    else if (suspended_count == ((UINT) 2))
 8007f84:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007f86:	2b02      	cmp	r3, #2
 8007f88:	d114      	bne.n	8007fb4 <_tx_byte_pool_prioritize+0x60>
    {

        /* Pickup the head pointer and the next pointer.  */
        head_ptr =  pool_ptr -> tx_byte_pool_suspension_list;
 8007f8a:	687b      	ldr	r3, [r7, #4]
 8007f8c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007f8e:	63bb      	str	r3, [r7, #56]	; 0x38
        next_thread =  head_ptr -> tx_thread_suspended_next;
 8007f90:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007f92:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8007f94:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Determine if the next suspended thread has a higher priority.  */
        if ((next_thread -> tx_thread_priority) < (head_ptr -> tx_thread_priority))
 8007f96:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007f98:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8007f9a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007f9c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007f9e:	429a      	cmp	r2, r3
 8007fa0:	d202      	bcs.n	8007fa8 <_tx_byte_pool_prioritize+0x54>
        {

            /* Yes, move the list head to the next thread.  */
            pool_ptr -> tx_byte_pool_suspension_list =  next_thread;
 8007fa2:	687b      	ldr	r3, [r7, #4]
 8007fa4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8007fa6:	625a      	str	r2, [r3, #36]	; 0x24
 8007fa8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007faa:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007fac:	69bb      	ldr	r3, [r7, #24]
 8007fae:	f383 8810 	msr	PRIMASK, r3
}
 8007fb2:	e07a      	b.n	80080aa <_tx_byte_pool_prioritize+0x156>
    }
    else
    {

        /* Remember the suspension count and head pointer.  */
        head_ptr =   pool_ptr -> tx_byte_pool_suspension_list;
 8007fb4:	687b      	ldr	r3, [r7, #4]
 8007fb6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007fb8:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Default the highest priority thread to the thread at the front of the list.  */
        priority_thread_ptr =  head_ptr;
 8007fba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007fbc:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Setup search pointer.  */
        thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
 8007fbe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007fc0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8007fc2:	643b      	str	r3, [r7, #64]	; 0x40

        /* Disable preemption.  */
        _tx_thread_preempt_disable++;
 8007fc4:	4b3b      	ldr	r3, [pc, #236]	; (80080b4 <_tx_byte_pool_prioritize+0x160>)
 8007fc6:	681b      	ldr	r3, [r3, #0]
 8007fc8:	3301      	adds	r3, #1
 8007fca:	4a3a      	ldr	r2, [pc, #232]	; (80080b4 <_tx_byte_pool_prioritize+0x160>)
 8007fcc:	6013      	str	r3, [r2, #0]

        /* Set the list changed flag to false.  */
        list_changed =  TX_FALSE;
 8007fce:	2300      	movs	r3, #0
 8007fd0:	633b      	str	r3, [r7, #48]	; 0x30
        /* Search through the list to find the highest priority thread.  */
        do
        {

            /* Is the current thread higher priority?  */
            if (thread_ptr -> tx_thread_priority < priority_thread_ptr -> tx_thread_priority)
 8007fd2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8007fd4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8007fd6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007fd8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007fda:	429a      	cmp	r2, r3
 8007fdc:	d201      	bcs.n	8007fe2 <_tx_byte_pool_prioritize+0x8e>
            {

                /* Yes, remember that this thread is the highest priority.  */
                priority_thread_ptr =  thread_ptr;
 8007fde:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8007fe0:	63fb      	str	r3, [r7, #60]	; 0x3c
 8007fe2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007fe4:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8007fe6:	68fb      	ldr	r3, [r7, #12]
 8007fe8:	f383 8810 	msr	PRIMASK, r3
}
 8007fec:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8007fee:	f3ef 8310 	mrs	r3, PRIMASK
 8007ff2:	617b      	str	r3, [r7, #20]
    return(posture);
 8007ff4:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 8007ff6:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 8007ff8:	b672      	cpsid	i
    return(int_posture);
 8007ffa:	693b      	ldr	r3, [r7, #16]

            /* Restore interrupts temporarily.  */
            TX_RESTORE

            /* Disable interrupts again.  */
            TX_DISABLE
 8007ffc:	647b      	str	r3, [r7, #68]	; 0x44

            /* Determine if any changes to the list have occurred while
               interrupts were enabled.  */

            /* Is the list head the same?  */
            if (head_ptr != pool_ptr -> tx_byte_pool_suspension_list)
 8007ffe:	687b      	ldr	r3, [r7, #4]
 8008000:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008002:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8008004:	429a      	cmp	r2, r3
 8008006:	d002      	beq.n	800800e <_tx_byte_pool_prioritize+0xba>
            {

                /* The list head has changed, set the list changed flag.  */
                list_changed =  TX_TRUE;
 8008008:	2301      	movs	r3, #1
 800800a:	633b      	str	r3, [r7, #48]	; 0x30
 800800c:	e006      	b.n	800801c <_tx_byte_pool_prioritize+0xc8>
            }
            else
            {

                /* Is the suspended count the same?  */
                if (suspended_count != pool_ptr -> tx_byte_pool_suspended_count)
 800800e:	687b      	ldr	r3, [r7, #4]
 8008010:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008012:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8008014:	429a      	cmp	r2, r3
 8008016:	d001      	beq.n	800801c <_tx_byte_pool_prioritize+0xc8>
                {

                    /* The list head has changed, set the list changed flag.  */
                    list_changed =  TX_TRUE;
 8008018:	2301      	movs	r3, #1
 800801a:	633b      	str	r3, [r7, #48]	; 0x30
                }
            }

            /* Determine if the list has changed.  */
            if (list_changed == TX_FALSE)
 800801c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800801e:	2b00      	cmp	r3, #0
 8008020:	d103      	bne.n	800802a <_tx_byte_pool_prioritize+0xd6>
            {

                /* Move the thread pointer to the next thread.  */
                thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 8008022:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008024:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008026:	643b      	str	r3, [r7, #64]	; 0x40
 8008028:	e00c      	b.n	8008044 <_tx_byte_pool_prioritize+0xf0>
            }
            else
            {

                /* Remember the suspension count and head pointer.  */
                head_ptr =   pool_ptr -> tx_byte_pool_suspension_list;
 800802a:	687b      	ldr	r3, [r7, #4]
 800802c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800802e:	63bb      	str	r3, [r7, #56]	; 0x38
                suspended_count =  pool_ptr -> tx_byte_pool_suspended_count;
 8008030:	687b      	ldr	r3, [r7, #4]
 8008032:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008034:	637b      	str	r3, [r7, #52]	; 0x34

                /* Default the highest priority thread to the thread at the front of the list.  */
                priority_thread_ptr =  head_ptr;
 8008036:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008038:	63fb      	str	r3, [r7, #60]	; 0x3c

                /* Setup search pointer.  */
                thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
 800803a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800803c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800803e:	643b      	str	r3, [r7, #64]	; 0x40

                /* Reset the list changed flag.  */
                list_changed =  TX_FALSE;
 8008040:	2300      	movs	r3, #0
 8008042:	633b      	str	r3, [r7, #48]	; 0x30
            }

        } while (thread_ptr != head_ptr);
 8008044:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8008046:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008048:	429a      	cmp	r2, r3
 800804a:	d1c2      	bne.n	8007fd2 <_tx_byte_pool_prioritize+0x7e>

        /* Release preemption.  */
        _tx_thread_preempt_disable--;
 800804c:	4b19      	ldr	r3, [pc, #100]	; (80080b4 <_tx_byte_pool_prioritize+0x160>)
 800804e:	681b      	ldr	r3, [r3, #0]
 8008050:	3b01      	subs	r3, #1
 8008052:	4a18      	ldr	r2, [pc, #96]	; (80080b4 <_tx_byte_pool_prioritize+0x160>)
 8008054:	6013      	str	r3, [r2, #0]

        /* Now determine if the highest priority thread is at the front
           of the list.  */
        if (priority_thread_ptr != head_ptr)
 8008056:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8008058:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800805a:	429a      	cmp	r2, r3
 800805c:	d01d      	beq.n	800809a <_tx_byte_pool_prioritize+0x146>
            /* No, we need to move the highest priority suspended thread to the
               front of the list.  */

            /* First, remove the highest priority thread by updating the
               adjacent suspended threads.  */
            next_thread =                                  priority_thread_ptr -> tx_thread_suspended_next;
 800805e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008060:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008062:	62fb      	str	r3, [r7, #44]	; 0x2c
            previous_thread =                              priority_thread_ptr -> tx_thread_suspended_previous;
 8008064:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008066:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8008068:	62bb      	str	r3, [r7, #40]	; 0x28
            next_thread -> tx_thread_suspended_previous =  previous_thread;
 800806a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800806c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800806e:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =  next_thread;
 8008070:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008072:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8008074:	671a      	str	r2, [r3, #112]	; 0x70

            /* Now, link the highest priority thread at the front of the list.  */
            previous_thread =                                      head_ptr -> tx_thread_suspended_previous;
 8008076:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008078:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800807a:	62bb      	str	r3, [r7, #40]	; 0x28
            priority_thread_ptr -> tx_thread_suspended_next =      head_ptr;
 800807c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800807e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8008080:	671a      	str	r2, [r3, #112]	; 0x70
            priority_thread_ptr -> tx_thread_suspended_previous =  previous_thread;
 8008082:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008084:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8008086:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =          priority_thread_ptr;
 8008088:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800808a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800808c:	671a      	str	r2, [r3, #112]	; 0x70
            head_ptr -> tx_thread_suspended_previous =             priority_thread_ptr;
 800808e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008090:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8008092:	675a      	str	r2, [r3, #116]	; 0x74

            /* Move the list head pointer to the highest priority suspended thread.  */
            pool_ptr -> tx_byte_pool_suspension_list =  priority_thread_ptr;
 8008094:	687b      	ldr	r3, [r7, #4]
 8008096:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8008098:	625a      	str	r2, [r3, #36]	; 0x24
 800809a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800809c:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800809e:	68bb      	ldr	r3, [r7, #8]
 80080a0:	f383 8810 	msr	PRIMASK, r3
}
 80080a4:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 80080a6:	f004 f987 	bl	800c3b8 <_tx_thread_system_preempt_check>
    }

    /* Return completion status.  */
    return(TX_SUCCESS);
 80080aa:	2300      	movs	r3, #0
}
 80080ac:	4618      	mov	r0, r3
 80080ae:	3748      	adds	r7, #72	; 0x48
 80080b0:	46bd      	mov	sp, r7
 80080b2:	bd80      	pop	{r7, pc}
 80080b4:	2000f054 	.word	0x2000f054

080080b8 <_tx_byte_pool_search>:
/*                                            calculation,                */
/*                                            resulting in version 6.1.7  */
/*                                                                        */
/**************************************************************************/
UCHAR  *_tx_byte_pool_search(TX_BYTE_POOL *pool_ptr, ULONG memory_size)
{
 80080b8:	b480      	push	{r7}
 80080ba:	b097      	sub	sp, #92	; 0x5c
 80080bc:	af00      	add	r7, sp, #0
 80080be:	6078      	str	r0, [r7, #4]
 80080c0:	6039      	str	r1, [r7, #0]
UCHAR           *next_ptr;
UCHAR           **this_block_link_ptr;
UCHAR           **next_block_link_ptr;
ULONG           available_bytes;
UINT            examine_blocks;
UINT            first_free_block_found =  TX_FALSE;
 80080c2:	2300      	movs	r3, #0
 80080c4:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80080c6:	f3ef 8310 	mrs	r3, PRIMASK
 80080ca:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 80080cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 80080ce:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 80080d0:	b672      	cpsid	i
    return(int_posture);
 80080d2:	6a3b      	ldr	r3, [r7, #32]
UCHAR           *work_ptr;
ULONG           total_theoretical_available;


    /* Disable interrupts.  */
    TX_DISABLE
 80080d4:	657b      	str	r3, [r7, #84]	; 0x54

    /* First, determine if there are enough bytes in the pool.  */
    /* Theoretical bytes available = free bytes + ((fragments-2) * overhead of each block) */
    total_theoretical_available = pool_ptr -> tx_byte_pool_available + ((pool_ptr -> tx_byte_pool_fragments - 2) * ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE))));
 80080d6:	687b      	ldr	r3, [r7, #4]
 80080d8:	689a      	ldr	r2, [r3, #8]
 80080da:	687b      	ldr	r3, [r7, #4]
 80080dc:	68db      	ldr	r3, [r3, #12]
 80080de:	3b02      	subs	r3, #2
 80080e0:	00db      	lsls	r3, r3, #3
 80080e2:	4413      	add	r3, r2
 80080e4:	643b      	str	r3, [r7, #64]	; 0x40
    if (memory_size >= total_theoretical_available)
 80080e6:	683a      	ldr	r2, [r7, #0]
 80080e8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80080ea:	429a      	cmp	r2, r3
 80080ec:	d308      	bcc.n	8008100 <_tx_byte_pool_search+0x48>
 80080ee:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80080f0:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80080f2:	69fb      	ldr	r3, [r7, #28]
 80080f4:	f383 8810 	msr	PRIMASK, r3
}
 80080f8:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Not enough memory, return a NULL pointer.  */
        current_ptr =  TX_NULL;
 80080fa:	2300      	movs	r3, #0
 80080fc:	653b      	str	r3, [r7, #80]	; 0x50
 80080fe:	e0dd      	b.n	80082bc <_tx_byte_pool_search+0x204>
    }
    else
    {

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 8008100:	4b72      	ldr	r3, [pc, #456]	; (80082cc <_tx_byte_pool_search+0x214>)
 8008102:	681b      	ldr	r3, [r3, #0]
 8008104:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Setup ownership of the byte pool.  */
        pool_ptr -> tx_byte_pool_owner =  thread_ptr;
 8008106:	687b      	ldr	r3, [r7, #4]
 8008108:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800810a:	621a      	str	r2, [r3, #32]

        /* Walk through the memory pool in search for a large enough block.  */
        current_ptr =      pool_ptr -> tx_byte_pool_search;
 800810c:	687b      	ldr	r3, [r7, #4]
 800810e:	695b      	ldr	r3, [r3, #20]
 8008110:	653b      	str	r3, [r7, #80]	; 0x50
        examine_blocks =   pool_ptr -> tx_byte_pool_fragments + ((UINT) 1);
 8008112:	687b      	ldr	r3, [r7, #4]
 8008114:	68db      	ldr	r3, [r3, #12]
 8008116:	3301      	adds	r3, #1
 8008118:	64bb      	str	r3, [r7, #72]	; 0x48
        available_bytes =  ((ULONG) 0);
 800811a:	2300      	movs	r3, #0
 800811c:	64fb      	str	r3, [r7, #76]	; 0x4c
            /* Increment the number of fragments searched on this pool.  */
            pool_ptr -> tx_byte_pool_performance_search_count++;
#endif

            /* Check to see if this block is free.  */
            work_ptr =  TX_UCHAR_POINTER_ADD(current_ptr, (sizeof(UCHAR *)));
 800811e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8008120:	3304      	adds	r3, #4
 8008122:	63bb      	str	r3, [r7, #56]	; 0x38
            free_ptr =  TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
 8008124:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008126:	637b      	str	r3, [r7, #52]	; 0x34
            if ((*free_ptr) == TX_BYTE_BLOCK_FREE)
 8008128:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800812a:	681b      	ldr	r3, [r3, #0]
 800812c:	4a68      	ldr	r2, [pc, #416]	; (80082d0 <_tx_byte_pool_search+0x218>)
 800812e:	4293      	cmp	r3, r2
 8008130:	d143      	bne.n	80081ba <_tx_byte_pool_search+0x102>
            {

                /* Determine if this is the first free block.  */
                if (first_free_block_found == TX_FALSE)
 8008132:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008134:	2b00      	cmp	r3, #0
 8008136:	d104      	bne.n	8008142 <_tx_byte_pool_search+0x8a>
                {
                    /* This is the first free block.  */
                    pool_ptr->tx_byte_pool_search =  current_ptr;
 8008138:	687b      	ldr	r3, [r7, #4]
 800813a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800813c:	615a      	str	r2, [r3, #20]

                    /* Set the flag to indicate we have found the first free
                       block.  */
                    first_free_block_found =  TX_TRUE;
 800813e:	2301      	movs	r3, #1
 8008140:	647b      	str	r3, [r7, #68]	; 0x44
                }

                /* Block is free, see if it is large enough.  */

                /* Pickup the next block's pointer.  */
                this_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
 8008142:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8008144:	633b      	str	r3, [r7, #48]	; 0x30
                next_ptr =             *this_block_link_ptr;
 8008146:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008148:	681b      	ldr	r3, [r3, #0]
 800814a:	62fb      	str	r3, [r7, #44]	; 0x2c

                /* Calculate the number of bytes available in this block.  */
                available_bytes =   TX_UCHAR_POINTER_DIF(next_ptr, current_ptr);
 800814c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800814e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8008150:	1ad3      	subs	r3, r2, r3
 8008152:	64fb      	str	r3, [r7, #76]	; 0x4c
                available_bytes =   available_bytes - ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)));
 8008154:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8008156:	3b08      	subs	r3, #8
 8008158:	64fb      	str	r3, [r7, #76]	; 0x4c

                /* If this is large enough, we are done because our first-fit algorithm
                   has been satisfied!  */
                if (available_bytes >= memory_size)
 800815a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800815c:	683b      	ldr	r3, [r7, #0]
 800815e:	429a      	cmp	r2, r3
 8008160:	d257      	bcs.n	8008212 <_tx_byte_pool_search+0x15a>
                }
                else
                {

                    /* Clear the available bytes variable.  */
                    available_bytes =  ((ULONG) 0);
 8008162:	2300      	movs	r3, #0
 8008164:	64fb      	str	r3, [r7, #76]	; 0x4c

                    /* Not enough memory, check to see if the neighbor is
                       free and can be merged.  */
                    work_ptr =  TX_UCHAR_POINTER_ADD(next_ptr, (sizeof(UCHAR *)));
 8008166:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008168:	3304      	adds	r3, #4
 800816a:	63bb      	str	r3, [r7, #56]	; 0x38
                    free_ptr =  TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
 800816c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800816e:	637b      	str	r3, [r7, #52]	; 0x34
                    if ((*free_ptr) == TX_BYTE_BLOCK_FREE)
 8008170:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008172:	681b      	ldr	r3, [r3, #0]
 8008174:	4a56      	ldr	r2, [pc, #344]	; (80082d0 <_tx_byte_pool_search+0x218>)
 8008176:	4293      	cmp	r3, r2
 8008178:	d113      	bne.n	80081a2 <_tx_byte_pool_search+0xea>
                    {

                        /* Yes, neighbor block can be merged!  This is quickly accomplished
                           by updating the current block with the next blocks pointer.  */
                        next_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
 800817a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800817c:	62bb      	str	r3, [r7, #40]	; 0x28
                        *this_block_link_ptr =  *next_block_link_ptr;
 800817e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008180:	681a      	ldr	r2, [r3, #0]
 8008182:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008184:	601a      	str	r2, [r3, #0]

                        /* Reduce the fragment total.  We don't need to increase the bytes
                           available because all free headers are also included in the available
                           count.  */
                        pool_ptr -> tx_byte_pool_fragments--;
 8008186:	687b      	ldr	r3, [r7, #4]
 8008188:	68db      	ldr	r3, [r3, #12]
 800818a:	1e5a      	subs	r2, r3, #1
 800818c:	687b      	ldr	r3, [r7, #4]
 800818e:	60da      	str	r2, [r3, #12]
                        /* Increment the number of blocks merged on this pool.  */
                        pool_ptr -> tx_byte_pool_performance_merge_count++;
#endif

                        /* See if the search pointer is affected.  */
                        if (pool_ptr -> tx_byte_pool_search ==  next_ptr)
 8008190:	687b      	ldr	r3, [r7, #4]
 8008192:	695b      	ldr	r3, [r3, #20]
 8008194:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8008196:	429a      	cmp	r2, r3
 8008198:	d114      	bne.n	80081c4 <_tx_byte_pool_search+0x10c>
                        {
                            /* Yes, update the search pointer.   */
                            pool_ptr -> tx_byte_pool_search =  current_ptr;
 800819a:	687b      	ldr	r3, [r7, #4]
 800819c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800819e:	615a      	str	r2, [r3, #20]
 80081a0:	e010      	b.n	80081c4 <_tx_byte_pool_search+0x10c>
                        }
                    }
                    else
                    {
                        /* Neighbor is not free so we can skip over it!  */
                        next_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
 80081a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80081a4:	62bb      	str	r3, [r7, #40]	; 0x28
                        current_ptr =  *next_block_link_ptr;
 80081a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80081a8:	681b      	ldr	r3, [r3, #0]
 80081aa:	653b      	str	r3, [r7, #80]	; 0x50

                        /* Decrement the examined block count to account for this one.  */
                        if (examine_blocks != ((UINT) 0))
 80081ac:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80081ae:	2b00      	cmp	r3, #0
 80081b0:	d008      	beq.n	80081c4 <_tx_byte_pool_search+0x10c>
                        {
                            examine_blocks--;
 80081b2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80081b4:	3b01      	subs	r3, #1
 80081b6:	64bb      	str	r3, [r7, #72]	; 0x48
 80081b8:	e004      	b.n	80081c4 <_tx_byte_pool_search+0x10c>
            }
            else
            {

                /* Block is not free, move to next block.  */
                this_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
 80081ba:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80081bc:	633b      	str	r3, [r7, #48]	; 0x30
                current_ptr =  *this_block_link_ptr;
 80081be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80081c0:	681b      	ldr	r3, [r3, #0]
 80081c2:	653b      	str	r3, [r7, #80]	; 0x50
            }

            /* Another block has been searched... decrement counter.  */
            if (examine_blocks != ((UINT) 0))
 80081c4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80081c6:	2b00      	cmp	r3, #0
 80081c8:	d002      	beq.n	80081d0 <_tx_byte_pool_search+0x118>
            {

                examine_blocks--;
 80081ca:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80081cc:	3b01      	subs	r3, #1
 80081ce:	64bb      	str	r3, [r7, #72]	; 0x48
 80081d0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80081d2:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80081d4:	693b      	ldr	r3, [r7, #16]
 80081d6:	f383 8810 	msr	PRIMASK, r3
}
 80081da:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80081dc:	f3ef 8310 	mrs	r3, PRIMASK
 80081e0:	61bb      	str	r3, [r7, #24]
    return(posture);
 80081e2:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 80081e4:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 80081e6:	b672      	cpsid	i
    return(int_posture);
 80081e8:	697b      	ldr	r3, [r7, #20]

            /* Restore interrupts temporarily.  */
            TX_RESTORE

            /* Disable interrupts.  */
            TX_DISABLE
 80081ea:	657b      	str	r3, [r7, #84]	; 0x54

            /* Determine if anything has changed in terms of pool ownership.  */
            if (pool_ptr -> tx_byte_pool_owner != thread_ptr)
 80081ec:	687b      	ldr	r3, [r7, #4]
 80081ee:	6a1b      	ldr	r3, [r3, #32]
 80081f0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80081f2:	429a      	cmp	r2, r3
 80081f4:	d009      	beq.n	800820a <_tx_byte_pool_search+0x152>
            {

                /* Pool changed ownership in the brief period interrupts were
                   enabled.  Reset the search.  */
                current_ptr =      pool_ptr -> tx_byte_pool_search;
 80081f6:	687b      	ldr	r3, [r7, #4]
 80081f8:	695b      	ldr	r3, [r3, #20]
 80081fa:	653b      	str	r3, [r7, #80]	; 0x50
                examine_blocks =   pool_ptr -> tx_byte_pool_fragments + ((UINT) 1);
 80081fc:	687b      	ldr	r3, [r7, #4]
 80081fe:	68db      	ldr	r3, [r3, #12]
 8008200:	3301      	adds	r3, #1
 8008202:	64bb      	str	r3, [r7, #72]	; 0x48

                /* Setup our ownership again.  */
                pool_ptr -> tx_byte_pool_owner =  thread_ptr;
 8008204:	687b      	ldr	r3, [r7, #4]
 8008206:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8008208:	621a      	str	r2, [r3, #32]
            }
        } while(examine_blocks != ((UINT) 0));
 800820a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800820c:	2b00      	cmp	r3, #0
 800820e:	d186      	bne.n	800811e <_tx_byte_pool_search+0x66>
 8008210:	e000      	b.n	8008214 <_tx_byte_pool_search+0x15c>
                    break;
 8008212:	bf00      	nop

        /* Determine if a block was found.  If so, determine if it needs to be
           split.  */
        if (available_bytes != ((ULONG) 0))
 8008214:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8008216:	2b00      	cmp	r3, #0
 8008218:	d048      	beq.n	80082ac <_tx_byte_pool_search+0x1f4>
        {

            /* Determine if we need to split this block.  */
            if ((available_bytes - memory_size) >= ((ULONG) TX_BYTE_BLOCK_MIN))
 800821a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800821c:	683b      	ldr	r3, [r7, #0]
 800821e:	1ad3      	subs	r3, r2, r3
 8008220:	2b13      	cmp	r3, #19
 8008222:	d91e      	bls.n	8008262 <_tx_byte_pool_search+0x1aa>
            {

                /* Split the block.  */
                next_ptr =  TX_UCHAR_POINTER_ADD(current_ptr, (memory_size + ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)))));
 8008224:	683b      	ldr	r3, [r7, #0]
 8008226:	3308      	adds	r3, #8
 8008228:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800822a:	4413      	add	r3, r2
 800822c:	62fb      	str	r3, [r7, #44]	; 0x2c

                /* Setup the new free block.  */
                next_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
 800822e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008230:	62bb      	str	r3, [r7, #40]	; 0x28
                this_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
 8008232:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8008234:	633b      	str	r3, [r7, #48]	; 0x30
                *next_block_link_ptr =  *this_block_link_ptr;
 8008236:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008238:	681a      	ldr	r2, [r3, #0]
 800823a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800823c:	601a      	str	r2, [r3, #0]
                work_ptr =              TX_UCHAR_POINTER_ADD(next_ptr, (sizeof(UCHAR *)));
 800823e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008240:	3304      	adds	r3, #4
 8008242:	63bb      	str	r3, [r7, #56]	; 0x38
                free_ptr =              TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
 8008244:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008246:	637b      	str	r3, [r7, #52]	; 0x34
                *free_ptr =             TX_BYTE_BLOCK_FREE;
 8008248:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800824a:	4a21      	ldr	r2, [pc, #132]	; (80082d0 <_tx_byte_pool_search+0x218>)
 800824c:	601a      	str	r2, [r3, #0]

                /* Increase the total fragment counter.  */
                pool_ptr -> tx_byte_pool_fragments++;
 800824e:	687b      	ldr	r3, [r7, #4]
 8008250:	68db      	ldr	r3, [r3, #12]
 8008252:	1c5a      	adds	r2, r3, #1
 8008254:	687b      	ldr	r3, [r7, #4]
 8008256:	60da      	str	r2, [r3, #12]

                /* Update the current pointer to point at the newly created block.  */
                *this_block_link_ptr =  next_ptr;
 8008258:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800825a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800825c:	601a      	str	r2, [r3, #0]

                /* Set available equal to memory size for subsequent calculation.  */
                available_bytes =  memory_size;
 800825e:	683b      	ldr	r3, [r7, #0]
 8008260:	64fb      	str	r3, [r7, #76]	; 0x4c
                pool_ptr -> tx_byte_pool_performance_split_count++;
#endif
            }

            /* In any case, mark the current block as allocated.  */
            work_ptr =              TX_UCHAR_POINTER_ADD(current_ptr, (sizeof(UCHAR *)));
 8008262:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8008264:	3304      	adds	r3, #4
 8008266:	63bb      	str	r3, [r7, #56]	; 0x38
            this_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
 8008268:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800826a:	633b      	str	r3, [r7, #48]	; 0x30
            *this_block_link_ptr =  TX_BYTE_POOL_TO_UCHAR_POINTER_CONVERT(pool_ptr);
 800826c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800826e:	687a      	ldr	r2, [r7, #4]
 8008270:	601a      	str	r2, [r3, #0]

            /* Reduce the number of available bytes in the pool.  */
            pool_ptr -> tx_byte_pool_available =  (pool_ptr -> tx_byte_pool_available - available_bytes) - ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)));
 8008272:	687b      	ldr	r3, [r7, #4]
 8008274:	689a      	ldr	r2, [r3, #8]
 8008276:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8008278:	1ad3      	subs	r3, r2, r3
 800827a:	f1a3 0208 	sub.w	r2, r3, #8
 800827e:	687b      	ldr	r3, [r7, #4]
 8008280:	609a      	str	r2, [r3, #8]

            /* Determine if the search pointer needs to be updated. This is only done
               if the search pointer matches the block to be returned.  */
            if (current_ptr == pool_ptr -> tx_byte_pool_search)
 8008282:	687b      	ldr	r3, [r7, #4]
 8008284:	695b      	ldr	r3, [r3, #20]
 8008286:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8008288:	429a      	cmp	r2, r3
 800828a:	d105      	bne.n	8008298 <_tx_byte_pool_search+0x1e0>
            {

                /* Yes, update the search pointer to the next block.  */
                this_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
 800828c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800828e:	633b      	str	r3, [r7, #48]	; 0x30
                pool_ptr -> tx_byte_pool_search =  *this_block_link_ptr;
 8008290:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008292:	681a      	ldr	r2, [r3, #0]
 8008294:	687b      	ldr	r3, [r7, #4]
 8008296:	615a      	str	r2, [r3, #20]
 8008298:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800829a:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800829c:	68fb      	ldr	r3, [r7, #12]
 800829e:	f383 8810 	msr	PRIMASK, r3
}
 80082a2:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Adjust the pointer for the application.  */
            current_ptr =  TX_UCHAR_POINTER_ADD(current_ptr, (((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)))));
 80082a4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80082a6:	3308      	adds	r3, #8
 80082a8:	653b      	str	r3, [r7, #80]	; 0x50
 80082aa:	e007      	b.n	80082bc <_tx_byte_pool_search+0x204>
 80082ac:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80082ae:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80082b0:	68bb      	ldr	r3, [r7, #8]
 80082b2:	f383 8810 	msr	PRIMASK, r3
}
 80082b6:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Set current pointer to NULL to indicate nothing was found.  */
            current_ptr =  TX_NULL;
 80082b8:	2300      	movs	r3, #0
 80082ba:	653b      	str	r3, [r7, #80]	; 0x50
        }
    }

    /* Return the search pointer.  */
    return(current_ptr);
 80082bc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
}
 80082be:	4618      	mov	r0, r3
 80082c0:	375c      	adds	r7, #92	; 0x5c
 80082c2:	46bd      	mov	sp, r7
 80082c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80082c8:	4770      	bx	lr
 80082ca:	bf00      	nop
 80082cc:	2000efb8 	.word	0x2000efb8
 80082d0:	ffffeeee 	.word	0xffffeeee

080082d4 <_tx_byte_release>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_byte_release(VOID *memory_ptr)
{
 80082d4:	b580      	push	{r7, lr}
 80082d6:	b09e      	sub	sp, #120	; 0x78
 80082d8:	af00      	add	r7, sp, #0
 80082da:	6078      	str	r0, [r7, #4]
UCHAR               **block_link_ptr;
UCHAR               **suspend_info_ptr;


    /* Default to successful status.  */
    status =  TX_SUCCESS;
 80082dc:	2300      	movs	r3, #0
 80082de:	673b      	str	r3, [r7, #112]	; 0x70

    /* Set the pool pointer to NULL.  */
    pool_ptr =  TX_NULL;
 80082e0:	2300      	movs	r3, #0
 80082e2:	66fb      	str	r3, [r7, #108]	; 0x6c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80082e4:	f3ef 8310 	mrs	r3, PRIMASK
 80082e8:	637b      	str	r3, [r7, #52]	; 0x34
    return(posture);
 80082ea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    int_posture = __get_interrupt_posture();
 80082ec:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("CPSID i" : : : "memory");
 80082ee:	b672      	cpsid	i
    return(int_posture);
 80082f0:	6b3b      	ldr	r3, [r7, #48]	; 0x30

    /* Lockout interrupts.  */
    TX_DISABLE
 80082f2:	677b      	str	r3, [r7, #116]	; 0x74

    /* Determine if the memory pointer is valid.  */
    work_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(memory_ptr);
 80082f4:	687b      	ldr	r3, [r7, #4]
 80082f6:	66bb      	str	r3, [r7, #104]	; 0x68
    if (work_ptr != TX_NULL)
 80082f8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80082fa:	2b00      	cmp	r3, #0
 80082fc:	d027      	beq.n	800834e <_tx_byte_release+0x7a>
    {

        /* Back off the memory pointer to pickup its header.  */
        work_ptr =  TX_UCHAR_POINTER_SUB(work_ptr, ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE))));
 80082fe:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8008300:	3b08      	subs	r3, #8
 8008302:	66bb      	str	r3, [r7, #104]	; 0x68

        /* There is a pointer, pickup the pool pointer address.  */
        temp_ptr =  TX_UCHAR_POINTER_ADD(work_ptr, (sizeof(UCHAR *)));
 8008304:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8008306:	3304      	adds	r3, #4
 8008308:	667b      	str	r3, [r7, #100]	; 0x64
        free_ptr =  TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(temp_ptr);
 800830a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800830c:	663b      	str	r3, [r7, #96]	; 0x60
        if ((*free_ptr) != TX_BYTE_BLOCK_FREE)
 800830e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8008310:	681b      	ldr	r3, [r3, #0]
 8008312:	4a7e      	ldr	r2, [pc, #504]	; (800850c <_tx_byte_release+0x238>)
 8008314:	4293      	cmp	r3, r2
 8008316:	d017      	beq.n	8008348 <_tx_byte_release+0x74>
        {

            /* Pickup the pool pointer.  */
            temp_ptr =  TX_UCHAR_POINTER_ADD(work_ptr, (sizeof(UCHAR *)));
 8008318:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800831a:	3304      	adds	r3, #4
 800831c:	667b      	str	r3, [r7, #100]	; 0x64
            byte_pool_ptr =  TX_UCHAR_TO_INDIRECT_BYTE_POOL_POINTER(temp_ptr);
 800831e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8008320:	65fb      	str	r3, [r7, #92]	; 0x5c
            pool_ptr =  *byte_pool_ptr;
 8008322:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8008324:	681b      	ldr	r3, [r3, #0]
 8008326:	66fb      	str	r3, [r7, #108]	; 0x6c

            /* See if we have a valid pool pointer.  */
            if (pool_ptr == TX_NULL)
 8008328:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800832a:	2b00      	cmp	r3, #0
 800832c:	d102      	bne.n	8008334 <_tx_byte_release+0x60>
            {

                /* Return pointer error.  */
                status =  TX_PTR_ERROR;
 800832e:	2303      	movs	r3, #3
 8008330:	673b      	str	r3, [r7, #112]	; 0x70
 8008332:	e00e      	b.n	8008352 <_tx_byte_release+0x7e>
            }
            else
            {

                /* See if we have a valid pool.  */
                if (pool_ptr -> tx_byte_pool_id != TX_BYTE_POOL_ID)
 8008334:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8008336:	681b      	ldr	r3, [r3, #0]
 8008338:	4a75      	ldr	r2, [pc, #468]	; (8008510 <_tx_byte_release+0x23c>)
 800833a:	4293      	cmp	r3, r2
 800833c:	d009      	beq.n	8008352 <_tx_byte_release+0x7e>
                {

                    /* Return pointer error.  */
                    status =  TX_PTR_ERROR;
 800833e:	2303      	movs	r3, #3
 8008340:	673b      	str	r3, [r7, #112]	; 0x70

                    /* Reset the pool pointer is NULL.  */
                    pool_ptr =  TX_NULL;
 8008342:	2300      	movs	r3, #0
 8008344:	66fb      	str	r3, [r7, #108]	; 0x6c
 8008346:	e004      	b.n	8008352 <_tx_byte_release+0x7e>
        }
        else
        {

            /* Return pointer error.  */
            status =  TX_PTR_ERROR;
 8008348:	2303      	movs	r3, #3
 800834a:	673b      	str	r3, [r7, #112]	; 0x70
 800834c:	e001      	b.n	8008352 <_tx_byte_release+0x7e>
    }
    else
    {

        /* Return pointer error.  */
        status =  TX_PTR_ERROR;
 800834e:	2303      	movs	r3, #3
 8008350:	673b      	str	r3, [r7, #112]	; 0x70
    }

    /* Determine if the pointer is valid.  */
    if (pool_ptr == TX_NULL)
 8008352:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8008354:	2b00      	cmp	r3, #0
 8008356:	d105      	bne.n	8008364 <_tx_byte_release+0x90>
 8008358:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800835a:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800835c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800835e:	f383 8810 	msr	PRIMASK, r3
}
 8008362:	e0cd      	b.n	8008500 <_tx_byte_release+0x22c>
    {

        /* At this point, we know that the pointer is valid.  */

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 8008364:	4b6b      	ldr	r3, [pc, #428]	; (8008514 <_tx_byte_release+0x240>)
 8008366:	681b      	ldr	r3, [r3, #0]
 8008368:	65bb      	str	r3, [r7, #88]	; 0x58

        /* Indicate that this thread is the current owner.  */
        pool_ptr -> tx_byte_pool_owner =  thread_ptr;
 800836a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800836c:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800836e:	621a      	str	r2, [r3, #32]

        /* Log this kernel call.  */
        TX_EL_BYTE_RELEASE_INSERT

        /* Release the memory.  */
        temp_ptr =   TX_UCHAR_POINTER_ADD(work_ptr, (sizeof(UCHAR *)));
 8008370:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8008372:	3304      	adds	r3, #4
 8008374:	667b      	str	r3, [r7, #100]	; 0x64
        free_ptr =   TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(temp_ptr);
 8008376:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8008378:	663b      	str	r3, [r7, #96]	; 0x60
        *free_ptr =  TX_BYTE_BLOCK_FREE;
 800837a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800837c:	4a63      	ldr	r2, [pc, #396]	; (800850c <_tx_byte_release+0x238>)
 800837e:	601a      	str	r2, [r3, #0]

        /* Update the number of available bytes in the pool.  */
        block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
 8008380:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8008382:	657b      	str	r3, [r7, #84]	; 0x54
        next_block_ptr =  *block_link_ptr;
 8008384:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8008386:	681b      	ldr	r3, [r3, #0]
 8008388:	653b      	str	r3, [r7, #80]	; 0x50
        pool_ptr -> tx_byte_pool_available =
            pool_ptr -> tx_byte_pool_available + TX_UCHAR_POINTER_DIF(next_block_ptr, work_ptr);
 800838a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800838c:	689b      	ldr	r3, [r3, #8]
 800838e:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8008390:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8008392:	1a8a      	subs	r2, r1, r2
 8008394:	441a      	add	r2, r3
        pool_ptr -> tx_byte_pool_available =
 8008396:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8008398:	609a      	str	r2, [r3, #8]

        /* Determine if the free block is prior to current search pointer.  */
        if (work_ptr < (pool_ptr -> tx_byte_pool_search))
 800839a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800839c:	695b      	ldr	r3, [r3, #20]
 800839e:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80083a0:	429a      	cmp	r2, r3
 80083a2:	d202      	bcs.n	80083aa <_tx_byte_release+0xd6>
        {

            /* Yes, update the search pointer to the released block.  */
            pool_ptr -> tx_byte_pool_search =  work_ptr;
 80083a4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80083a6:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80083a8:	615a      	str	r2, [r3, #20]
        }

        /* Determine if there are threads suspended on this byte pool.  */
        if (pool_ptr -> tx_byte_pool_suspended_count != TX_NO_SUSPENSIONS)
 80083aa:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80083ac:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80083ae:	2b00      	cmp	r3, #0
 80083b0:	f000 80a0 	beq.w	80084f4 <_tx_byte_release+0x220>
        {

            /* Now examine the suspension list to find threads waiting for
               memory.  Maybe it is now available!  */
            while (pool_ptr -> tx_byte_pool_suspended_count != TX_NO_SUSPENSIONS)
 80083b4:	e08e      	b.n	80084d4 <_tx_byte_release+0x200>
            {

                /* Pickup the first suspended thread pointer.  */
                susp_thread_ptr =  pool_ptr -> tx_byte_pool_suspension_list;
 80083b6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80083b8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80083ba:	64fb      	str	r3, [r7, #76]	; 0x4c

                /* Pickup the size of the memory the thread is requesting.  */
                memory_size =  susp_thread_ptr -> tx_thread_suspend_info;
 80083bc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80083be:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80083c0:	64bb      	str	r3, [r7, #72]	; 0x48
 80083c2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80083c4:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80083c6:	6a3b      	ldr	r3, [r7, #32]
 80083c8:	f383 8810 	msr	PRIMASK, r3
}
 80083cc:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* See if the request can be satisfied.  */
                work_ptr =  _tx_byte_pool_search(pool_ptr, memory_size);
 80083ce:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 80083d0:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 80083d2:	f7ff fe71 	bl	80080b8 <_tx_byte_pool_search>
 80083d6:	66b8      	str	r0, [r7, #104]	; 0x68
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80083d8:	f3ef 8310 	mrs	r3, PRIMASK
 80083dc:	62bb      	str	r3, [r7, #40]	; 0x28
    return(posture);
 80083de:	6abb      	ldr	r3, [r7, #40]	; 0x28
    int_posture = __get_interrupt_posture();
 80083e0:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
 80083e2:	b672      	cpsid	i
    return(int_posture);
 80083e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24

                /* Optional processing extension.  */
                TX_BYTE_RELEASE_EXTENSION

                /* Disable interrupts.  */
                TX_DISABLE
 80083e6:	677b      	str	r3, [r7, #116]	; 0x74

                /* Indicate that this thread is the current owner.  */
                pool_ptr -> tx_byte_pool_owner =  thread_ptr;
 80083e8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80083ea:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80083ec:	621a      	str	r2, [r3, #32]

                /* If there is not enough memory, break this loop!  */
                if (work_ptr == TX_NULL)
 80083ee:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80083f0:	2b00      	cmp	r3, #0
 80083f2:	d075      	beq.n	80084e0 <_tx_byte_release+0x20c>
                  /* Break out of the loop.  */
                    break;
                }

                /* Check to make sure the thread is still suspended.  */
                if (susp_thread_ptr ==  pool_ptr -> tx_byte_pool_suspension_list)
 80083f4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80083f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80083f8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80083fa:	429a      	cmp	r2, r3
 80083fc:	d147      	bne.n	800848e <_tx_byte_release+0x1ba>
                {

                    /* Also, makes sure the memory size is the same.  */
                    if (susp_thread_ptr -> tx_thread_suspend_info == memory_size)
 80083fe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8008400:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8008402:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8008404:	429a      	cmp	r2, r3
 8008406:	d142      	bne.n	800848e <_tx_byte_release+0x1ba>
                    {

                        /* Remove the suspended thread from the list.  */

                        /* Decrement the number of threads suspended.  */
                        pool_ptr -> tx_byte_pool_suspended_count--;
 8008408:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800840a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800840c:	1e5a      	subs	r2, r3, #1
 800840e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8008410:	629a      	str	r2, [r3, #40]	; 0x28

                        /* Pickup the suspended count.  */
                        suspended_count =  pool_ptr -> tx_byte_pool_suspended_count;
 8008412:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8008414:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008416:	647b      	str	r3, [r7, #68]	; 0x44

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
 8008418:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800841a:	2b00      	cmp	r3, #0
 800841c:	d103      	bne.n	8008426 <_tx_byte_release+0x152>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            pool_ptr -> tx_byte_pool_suspension_list =  TX_NULL;
 800841e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8008420:	2200      	movs	r2, #0
 8008422:	625a      	str	r2, [r3, #36]	; 0x24
 8008424:	e00e      	b.n	8008444 <_tx_byte_release+0x170>
                        {

                            /* At least one more thread is on the same expiration list.  */

                            /* Update the list head pointer.  */
                            next_thread =                                susp_thread_ptr -> tx_thread_suspended_next;
 8008426:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8008428:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800842a:	643b      	str	r3, [r7, #64]	; 0x40
                            pool_ptr -> tx_byte_pool_suspension_list =   next_thread;
 800842c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800842e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8008430:	625a      	str	r2, [r3, #36]	; 0x24

                            /* Update the links of the adjacent threads.  */
                            previous_thread =                              susp_thread_ptr -> tx_thread_suspended_previous;
 8008432:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8008434:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8008436:	63fb      	str	r3, [r7, #60]	; 0x3c
                            next_thread -> tx_thread_suspended_previous =  previous_thread;
 8008438:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800843a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800843c:	675a      	str	r2, [r3, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =  next_thread;
 800843e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008440:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8008442:	671a      	str	r2, [r3, #112]	; 0x70
                        }

                        /* Prepare for resumption of the thread.  */

                        /* Clear cleanup routine to avoid timeout.  */
                        susp_thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8008444:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8008446:	2200      	movs	r2, #0
 8008448:	669a      	str	r2, [r3, #104]	; 0x68

                        /* Return this block pointer to the suspended thread waiting for
                           a block.  */
                        suspend_info_ptr =   TX_VOID_TO_INDIRECT_UCHAR_POINTER_CONVERT(susp_thread_ptr -> tx_thread_additional_suspend_info);
 800844a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800844c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800844e:	63bb      	str	r3, [r7, #56]	; 0x38
                        *suspend_info_ptr =  work_ptr;
 8008450:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008452:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8008454:	601a      	str	r2, [r3, #0]

                        /* Clear the memory pointer to indicate that it was given to the suspended thread.  */
                        work_ptr =  TX_NULL;
 8008456:	2300      	movs	r3, #0
 8008458:	66bb      	str	r3, [r7, #104]	; 0x68

                        /* Put return status into the thread control block.  */
                        susp_thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 800845a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800845c:	2200      	movs	r2, #0
 800845e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

                        /* Restore interrupts.  */
                        TX_RESTORE
#else
                        /* Temporarily disable preemption.  */
                        _tx_thread_preempt_disable++;
 8008462:	4b2d      	ldr	r3, [pc, #180]	; (8008518 <_tx_byte_release+0x244>)
 8008464:	681b      	ldr	r3, [r3, #0]
 8008466:	3301      	adds	r3, #1
 8008468:	4a2b      	ldr	r2, [pc, #172]	; (8008518 <_tx_byte_release+0x244>)
 800846a:	6013      	str	r3, [r2, #0]
 800846c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800846e:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8008470:	697b      	ldr	r3, [r7, #20]
 8008472:	f383 8810 	msr	PRIMASK, r3
}
 8008476:	bf00      	nop

                        /* Restore interrupts.  */
                        TX_RESTORE

                        /* Resume thread.  */
                        _tx_thread_system_resume(susp_thread_ptr);
 8008478:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800847a:	f003 ffd7 	bl	800c42c <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800847e:	f3ef 8310 	mrs	r3, PRIMASK
 8008482:	61fb      	str	r3, [r7, #28]
    return(posture);
 8008484:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 8008486:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8008488:	b672      	cpsid	i
    return(int_posture);
 800848a:	69bb      	ldr	r3, [r7, #24]
#endif

                        /* Lockout interrupts.  */
                        TX_DISABLE
 800848c:	677b      	str	r3, [r7, #116]	; 0x74
                    }
                }

                /* Determine if the memory was given to the suspended thread.  */
                if (work_ptr != TX_NULL)
 800848e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8008490:	2b00      	cmp	r3, #0
 8008492:	d01f      	beq.n	80084d4 <_tx_byte_release+0x200>

                    /* No, it wasn't given to the suspended thread.  */

                    /* Put the memory back on the available list since this thread is no longer
                       suspended.  */
                    work_ptr =  TX_UCHAR_POINTER_SUB(work_ptr, (((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)))));
 8008494:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8008496:	3b08      	subs	r3, #8
 8008498:	66bb      	str	r3, [r7, #104]	; 0x68
                    temp_ptr =  TX_UCHAR_POINTER_ADD(work_ptr, (sizeof(UCHAR *)));
 800849a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800849c:	3304      	adds	r3, #4
 800849e:	667b      	str	r3, [r7, #100]	; 0x64
                    free_ptr =  TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(temp_ptr);
 80084a0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80084a2:	663b      	str	r3, [r7, #96]	; 0x60
                    *free_ptr =  TX_BYTE_BLOCK_FREE;
 80084a4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80084a6:	4a19      	ldr	r2, [pc, #100]	; (800850c <_tx_byte_release+0x238>)
 80084a8:	601a      	str	r2, [r3, #0]

                    /* Update the number of available bytes in the pool.  */
                    block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
 80084aa:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80084ac:	657b      	str	r3, [r7, #84]	; 0x54
                    next_block_ptr =  *block_link_ptr;
 80084ae:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80084b0:	681b      	ldr	r3, [r3, #0]
 80084b2:	653b      	str	r3, [r7, #80]	; 0x50
                    pool_ptr -> tx_byte_pool_available =
                        pool_ptr -> tx_byte_pool_available + TX_UCHAR_POINTER_DIF(next_block_ptr, work_ptr);
 80084b4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80084b6:	689b      	ldr	r3, [r3, #8]
 80084b8:	6d39      	ldr	r1, [r7, #80]	; 0x50
 80084ba:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80084bc:	1a8a      	subs	r2, r1, r2
 80084be:	441a      	add	r2, r3
                    pool_ptr -> tx_byte_pool_available =
 80084c0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80084c2:	609a      	str	r2, [r3, #8]

                    /* Determine if the current pointer is before the search pointer.  */
                    if (work_ptr < (pool_ptr -> tx_byte_pool_search))
 80084c4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80084c6:	695b      	ldr	r3, [r3, #20]
 80084c8:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80084ca:	429a      	cmp	r2, r3
 80084cc:	d202      	bcs.n	80084d4 <_tx_byte_release+0x200>
                    {

                        /* Yes, update the search pointer.  */
                        pool_ptr -> tx_byte_pool_search =  work_ptr;
 80084ce:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80084d0:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80084d2:	615a      	str	r2, [r3, #20]
            while (pool_ptr -> tx_byte_pool_suspended_count != TX_NO_SUSPENSIONS)
 80084d4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80084d6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80084d8:	2b00      	cmp	r3, #0
 80084da:	f47f af6c 	bne.w	80083b6 <_tx_byte_release+0xe2>
 80084de:	e000      	b.n	80084e2 <_tx_byte_release+0x20e>
                    break;
 80084e0:	bf00      	nop
 80084e2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80084e4:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80084e6:	693b      	ldr	r3, [r7, #16]
 80084e8:	f383 8810 	msr	PRIMASK, r3
}
 80084ec:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Check for preemption.  */
            _tx_thread_system_preempt_check();
 80084ee:	f003 ff63 	bl	800c3b8 <_tx_thread_system_preempt_check>
 80084f2:	e005      	b.n	8008500 <_tx_byte_release+0x22c>
 80084f4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80084f6:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80084f8:	68fb      	ldr	r3, [r7, #12]
 80084fa:	f383 8810 	msr	PRIMASK, r3
}
 80084fe:	bf00      	nop
            TX_RESTORE
        }
    }

    /* Return completion status.  */
    return(status);
 8008500:	6f3b      	ldr	r3, [r7, #112]	; 0x70
}
 8008502:	4618      	mov	r0, r3
 8008504:	3778      	adds	r7, #120	; 0x78
 8008506:	46bd      	mov	sp, r7
 8008508:	bd80      	pop	{r7, pc}
 800850a:	bf00      	nop
 800850c:	ffffeeee 	.word	0xffffeeee
 8008510:	42595445 	.word	0x42595445
 8008514:	2000efb8 	.word	0x2000efb8
 8008518:	2000f054 	.word	0x2000f054

0800851c <_tx_event_flags_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_event_flags_cleanup(TX_THREAD  *thread_ptr, ULONG suspension_sequence)
{
 800851c:	b580      	push	{r7, lr}
 800851e:	b08e      	sub	sp, #56	; 0x38
 8008520:	af00      	add	r7, sp, #0
 8008522:	6078      	str	r0, [r7, #4]
 8008524:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8008526:	f3ef 8310 	mrs	r3, PRIMASK
 800852a:	61fb      	str	r3, [r7, #28]
    return(posture);
 800852c:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800852e:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8008530:	b672      	cpsid	i
    return(int_posture);
 8008532:	69bb      	ldr	r3, [r7, #24]


#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the event flags group.  */
    TX_DISABLE
 8008534:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_event_flags_cleanup))
 8008536:	687b      	ldr	r3, [r7, #4]
 8008538:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800853a:	4a38      	ldr	r2, [pc, #224]	; (800861c <_tx_event_flags_cleanup+0x100>)
 800853c:	4293      	cmp	r3, r2
 800853e:	d162      	bne.n	8008606 <_tx_event_flags_cleanup+0xea>
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
 8008540:	687b      	ldr	r3, [r7, #4]
 8008542:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 8008546:	683a      	ldr	r2, [r7, #0]
 8008548:	429a      	cmp	r2, r3
 800854a:	d15c      	bne.n	8008606 <_tx_event_flags_cleanup+0xea>
        {

            /* Setup pointer to event flags control block.  */
            group_ptr =  TX_VOID_TO_EVENT_FLAGS_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
 800854c:	687b      	ldr	r3, [r7, #4]
 800854e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008550:	633b      	str	r3, [r7, #48]	; 0x30

            /* Check for a NULL event flags control block pointer.  */
            if (group_ptr != TX_NULL)
 8008552:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008554:	2b00      	cmp	r3, #0
 8008556:	d056      	beq.n	8008606 <_tx_event_flags_cleanup+0xea>
            {

                /* Is the group pointer ID valid?  */
                if (group_ptr -> tx_event_flags_group_id == TX_EVENT_FLAGS_ID)
 8008558:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800855a:	681b      	ldr	r3, [r3, #0]
 800855c:	4a30      	ldr	r2, [pc, #192]	; (8008620 <_tx_event_flags_cleanup+0x104>)
 800855e:	4293      	cmp	r3, r2
 8008560:	d151      	bne.n	8008606 <_tx_event_flags_cleanup+0xea>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
 8008562:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008564:	695b      	ldr	r3, [r3, #20]
 8008566:	2b00      	cmp	r3, #0
 8008568:	d04d      	beq.n	8008606 <_tx_event_flags_cleanup+0xea>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800856a:	687b      	ldr	r3, [r7, #4]
 800856c:	2200      	movs	r2, #0
 800856e:	669a      	str	r2, [r3, #104]	; 0x68

                        /* Pickup the suspended count.  */
                        suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
 8008570:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008572:	695b      	ldr	r3, [r3, #20]
 8008574:	62fb      	str	r3, [r7, #44]	; 0x2c

                        /* Pickup the suspension head.  */
                        suspension_head =  group_ptr -> tx_event_flags_group_suspension_list;
 8008576:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008578:	691b      	ldr	r3, [r3, #16]
 800857a:	62bb      	str	r3, [r7, #40]	; 0x28

                        /* Determine if the cleanup is being done while a set operation was interrupted.  If the
                           suspended count is non-zero and the suspension head is NULL, the list is being processed
                           and cannot be touched from here. The suspension list removal will instead take place
                           inside the event flag set code.  */
                        if (suspension_head != TX_NULL)
 800857c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800857e:	2b00      	cmp	r3, #0
 8008580:	d020      	beq.n	80085c4 <_tx_event_flags_cleanup+0xa8>
                        {

                            /* Remove the suspended thread from the list.  */

                            /* Decrement the local suspension count.  */
                            suspended_count--;
 8008582:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008584:	3b01      	subs	r3, #1
 8008586:	62fb      	str	r3, [r7, #44]	; 0x2c

                            /* Store the updated suspended count.  */
                            group_ptr -> tx_event_flags_group_suspended_count =  suspended_count;
 8008588:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800858a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800858c:	615a      	str	r2, [r3, #20]

                            /* See if this is the only suspended thread on the list.  */
                            if (suspended_count == TX_NO_SUSPENSIONS)
 800858e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008590:	2b00      	cmp	r3, #0
 8008592:	d103      	bne.n	800859c <_tx_event_flags_cleanup+0x80>
                            {

                                /* Yes, the only suspended thread.  */

                                /* Update the head pointer.  */
                                group_ptr -> tx_event_flags_group_suspension_list =  TX_NULL;
 8008594:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008596:	2200      	movs	r2, #0
 8008598:	611a      	str	r2, [r3, #16]
 800859a:	e016      	b.n	80085ca <_tx_event_flags_cleanup+0xae>
                            {

                                /* At least one more thread is on the same suspension list.  */

                                /* Update the links of the adjacent threads.  */
                                next_thread =                                  thread_ptr -> tx_thread_suspended_next;
 800859c:	687b      	ldr	r3, [r7, #4]
 800859e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80085a0:	627b      	str	r3, [r7, #36]	; 0x24
                                previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
 80085a2:	687b      	ldr	r3, [r7, #4]
 80085a4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80085a6:	623b      	str	r3, [r7, #32]
                                next_thread -> tx_thread_suspended_previous =  previous_thread;
 80085a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80085aa:	6a3a      	ldr	r2, [r7, #32]
 80085ac:	675a      	str	r2, [r3, #116]	; 0x74
                                previous_thread -> tx_thread_suspended_next =  next_thread;
 80085ae:	6a3b      	ldr	r3, [r7, #32]
 80085b0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80085b2:	671a      	str	r2, [r3, #112]	; 0x70

                                /* Determine if we need to update the head pointer.  */
                                if (suspension_head == thread_ptr)
 80085b4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80085b6:	687b      	ldr	r3, [r7, #4]
 80085b8:	429a      	cmp	r2, r3
 80085ba:	d106      	bne.n	80085ca <_tx_event_flags_cleanup+0xae>
                                {

                                    /* Update the list head pointer.  */
                                    group_ptr -> tx_event_flags_group_suspension_list =  next_thread;
 80085bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80085be:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80085c0:	611a      	str	r2, [r3, #16]
 80085c2:	e002      	b.n	80085ca <_tx_event_flags_cleanup+0xae>
                        }
                        else
                        {

                            /* In this case, the search pointer in an interrupted event flag set must be reset.  */
                            group_ptr -> tx_event_flags_group_reset_search =  TX_TRUE;
 80085c4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80085c6:	2201      	movs	r2, #1
 80085c8:	60da      	str	r2, [r3, #12]
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_EVENT_FLAG)
 80085ca:	687b      	ldr	r3, [r7, #4]
 80085cc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80085ce:	2b07      	cmp	r3, #7
 80085d0:	d119      	bne.n	8008606 <_tx_event_flags_cleanup+0xea>
                            /* Increment the number of timeouts on this event flags group.  */
                            group_ptr -> tx_event_flags_group____performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_EVENTS;
 80085d2:	687b      	ldr	r3, [r7, #4]
 80085d4:	2207      	movs	r2, #7
 80085d6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                           /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 80085da:	4b12      	ldr	r3, [pc, #72]	; (8008624 <_tx_event_flags_cleanup+0x108>)
 80085dc:	681b      	ldr	r3, [r3, #0]
 80085de:	3301      	adds	r3, #1
 80085e0:	4a10      	ldr	r2, [pc, #64]	; (8008624 <_tx_event_flags_cleanup+0x108>)
 80085e2:	6013      	str	r3, [r2, #0]
 80085e4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80085e6:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80085e8:	68fb      	ldr	r3, [r7, #12]
 80085ea:	f383 8810 	msr	PRIMASK, r3
}
 80085ee:	bf00      	nop
                            TX_RESTORE

                            /* Resume the thread!  Check for preemption even though we are executing
                               from the system timer thread right now which normally executes at the
                               highest priority.  */
                            _tx_thread_system_resume(thread_ptr);
 80085f0:	6878      	ldr	r0, [r7, #4]
 80085f2:	f003 ff1b 	bl	800c42c <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80085f6:	f3ef 8310 	mrs	r3, PRIMASK
 80085fa:	617b      	str	r3, [r7, #20]
    return(posture);
 80085fc:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 80085fe:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 8008600:	b672      	cpsid	i
    return(int_posture);
 8008602:	693b      	ldr	r3, [r7, #16]

                            /* Disable interrupts.  */
                            TX_DISABLE
 8008604:	637b      	str	r3, [r7, #52]	; 0x34
 8008606:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008608:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800860a:	68bb      	ldr	r3, [r7, #8]
 800860c:	f383 8810 	msr	PRIMASK, r3
}
 8008610:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 8008612:	bf00      	nop
 8008614:	3738      	adds	r7, #56	; 0x38
 8008616:	46bd      	mov	sp, r7
 8008618:	bd80      	pop	{r7, pc}
 800861a:	bf00      	nop
 800861c:	0800851d 	.word	0x0800851d
 8008620:	4456444e 	.word	0x4456444e
 8008624:	2000f054 	.word	0x2000f054

08008628 <_tx_event_flags_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_create(TX_EVENT_FLAGS_GROUP *group_ptr, CHAR *name_ptr)
{
 8008628:	b580      	push	{r7, lr}
 800862a:	b088      	sub	sp, #32
 800862c:	af00      	add	r7, sp, #0
 800862e:	6078      	str	r0, [r7, #4]
 8008630:	6039      	str	r1, [r7, #0]
TX_EVENT_FLAGS_GROUP    *next_group;
TX_EVENT_FLAGS_GROUP    *previous_group;


    /* Initialize event flags control block to all zeros.  */
    TX_MEMSET(group_ptr, 0, (sizeof(TX_EVENT_FLAGS_GROUP)));
 8008632:	2230      	movs	r2, #48	; 0x30
 8008634:	2100      	movs	r1, #0
 8008636:	6878      	ldr	r0, [r7, #4]
 8008638:	f00e f9d4 	bl	80169e4 <memset>

    /* Setup the basic event flags group fields.  */
    group_ptr -> tx_event_flags_group_name =             name_ptr;
 800863c:	687b      	ldr	r3, [r7, #4]
 800863e:	683a      	ldr	r2, [r7, #0]
 8008640:	605a      	str	r2, [r3, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8008642:	f3ef 8310 	mrs	r3, PRIMASK
 8008646:	613b      	str	r3, [r7, #16]
    return(posture);
 8008648:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 800864a:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 800864c:	b672      	cpsid	i
    return(int_posture);
 800864e:	68fb      	ldr	r3, [r7, #12]

    /* Disable interrupts to put the event flags group on the created list.  */
    TX_DISABLE
 8008650:	61fb      	str	r3, [r7, #28]

    /* Setup the event flags ID to make it valid.  */
    group_ptr -> tx_event_flags_group_id =  TX_EVENT_FLAGS_ID;
 8008652:	687b      	ldr	r3, [r7, #4]
 8008654:	4a18      	ldr	r2, [pc, #96]	; (80086b8 <_tx_event_flags_create+0x90>)
 8008656:	601a      	str	r2, [r3, #0]

    /* Place the group on the list of created event flag groups.  First,
       check for an empty list.  */
    if (_tx_event_flags_created_count == TX_EMPTY)
 8008658:	4b18      	ldr	r3, [pc, #96]	; (80086bc <_tx_event_flags_create+0x94>)
 800865a:	681b      	ldr	r3, [r3, #0]
 800865c:	2b00      	cmp	r3, #0
 800865e:	d109      	bne.n	8008674 <_tx_event_flags_create+0x4c>
    {

        /* The created event flags list is empty.  Add event flag group to empty list.  */
        _tx_event_flags_created_ptr =                         group_ptr;
 8008660:	4a17      	ldr	r2, [pc, #92]	; (80086c0 <_tx_event_flags_create+0x98>)
 8008662:	687b      	ldr	r3, [r7, #4]
 8008664:	6013      	str	r3, [r2, #0]
        group_ptr -> tx_event_flags_group_created_next =      group_ptr;
 8008666:	687b      	ldr	r3, [r7, #4]
 8008668:	687a      	ldr	r2, [r7, #4]
 800866a:	619a      	str	r2, [r3, #24]
        group_ptr -> tx_event_flags_group_created_previous =  group_ptr;
 800866c:	687b      	ldr	r3, [r7, #4]
 800866e:	687a      	ldr	r2, [r7, #4]
 8008670:	61da      	str	r2, [r3, #28]
 8008672:	e011      	b.n	8008698 <_tx_event_flags_create+0x70>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_group =      _tx_event_flags_created_ptr;
 8008674:	4b12      	ldr	r3, [pc, #72]	; (80086c0 <_tx_event_flags_create+0x98>)
 8008676:	681b      	ldr	r3, [r3, #0]
 8008678:	61bb      	str	r3, [r7, #24]
        previous_group =  next_group -> tx_event_flags_group_created_previous;
 800867a:	69bb      	ldr	r3, [r7, #24]
 800867c:	69db      	ldr	r3, [r3, #28]
 800867e:	617b      	str	r3, [r7, #20]

        /* Place the new event flag group in the list.  */
        next_group -> tx_event_flags_group_created_previous =  group_ptr;
 8008680:	69bb      	ldr	r3, [r7, #24]
 8008682:	687a      	ldr	r2, [r7, #4]
 8008684:	61da      	str	r2, [r3, #28]
        previous_group -> tx_event_flags_group_created_next =  group_ptr;
 8008686:	697b      	ldr	r3, [r7, #20]
 8008688:	687a      	ldr	r2, [r7, #4]
 800868a:	619a      	str	r2, [r3, #24]

        /* Setup this group's created links.  */
        group_ptr -> tx_event_flags_group_created_previous =  previous_group;
 800868c:	687b      	ldr	r3, [r7, #4]
 800868e:	697a      	ldr	r2, [r7, #20]
 8008690:	61da      	str	r2, [r3, #28]
        group_ptr -> tx_event_flags_group_created_next =      next_group;
 8008692:	687b      	ldr	r3, [r7, #4]
 8008694:	69ba      	ldr	r2, [r7, #24]
 8008696:	619a      	str	r2, [r3, #24]
    }

    /* Increment the number of created event flag groups.  */
    _tx_event_flags_created_count++;
 8008698:	4b08      	ldr	r3, [pc, #32]	; (80086bc <_tx_event_flags_create+0x94>)
 800869a:	681b      	ldr	r3, [r3, #0]
 800869c:	3301      	adds	r3, #1
 800869e:	4a07      	ldr	r2, [pc, #28]	; (80086bc <_tx_event_flags_create+0x94>)
 80086a0:	6013      	str	r3, [r2, #0]
 80086a2:	69fb      	ldr	r3, [r7, #28]
 80086a4:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80086a6:	68bb      	ldr	r3, [r7, #8]
 80086a8:	f383 8810 	msr	PRIMASK, r3
}
 80086ac:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 80086ae:	2300      	movs	r3, #0
}
 80086b0:	4618      	mov	r0, r3
 80086b2:	3720      	adds	r7, #32
 80086b4:	46bd      	mov	sp, r7
 80086b6:	bd80      	pop	{r7, pc}
 80086b8:	4456444e 	.word	0x4456444e
 80086bc:	2000ef94 	.word	0x2000ef94
 80086c0:	2000ef90 	.word	0x2000ef90

080086c4 <_tx_event_flags_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_delete(TX_EVENT_FLAGS_GROUP *group_ptr)
{
 80086c4:	b580      	push	{r7, lr}
 80086c6:	b092      	sub	sp, #72	; 0x48
 80086c8:	af00      	add	r7, sp, #0
 80086ca:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80086cc:	f3ef 8310 	mrs	r3, PRIMASK
 80086d0:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 80086d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 80086d4:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 80086d6:	b672      	cpsid	i
    return(int_posture);
 80086d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
TX_EVENT_FLAGS_GROUP    *next_group;
TX_EVENT_FLAGS_GROUP    *previous_group;


    /* Disable interrupts to remove the group from the created list.  */
    TX_DISABLE
 80086da:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Log this kernel call.  */
    TX_EL_EVENT_FLAGS_DELETE_INSERT

    /* Clear the event flag group ID to make it invalid.  */
    group_ptr -> tx_event_flags_group_id =  TX_CLEAR_ID;
 80086dc:	687b      	ldr	r3, [r7, #4]
 80086de:	2200      	movs	r2, #0
 80086e0:	601a      	str	r2, [r3, #0]

    /* Decrement the number of created event flag groups.  */
    _tx_event_flags_created_count--;
 80086e2:	4b3d      	ldr	r3, [pc, #244]	; (80087d8 <_tx_event_flags_delete+0x114>)
 80086e4:	681b      	ldr	r3, [r3, #0]
 80086e6:	3b01      	subs	r3, #1
 80086e8:	4a3b      	ldr	r2, [pc, #236]	; (80087d8 <_tx_event_flags_delete+0x114>)
 80086ea:	6013      	str	r3, [r2, #0]

    /* See if this group is the only one on the list.  */
    if (_tx_event_flags_created_count == TX_EMPTY)
 80086ec:	4b3a      	ldr	r3, [pc, #232]	; (80087d8 <_tx_event_flags_delete+0x114>)
 80086ee:	681b      	ldr	r3, [r3, #0]
 80086f0:	2b00      	cmp	r3, #0
 80086f2:	d103      	bne.n	80086fc <_tx_event_flags_delete+0x38>
    {

        /* Only created event flag group, just set the created list to NULL.  */
        _tx_event_flags_created_ptr =  TX_NULL;
 80086f4:	4b39      	ldr	r3, [pc, #228]	; (80087dc <_tx_event_flags_delete+0x118>)
 80086f6:	2200      	movs	r2, #0
 80086f8:	601a      	str	r2, [r3, #0]
 80086fa:	e013      	b.n	8008724 <_tx_event_flags_delete+0x60>
    }
    else
    {

        /* Link-up the neighbors.  */
        next_group =                                           group_ptr -> tx_event_flags_group_created_next;
 80086fc:	687b      	ldr	r3, [r7, #4]
 80086fe:	699b      	ldr	r3, [r3, #24]
 8008700:	63bb      	str	r3, [r7, #56]	; 0x38
        previous_group =                                       group_ptr -> tx_event_flags_group_created_previous;
 8008702:	687b      	ldr	r3, [r7, #4]
 8008704:	69db      	ldr	r3, [r3, #28]
 8008706:	637b      	str	r3, [r7, #52]	; 0x34
        next_group -> tx_event_flags_group_created_previous =  previous_group;
 8008708:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800870a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800870c:	61da      	str	r2, [r3, #28]
        previous_group -> tx_event_flags_group_created_next =  next_group;
 800870e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008710:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8008712:	619a      	str	r2, [r3, #24]

        /* See if we have to update the created list head pointer.  */
        if (_tx_event_flags_created_ptr == group_ptr)
 8008714:	4b31      	ldr	r3, [pc, #196]	; (80087dc <_tx_event_flags_delete+0x118>)
 8008716:	681b      	ldr	r3, [r3, #0]
 8008718:	687a      	ldr	r2, [r7, #4]
 800871a:	429a      	cmp	r2, r3
 800871c:	d102      	bne.n	8008724 <_tx_event_flags_delete+0x60>
        {

            /* Yes, move the head pointer to the next link. */
            _tx_event_flags_created_ptr =  next_group;
 800871e:	4a2f      	ldr	r2, [pc, #188]	; (80087dc <_tx_event_flags_delete+0x118>)
 8008720:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008722:	6013      	str	r3, [r2, #0]
        }
    }

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 8008724:	4b2e      	ldr	r3, [pc, #184]	; (80087e0 <_tx_event_flags_delete+0x11c>)
 8008726:	681b      	ldr	r3, [r3, #0]
 8008728:	3301      	adds	r3, #1
 800872a:	4a2d      	ldr	r2, [pc, #180]	; (80087e0 <_tx_event_flags_delete+0x11c>)
 800872c:	6013      	str	r3, [r2, #0]

    /* Pickup the suspension information.  */
    thread_ptr =                                         group_ptr -> tx_event_flags_group_suspension_list;
 800872e:	687b      	ldr	r3, [r7, #4]
 8008730:	691b      	ldr	r3, [r3, #16]
 8008732:	647b      	str	r3, [r7, #68]	; 0x44
    group_ptr -> tx_event_flags_group_suspension_list =  TX_NULL;
 8008734:	687b      	ldr	r3, [r7, #4]
 8008736:	2200      	movs	r2, #0
 8008738:	611a      	str	r2, [r3, #16]
    suspended_count =                                    group_ptr -> tx_event_flags_group_suspended_count;
 800873a:	687b      	ldr	r3, [r7, #4]
 800873c:	695b      	ldr	r3, [r3, #20]
 800873e:	643b      	str	r3, [r7, #64]	; 0x40
    group_ptr -> tx_event_flags_group_suspended_count =  TX_NO_SUSPENSIONS;
 8008740:	687b      	ldr	r3, [r7, #4]
 8008742:	2200      	movs	r2, #0
 8008744:	615a      	str	r2, [r3, #20]
 8008746:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008748:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800874a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800874c:	f383 8810 	msr	PRIMASK, r3
}
 8008750:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the event flag suspension list to resume any and all threads
       suspended on this group.  */
    while (suspended_count != TX_NO_SUSPENSIONS)
 8008752:	e024      	b.n	800879e <_tx_event_flags_delete+0xda>
    {

        /* Decrement the number of suspended threads.  */
        suspended_count--;
 8008754:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008756:	3b01      	subs	r3, #1
 8008758:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800875a:	f3ef 8310 	mrs	r3, PRIMASK
 800875e:	61fb      	str	r3, [r7, #28]
    return(posture);
 8008760:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 8008762:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8008764:	b672      	cpsid	i
    return(int_posture);
 8008766:	69bb      	ldr	r3, [r7, #24]

        /* Lockout interrupts.  */
        TX_DISABLE
 8008768:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Clear the cleanup pointer, this prevents the timeout from doing
           anything.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800876a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800876c:	2200      	movs	r2, #0
 800876e:	669a      	str	r2, [r3, #104]	; 0x68

        /* Set the return status in the thread to TX_DELETED.  */
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
 8008770:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008772:	2201      	movs	r2, #1
 8008774:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Move the thread pointer ahead.  */
        next_thread =  thread_ptr -> tx_thread_suspended_next;
 8008778:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800877a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800877c:	633b      	str	r3, [r7, #48]	; 0x30
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption again.  */
        _tx_thread_preempt_disable++;
 800877e:	4b18      	ldr	r3, [pc, #96]	; (80087e0 <_tx_event_flags_delete+0x11c>)
 8008780:	681b      	ldr	r3, [r3, #0]
 8008782:	3301      	adds	r3, #1
 8008784:	4a16      	ldr	r2, [pc, #88]	; (80087e0 <_tx_event_flags_delete+0x11c>)
 8008786:	6013      	str	r3, [r2, #0]
 8008788:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800878a:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800878c:	6a3b      	ldr	r3, [r7, #32]
 800878e:	f383 8810 	msr	PRIMASK, r3
}
 8008792:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
 8008794:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8008796:	f003 fe49 	bl	800c42c <_tx_thread_system_resume>
#endif

        /* Move to next thread.  */
        thread_ptr =  next_thread;
 800879a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800879c:	647b      	str	r3, [r7, #68]	; 0x44
    while (suspended_count != TX_NO_SUSPENSIONS)
 800879e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80087a0:	2b00      	cmp	r3, #0
 80087a2:	d1d7      	bne.n	8008754 <_tx_event_flags_delete+0x90>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80087a4:	f3ef 8310 	mrs	r3, PRIMASK
 80087a8:	613b      	str	r3, [r7, #16]
    return(posture);
 80087aa:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 80087ac:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 80087ae:	b672      	cpsid	i
    return(int_posture);
 80087b0:	68fb      	ldr	r3, [r7, #12]

    /* Execute Port-Specific completion processing. If needed, it is typically defined in tx_port.h.  */
    TX_EVENT_FLAGS_GROUP_DELETE_PORT_COMPLETION(group_ptr)

    /* Disable interrupts.  */
    TX_DISABLE
 80087b2:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Release previous preempt disable.  */
    _tx_thread_preempt_disable--;
 80087b4:	4b0a      	ldr	r3, [pc, #40]	; (80087e0 <_tx_event_flags_delete+0x11c>)
 80087b6:	681b      	ldr	r3, [r3, #0]
 80087b8:	3b01      	subs	r3, #1
 80087ba:	4a09      	ldr	r2, [pc, #36]	; (80087e0 <_tx_event_flags_delete+0x11c>)
 80087bc:	6013      	str	r3, [r2, #0]
 80087be:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80087c0:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80087c2:	697b      	ldr	r3, [r7, #20]
 80087c4:	f383 8810 	msr	PRIMASK, r3
}
 80087c8:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 80087ca:	f003 fdf5 	bl	800c3b8 <_tx_thread_system_preempt_check>

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 80087ce:	2300      	movs	r3, #0
}
 80087d0:	4618      	mov	r0, r3
 80087d2:	3748      	adds	r7, #72	; 0x48
 80087d4:	46bd      	mov	sp, r7
 80087d6:	bd80      	pop	{r7, pc}
 80087d8:	2000ef94 	.word	0x2000ef94
 80087dc:	2000ef90 	.word	0x2000ef90
 80087e0:	2000f054 	.word	0x2000f054

080087e4 <_tx_event_flags_get>:
/*                                            resulting in version 6.2.0  */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_get(TX_EVENT_FLAGS_GROUP *group_ptr, ULONG requested_flags,
                    UINT get_option, ULONG *actual_flags_ptr, ULONG wait_option)
{
 80087e4:	b580      	push	{r7, lr}
 80087e6:	b096      	sub	sp, #88	; 0x58
 80087e8:	af00      	add	r7, sp, #0
 80087ea:	60f8      	str	r0, [r7, #12]
 80087ec:	60b9      	str	r1, [r7, #8]
 80087ee:	607a      	str	r2, [r7, #4]
 80087f0:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80087f2:	f3ef 8310 	mrs	r3, PRIMASK
 80087f6:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 80087f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 80087fa:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 80087fc:	b672      	cpsid	i
    return(int_posture);
 80087fe:	6a3b      	ldr	r3, [r7, #32]
UINT            interrupted_set_request;
#endif


    /* Disable interrupts to examine the event flags group.  */
    TX_DISABLE
 8008800:	657b      	str	r3, [r7, #84]	; 0x54

    /* Log this kernel call.  */
    TX_EL_EVENT_FLAGS_GET_INSERT

    /* Pickup current flags.  */
    current_flags =  group_ptr -> tx_event_flags_group_current;
 8008802:	68fb      	ldr	r3, [r7, #12]
 8008804:	689b      	ldr	r3, [r3, #8]
 8008806:	64fb      	str	r3, [r7, #76]	; 0x4c

    /* Return the actual event flags and apply delayed clearing.  */
    *actual_flags_ptr =  current_flags & ~group_ptr -> tx_event_flags_group_delayed_clear;
 8008808:	68fb      	ldr	r3, [r7, #12]
 800880a:	6a1b      	ldr	r3, [r3, #32]
 800880c:	43da      	mvns	r2, r3
 800880e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8008810:	401a      	ands	r2, r3
 8008812:	683b      	ldr	r3, [r7, #0]
 8008814:	601a      	str	r2, [r3, #0]

    /* Apply the event flag option mask.  */
    and_request =  (get_option & TX_AND);
 8008816:	687b      	ldr	r3, [r7, #4]
 8008818:	f003 0302 	and.w	r3, r3, #2
 800881c:	643b      	str	r3, [r7, #64]	; 0x40
    }

#else

    /* Pickup delayed clear flags.  */
    delayed_clear_flags =  group_ptr -> tx_event_flags_group_delayed_clear;
 800881e:	68fb      	ldr	r3, [r7, #12]
 8008820:	6a1b      	ldr	r3, [r3, #32]
 8008822:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Determine if there are any delayed clear operations pending.  */
    if (delayed_clear_flags != ((ULONG) 0))
 8008824:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008826:	2b00      	cmp	r3, #0
 8008828:	d004      	beq.n	8008834 <_tx_event_flags_get+0x50>
    {

        /* Yes, apply them to the current flags.  */
        current_flags =  current_flags & (~delayed_clear_flags);
 800882a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800882c:	43db      	mvns	r3, r3
 800882e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8008830:	4013      	ands	r3, r2
 8008832:	64fb      	str	r3, [r7, #76]	; 0x4c
    }

    /* Check for AND condition. All flags must be present to satisfy request.  */
    if (and_request == TX_AND)
 8008834:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008836:	2b02      	cmp	r3, #2
 8008838:	d10a      	bne.n	8008850 <_tx_event_flags_get+0x6c>
    {

        /* AND request is present.  */

        /* Calculate the flags present.  */
        flags_satisfied =  (current_flags & requested_flags);
 800883a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800883c:	68bb      	ldr	r3, [r7, #8]
 800883e:	4013      	ands	r3, r2
 8008840:	64bb      	str	r3, [r7, #72]	; 0x48

        /* Determine if they satisfy the AND request.  */
        if (flags_satisfied != requested_flags)
 8008842:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8008844:	68bb      	ldr	r3, [r7, #8]
 8008846:	429a      	cmp	r2, r3
 8008848:	d006      	beq.n	8008858 <_tx_event_flags_get+0x74>
        {

            /* No, not all the requested flags are present. Clear the flags present variable.  */
            flags_satisfied =  ((ULONG) 0);
 800884a:	2300      	movs	r3, #0
 800884c:	64bb      	str	r3, [r7, #72]	; 0x48
 800884e:	e003      	b.n	8008858 <_tx_event_flags_get+0x74>
    else
    {

        /* OR request is present. Simply AND together the requested flags and the current flags
           to see if any are present.  */
        flags_satisfied =  (current_flags & requested_flags);
 8008850:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8008852:	68bb      	ldr	r3, [r7, #8]
 8008854:	4013      	ands	r3, r2
 8008856:	64bb      	str	r3, [r7, #72]	; 0x48
    }

    /* Determine if the request is satisfied.  */
    if (flags_satisfied != ((ULONG) 0))
 8008858:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800885a:	2b00      	cmp	r3, #0
 800885c:	d026      	beq.n	80088ac <_tx_event_flags_get+0xc8>
    {

        /* Yes, this request can be handled immediately.  */

        /* Pickup the clear bit.  */
        clear_request =  (get_option & TX_EVENT_FLAGS_CLEAR_MASK);
 800885e:	687b      	ldr	r3, [r7, #4]
 8008860:	f003 0301 	and.w	r3, r3, #1
 8008864:	62bb      	str	r3, [r7, #40]	; 0x28

        /* Determine whether or not clearing needs to take place.  */
        if (clear_request == TX_TRUE)
 8008866:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008868:	2b01      	cmp	r3, #1
 800886a:	d11c      	bne.n	80088a6 <_tx_event_flags_get+0xc2>
        {

            /* Set interrupted set request flag to false.  */
            interrupted_set_request =  TX_FALSE;
 800886c:	2300      	movs	r3, #0
 800886e:	647b      	str	r3, [r7, #68]	; 0x44

            /* Determine if the suspension list is being processed by an interrupted
               set request.  */
            if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
 8008870:	68fb      	ldr	r3, [r7, #12]
 8008872:	695b      	ldr	r3, [r3, #20]
 8008874:	2b00      	cmp	r3, #0
 8008876:	d005      	beq.n	8008884 <_tx_event_flags_get+0xa0>
            {

                if (group_ptr -> tx_event_flags_group_suspension_list == TX_NULL)
 8008878:	68fb      	ldr	r3, [r7, #12]
 800887a:	691b      	ldr	r3, [r3, #16]
 800887c:	2b00      	cmp	r3, #0
 800887e:	d101      	bne.n	8008884 <_tx_event_flags_get+0xa0>
                {

                    /* Set the interrupted set request flag.  */
                    interrupted_set_request =  TX_TRUE;
 8008880:	2301      	movs	r3, #1
 8008882:	647b      	str	r3, [r7, #68]	; 0x44
                }
            }

            /* Was a set request interrupted?  */
            if (interrupted_set_request == TX_TRUE)
 8008884:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008886:	2b01      	cmp	r3, #1
 8008888:	d106      	bne.n	8008898 <_tx_event_flags_get+0xb4>
                /* A previous set operation is was interrupted, we need to defer the
                   event clearing until the set operation is complete.  */

                /* Remember the events to clear.  */
                group_ptr -> tx_event_flags_group_delayed_clear =
                                        group_ptr -> tx_event_flags_group_delayed_clear | requested_flags;
 800888a:	68fb      	ldr	r3, [r7, #12]
 800888c:	6a1a      	ldr	r2, [r3, #32]
 800888e:	68bb      	ldr	r3, [r7, #8]
 8008890:	431a      	orrs	r2, r3
                group_ptr -> tx_event_flags_group_delayed_clear =
 8008892:	68fb      	ldr	r3, [r7, #12]
 8008894:	621a      	str	r2, [r3, #32]
 8008896:	e006      	b.n	80088a6 <_tx_event_flags_get+0xc2>
            else
            {

                /* Yes, clear the flags that satisfied this request.  */
                group_ptr -> tx_event_flags_group_current =
                                        group_ptr -> tx_event_flags_group_current & ~requested_flags;
 8008898:	68fb      	ldr	r3, [r7, #12]
 800889a:	689a      	ldr	r2, [r3, #8]
 800889c:	68bb      	ldr	r3, [r7, #8]
 800889e:	43db      	mvns	r3, r3
 80088a0:	401a      	ands	r2, r3
                group_ptr -> tx_event_flags_group_current =
 80088a2:	68fb      	ldr	r3, [r7, #12]
 80088a4:	609a      	str	r2, [r3, #8]
            }
        }

        /* Set status to success.  */
        status =  TX_SUCCESS;
 80088a6:	2300      	movs	r3, #0
 80088a8:	653b      	str	r3, [r7, #80]	; 0x50
 80088aa:	e073      	b.n	8008994 <_tx_event_flags_get+0x1b0>
#endif
    else
    {
        /* flags_satisfied is 0.  */
        /* Determine if the request specifies suspension.  */
        if (wait_option != TX_NO_WAIT)
 80088ac:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80088ae:	2b00      	cmp	r3, #0
 80088b0:	d06e      	beq.n	8008990 <_tx_event_flags_get+0x1ac>
        {

            /* Determine if the preempt disable flag is non-zero OR the requested events is 0.  */
            if ((_tx_thread_preempt_disable != ((UINT) 0)) || (requested_flags == (UINT) 0))
 80088b2:	4b3e      	ldr	r3, [pc, #248]	; (80089ac <_tx_event_flags_get+0x1c8>)
 80088b4:	681b      	ldr	r3, [r3, #0]
 80088b6:	2b00      	cmp	r3, #0
 80088b8:	d102      	bne.n	80088c0 <_tx_event_flags_get+0xdc>
 80088ba:	68bb      	ldr	r3, [r7, #8]
 80088bc:	2b00      	cmp	r3, #0
 80088be:	d102      	bne.n	80088c6 <_tx_event_flags_get+0xe2>
            {

                /* Suspension is not allowed if the preempt disable flag is non-zero at this point,
                   or if requested_flags is 0, return error completion.  */
                status =  TX_NO_EVENTS;
 80088c0:	2307      	movs	r3, #7
 80088c2:	653b      	str	r3, [r7, #80]	; 0x50
 80088c4:	e066      	b.n	8008994 <_tx_event_flags_get+0x1b0>
                /* Increment the number of event flags suspensions on this semaphore.  */
                group_ptr -> tx_event_flags_group___performance_suspension_count++;
#endif

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(thread_ptr)
 80088c6:	4b3a      	ldr	r3, [pc, #232]	; (80089b0 <_tx_event_flags_get+0x1cc>)
 80088c8:	681b      	ldr	r3, [r3, #0]
 80088ca:	63bb      	str	r3, [r7, #56]	; 0x38

                /* Setup cleanup routine pointer.  */
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_event_flags_cleanup);
 80088cc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80088ce:	4a39      	ldr	r2, [pc, #228]	; (80089b4 <_tx_event_flags_get+0x1d0>)
 80088d0:	669a      	str	r2, [r3, #104]	; 0x68

                /* Remember which event flags we are looking for.  */
                thread_ptr -> tx_thread_suspend_info =  requested_flags;
 80088d2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80088d4:	68ba      	ldr	r2, [r7, #8]
 80088d6:	679a      	str	r2, [r3, #120]	; 0x78

                /* Save the get option as well.  */
                thread_ptr -> tx_thread_suspend_option =  get_option;
 80088d8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80088da:	687a      	ldr	r2, [r7, #4]
 80088dc:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

                /* Save the destination for the current events.  */
                thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) actual_flags_ptr;
 80088e0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80088e2:	683a      	ldr	r2, [r7, #0]
 80088e4:	67da      	str	r2, [r3, #124]	; 0x7c

                /* Setup cleanup information, i.e. this event flags group control
                   block.  */
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) group_ptr;
 80088e6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80088e8:	68fa      	ldr	r2, [r7, #12]
 80088ea:	66da      	str	r2, [r3, #108]	; 0x6c

#ifndef TX_NOT_INTERRUPTABLE

                /* Increment the suspension sequence number, which is used to identify
                   this suspension event.  */
                thread_ptr -> tx_thread_suspension_sequence++;
 80088ec:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80088ee:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 80088f2:	1c5a      	adds	r2, r3, #1
 80088f4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80088f6:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
#endif

                /* Pickup the suspended count.  */
                suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
 80088fa:	68fb      	ldr	r3, [r7, #12]
 80088fc:	695b      	ldr	r3, [r3, #20]
 80088fe:	637b      	str	r3, [r7, #52]	; 0x34

                /* Setup suspension list.  */
                if (suspended_count == TX_NO_SUSPENSIONS)
 8008900:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008902:	2b00      	cmp	r3, #0
 8008904:	d109      	bne.n	800891a <_tx_event_flags_get+0x136>
                {

                    /* No other threads are suspended.  Setup the head pointer and
                       just setup this threads pointers to itself.  */
                    group_ptr -> tx_event_flags_group_suspension_list =   thread_ptr;
 8008906:	68fb      	ldr	r3, [r7, #12]
 8008908:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800890a:	611a      	str	r2, [r3, #16]
                    thread_ptr -> tx_thread_suspended_next =              thread_ptr;
 800890c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800890e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8008910:	671a      	str	r2, [r3, #112]	; 0x70
                    thread_ptr -> tx_thread_suspended_previous =          thread_ptr;
 8008912:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008914:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8008916:	675a      	str	r2, [r3, #116]	; 0x74
 8008918:	e011      	b.n	800893e <_tx_event_flags_get+0x15a>
                }
                else
                {

                    /* This list is not NULL, add current thread to the end. */
                    next_thread =                                   group_ptr -> tx_event_flags_group_suspension_list;
 800891a:	68fb      	ldr	r3, [r7, #12]
 800891c:	691b      	ldr	r3, [r3, #16]
 800891e:	633b      	str	r3, [r7, #48]	; 0x30
                    thread_ptr -> tx_thread_suspended_next =        next_thread;
 8008920:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008922:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8008924:	671a      	str	r2, [r3, #112]	; 0x70
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
 8008926:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008928:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800892a:	62fb      	str	r3, [r7, #44]	; 0x2c
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 800892c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800892e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8008930:	675a      	str	r2, [r3, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
 8008932:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008934:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8008936:	671a      	str	r2, [r3, #112]	; 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
 8008938:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800893a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800893c:	675a      	str	r2, [r3, #116]	; 0x74
                }

                /* Increment the number of threads suspended.  */
                group_ptr -> tx_event_flags_group_suspended_count++;
 800893e:	68fb      	ldr	r3, [r7, #12]
 8008940:	695b      	ldr	r3, [r3, #20]
 8008942:	1c5a      	adds	r2, r3, #1
 8008944:	68fb      	ldr	r3, [r7, #12]
 8008946:	615a      	str	r2, [r3, #20]

                /* Set the state to suspended.  */
                thread_ptr -> tx_thread_state =    TX_EVENT_FLAG;
 8008948:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800894a:	2207      	movs	r2, #7
 800894c:	631a      	str	r2, [r3, #48]	; 0x30
                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
#else

                /* Set the suspending flag.  */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800894e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008950:	2201      	movs	r2, #1
 8008952:	639a      	str	r2, [r3, #56]	; 0x38

                /* Setup the timeout period.  */
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 8008954:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008956:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8008958:	64da      	str	r2, [r3, #76]	; 0x4c

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
 800895a:	4b14      	ldr	r3, [pc, #80]	; (80089ac <_tx_event_flags_get+0x1c8>)
 800895c:	681b      	ldr	r3, [r3, #0]
 800895e:	3301      	adds	r3, #1
 8008960:	4a12      	ldr	r2, [pc, #72]	; (80089ac <_tx_event_flags_get+0x1c8>)
 8008962:	6013      	str	r3, [r2, #0]
 8008964:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8008966:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8008968:	697b      	ldr	r3, [r7, #20]
 800896a:	f383 8810 	msr	PRIMASK, r3
}
 800896e:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
 8008970:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8008972:	f003 fe6f 	bl	800c654 <_tx_thread_system_suspend>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8008976:	f3ef 8310 	mrs	r3, PRIMASK
 800897a:	61fb      	str	r3, [r7, #28]
    return(posture);
 800897c:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800897e:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8008980:	b672      	cpsid	i
    return(int_posture);
 8008982:	69bb      	ldr	r3, [r7, #24]

                /* Disable interrupts.  */
                TX_DISABLE
 8008984:	657b      	str	r3, [r7, #84]	; 0x54

                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
 8008986:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008988:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800898c:	653b      	str	r3, [r7, #80]	; 0x50
 800898e:	e001      	b.n	8008994 <_tx_event_flags_get+0x1b0>
        }
        else
        {

            /* Immediate return, return error completion.  */
            status =  TX_NO_EVENTS;
 8008990:	2307      	movs	r3, #7
 8008992:	653b      	str	r3, [r7, #80]	; 0x50
 8008994:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8008996:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8008998:	693b      	ldr	r3, [r7, #16]
 800899a:	f383 8810 	msr	PRIMASK, r3
}
 800899e:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(status);
 80089a0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
}
 80089a2:	4618      	mov	r0, r3
 80089a4:	3758      	adds	r7, #88	; 0x58
 80089a6:	46bd      	mov	sp, r7
 80089a8:	bd80      	pop	{r7, pc}
 80089aa:	bf00      	nop
 80089ac:	2000f054 	.word	0x2000f054
 80089b0:	2000efb8 	.word	0x2000efb8
 80089b4:	0800851d 	.word	0x0800851d

080089b8 <_tx_event_flags_info_get>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_info_get(TX_EVENT_FLAGS_GROUP *group_ptr, CHAR **name, ULONG *current_flags,
                    TX_THREAD **first_suspended, ULONG *suspended_count,
                    TX_EVENT_FLAGS_GROUP **next_group)
{
 80089b8:	b480      	push	{r7}
 80089ba:	b089      	sub	sp, #36	; 0x24
 80089bc:	af00      	add	r7, sp, #0
 80089be:	60f8      	str	r0, [r7, #12]
 80089c0:	60b9      	str	r1, [r7, #8]
 80089c2:	607a      	str	r2, [r7, #4]
 80089c4:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80089c6:	f3ef 8310 	mrs	r3, PRIMASK
 80089ca:	61bb      	str	r3, [r7, #24]
    return(posture);
 80089cc:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 80089ce:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 80089d0:	b672      	cpsid	i
    return(int_posture);
 80089d2:	697b      	ldr	r3, [r7, #20]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts.  */
    TX_DISABLE
 80089d4:	61fb      	str	r3, [r7, #28]

    /* Retrieve all the pertinent information and return it in the supplied
       destinations.  */

    /* Retrieve the name of the event flag group.  */
    if (name != TX_NULL)
 80089d6:	68bb      	ldr	r3, [r7, #8]
 80089d8:	2b00      	cmp	r3, #0
 80089da:	d003      	beq.n	80089e4 <_tx_event_flags_info_get+0x2c>
    {

        *name =  group_ptr -> tx_event_flags_group_name;
 80089dc:	68fb      	ldr	r3, [r7, #12]
 80089de:	685a      	ldr	r2, [r3, #4]
 80089e0:	68bb      	ldr	r3, [r7, #8]
 80089e2:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the current event flags in the event flag group.  */
    if (current_flags != TX_NULL)
 80089e4:	687b      	ldr	r3, [r7, #4]
 80089e6:	2b00      	cmp	r3, #0
 80089e8:	d007      	beq.n	80089fa <_tx_event_flags_info_get+0x42>
    {

        /* Pickup the current flags and apply delayed clearing.  */
        *current_flags =  group_ptr -> tx_event_flags_group_current &
 80089ea:	68fb      	ldr	r3, [r7, #12]
 80089ec:	689a      	ldr	r2, [r3, #8]
                                                        ~group_ptr -> tx_event_flags_group_delayed_clear;
 80089ee:	68fb      	ldr	r3, [r7, #12]
 80089f0:	6a1b      	ldr	r3, [r3, #32]
 80089f2:	43db      	mvns	r3, r3
        *current_flags =  group_ptr -> tx_event_flags_group_current &
 80089f4:	401a      	ands	r2, r3
 80089f6:	687b      	ldr	r3, [r7, #4]
 80089f8:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the first thread suspended on this event flag group.  */
    if (first_suspended != TX_NULL)
 80089fa:	683b      	ldr	r3, [r7, #0]
 80089fc:	2b00      	cmp	r3, #0
 80089fe:	d003      	beq.n	8008a08 <_tx_event_flags_info_get+0x50>
    {

        *first_suspended =  group_ptr -> tx_event_flags_group_suspension_list;
 8008a00:	68fb      	ldr	r3, [r7, #12]
 8008a02:	691a      	ldr	r2, [r3, #16]
 8008a04:	683b      	ldr	r3, [r7, #0]
 8008a06:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the number of threads suspended on this event flag group.  */
    if (suspended_count != TX_NULL)
 8008a08:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008a0a:	2b00      	cmp	r3, #0
 8008a0c:	d003      	beq.n	8008a16 <_tx_event_flags_info_get+0x5e>
    {

        *suspended_count =  (ULONG) group_ptr -> tx_event_flags_group_suspended_count;
 8008a0e:	68fb      	ldr	r3, [r7, #12]
 8008a10:	695a      	ldr	r2, [r3, #20]
 8008a12:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008a14:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the pointer to the next event flag group created.  */
    if (next_group != TX_NULL)
 8008a16:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008a18:	2b00      	cmp	r3, #0
 8008a1a:	d003      	beq.n	8008a24 <_tx_event_flags_info_get+0x6c>
    {

        *next_group =  group_ptr -> tx_event_flags_group_created_next;
 8008a1c:	68fb      	ldr	r3, [r7, #12]
 8008a1e:	699a      	ldr	r2, [r3, #24]
 8008a20:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008a22:	601a      	str	r2, [r3, #0]
 8008a24:	69fb      	ldr	r3, [r7, #28]
 8008a26:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8008a28:	693b      	ldr	r3, [r7, #16]
 8008a2a:	f383 8810 	msr	PRIMASK, r3
}
 8008a2e:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(TX_SUCCESS);
 8008a30:	2300      	movs	r3, #0
}
 8008a32:	4618      	mov	r0, r3
 8008a34:	3724      	adds	r7, #36	; 0x24
 8008a36:	46bd      	mov	sp, r7
 8008a38:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a3c:	4770      	bx	lr

08008a3e <_tx_event_flags_performance_info_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_performance_info_get(TX_EVENT_FLAGS_GROUP *group_ptr, ULONG *sets, ULONG *gets,
                    ULONG *suspensions, ULONG *timeouts)
{
 8008a3e:	b480      	push	{r7}
 8008a40:	b087      	sub	sp, #28
 8008a42:	af00      	add	r7, sp, #0
 8008a44:	60f8      	str	r0, [r7, #12]
 8008a46:	60b9      	str	r1, [r7, #8]
 8008a48:	607a      	str	r2, [r7, #4]
 8008a4a:	603b      	str	r3, [r7, #0]
#else
UINT                    status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (group_ptr != TX_NULL)
 8008a4c:	68fb      	ldr	r3, [r7, #12]
 8008a4e:	2b00      	cmp	r3, #0
 8008a50:	d002      	beq.n	8008a58 <_tx_event_flags_performance_info_get+0x1a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8008a52:	23ff      	movs	r3, #255	; 0xff
 8008a54:	617b      	str	r3, [r7, #20]
 8008a56:	e019      	b.n	8008a8c <_tx_event_flags_performance_info_get+0x4e>
    }
    else if (sets != TX_NULL)
 8008a58:	68bb      	ldr	r3, [r7, #8]
 8008a5a:	2b00      	cmp	r3, #0
 8008a5c:	d002      	beq.n	8008a64 <_tx_event_flags_performance_info_get+0x26>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8008a5e:	23ff      	movs	r3, #255	; 0xff
 8008a60:	617b      	str	r3, [r7, #20]
 8008a62:	e013      	b.n	8008a8c <_tx_event_flags_performance_info_get+0x4e>
    }
    else if (gets != TX_NULL)
 8008a64:	687b      	ldr	r3, [r7, #4]
 8008a66:	2b00      	cmp	r3, #0
 8008a68:	d002      	beq.n	8008a70 <_tx_event_flags_performance_info_get+0x32>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8008a6a:	23ff      	movs	r3, #255	; 0xff
 8008a6c:	617b      	str	r3, [r7, #20]
 8008a6e:	e00d      	b.n	8008a8c <_tx_event_flags_performance_info_get+0x4e>
    }
    else if (suspensions != TX_NULL)
 8008a70:	683b      	ldr	r3, [r7, #0]
 8008a72:	2b00      	cmp	r3, #0
 8008a74:	d002      	beq.n	8008a7c <_tx_event_flags_performance_info_get+0x3e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8008a76:	23ff      	movs	r3, #255	; 0xff
 8008a78:	617b      	str	r3, [r7, #20]
 8008a7a:	e007      	b.n	8008a8c <_tx_event_flags_performance_info_get+0x4e>
    }
    else if (timeouts != TX_NULL)
 8008a7c:	6a3b      	ldr	r3, [r7, #32]
 8008a7e:	2b00      	cmp	r3, #0
 8008a80:	d002      	beq.n	8008a88 <_tx_event_flags_performance_info_get+0x4a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8008a82:	23ff      	movs	r3, #255	; 0xff
 8008a84:	617b      	str	r3, [r7, #20]
 8008a86:	e001      	b.n	8008a8c <_tx_event_flags_performance_info_get+0x4e>
    }
    else
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8008a88:	23ff      	movs	r3, #255	; 0xff
 8008a8a:	617b      	str	r3, [r7, #20]
    }
#endif

    /* Return completion status.  */
    return(status);
 8008a8c:	697b      	ldr	r3, [r7, #20]
}
 8008a8e:	4618      	mov	r0, r3
 8008a90:	371c      	adds	r7, #28
 8008a92:	46bd      	mov	sp, r7
 8008a94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a98:	4770      	bx	lr

08008a9a <_tx_event_flags_performance_system_info_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_performance_system_info_get(ULONG *sets, ULONG *gets, ULONG *suspensions, ULONG *timeouts)
{
 8008a9a:	b480      	push	{r7}
 8008a9c:	b087      	sub	sp, #28
 8008a9e:	af00      	add	r7, sp, #0
 8008aa0:	60f8      	str	r0, [r7, #12]
 8008aa2:	60b9      	str	r1, [r7, #8]
 8008aa4:	607a      	str	r2, [r7, #4]
 8008aa6:	603b      	str	r3, [r7, #0]

UINT        status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (sets != TX_NULL)
 8008aa8:	68fb      	ldr	r3, [r7, #12]
 8008aaa:	2b00      	cmp	r3, #0
 8008aac:	d002      	beq.n	8008ab4 <_tx_event_flags_performance_system_info_get+0x1a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8008aae:	23ff      	movs	r3, #255	; 0xff
 8008ab0:	617b      	str	r3, [r7, #20]
 8008ab2:	e013      	b.n	8008adc <_tx_event_flags_performance_system_info_get+0x42>
    }
    else if (gets != TX_NULL)
 8008ab4:	68bb      	ldr	r3, [r7, #8]
 8008ab6:	2b00      	cmp	r3, #0
 8008ab8:	d002      	beq.n	8008ac0 <_tx_event_flags_performance_system_info_get+0x26>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8008aba:	23ff      	movs	r3, #255	; 0xff
 8008abc:	617b      	str	r3, [r7, #20]
 8008abe:	e00d      	b.n	8008adc <_tx_event_flags_performance_system_info_get+0x42>
    }
    else if (suspensions != TX_NULL)
 8008ac0:	687b      	ldr	r3, [r7, #4]
 8008ac2:	2b00      	cmp	r3, #0
 8008ac4:	d002      	beq.n	8008acc <_tx_event_flags_performance_system_info_get+0x32>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8008ac6:	23ff      	movs	r3, #255	; 0xff
 8008ac8:	617b      	str	r3, [r7, #20]
 8008aca:	e007      	b.n	8008adc <_tx_event_flags_performance_system_info_get+0x42>
    }
    else if (timeouts != TX_NULL)
 8008acc:	683b      	ldr	r3, [r7, #0]
 8008ace:	2b00      	cmp	r3, #0
 8008ad0:	d002      	beq.n	8008ad8 <_tx_event_flags_performance_system_info_get+0x3e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8008ad2:	23ff      	movs	r3, #255	; 0xff
 8008ad4:	617b      	str	r3, [r7, #20]
 8008ad6:	e001      	b.n	8008adc <_tx_event_flags_performance_system_info_get+0x42>
    }
    else
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8008ad8:	23ff      	movs	r3, #255	; 0xff
 8008ada:	617b      	str	r3, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 8008adc:	697b      	ldr	r3, [r7, #20]
#endif
}
 8008ade:	4618      	mov	r0, r3
 8008ae0:	371c      	adds	r7, #28
 8008ae2:	46bd      	mov	sp, r7
 8008ae4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008ae8:	4770      	bx	lr
	...

08008aec <_tx_event_flags_set>:
/*                                            check logic, resulting in   */
/*                                            version 6.1.11              */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_set(TX_EVENT_FLAGS_GROUP *group_ptr, ULONG flags_to_set, UINT set_option)
{
 8008aec:	b580      	push	{r7, lr}
 8008aee:	b0a8      	sub	sp, #160	; 0xa0
 8008af0:	af00      	add	r7, sp, #0
 8008af2:	60f8      	str	r0, [r7, #12]
 8008af4:	60b9      	str	r1, [r7, #8]
 8008af6:	607a      	str	r2, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8008af8:	f3ef 8310 	mrs	r3, PRIMASK
 8008afc:	653b      	str	r3, [r7, #80]	; 0x50
    return(posture);
 8008afe:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    int_posture = __get_interrupt_posture();
 8008b00:	64fb      	str	r3, [r7, #76]	; 0x4c
    __asm__ volatile ("CPSID i" : : : "memory");
 8008b02:	b672      	cpsid	i
    return(int_posture);
 8008b04:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
VOID            (*events_set_notify)(struct TX_EVENT_FLAGS_GROUP_STRUCT *notify_group_ptr);
#endif


    /* Disable interrupts to remove the semaphore from the created list.  */
    TX_DISABLE
 8008b06:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c

    /* Log this kernel call.  */
    TX_EL_EVENT_FLAGS_SET_INSERT

    /* Determine how to set this group's event flags.  */
    if ((set_option & TX_EVENT_FLAGS_AND_MASK) == TX_AND)
 8008b0a:	687b      	ldr	r3, [r7, #4]
 8008b0c:	f003 0302 	and.w	r3, r3, #2
 8008b10:	2b00      	cmp	r3, #0
 8008b12:	d023      	beq.n	8008b5c <_tx_event_flags_set+0x70>
    {

#ifndef TX_NOT_INTERRUPTABLE

        /* Set interrupted set request flag to false.  */
        interrupted_set_request =  TX_FALSE;
 8008b14:	2300      	movs	r3, #0
 8008b16:	67bb      	str	r3, [r7, #120]	; 0x78

        /* Determine if the suspension list is being processed by an interrupted
           set request.  */
        if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
 8008b18:	68fb      	ldr	r3, [r7, #12]
 8008b1a:	695b      	ldr	r3, [r3, #20]
 8008b1c:	2b00      	cmp	r3, #0
 8008b1e:	d005      	beq.n	8008b2c <_tx_event_flags_set+0x40>
        {

            if (group_ptr -> tx_event_flags_group_suspension_list == TX_NULL)
 8008b20:	68fb      	ldr	r3, [r7, #12]
 8008b22:	691b      	ldr	r3, [r3, #16]
 8008b24:	2b00      	cmp	r3, #0
 8008b26:	d101      	bne.n	8008b2c <_tx_event_flags_set+0x40>
            {

                /* Set the interrupted set request flag.  */
                interrupted_set_request =  TX_TRUE;
 8008b28:	2301      	movs	r3, #1
 8008b2a:	67bb      	str	r3, [r7, #120]	; 0x78
            }
        }

        /* Was a set request interrupted?  */
        if (interrupted_set_request == TX_TRUE)
 8008b2c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8008b2e:	2b01      	cmp	r3, #1
 8008b30:	d107      	bne.n	8008b42 <_tx_event_flags_set+0x56>
            /* A previous set operation was interrupted, we need to defer the
               event clearing until the set operation is complete.  */

            /* Remember the events to clear.  */
            group_ptr -> tx_event_flags_group_delayed_clear =
                                        group_ptr -> tx_event_flags_group_delayed_clear | ~flags_to_set;
 8008b32:	68fb      	ldr	r3, [r7, #12]
 8008b34:	6a1a      	ldr	r2, [r3, #32]
 8008b36:	68bb      	ldr	r3, [r7, #8]
 8008b38:	43db      	mvns	r3, r3
 8008b3a:	431a      	orrs	r2, r3
            group_ptr -> tx_event_flags_group_delayed_clear =
 8008b3c:	68fb      	ldr	r3, [r7, #12]
 8008b3e:	621a      	str	r2, [r3, #32]
 8008b40:	e005      	b.n	8008b4e <_tx_event_flags_set+0x62>

            /* Previous set operation was not interrupted, simply clear the
               specified flags by "ANDing" the flags into the current events
               of the group.  */
            group_ptr -> tx_event_flags_group_current =
                group_ptr -> tx_event_flags_group_current & flags_to_set;
 8008b42:	68fb      	ldr	r3, [r7, #12]
 8008b44:	689a      	ldr	r2, [r3, #8]
 8008b46:	68bb      	ldr	r3, [r7, #8]
 8008b48:	401a      	ands	r2, r3
            group_ptr -> tx_event_flags_group_current =
 8008b4a:	68fb      	ldr	r3, [r7, #12]
 8008b4c:	609a      	str	r2, [r3, #8]
 8008b4e:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8008b52:	64bb      	str	r3, [r7, #72]	; 0x48
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8008b54:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8008b56:	f383 8810 	msr	PRIMASK, r3
}
 8008b5a:	e1f0      	b.n	8008f3e <_tx_event_flags_set+0x452>
    {

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Pickup the notify callback routine for this event flag group.  */
        events_set_notify =  group_ptr -> tx_event_flags_group_set_notify;
 8008b5c:	68fb      	ldr	r3, [r7, #12]
 8008b5e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008b60:	677b      	str	r3, [r7, #116]	; 0x74
#endif

        /* "OR" the flags into the current events of the group.  */
        group_ptr -> tx_event_flags_group_current =
            group_ptr -> tx_event_flags_group_current | flags_to_set;
 8008b62:	68fb      	ldr	r3, [r7, #12]
 8008b64:	689a      	ldr	r2, [r3, #8]
 8008b66:	68bb      	ldr	r3, [r7, #8]
 8008b68:	431a      	orrs	r2, r3
        group_ptr -> tx_event_flags_group_current =
 8008b6a:	68fb      	ldr	r3, [r7, #12]
 8008b6c:	609a      	str	r2, [r3, #8]

#ifndef TX_NOT_INTERRUPTABLE

        /* Determine if there are any delayed flags to clear.  */
        if (group_ptr -> tx_event_flags_group_delayed_clear != ((ULONG) 0))
 8008b6e:	68fb      	ldr	r3, [r7, #12]
 8008b70:	6a1b      	ldr	r3, [r3, #32]
 8008b72:	2b00      	cmp	r3, #0
 8008b74:	d006      	beq.n	8008b84 <_tx_event_flags_set+0x98>
        {

            /* Yes, we need to neutralize the delayed clearing as well.  */
            group_ptr -> tx_event_flags_group_delayed_clear =
                                        group_ptr -> tx_event_flags_group_delayed_clear & ~flags_to_set;
 8008b76:	68fb      	ldr	r3, [r7, #12]
 8008b78:	6a1a      	ldr	r2, [r3, #32]
 8008b7a:	68bb      	ldr	r3, [r7, #8]
 8008b7c:	43db      	mvns	r3, r3
 8008b7e:	401a      	ands	r2, r3
            group_ptr -> tx_event_flags_group_delayed_clear =
 8008b80:	68fb      	ldr	r3, [r7, #12]
 8008b82:	621a      	str	r2, [r3, #32]
        }
#endif

        /* Clear the preempt check flag.  */
        preempt_check =  TX_FALSE;
 8008b84:	2300      	movs	r3, #0
 8008b86:	67fb      	str	r3, [r7, #124]	; 0x7c

        /* Pickup the thread suspended count.  */
        suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
 8008b88:	68fb      	ldr	r3, [r7, #12]
 8008b8a:	695b      	ldr	r3, [r3, #20]
 8008b8c:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88

        /* Determine if there are any threads suspended on the event flag group.  */
        if (group_ptr -> tx_event_flags_group_suspension_list != TX_NULL)
 8008b90:	68fb      	ldr	r3, [r7, #12]
 8008b92:	691b      	ldr	r3, [r3, #16]
 8008b94:	2b00      	cmp	r3, #0
 8008b96:	f000 81b9 	beq.w	8008f0c <_tx_event_flags_set+0x420>
        {

            /* Determine if there is just a single thread waiting on the event
               flag group.  */
            if (suspended_count == ((UINT) 1))
 8008b9a:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8008b9e:	2b01      	cmp	r3, #1
 8008ba0:	d170      	bne.n	8008c84 <_tx_event_flags_set+0x198>

                /* Single thread waiting for event flags.  Bypass the multiple thread
                   logic.  */

                /* Setup thread pointer.  */
                thread_ptr =  group_ptr -> tx_event_flags_group_suspension_list;
 8008ba2:	68fb      	ldr	r3, [r7, #12]
 8008ba4:	691b      	ldr	r3, [r3, #16]
 8008ba6:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98

                /* Pickup the current event flags.  */
                current_event_flags =  group_ptr -> tx_event_flags_group_current;
 8008baa:	68fb      	ldr	r3, [r7, #12]
 8008bac:	689b      	ldr	r3, [r3, #8]
 8008bae:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84

                /* Pickup the suspend information.  */
                requested_flags =  thread_ptr -> tx_thread_suspend_info;
 8008bb2:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008bb6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8008bb8:	66fb      	str	r3, [r7, #108]	; 0x6c

                /* Pickup the suspend option.  */
                get_option =  thread_ptr -> tx_thread_suspend_option;
 8008bba:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008bbe:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8008bc2:	66bb      	str	r3, [r7, #104]	; 0x68

                /* Isolate the AND selection.  */
                and_request =  (get_option & TX_AND);
 8008bc4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8008bc6:	f003 0302 	and.w	r3, r3, #2
 8008bca:	667b      	str	r3, [r7, #100]	; 0x64

                /* Check for AND condition. All flags must be present to satisfy request.  */
                if (and_request == TX_AND)
 8008bcc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8008bce:	2b02      	cmp	r3, #2
 8008bd0:	d10e      	bne.n	8008bf0 <_tx_event_flags_set+0x104>
                {

                    /* AND request is present.  */

                    /* Calculate the flags present.  */
                    flags_satisfied =  (current_event_flags & requested_flags);
 8008bd2:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8008bd6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8008bd8:	4013      	ands	r3, r2
 8008bda:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

                    /* Determine if they satisfy the AND request.  */
                    if (flags_satisfied != requested_flags)
 8008bde:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8008be2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8008be4:	429a      	cmp	r2, r3
 8008be6:	d009      	beq.n	8008bfc <_tx_event_flags_set+0x110>
                    {

                        /* No, not all the requested flags are present. Clear the flags present variable.  */
                        flags_satisfied =  ((ULONG) 0);
 8008be8:	2300      	movs	r3, #0
 8008bea:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 8008bee:	e005      	b.n	8008bfc <_tx_event_flags_set+0x110>
                }
                else
                {

                    /* OR request is present. Simply or the requested flags and the current flags.  */
                    flags_satisfied =  (current_event_flags & requested_flags);
 8008bf0:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8008bf4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8008bf6:	4013      	ands	r3, r2
 8008bf8:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
                }

                /* Determine if the request is satisfied.  */
                if (flags_satisfied != ((ULONG) 0))
 8008bfc:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8008c00:	2b00      	cmp	r3, #0
 8008c02:	f000 818a 	beq.w	8008f1a <_tx_event_flags_set+0x42e>

                    /* Yes, resume the thread and apply any event flag
                       clearing.  */

                    /* Return the actual event flags that satisfied the request.  */
                    suspend_info_ptr =   TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
 8008c06:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008c0a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008c0c:	663b      	str	r3, [r7, #96]	; 0x60
                    *suspend_info_ptr =  current_event_flags;
 8008c0e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8008c10:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8008c14:	601a      	str	r2, [r3, #0]

                    /* Pickup the clear bit.  */
                    clear_request =  (get_option & TX_EVENT_FLAGS_CLEAR_MASK);
 8008c16:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8008c18:	f003 0301 	and.w	r3, r3, #1
 8008c1c:	65fb      	str	r3, [r7, #92]	; 0x5c

                    /* Determine whether or not clearing needs to take place.  */
                    if (clear_request == TX_TRUE)
 8008c1e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8008c20:	2b01      	cmp	r3, #1
 8008c22:	d106      	bne.n	8008c32 <_tx_event_flags_set+0x146>
                    {

                        /* Yes, clear the flags that satisfied this request.  */
                        group_ptr -> tx_event_flags_group_current =  group_ptr -> tx_event_flags_group_current & (~requested_flags);
 8008c24:	68fb      	ldr	r3, [r7, #12]
 8008c26:	689a      	ldr	r2, [r3, #8]
 8008c28:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8008c2a:	43db      	mvns	r3, r3
 8008c2c:	401a      	ands	r2, r3
 8008c2e:	68fb      	ldr	r3, [r7, #12]
 8008c30:	609a      	str	r2, [r3, #8]
                    }

                    /* Clear the suspension information in the event flag group.  */
                    group_ptr -> tx_event_flags_group_suspension_list =  TX_NULL;
 8008c32:	68fb      	ldr	r3, [r7, #12]
 8008c34:	2200      	movs	r2, #0
 8008c36:	611a      	str	r2, [r3, #16]
                    group_ptr -> tx_event_flags_group_suspended_count =  TX_NO_SUSPENSIONS;
 8008c38:	68fb      	ldr	r3, [r7, #12]
 8008c3a:	2200      	movs	r2, #0
 8008c3c:	615a      	str	r2, [r3, #20]

                    /* Clear cleanup routine to avoid timeout.  */
                    thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8008c3e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008c42:	2200      	movs	r2, #0
 8008c44:	669a      	str	r2, [r3, #104]	; 0x68

                    /* Put return status into the thread control block.  */
                    thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 8008c46:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008c4a:	2200      	movs	r2, #0
 8008c4c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                    /* Resume the thread!  */
                    _tx_thread_system_ni_resume(thread_ptr);
#else

                    /* Temporarily disable preemption.  */
                    _tx_thread_preempt_disable++;
 8008c50:	4bad      	ldr	r3, [pc, #692]	; (8008f08 <_tx_event_flags_set+0x41c>)
 8008c52:	681b      	ldr	r3, [r3, #0]
 8008c54:	3301      	adds	r3, #1
 8008c56:	4aac      	ldr	r2, [pc, #688]	; (8008f08 <_tx_event_flags_set+0x41c>)
 8008c58:	6013      	str	r3, [r2, #0]
 8008c5a:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8008c5e:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8008c60:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008c62:	f383 8810 	msr	PRIMASK, r3
}
 8008c66:	bf00      	nop

                    /* Restore interrupts.  */
                    TX_RESTORE

                    /* Resume thread.  */
                    _tx_thread_system_resume(thread_ptr);
 8008c68:	f8d7 0098 	ldr.w	r0, [r7, #152]	; 0x98
 8008c6c:	f003 fbde 	bl	800c42c <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8008c70:	f3ef 8310 	mrs	r3, PRIMASK
 8008c74:	647b      	str	r3, [r7, #68]	; 0x44
    return(posture);
 8008c76:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    int_posture = __get_interrupt_posture();
 8008c78:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("CPSID i" : : : "memory");
 8008c7a:	b672      	cpsid	i
    return(int_posture);
 8008c7c:	6c3b      	ldr	r3, [r7, #64]	; 0x40

                    /* Disable interrupts to remove the semaphore from the created list.  */
                    TX_DISABLE
 8008c7e:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 8008c82:	e14a      	b.n	8008f1a <_tx_event_flags_set+0x42e>

                /* Otherwise, the event flag requests of multiple threads must be
                   examined.  */

                /* Setup thread pointer, keep a local copy of the head pointer.  */
                suspended_list =  group_ptr -> tx_event_flags_group_suspension_list;
 8008c84:	68fb      	ldr	r3, [r7, #12]
 8008c86:	691b      	ldr	r3, [r3, #16]
 8008c88:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
                thread_ptr =      suspended_list;
 8008c8c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8008c90:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98

                /* Clear the suspended list head pointer to thwart manipulation of
                   the list in ISR's while we are processing here.  */
                group_ptr -> tx_event_flags_group_suspension_list =  TX_NULL;
 8008c94:	68fb      	ldr	r3, [r7, #12]
 8008c96:	2200      	movs	r2, #0
 8008c98:	611a      	str	r2, [r3, #16]

                /* Setup the satisfied thread pointers.  */
                satisfied_list =  TX_NULL;
 8008c9a:	2300      	movs	r3, #0
 8008c9c:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
                last_satisfied =  TX_NULL;
 8008ca0:	2300      	movs	r3, #0
 8008ca2:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

                /* Pickup the current event flags.  */
                current_event_flags =  group_ptr -> tx_event_flags_group_current;
 8008ca6:	68fb      	ldr	r3, [r7, #12]
 8008ca8:	689b      	ldr	r3, [r3, #8]
 8008caa:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84

                /* Disable preemption while we process the suspended list.  */
                _tx_thread_preempt_disable++;
 8008cae:	4b96      	ldr	r3, [pc, #600]	; (8008f08 <_tx_event_flags_set+0x41c>)
 8008cb0:	681b      	ldr	r3, [r3, #0]
 8008cb2:	3301      	adds	r3, #1
 8008cb4:	4a94      	ldr	r2, [pc, #592]	; (8008f08 <_tx_event_flags_set+0x41c>)
 8008cb6:	6013      	str	r3, [r2, #0]

                /* Since we have temporarily disabled preemption globally, set the preempt 
                   check flag to check for any preemption condition - including from 
                   unrelated ISR processing.  */
                preempt_check =  TX_TRUE;
 8008cb8:	2301      	movs	r3, #1
 8008cba:	67fb      	str	r3, [r7, #124]	; 0x7c
 8008cbc:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8008cc0:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8008cc2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008cc4:	f383 8810 	msr	PRIMASK, r3
}
 8008cc8:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8008cca:	f3ef 8310 	mrs	r3, PRIMASK
 8008cce:	63bb      	str	r3, [r7, #56]	; 0x38
    return(posture);
 8008cd0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    int_posture = __get_interrupt_posture();
 8008cd2:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile ("CPSID i" : : : "memory");
 8008cd4:	b672      	cpsid	i
    return(int_posture);
 8008cd6:	6b7b      	ldr	r3, [r7, #52]	; 0x34

                    /* Restore interrupts temporarily.  */
                    TX_RESTORE

                    /* Disable interrupts again.  */
                    TX_DISABLE
 8008cd8:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
#endif

                    /* Determine if we need to reset the search.  */
                    if (group_ptr -> tx_event_flags_group_reset_search != TX_FALSE)
 8008cdc:	68fb      	ldr	r3, [r7, #12]
 8008cde:	68db      	ldr	r3, [r3, #12]
 8008ce0:	2b00      	cmp	r3, #0
 8008ce2:	d011      	beq.n	8008d08 <_tx_event_flags_set+0x21c>
                    {

                        /* Clear the reset search flag.  */
                        group_ptr -> tx_event_flags_group_reset_search =  TX_FALSE;
 8008ce4:	68fb      	ldr	r3, [r7, #12]
 8008ce6:	2200      	movs	r2, #0
 8008ce8:	60da      	str	r2, [r3, #12]

                        /* Move the thread pointer to the beginning of the search list.  */
                        thread_ptr =  suspended_list;
 8008cea:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8008cee:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98

                        /* Reset the suspended count.  */
                        suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
 8008cf2:	68fb      	ldr	r3, [r7, #12]
 8008cf4:	695b      	ldr	r3, [r3, #20]
 8008cf6:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88

                        /* Update the current events with any new ones that might
                           have been set in a nested set events call from an ISR.  */
                        current_event_flags =  current_event_flags | group_ptr -> tx_event_flags_group_current;
 8008cfa:	68fb      	ldr	r3, [r7, #12]
 8008cfc:	689b      	ldr	r3, [r3, #8]
 8008cfe:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8008d02:	4313      	orrs	r3, r2
 8008d04:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                    }

                    /* Save next thread pointer.  */
                    next_thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 8008d08:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008d0c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008d0e:	673b      	str	r3, [r7, #112]	; 0x70

                    /* Pickup the suspend information.  */
                    requested_flags =  thread_ptr -> tx_thread_suspend_info;
 8008d10:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008d14:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8008d16:	66fb      	str	r3, [r7, #108]	; 0x6c

                    /* Pickup this thread's suspension get option.  */
                    get_option =  thread_ptr -> tx_thread_suspend_option;
 8008d18:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008d1c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8008d20:	66bb      	str	r3, [r7, #104]	; 0x68

                    /* Isolate the AND selection.  */
                    and_request =  (get_option & TX_AND);
 8008d22:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8008d24:	f003 0302 	and.w	r3, r3, #2
 8008d28:	667b      	str	r3, [r7, #100]	; 0x64

                    /* Check for AND condition. All flags must be present to satisfy request.  */
                    if (and_request == TX_AND)
 8008d2a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8008d2c:	2b02      	cmp	r3, #2
 8008d2e:	d10e      	bne.n	8008d4e <_tx_event_flags_set+0x262>
                    {

                        /* AND request is present.  */

                        /* Calculate the flags present.  */
                        flags_satisfied =  (current_event_flags & requested_flags);
 8008d30:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8008d34:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8008d36:	4013      	ands	r3, r2
 8008d38:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

                        /* Determine if they satisfy the AND request.  */
                        if (flags_satisfied != requested_flags)
 8008d3c:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8008d40:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8008d42:	429a      	cmp	r2, r3
 8008d44:	d009      	beq.n	8008d5a <_tx_event_flags_set+0x26e>
                        {

                            /* No, not all the requested flags are present. Clear the flags present variable.  */
                            flags_satisfied =  ((ULONG) 0);
 8008d46:	2300      	movs	r3, #0
 8008d48:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 8008d4c:	e005      	b.n	8008d5a <_tx_event_flags_set+0x26e>
                    }
                    else
                    {

                        /* OR request is present. Simply or the requested flags and the current flags.  */
                        flags_satisfied =  (current_event_flags & requested_flags);
 8008d4e:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8008d52:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8008d54:	4013      	ands	r3, r2
 8008d56:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
                    }

                    /* Check to see if the thread had a timeout or wait abort during the event search processing.
                       If so, just set the flags satisfied to ensure the processing here removes the thread from
                       the suspension list.  */
                    if (thread_ptr -> tx_thread_state != TX_EVENT_FLAG)
 8008d5a:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008d5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008d60:	2b07      	cmp	r3, #7
 8008d62:	d002      	beq.n	8008d6a <_tx_event_flags_set+0x27e>
                    {

                       /* Simply set the satisfied flags to 1 in order to remove the thread from the suspension list.  */
                        flags_satisfied =  ((ULONG) 1);
 8008d64:	2301      	movs	r3, #1
 8008d66:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
                    }

                    /* Determine if the request is satisfied.  */
                    if (flags_satisfied != ((ULONG) 0))
 8008d6a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8008d6e:	2b00      	cmp	r3, #0
 8008d70:	d06a      	beq.n	8008e48 <_tx_event_flags_set+0x35c>

                        /* Yes, this request can be handled now.  */

                        /* Determine if the thread is still suspended on the event flag group. If not, a wait
                           abort must have been done from an ISR.  */
                        if (thread_ptr -> tx_thread_state == TX_EVENT_FLAG)
 8008d72:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008d76:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008d78:	2b07      	cmp	r3, #7
 8008d7a:	d11e      	bne.n	8008dba <_tx_event_flags_set+0x2ce>
                        {

                            /* Return the actual event flags that satisfied the request.  */
                            suspend_info_ptr =   TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
 8008d7c:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008d80:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008d82:	663b      	str	r3, [r7, #96]	; 0x60
                            *suspend_info_ptr =  current_event_flags;
 8008d84:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8008d86:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8008d8a:	601a      	str	r2, [r3, #0]

                            /* Pickup the clear bit.  */
                            clear_request =  (get_option & TX_EVENT_FLAGS_CLEAR_MASK);
 8008d8c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8008d8e:	f003 0301 	and.w	r3, r3, #1
 8008d92:	65fb      	str	r3, [r7, #92]	; 0x5c

                            /* Determine whether or not clearing needs to take place.  */
                            if (clear_request == TX_TRUE)
 8008d94:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8008d96:	2b01      	cmp	r3, #1
 8008d98:	d106      	bne.n	8008da8 <_tx_event_flags_set+0x2bc>
                            {

                                /* Yes, clear the flags that satisfied this request.  */
                                group_ptr -> tx_event_flags_group_current =  group_ptr -> tx_event_flags_group_current & ~requested_flags;
 8008d9a:	68fb      	ldr	r3, [r7, #12]
 8008d9c:	689a      	ldr	r2, [r3, #8]
 8008d9e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8008da0:	43db      	mvns	r3, r3
 8008da2:	401a      	ands	r2, r3
 8008da4:	68fb      	ldr	r3, [r7, #12]
 8008da6:	609a      	str	r2, [r3, #8]
                            }

                            /* Prepare for resumption of the first thread.  */

                            /* Clear cleanup routine to avoid timeout.  */
                            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8008da8:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008dac:	2200      	movs	r2, #0
 8008dae:	669a      	str	r2, [r3, #104]	; 0x68

                            /* Put return status into the thread control block.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 8008db0:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008db4:	2200      	movs	r2, #0
 8008db6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

                        /* We need to remove the thread from the suspension list and place it in the
                           expired list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (thread_ptr == thread_ptr -> tx_thread_suspended_next)
 8008dba:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008dbe:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008dc0:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8008dc4:	429a      	cmp	r2, r3
 8008dc6:	d103      	bne.n	8008dd0 <_tx_event_flags_set+0x2e4>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            suspended_list =  TX_NULL;
 8008dc8:	2300      	movs	r3, #0
 8008dca:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 8008dce:	e018      	b.n	8008e02 <_tx_event_flags_set+0x316>
                        {

                            /* At least one more thread is on the same expiration list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                  thread_ptr -> tx_thread_suspended_next;
 8008dd0:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008dd4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008dd6:	65bb      	str	r3, [r7, #88]	; 0x58
                            previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
 8008dd8:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008ddc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8008dde:	657b      	str	r3, [r7, #84]	; 0x54
                            next_thread -> tx_thread_suspended_previous =  previous_thread;
 8008de0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8008de2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8008de4:	675a      	str	r2, [r3, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =  next_thread;
 8008de6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8008de8:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8008dea:	671a      	str	r2, [r3, #112]	; 0x70

                            /* Update the list head pointer, if removing the head of the
                               list.  */
                            if (suspended_list == thread_ptr)
 8008dec:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 8008df0:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008df4:	429a      	cmp	r2, r3
 8008df6:	d104      	bne.n	8008e02 <_tx_event_flags_set+0x316>
                            {

                                /* Yes, head pointer needs to be updated.  */
                                suspended_list =  thread_ptr -> tx_thread_suspended_next;
 8008df8:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008dfc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008dfe:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
                            }
                        }

                        /* Decrement the suspension count.  */
                        group_ptr -> tx_event_flags_group_suspended_count--;
 8008e02:	68fb      	ldr	r3, [r7, #12]
 8008e04:	695b      	ldr	r3, [r3, #20]
 8008e06:	1e5a      	subs	r2, r3, #1
 8008e08:	68fb      	ldr	r3, [r7, #12]
 8008e0a:	615a      	str	r2, [r3, #20]

                        /* Place this thread on the expired list.  */
                        if (satisfied_list == TX_NULL)
 8008e0c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8008e10:	2b00      	cmp	r3, #0
 8008e12:	d10c      	bne.n	8008e2e <_tx_event_flags_set+0x342>
                        {

                            /* First thread on the satisfied list.  */
                            satisfied_list =  thread_ptr;
 8008e14:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008e18:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
                            last_satisfied =  thread_ptr;
 8008e1c:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008e20:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

                            /* Setup initial next pointer.  */
                            thread_ptr -> tx_thread_suspended_next =  TX_NULL;
 8008e24:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008e28:	2200      	movs	r2, #0
 8008e2a:	671a      	str	r2, [r3, #112]	; 0x70
 8008e2c:	e00c      	b.n	8008e48 <_tx_event_flags_set+0x35c>
                        {

                            /* Not the first thread on the satisfied list.  */

                            /* Link it up at the end.  */
                            last_satisfied -> tx_thread_suspended_next =  thread_ptr;
 8008e2e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8008e32:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8008e36:	671a      	str	r2, [r3, #112]	; 0x70
                            thread_ptr -> tx_thread_suspended_next =      TX_NULL;
 8008e38:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008e3c:	2200      	movs	r2, #0
 8008e3e:	671a      	str	r2, [r3, #112]	; 0x70
                            last_satisfied =                              thread_ptr;
 8008e40:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008e44:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
                        }
                    }

                    /* Copy next thread pointer to working thread ptr.  */
                    thread_ptr =  next_thread_ptr;
 8008e48:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8008e4a:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98

                    /* Decrement the suspension count.  */
                    suspended_count--;
 8008e4e:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8008e52:	3b01      	subs	r3, #1
 8008e54:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88

                } while (suspended_count != TX_NO_SUSPENSIONS);
 8008e58:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8008e5c:	2b00      	cmp	r3, #0
 8008e5e:	f47f af2d 	bne.w	8008cbc <_tx_event_flags_set+0x1d0>

                /* Setup the group's suspension list head again.  */
                group_ptr -> tx_event_flags_group_suspension_list =  suspended_list;
 8008e62:	68fb      	ldr	r3, [r7, #12]
 8008e64:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 8008e68:	611a      	str	r2, [r3, #16]

#ifndef TX_NOT_INTERRUPTABLE

                /* Determine if there is any delayed event clearing to perform.  */
                if (group_ptr -> tx_event_flags_group_delayed_clear != ((ULONG) 0))
 8008e6a:	68fb      	ldr	r3, [r7, #12]
 8008e6c:	6a1b      	ldr	r3, [r3, #32]
 8008e6e:	2b00      	cmp	r3, #0
 8008e70:	d00a      	beq.n	8008e88 <_tx_event_flags_set+0x39c>
                {

                    /* Perform the delayed event clearing.  */
                    group_ptr -> tx_event_flags_group_current =
                        group_ptr -> tx_event_flags_group_current & ~(group_ptr -> tx_event_flags_group_delayed_clear);
 8008e72:	68fb      	ldr	r3, [r7, #12]
 8008e74:	689a      	ldr	r2, [r3, #8]
 8008e76:	68fb      	ldr	r3, [r7, #12]
 8008e78:	6a1b      	ldr	r3, [r3, #32]
 8008e7a:	43db      	mvns	r3, r3
 8008e7c:	401a      	ands	r2, r3
                    group_ptr -> tx_event_flags_group_current =
 8008e7e:	68fb      	ldr	r3, [r7, #12]
 8008e80:	609a      	str	r2, [r3, #8]

                    /* Clear the delayed event flag clear value.  */
                    group_ptr -> tx_event_flags_group_delayed_clear =  ((ULONG) 0);
 8008e82:	68fb      	ldr	r3, [r7, #12]
 8008e84:	2200      	movs	r2, #0
 8008e86:	621a      	str	r2, [r3, #32]
 8008e88:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8008e8c:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8008e8e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008e90:	f383 8810 	msr	PRIMASK, r3
}
 8008e94:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Walk through the satisfied list, setup initial thread pointer. */
                thread_ptr =  satisfied_list;
 8008e96:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8008e9a:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
                while(thread_ptr != TX_NULL)
 8008e9e:	e01f      	b.n	8008ee0 <_tx_event_flags_set+0x3f4>
                {

                    /* Get next pointer first.  */
                    next_thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 8008ea0:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008ea4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008ea6:	673b      	str	r3, [r7, #112]	; 0x70
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8008ea8:	f3ef 8310 	mrs	r3, PRIMASK
 8008eac:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 8008eae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 8008eb0:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 8008eb2:	b672      	cpsid	i
    return(int_posture);
 8008eb4:	6a3b      	ldr	r3, [r7, #32]

                    /* Disable interrupts.  */
                    TX_DISABLE
 8008eb6:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
                    /* Restore interrupts.  */
                    TX_RESTORE
#else

                    /* Disable preemption again.  */
                    _tx_thread_preempt_disable++;
 8008eba:	4b13      	ldr	r3, [pc, #76]	; (8008f08 <_tx_event_flags_set+0x41c>)
 8008ebc:	681b      	ldr	r3, [r3, #0]
 8008ebe:	3301      	adds	r3, #1
 8008ec0:	4a11      	ldr	r2, [pc, #68]	; (8008f08 <_tx_event_flags_set+0x41c>)
 8008ec2:	6013      	str	r3, [r2, #0]
 8008ec4:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8008ec8:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8008eca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008ecc:	f383 8810 	msr	PRIMASK, r3
}
 8008ed0:	bf00      	nop

                    /* Restore interrupt posture.  */
                    TX_RESTORE

                    /* Resume the thread.  */
                    _tx_thread_system_resume(thread_ptr);
 8008ed2:	f8d7 0098 	ldr.w	r0, [r7, #152]	; 0x98
 8008ed6:	f003 faa9 	bl	800c42c <_tx_thread_system_resume>
#endif

                    /* Move next thread to current.  */
                    thread_ptr =  next_thread_ptr;
 8008eda:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8008edc:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
                while(thread_ptr != TX_NULL)
 8008ee0:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008ee4:	2b00      	cmp	r3, #0
 8008ee6:	d1db      	bne.n	8008ea0 <_tx_event_flags_set+0x3b4>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8008ee8:	f3ef 8310 	mrs	r3, PRIMASK
 8008eec:	61fb      	str	r3, [r7, #28]
    return(posture);
 8008eee:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 8008ef0:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8008ef2:	b672      	cpsid	i
    return(int_posture);
 8008ef4:	69bb      	ldr	r3, [r7, #24]
                }

                /* Disable interrupts.  */
                TX_DISABLE
 8008ef6:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c

                /* Release thread preemption disable.  */
                _tx_thread_preempt_disable--;
 8008efa:	4b03      	ldr	r3, [pc, #12]	; (8008f08 <_tx_event_flags_set+0x41c>)
 8008efc:	681b      	ldr	r3, [r3, #0]
 8008efe:	3b01      	subs	r3, #1
 8008f00:	4a01      	ldr	r2, [pc, #4]	; (8008f08 <_tx_event_flags_set+0x41c>)
 8008f02:	6013      	str	r3, [r2, #0]
 8008f04:	e009      	b.n	8008f1a <_tx_event_flags_set+0x42e>
 8008f06:	bf00      	nop
 8008f08:	2000f054 	.word	0x2000f054
        }
        else
        {

            /* Determine if we need to set the reset search field.  */
            if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
 8008f0c:	68fb      	ldr	r3, [r7, #12]
 8008f0e:	695b      	ldr	r3, [r3, #20]
 8008f10:	2b00      	cmp	r3, #0
 8008f12:	d002      	beq.n	8008f1a <_tx_event_flags_set+0x42e>
            {

                /* We interrupted a search of an event flag group suspension
                   list.  Make sure we reset the search.  */
                group_ptr -> tx_event_flags_group_reset_search =  TX_TRUE;
 8008f14:	68fb      	ldr	r3, [r7, #12]
 8008f16:	2201      	movs	r2, #1
 8008f18:	60da      	str	r2, [r3, #12]
 8008f1a:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8008f1e:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8008f20:	697b      	ldr	r3, [r7, #20]
 8008f22:	f383 8810 	msr	PRIMASK, r3
}
 8008f26:	bf00      	nop
        TX_RESTORE

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Determine if a notify callback is required.  */
        if (events_set_notify != TX_NULL)
 8008f28:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8008f2a:	2b00      	cmp	r3, #0
 8008f2c:	d002      	beq.n	8008f34 <_tx_event_flags_set+0x448>
        {

            /* Call application event flags set notification.  */
            (events_set_notify)(group_ptr);
 8008f2e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8008f30:	68f8      	ldr	r0, [r7, #12]
 8008f32:	4798      	blx	r3
        }
#endif

        /* Determine if a check for preemption is necessary.  */
        if (preempt_check == TX_TRUE)
 8008f34:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8008f36:	2b01      	cmp	r3, #1
 8008f38:	d101      	bne.n	8008f3e <_tx_event_flags_set+0x452>
        {

            /* Yes, one or more threads were resumed, check for preemption.  */
            _tx_thread_system_preempt_check();
 8008f3a:	f003 fa3d 	bl	800c3b8 <_tx_thread_system_preempt_check>
        }
    }

    /* Return completion status.  */
    return(TX_SUCCESS);
 8008f3e:	2300      	movs	r3, #0
}
 8008f40:	4618      	mov	r0, r3
 8008f42:	37a0      	adds	r7, #160	; 0xa0
 8008f44:	46bd      	mov	sp, r7
 8008f46:	bd80      	pop	{r7, pc}

08008f48 <_tx_event_flags_set_notify>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_set_notify(TX_EVENT_FLAGS_GROUP *group_ptr, VOID (*events_set_notify)(TX_EVENT_FLAGS_GROUP *notify_group_ptr))
{
 8008f48:	b480      	push	{r7}
 8008f4a:	b087      	sub	sp, #28
 8008f4c:	af00      	add	r7, sp, #0
 8008f4e:	6078      	str	r0, [r7, #4]
 8008f50:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8008f52:	f3ef 8310 	mrs	r3, PRIMASK
 8008f56:	60fb      	str	r3, [r7, #12]
    return(posture);
 8008f58:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 8008f5a:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 8008f5c:	b672      	cpsid	i
    return(int_posture);
 8008f5e:	68bb      	ldr	r3, [r7, #8]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts.  */
    TX_DISABLE
 8008f60:	617b      	str	r3, [r7, #20]

    /* Make entry in event log.  */
    TX_EL_EVENT_FLAGS_SET_NOTIFY_INSERT

    /* Setup event flag group set notification callback function.  */
    group_ptr -> tx_event_flags_group_set_notify =  events_set_notify;
 8008f62:	687b      	ldr	r3, [r7, #4]
 8008f64:	683a      	ldr	r2, [r7, #0]
 8008f66:	625a      	str	r2, [r3, #36]	; 0x24
 8008f68:	697b      	ldr	r3, [r7, #20]
 8008f6a:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8008f6c:	693b      	ldr	r3, [r7, #16]
 8008f6e:	f383 8810 	msr	PRIMASK, r3
}
 8008f72:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return success to caller.  */
    return(TX_SUCCESS);
 8008f74:	2300      	movs	r3, #0
#endif
}
 8008f76:	4618      	mov	r0, r3
 8008f78:	371c      	adds	r7, #28
 8008f7a:	46bd      	mov	sp, r7
 8008f7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008f80:	4770      	bx	lr
	...

08008f84 <_tx_initialize_high_level>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID    _tx_initialize_high_level(VOID)
{
 8008f84:	b580      	push	{r7, lr}
 8008f86:	af00      	add	r7, sp, #0

    /* Initialize the event log, if enabled.  */
    TX_EL_INITIALIZE

    /* Call the thread control initialization function.  */
    _tx_thread_initialize();
 8008f88:	f002 fdb6 	bl	800baf8 <_tx_thread_initialize>

#ifndef TX_NO_TIMER

    /* Call the timer control initialization function.  */
    _tx_timer_initialize();
 8008f8c:	f004 fa68 	bl	800d460 <_tx_timer_initialize>
#endif

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Call the semaphore initialization function.  */
    _tx_semaphore_initialize();
 8008f90:	4b12      	ldr	r3, [pc, #72]	; (8008fdc <_tx_initialize_high_level+0x58>)
 8008f92:	2200      	movs	r2, #0
 8008f94:	601a      	str	r2, [r3, #0]
 8008f96:	4b12      	ldr	r3, [pc, #72]	; (8008fe0 <_tx_initialize_high_level+0x5c>)
 8008f98:	2200      	movs	r2, #0
 8008f9a:	601a      	str	r2, [r3, #0]

    /* Call the queue initialization function.  */
    _tx_queue_initialize();
 8008f9c:	4b11      	ldr	r3, [pc, #68]	; (8008fe4 <_tx_initialize_high_level+0x60>)
 8008f9e:	2200      	movs	r2, #0
 8008fa0:	601a      	str	r2, [r3, #0]
 8008fa2:	4b11      	ldr	r3, [pc, #68]	; (8008fe8 <_tx_initialize_high_level+0x64>)
 8008fa4:	2200      	movs	r2, #0
 8008fa6:	601a      	str	r2, [r3, #0]

    /* Call the event flag initialization function.  */
    _tx_event_flags_initialize();
 8008fa8:	4b10      	ldr	r3, [pc, #64]	; (8008fec <_tx_initialize_high_level+0x68>)
 8008faa:	2200      	movs	r2, #0
 8008fac:	601a      	str	r2, [r3, #0]
 8008fae:	4b10      	ldr	r3, [pc, #64]	; (8008ff0 <_tx_initialize_high_level+0x6c>)
 8008fb0:	2200      	movs	r2, #0
 8008fb2:	601a      	str	r2, [r3, #0]

    /* Call the block pool initialization function.  */
    _tx_block_pool_initialize();
 8008fb4:	4b0f      	ldr	r3, [pc, #60]	; (8008ff4 <_tx_initialize_high_level+0x70>)
 8008fb6:	2200      	movs	r2, #0
 8008fb8:	601a      	str	r2, [r3, #0]
 8008fba:	4b0f      	ldr	r3, [pc, #60]	; (8008ff8 <_tx_initialize_high_level+0x74>)
 8008fbc:	2200      	movs	r2, #0
 8008fbe:	601a      	str	r2, [r3, #0]

    /* Call the byte pool initialization function.  */
    _tx_byte_pool_initialize();
 8008fc0:	4b0e      	ldr	r3, [pc, #56]	; (8008ffc <_tx_initialize_high_level+0x78>)
 8008fc2:	2200      	movs	r2, #0
 8008fc4:	601a      	str	r2, [r3, #0]
 8008fc6:	4b0e      	ldr	r3, [pc, #56]	; (8009000 <_tx_initialize_high_level+0x7c>)
 8008fc8:	2200      	movs	r2, #0
 8008fca:	601a      	str	r2, [r3, #0]

    /* Call the mutex initialization function.  */
    _tx_mutex_initialize();
 8008fcc:	4b0d      	ldr	r3, [pc, #52]	; (8009004 <_tx_initialize_high_level+0x80>)
 8008fce:	2200      	movs	r2, #0
 8008fd0:	601a      	str	r2, [r3, #0]
 8008fd2:	4b0d      	ldr	r3, [pc, #52]	; (8009008 <_tx_initialize_high_level+0x84>)
 8008fd4:	2200      	movs	r2, #0
 8008fd6:	601a      	str	r2, [r3, #0]
#endif
}
 8008fd8:	bf00      	nop
 8008fda:	bd80      	pop	{r7, pc}
 8008fdc:	2000ef80 	.word	0x2000ef80
 8008fe0:	2000ef84 	.word	0x2000ef84
 8008fe4:	2000ef88 	.word	0x2000ef88
 8008fe8:	2000ef8c 	.word	0x2000ef8c
 8008fec:	2000ef90 	.word	0x2000ef90
 8008ff0:	2000ef94 	.word	0x2000ef94
 8008ff4:	2000efa0 	.word	0x2000efa0
 8008ff8:	2000efa4 	.word	0x2000efa4
 8008ffc:	2000efa8 	.word	0x2000efa8
 8009000:	2000efac 	.word	0x2000efac
 8009004:	2000ef98 	.word	0x2000ef98
 8009008:	2000ef9c 	.word	0x2000ef9c

0800900c <_tx_initialize_kernel_enter>:
/*                                            added EPK initialization,   */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
VOID  _tx_initialize_kernel_enter(VOID)
{
 800900c:	b580      	push	{r7, lr}
 800900e:	af00      	add	r7, sp, #0

    /* Determine if the compiler has pre-initialized ThreadX.  */
    if (_tx_thread_system_state != TX_INITIALIZE_ALMOST_DONE)
 8009010:	4b10      	ldr	r3, [pc, #64]	; (8009054 <_tx_initialize_kernel_enter+0x48>)
 8009012:	681b      	ldr	r3, [r3, #0]
 8009014:	f113 3f0f 	cmn.w	r3, #252645135	; 0xf0f0f0f
 8009018:	d00c      	beq.n	8009034 <_tx_initialize_kernel_enter+0x28>
        /* No, the initialization still needs to take place.  */

        /* Ensure that the system state variable is set to indicate
           initialization is in progress.  Note that this variable is
           later used to represent interrupt nesting.  */
        _tx_thread_system_state =  TX_INITIALIZE_IN_PROGRESS;
 800901a:	4b0e      	ldr	r3, [pc, #56]	; (8009054 <_tx_initialize_kernel_enter+0x48>)
 800901c:	f04f 32f0 	mov.w	r2, #4042322160	; 0xf0f0f0f0
 8009020:	601a      	str	r2, [r3, #0]
        /* Call any port specific preprocessing.  */
        TX_PORT_SPECIFIC_PRE_INITIALIZATION

        /* Invoke the low-level initialization to handle all processor specific
           initialization issues.  */
        _tx_initialize_low_level();
 8009022:	f7f7 f92d 	bl	8000280 <_tx_initialize_low_level>

        /* Invoke the high-level initialization to exercise all of the
           ThreadX components and the application's initialization
           function.  */
        _tx_initialize_high_level();
 8009026:	f7ff ffad 	bl	8008f84 <_tx_initialize_high_level>

        /* Call any port specific post-processing.  */
        TX_PORT_SPECIFIC_POST_INITIALIZATION
 800902a:	4b0b      	ldr	r3, [pc, #44]	; (8009058 <_tx_initialize_kernel_enter+0x4c>)
 800902c:	681b      	ldr	r3, [r3, #0]
 800902e:	3301      	adds	r3, #1
 8009030:	4a09      	ldr	r2, [pc, #36]	; (8009058 <_tx_initialize_kernel_enter+0x4c>)
 8009032:	6013      	str	r3, [r2, #0]
    TX_INITIALIZE_KERNEL_ENTER_EXTENSION

    /* Ensure that the system state variable is set to indicate
       initialization is in progress.  Note that this variable is
       later used to represent interrupt nesting.  */
    _tx_thread_system_state =  TX_INITIALIZE_IN_PROGRESS;
 8009034:	4b07      	ldr	r3, [pc, #28]	; (8009054 <_tx_initialize_kernel_enter+0x48>)
 8009036:	f04f 32f0 	mov.w	r2, #4042322160	; 0xf0f0f0f0
 800903a:	601a      	str	r2, [r3, #0]

    /* Call the application provided initialization function.  Pass the
       first available memory address to it.  */
    tx_application_define(_tx_initialize_unused_memory);
 800903c:	4b07      	ldr	r3, [pc, #28]	; (800905c <_tx_initialize_kernel_enter+0x50>)
 800903e:	681b      	ldr	r3, [r3, #0]
 8009040:	4618      	mov	r0, r3
 8009042:	f7f7 fd83 	bl	8000b4c <tx_application_define>

    /* Set the system state in preparation for entering the thread
       scheduler.  */
    _tx_thread_system_state =  TX_INITIALIZE_IS_FINISHED;
 8009046:	4b03      	ldr	r3, [pc, #12]	; (8009054 <_tx_initialize_kernel_enter+0x48>)
 8009048:	2200      	movs	r2, #0
 800904a:	601a      	str	r2, [r3, #0]
    /* Initialize Execution Profile Kit.  */
    _tx_execution_initialize();
#endif

    /* Enter the scheduling loop to start executing threads!  */
    _tx_thread_schedule();
 800904c:	f7f7 f9b8 	bl	80003c0 <_tx_thread_schedule>
#ifdef TX_SAFETY_CRITICAL

    /* If we ever get here, raise safety critical exception.  */
    TX_SAFETY_CRITICAL_EXCEPTION(__FILE__, __LINE__, 0);
#endif
}
 8009050:	bf00      	nop
 8009052:	bd80      	pop	{r7, pc}
 8009054:	2000000c 	.word	0x2000000c
 8009058:	2000f054 	.word	0x2000f054
 800905c:	2000efb0 	.word	0x2000efb0

08009060 <_tx_mutex_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_cleanup(TX_THREAD  *thread_ptr, ULONG suspension_sequence)
{
 8009060:	b580      	push	{r7, lr}
 8009062:	b08e      	sub	sp, #56	; 0x38
 8009064:	af00      	add	r7, sp, #0
 8009066:	6078      	str	r0, [r7, #4]
 8009068:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800906a:	f3ef 8310 	mrs	r3, PRIMASK
 800906e:	623b      	str	r3, [r7, #32]
    return(posture);
 8009070:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 8009072:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 8009074:	b672      	cpsid	i
    return(int_posture);
 8009076:	69fb      	ldr	r3, [r7, #28]


#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the mutex.  */
    TX_DISABLE
 8009078:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_mutex_cleanup))
 800907a:	687b      	ldr	r3, [r7, #4]
 800907c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800907e:	4a33      	ldr	r2, [pc, #204]	; (800914c <_tx_mutex_cleanup+0xec>)
 8009080:	4293      	cmp	r3, r2
 8009082:	d158      	bne.n	8009136 <_tx_mutex_cleanup+0xd6>
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
 8009084:	687b      	ldr	r3, [r7, #4]
 8009086:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 800908a:	683a      	ldr	r2, [r7, #0]
 800908c:	429a      	cmp	r2, r3
 800908e:	d152      	bne.n	8009136 <_tx_mutex_cleanup+0xd6>
        {

            /* Setup pointer to mutex control block.  */
            mutex_ptr =  TX_VOID_TO_MUTEX_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
 8009090:	687b      	ldr	r3, [r7, #4]
 8009092:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8009094:	633b      	str	r3, [r7, #48]	; 0x30

            /* Check for NULL mutex pointer.  */
            if (mutex_ptr != TX_NULL)
 8009096:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009098:	2b00      	cmp	r3, #0
 800909a:	d04c      	beq.n	8009136 <_tx_mutex_cleanup+0xd6>
            {

                /* Determine if the mutex ID is valid.  */
                if (mutex_ptr -> tx_mutex_id == TX_MUTEX_ID)
 800909c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800909e:	681b      	ldr	r3, [r3, #0]
 80090a0:	4a2b      	ldr	r2, [pc, #172]	; (8009150 <_tx_mutex_cleanup+0xf0>)
 80090a2:	4293      	cmp	r3, r2
 80090a4:	d147      	bne.n	8009136 <_tx_mutex_cleanup+0xd6>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (mutex_ptr -> tx_mutex_suspended_count != TX_NO_SUSPENSIONS)
 80090a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80090a8:	69db      	ldr	r3, [r3, #28]
 80090aa:	2b00      	cmp	r3, #0
 80090ac:	d043      	beq.n	8009136 <_tx_mutex_cleanup+0xd6>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 80090ae:	687b      	ldr	r3, [r7, #4]
 80090b0:	2200      	movs	r2, #0
 80090b2:	669a      	str	r2, [r3, #104]	; 0x68

                        /* Decrement the suspension count.  */
                        mutex_ptr -> tx_mutex_suspended_count--;
 80090b4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80090b6:	69db      	ldr	r3, [r3, #28]
 80090b8:	1e5a      	subs	r2, r3, #1
 80090ba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80090bc:	61da      	str	r2, [r3, #28]

                        /* Pickup the suspended count.  */
                        suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
 80090be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80090c0:	69db      	ldr	r3, [r3, #28]
 80090c2:	62fb      	str	r3, [r7, #44]	; 0x2c

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
 80090c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80090c6:	2b00      	cmp	r3, #0
 80090c8:	d103      	bne.n	80090d2 <_tx_mutex_cleanup+0x72>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
 80090ca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80090cc:	2200      	movs	r2, #0
 80090ce:	619a      	str	r2, [r3, #24]
 80090d0:	e013      	b.n	80090fa <_tx_mutex_cleanup+0x9a>
                        {

                            /* At least one more thread is on the same suspension list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
 80090d2:	687b      	ldr	r3, [r7, #4]
 80090d4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80090d6:	62bb      	str	r3, [r7, #40]	; 0x28
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 80090d8:	687b      	ldr	r3, [r7, #4]
 80090da:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80090dc:	627b      	str	r3, [r7, #36]	; 0x24
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
 80090de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80090e0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80090e2:	675a      	str	r2, [r3, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
 80090e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80090e6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80090e8:	671a      	str	r2, [r3, #112]	; 0x70

                            /* Determine if we need to update the head pointer.  */
                            if (mutex_ptr -> tx_mutex_suspension_list == thread_ptr)
 80090ea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80090ec:	699b      	ldr	r3, [r3, #24]
 80090ee:	687a      	ldr	r2, [r7, #4]
 80090f0:	429a      	cmp	r2, r3
 80090f2:	d102      	bne.n	80090fa <_tx_mutex_cleanup+0x9a>
                            {

                                /* Update the list head pointer.  */
                                mutex_ptr -> tx_mutex_suspension_list =         next_thread;
 80090f4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80090f6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80090f8:	619a      	str	r2, [r3, #24]
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_MUTEX_SUSP)
 80090fa:	687b      	ldr	r3, [r7, #4]
 80090fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80090fe:	2b0d      	cmp	r3, #13
 8009100:	d119      	bne.n	8009136 <_tx_mutex_cleanup+0xd6>
                            /* Increment the number of timeouts on this semaphore.  */
                            mutex_ptr -> tx_mutex_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NOT_AVAILABLE;
 8009102:	687b      	ldr	r3, [r7, #4]
 8009104:	221d      	movs	r2, #29
 8009106:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 800910a:	4b12      	ldr	r3, [pc, #72]	; (8009154 <_tx_mutex_cleanup+0xf4>)
 800910c:	681b      	ldr	r3, [r3, #0]
 800910e:	3301      	adds	r3, #1
 8009110:	4a10      	ldr	r2, [pc, #64]	; (8009154 <_tx_mutex_cleanup+0xf4>)
 8009112:	6013      	str	r3, [r2, #0]
 8009114:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009116:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009118:	693b      	ldr	r3, [r7, #16]
 800911a:	f383 8810 	msr	PRIMASK, r3
}
 800911e:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
 8009120:	6878      	ldr	r0, [r7, #4]
 8009122:	f003 f983 	bl	800c42c <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009126:	f3ef 8310 	mrs	r3, PRIMASK
 800912a:	61bb      	str	r3, [r7, #24]
    return(posture);
 800912c:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800912e:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8009130:	b672      	cpsid	i
    return(int_posture);
 8009132:	697b      	ldr	r3, [r7, #20]

                            /* Disable interrupts.  */
                            TX_DISABLE
 8009134:	637b      	str	r3, [r7, #52]	; 0x34
 8009136:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009138:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800913a:	68fb      	ldr	r3, [r7, #12]
 800913c:	f383 8810 	msr	PRIMASK, r3
}
 8009140:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 8009142:	bf00      	nop
 8009144:	3738      	adds	r7, #56	; 0x38
 8009146:	46bd      	mov	sp, r7
 8009148:	bd80      	pop	{r7, pc}
 800914a:	bf00      	nop
 800914c:	08009061 	.word	0x08009061
 8009150:	4d555445 	.word	0x4d555445
 8009154:	2000f054 	.word	0x2000f054

08009158 <_tx_mutex_thread_release>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_thread_release(TX_THREAD  *thread_ptr)
{
 8009158:	b580      	push	{r7, lr}
 800915a:	b08a      	sub	sp, #40	; 0x28
 800915c:	af00      	add	r7, sp, #0
 800915e:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009160:	f3ef 8310 	mrs	r3, PRIMASK
 8009164:	61fb      	str	r3, [r7, #28]
    return(posture);
 8009166:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 8009168:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800916a:	b672      	cpsid	i
    return(int_posture);
 800916c:	69bb      	ldr	r3, [r7, #24]
UINT        status;
#endif


    /* Disable interrupts.  */
    TX_DISABLE
 800916e:	627b      	str	r3, [r7, #36]	; 0x24

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 8009170:	4b1a      	ldr	r3, [pc, #104]	; (80091dc <_tx_mutex_thread_release+0x84>)
 8009172:	681b      	ldr	r3, [r3, #0]
 8009174:	3301      	adds	r3, #1
 8009176:	4a19      	ldr	r2, [pc, #100]	; (80091dc <_tx_mutex_thread_release+0x84>)
 8009178:	6013      	str	r3, [r2, #0]
    /* Loop to look at all the mutexes.  */
    do
    {

        /* Pickup the mutex head pointer.  */
        mutex_ptr =  thread_ptr -> tx_thread_owned_mutex_list;
 800917a:	687b      	ldr	r3, [r7, #4]
 800917c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8009180:	623b      	str	r3, [r7, #32]

        /* Determine if there is a mutex.  */
        if (mutex_ptr != TX_NULL)
 8009182:	6a3b      	ldr	r3, [r7, #32]
 8009184:	2b00      	cmp	r3, #0
 8009186:	d017      	beq.n	80091b8 <_tx_mutex_thread_release+0x60>
        {

            /* Yes, set the ownership count to 1.  */
            mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
 8009188:	6a3b      	ldr	r3, [r7, #32]
 800918a:	2201      	movs	r2, #1
 800918c:	609a      	str	r2, [r3, #8]
 800918e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009190:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009192:	68fb      	ldr	r3, [r7, #12]
 8009194:	f383 8810 	msr	PRIMASK, r3
}
 8009198:	bf00      	nop
            do
            {
                status =  _tx_mutex_put(mutex_ptr);
            } while (status != TX_SUCCESS);
#else
            _tx_mutex_put(mutex_ptr);
 800919a:	6a38      	ldr	r0, [r7, #32]
 800919c:	f000 fc5e 	bl	8009a5c <_tx_mutex_put>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80091a0:	f3ef 8310 	mrs	r3, PRIMASK
 80091a4:	617b      	str	r3, [r7, #20]
    return(posture);
 80091a6:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 80091a8:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 80091aa:	b672      	cpsid	i
    return(int_posture);
 80091ac:	693b      	ldr	r3, [r7, #16]
#endif

            /* Disable interrupts.  */
            TX_DISABLE
 80091ae:	627b      	str	r3, [r7, #36]	; 0x24

            /* Move to the next mutex.  */
            mutex_ptr =  thread_ptr -> tx_thread_owned_mutex_list;
 80091b0:	687b      	ldr	r3, [r7, #4]
 80091b2:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 80091b6:	623b      	str	r3, [r7, #32]
        }
    } while (mutex_ptr != TX_NULL);
 80091b8:	6a3b      	ldr	r3, [r7, #32]
 80091ba:	2b00      	cmp	r3, #0
 80091bc:	d1dd      	bne.n	800917a <_tx_mutex_thread_release+0x22>

    /* Restore preemption.  */
    _tx_thread_preempt_disable--;
 80091be:	4b07      	ldr	r3, [pc, #28]	; (80091dc <_tx_mutex_thread_release+0x84>)
 80091c0:	681b      	ldr	r3, [r3, #0]
 80091c2:	3b01      	subs	r3, #1
 80091c4:	4a05      	ldr	r2, [pc, #20]	; (80091dc <_tx_mutex_thread_release+0x84>)
 80091c6:	6013      	str	r3, [r2, #0]
 80091c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80091ca:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80091cc:	68bb      	ldr	r3, [r7, #8]
 80091ce:	f383 8810 	msr	PRIMASK, r3
}
 80091d2:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE
}
 80091d4:	bf00      	nop
 80091d6:	3728      	adds	r7, #40	; 0x28
 80091d8:	46bd      	mov	sp, r7
 80091da:	bd80      	pop	{r7, pc}
 80091dc:	2000f054 	.word	0x2000f054

080091e0 <_tx_mutex_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_create(TX_MUTEX *mutex_ptr, CHAR *name_ptr, UINT inherit)
{
 80091e0:	b580      	push	{r7, lr}
 80091e2:	b08a      	sub	sp, #40	; 0x28
 80091e4:	af00      	add	r7, sp, #0
 80091e6:	60f8      	str	r0, [r7, #12]
 80091e8:	60b9      	str	r1, [r7, #8]
 80091ea:	607a      	str	r2, [r7, #4]
TX_MUTEX        *next_mutex;
TX_MUTEX        *previous_mutex;


    /* Initialize mutex control block to all zeros.  */
    TX_MEMSET(mutex_ptr, 0, (sizeof(TX_MUTEX)));
 80091ec:	2234      	movs	r2, #52	; 0x34
 80091ee:	2100      	movs	r1, #0
 80091f0:	68f8      	ldr	r0, [r7, #12]
 80091f2:	f00d fbf7 	bl	80169e4 <memset>

    /* Setup the basic mutex fields.  */
    mutex_ptr -> tx_mutex_name =             name_ptr;
 80091f6:	68fb      	ldr	r3, [r7, #12]
 80091f8:	68ba      	ldr	r2, [r7, #8]
 80091fa:	605a      	str	r2, [r3, #4]
    mutex_ptr -> tx_mutex_inherit =          inherit;
 80091fc:	68fb      	ldr	r3, [r7, #12]
 80091fe:	687a      	ldr	r2, [r7, #4]
 8009200:	611a      	str	r2, [r3, #16]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009202:	f3ef 8310 	mrs	r3, PRIMASK
 8009206:	61bb      	str	r3, [r7, #24]
    return(posture);
 8009208:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800920a:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800920c:	b672      	cpsid	i
    return(int_posture);
 800920e:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to place the mutex on the created list.  */
    TX_DISABLE
 8009210:	627b      	str	r3, [r7, #36]	; 0x24

    /* Setup the mutex ID to make it valid.  */
    mutex_ptr -> tx_mutex_id =  TX_MUTEX_ID;
 8009212:	68fb      	ldr	r3, [r7, #12]
 8009214:	4a1a      	ldr	r2, [pc, #104]	; (8009280 <_tx_mutex_create+0xa0>)
 8009216:	601a      	str	r2, [r3, #0]

    /* Setup the thread mutex release function pointer.  */
    _tx_thread_mutex_release =  &(_tx_mutex_thread_release);
 8009218:	4b1a      	ldr	r3, [pc, #104]	; (8009284 <_tx_mutex_create+0xa4>)
 800921a:	4a1b      	ldr	r2, [pc, #108]	; (8009288 <_tx_mutex_create+0xa8>)
 800921c:	601a      	str	r2, [r3, #0]

    /* Place the mutex on the list of created mutexes.  First,
       check for an empty list.  */
    if (_tx_mutex_created_count == TX_EMPTY)
 800921e:	4b1b      	ldr	r3, [pc, #108]	; (800928c <_tx_mutex_create+0xac>)
 8009220:	681b      	ldr	r3, [r3, #0]
 8009222:	2b00      	cmp	r3, #0
 8009224:	d109      	bne.n	800923a <_tx_mutex_create+0x5a>
    {

        /* The created mutex list is empty.  Add mutex to empty list.  */
        _tx_mutex_created_ptr =                   mutex_ptr;
 8009226:	4a1a      	ldr	r2, [pc, #104]	; (8009290 <_tx_mutex_create+0xb0>)
 8009228:	68fb      	ldr	r3, [r7, #12]
 800922a:	6013      	str	r3, [r2, #0]
        mutex_ptr -> tx_mutex_created_next =      mutex_ptr;
 800922c:	68fb      	ldr	r3, [r7, #12]
 800922e:	68fa      	ldr	r2, [r7, #12]
 8009230:	621a      	str	r2, [r3, #32]
        mutex_ptr -> tx_mutex_created_previous =  mutex_ptr;
 8009232:	68fb      	ldr	r3, [r7, #12]
 8009234:	68fa      	ldr	r2, [r7, #12]
 8009236:	625a      	str	r2, [r3, #36]	; 0x24
 8009238:	e011      	b.n	800925e <_tx_mutex_create+0x7e>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_mutex =      _tx_mutex_created_ptr;
 800923a:	4b15      	ldr	r3, [pc, #84]	; (8009290 <_tx_mutex_create+0xb0>)
 800923c:	681b      	ldr	r3, [r3, #0]
 800923e:	623b      	str	r3, [r7, #32]
        previous_mutex =  next_mutex -> tx_mutex_created_previous;
 8009240:	6a3b      	ldr	r3, [r7, #32]
 8009242:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009244:	61fb      	str	r3, [r7, #28]

        /* Place the new mutex in the list.  */
        next_mutex -> tx_mutex_created_previous =  mutex_ptr;
 8009246:	6a3b      	ldr	r3, [r7, #32]
 8009248:	68fa      	ldr	r2, [r7, #12]
 800924a:	625a      	str	r2, [r3, #36]	; 0x24
        previous_mutex -> tx_mutex_created_next =  mutex_ptr;
 800924c:	69fb      	ldr	r3, [r7, #28]
 800924e:	68fa      	ldr	r2, [r7, #12]
 8009250:	621a      	str	r2, [r3, #32]

        /* Setup this mutex's next and previous created links.  */
        mutex_ptr -> tx_mutex_created_previous =  previous_mutex;
 8009252:	68fb      	ldr	r3, [r7, #12]
 8009254:	69fa      	ldr	r2, [r7, #28]
 8009256:	625a      	str	r2, [r3, #36]	; 0x24
        mutex_ptr -> tx_mutex_created_next =      next_mutex;
 8009258:	68fb      	ldr	r3, [r7, #12]
 800925a:	6a3a      	ldr	r2, [r7, #32]
 800925c:	621a      	str	r2, [r3, #32]
    }

    /* Increment the ownership count.  */
    _tx_mutex_created_count++;
 800925e:	4b0b      	ldr	r3, [pc, #44]	; (800928c <_tx_mutex_create+0xac>)
 8009260:	681b      	ldr	r3, [r3, #0]
 8009262:	3301      	adds	r3, #1
 8009264:	4a09      	ldr	r2, [pc, #36]	; (800928c <_tx_mutex_create+0xac>)
 8009266:	6013      	str	r3, [r2, #0]
 8009268:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800926a:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800926c:	693b      	ldr	r3, [r7, #16]
 800926e:	f383 8810 	msr	PRIMASK, r3
}
 8009272:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 8009274:	2300      	movs	r3, #0
}
 8009276:	4618      	mov	r0, r3
 8009278:	3728      	adds	r7, #40	; 0x28
 800927a:	46bd      	mov	sp, r7
 800927c:	bd80      	pop	{r7, pc}
 800927e:	bf00      	nop
 8009280:	4d555445 	.word	0x4d555445
 8009284:	2000f058 	.word	0x2000f058
 8009288:	08009159 	.word	0x08009159
 800928c:	2000ef9c 	.word	0x2000ef9c
 8009290:	2000ef98 	.word	0x2000ef98

08009294 <_tx_mutex_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_delete(TX_MUTEX *mutex_ptr)
{
 8009294:	b580      	push	{r7, lr}
 8009296:	b096      	sub	sp, #88	; 0x58
 8009298:	af00      	add	r7, sp, #0
 800929a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800929c:	f3ef 8310 	mrs	r3, PRIMASK
 80092a0:	63bb      	str	r3, [r7, #56]	; 0x38
    return(posture);
 80092a2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    int_posture = __get_interrupt_posture();
 80092a4:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile ("CPSID i" : : : "memory");
 80092a6:	b672      	cpsid	i
    return(int_posture);
 80092a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
#ifdef TX_MISRA_ENABLE
UINT            status;
#endif

    /* Disable interrupts to remove the mutex from the created list.  */
    TX_DISABLE
 80092aa:	657b      	str	r3, [r7, #84]	; 0x54

    /* Log this kernel call.  */
    TX_EL_MUTEX_DELETE_INSERT

    /* Clear the mutex ID to make it invalid.  */
    mutex_ptr -> tx_mutex_id =  TX_CLEAR_ID;
 80092ac:	687b      	ldr	r3, [r7, #4]
 80092ae:	2200      	movs	r2, #0
 80092b0:	601a      	str	r2, [r3, #0]

    /* Decrement the created count.  */
    _tx_mutex_created_count--;
 80092b2:	4b4a      	ldr	r3, [pc, #296]	; (80093dc <_tx_mutex_delete+0x148>)
 80092b4:	681b      	ldr	r3, [r3, #0]
 80092b6:	3b01      	subs	r3, #1
 80092b8:	4a48      	ldr	r2, [pc, #288]	; (80093dc <_tx_mutex_delete+0x148>)
 80092ba:	6013      	str	r3, [r2, #0]

    /* See if the mutex is the only one on the list.  */
    if (_tx_mutex_created_count == TX_EMPTY)
 80092bc:	4b47      	ldr	r3, [pc, #284]	; (80093dc <_tx_mutex_delete+0x148>)
 80092be:	681b      	ldr	r3, [r3, #0]
 80092c0:	2b00      	cmp	r3, #0
 80092c2:	d103      	bne.n	80092cc <_tx_mutex_delete+0x38>
    {

        /* Only created mutex, just set the created list to NULL.  */
        _tx_mutex_created_ptr =  TX_NULL;
 80092c4:	4b46      	ldr	r3, [pc, #280]	; (80093e0 <_tx_mutex_delete+0x14c>)
 80092c6:	2200      	movs	r2, #0
 80092c8:	601a      	str	r2, [r3, #0]
 80092ca:	e013      	b.n	80092f4 <_tx_mutex_delete+0x60>
    }
    else
    {

        /* Link-up the neighbors.  */
        next_mutex =                               mutex_ptr -> tx_mutex_created_next;
 80092cc:	687b      	ldr	r3, [r7, #4]
 80092ce:	6a1b      	ldr	r3, [r3, #32]
 80092d0:	64bb      	str	r3, [r7, #72]	; 0x48
        previous_mutex =                           mutex_ptr -> tx_mutex_created_previous;
 80092d2:	687b      	ldr	r3, [r7, #4]
 80092d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80092d6:	647b      	str	r3, [r7, #68]	; 0x44
        next_mutex -> tx_mutex_created_previous =  previous_mutex;
 80092d8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80092da:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80092dc:	625a      	str	r2, [r3, #36]	; 0x24
        previous_mutex -> tx_mutex_created_next =  next_mutex;
 80092de:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80092e0:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80092e2:	621a      	str	r2, [r3, #32]

        /* See if we have to update the created list head pointer.  */
        if (_tx_mutex_created_ptr == mutex_ptr)
 80092e4:	4b3e      	ldr	r3, [pc, #248]	; (80093e0 <_tx_mutex_delete+0x14c>)
 80092e6:	681b      	ldr	r3, [r3, #0]
 80092e8:	687a      	ldr	r2, [r7, #4]
 80092ea:	429a      	cmp	r2, r3
 80092ec:	d102      	bne.n	80092f4 <_tx_mutex_delete+0x60>
        {

            /* Yes, move the head pointer to the next link. */
            _tx_mutex_created_ptr =  next_mutex;
 80092ee:	4a3c      	ldr	r2, [pc, #240]	; (80093e0 <_tx_mutex_delete+0x14c>)
 80092f0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80092f2:	6013      	str	r3, [r2, #0]
        }
    }

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 80092f4:	4b3b      	ldr	r3, [pc, #236]	; (80093e4 <_tx_mutex_delete+0x150>)
 80092f6:	681b      	ldr	r3, [r3, #0]
 80092f8:	3301      	adds	r3, #1
 80092fa:	4a3a      	ldr	r2, [pc, #232]	; (80093e4 <_tx_mutex_delete+0x150>)
 80092fc:	6013      	str	r3, [r2, #0]

    /* Pickup the suspension information.  */
    thread_ptr =                             mutex_ptr -> tx_mutex_suspension_list;
 80092fe:	687b      	ldr	r3, [r7, #4]
 8009300:	699b      	ldr	r3, [r3, #24]
 8009302:	653b      	str	r3, [r7, #80]	; 0x50
    mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
 8009304:	687b      	ldr	r3, [r7, #4]
 8009306:	2200      	movs	r2, #0
 8009308:	619a      	str	r2, [r3, #24]
    suspended_count =                        mutex_ptr -> tx_mutex_suspended_count;
 800930a:	687b      	ldr	r3, [r7, #4]
 800930c:	69db      	ldr	r3, [r3, #28]
 800930e:	64fb      	str	r3, [r7, #76]	; 0x4c
    mutex_ptr -> tx_mutex_suspended_count =  TX_NO_SUSPENSIONS;
 8009310:	687b      	ldr	r3, [r7, #4]
 8009312:	2200      	movs	r2, #0
 8009314:	61da      	str	r2, [r3, #28]


    /* Determine if the mutex is currently on a thread's ownership list.  */

    /* Setup pointer to owner of mutex.  */
    owner_thread =  mutex_ptr -> tx_mutex_owner;
 8009316:	687b      	ldr	r3, [r7, #4]
 8009318:	68db      	ldr	r3, [r3, #12]
 800931a:	643b      	str	r3, [r7, #64]	; 0x40

    /* Determine if there is a valid thread pointer.  */
    if (owner_thread != TX_NULL)
 800931c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800931e:	2b00      	cmp	r3, #0
 8009320:	d013      	beq.n	800934a <_tx_mutex_delete+0xb6>
    {

        /* Yes, remove this mutex from the owned list.  */

        /* Set the ownership count to 1.  */
        mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
 8009322:	687b      	ldr	r3, [r7, #4]
 8009324:	2201      	movs	r2, #1
 8009326:	609a      	str	r2, [r3, #8]
 8009328:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800932a:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800932c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800932e:	f383 8810 	msr	PRIMASK, r3
}
 8009332:	bf00      	nop
        do
        {
            status =  _tx_mutex_put(mutex_ptr);
        } while (status != TX_SUCCESS);
#else
        _tx_mutex_put(mutex_ptr);
 8009334:	6878      	ldr	r0, [r7, #4]
 8009336:	f000 fb91 	bl	8009a5c <_tx_mutex_put>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800933a:	f3ef 8310 	mrs	r3, PRIMASK
 800933e:	633b      	str	r3, [r7, #48]	; 0x30
    return(posture);
 8009340:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    int_posture = __get_interrupt_posture();
 8009342:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("CPSID i" : : : "memory");
 8009344:	b672      	cpsid	i
    return(int_posture);
 8009346:	6afb      	ldr	r3, [r7, #44]	; 0x2c
#endif

        /* Disable interrupts.  */
        TX_DISABLE
 8009348:	657b      	str	r3, [r7, #84]	; 0x54
 800934a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800934c:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800934e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009350:	f383 8810 	msr	PRIMASK, r3
}
 8009354:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the mutex list to resume any and all threads suspended
       on this mutex.  */
    while (suspended_count != ((ULONG) 0))
 8009356:	e024      	b.n	80093a2 <_tx_mutex_delete+0x10e>
    {

        /* Decrement the suspension count.  */
        suspended_count--;
 8009358:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800935a:	3b01      	subs	r3, #1
 800935c:	64fb      	str	r3, [r7, #76]	; 0x4c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800935e:	f3ef 8310 	mrs	r3, PRIMASK
 8009362:	61fb      	str	r3, [r7, #28]
    return(posture);
 8009364:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 8009366:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8009368:	b672      	cpsid	i
    return(int_posture);
 800936a:	69bb      	ldr	r3, [r7, #24]

        /* Lockout interrupts.  */
        TX_DISABLE
 800936c:	657b      	str	r3, [r7, #84]	; 0x54

        /* Clear the cleanup pointer, this prevents the timeout from doing
           anything.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800936e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8009370:	2200      	movs	r2, #0
 8009372:	669a      	str	r2, [r3, #104]	; 0x68

        /* Set the return status in the thread to TX_DELETED.  */
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
 8009374:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8009376:	2201      	movs	r2, #1
 8009378:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Move the thread pointer ahead.  */
        next_thread =  thread_ptr -> tx_thread_suspended_next;
 800937c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800937e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8009380:	63fb      	str	r3, [r7, #60]	; 0x3c
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption again.  */
        _tx_thread_preempt_disable++;
 8009382:	4b18      	ldr	r3, [pc, #96]	; (80093e4 <_tx_mutex_delete+0x150>)
 8009384:	681b      	ldr	r3, [r3, #0]
 8009386:	3301      	adds	r3, #1
 8009388:	4a16      	ldr	r2, [pc, #88]	; (80093e4 <_tx_mutex_delete+0x150>)
 800938a:	6013      	str	r3, [r2, #0]
 800938c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800938e:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009390:	6a3b      	ldr	r3, [r7, #32]
 8009392:	f383 8810 	msr	PRIMASK, r3
}
 8009396:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
 8009398:	6d38      	ldr	r0, [r7, #80]	; 0x50
 800939a:	f003 f847 	bl	800c42c <_tx_thread_system_resume>
#endif

        /* Move to next thread.  */
        thread_ptr =  next_thread;
 800939e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80093a0:	653b      	str	r3, [r7, #80]	; 0x50
    while (suspended_count != ((ULONG) 0))
 80093a2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80093a4:	2b00      	cmp	r3, #0
 80093a6:	d1d7      	bne.n	8009358 <_tx_mutex_delete+0xc4>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80093a8:	f3ef 8310 	mrs	r3, PRIMASK
 80093ac:	613b      	str	r3, [r7, #16]
    return(posture);
 80093ae:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 80093b0:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 80093b2:	b672      	cpsid	i
    return(int_posture);
 80093b4:	68fb      	ldr	r3, [r7, #12]

    /* Execute Port-Specific completion processing. If needed, it is typically defined in tx_port.h.  */
    TX_MUTEX_DELETE_PORT_COMPLETION(mutex_ptr)

    /* Disable interrupts.  */
    TX_DISABLE
 80093b6:	657b      	str	r3, [r7, #84]	; 0x54

    /* Release previous preempt disable.  */
    _tx_thread_preempt_disable--;
 80093b8:	4b0a      	ldr	r3, [pc, #40]	; (80093e4 <_tx_mutex_delete+0x150>)
 80093ba:	681b      	ldr	r3, [r3, #0]
 80093bc:	3b01      	subs	r3, #1
 80093be:	4a09      	ldr	r2, [pc, #36]	; (80093e4 <_tx_mutex_delete+0x150>)
 80093c0:	6013      	str	r3, [r2, #0]
 80093c2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80093c4:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80093c6:	697b      	ldr	r3, [r7, #20]
 80093c8:	f383 8810 	msr	PRIMASK, r3
}
 80093cc:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 80093ce:	f002 fff3 	bl	800c3b8 <_tx_thread_system_preempt_check>

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 80093d2:	2300      	movs	r3, #0
}
 80093d4:	4618      	mov	r0, r3
 80093d6:	3758      	adds	r7, #88	; 0x58
 80093d8:	46bd      	mov	sp, r7
 80093da:	bd80      	pop	{r7, pc}
 80093dc:	2000ef9c 	.word	0x2000ef9c
 80093e0:	2000ef98 	.word	0x2000ef98
 80093e4:	2000f054 	.word	0x2000f054

080093e8 <_tx_mutex_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_get(TX_MUTEX *mutex_ptr, ULONG wait_option)
{
 80093e8:	b580      	push	{r7, lr}
 80093ea:	b092      	sub	sp, #72	; 0x48
 80093ec:	af00      	add	r7, sp, #0
 80093ee:	6078      	str	r0, [r7, #4]
 80093f0:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80093f2:	f3ef 8310 	mrs	r3, PRIMASK
 80093f6:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 80093f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 80093fa:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 80093fc:	b672      	cpsid	i
    return(int_posture);
 80093fe:	6a3b      	ldr	r3, [r7, #32]
TX_THREAD       *previous_thread;
UINT            status;


    /* Disable interrupts to get an instance from the mutex.  */
    TX_DISABLE
 8009400:	643b      	str	r3, [r7, #64]	; 0x40

    /* Log this kernel call.  */
    TX_EL_MUTEX_GET_INSERT

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 8009402:	4b7a      	ldr	r3, [pc, #488]	; (80095ec <_tx_mutex_get+0x204>)
 8009404:	681b      	ldr	r3, [r3, #0]
 8009406:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Determine if this mutex is available.  */
    if (mutex_ptr -> tx_mutex_ownership_count == ((UINT) 0))
 8009408:	687b      	ldr	r3, [r7, #4]
 800940a:	689b      	ldr	r3, [r3, #8]
 800940c:	2b00      	cmp	r3, #0
 800940e:	d144      	bne.n	800949a <_tx_mutex_get+0xb2>
    {

        /* Set the ownership count to 1.  */
        mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
 8009410:	687b      	ldr	r3, [r7, #4]
 8009412:	2201      	movs	r2, #1
 8009414:	609a      	str	r2, [r3, #8]

        /* Remember that the calling thread owns the mutex.  */
        mutex_ptr -> tx_mutex_owner =  thread_ptr;
 8009416:	687b      	ldr	r3, [r7, #4]
 8009418:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800941a:	60da      	str	r2, [r3, #12]

        /* Determine if the thread pointer is valid.  */
        if (thread_ptr != TX_NULL)
 800941c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800941e:	2b00      	cmp	r3, #0
 8009420:	d032      	beq.n	8009488 <_tx_mutex_get+0xa0>
        {

            /* Determine if priority inheritance is required.  */
            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 8009422:	687b      	ldr	r3, [r7, #4]
 8009424:	691b      	ldr	r3, [r3, #16]
 8009426:	2b01      	cmp	r3, #1
 8009428:	d106      	bne.n	8009438 <_tx_mutex_get+0x50>
            {

                /* Remember the current priority of thread.  */
                mutex_ptr -> tx_mutex_original_priority =   thread_ptr -> tx_thread_priority;
 800942a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800942c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800942e:	687b      	ldr	r3, [r7, #4]
 8009430:	615a      	str	r2, [r3, #20]

                /* Setup the highest priority waiting thread.  */
                mutex_ptr -> tx_mutex_highest_priority_waiting =  ((UINT) TX_MAX_PRIORITIES);
 8009432:	687b      	ldr	r3, [r7, #4]
 8009434:	2220      	movs	r2, #32
 8009436:	629a      	str	r2, [r3, #40]	; 0x28
            }

            /* Pickup next mutex pointer, which is the head of the list.  */
            next_mutex =  thread_ptr -> tx_thread_owned_mutex_list;
 8009438:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800943a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800943e:	62fb      	str	r3, [r7, #44]	; 0x2c

            /* Determine if this thread owns any other mutexes that have priority inheritance.  */
            if (next_mutex != TX_NULL)
 8009440:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009442:	2b00      	cmp	r3, #0
 8009444:	d00f      	beq.n	8009466 <_tx_mutex_get+0x7e>
            {

                /* Non-empty list. Link up the mutex.  */

                /* Pickup the next and previous mutex pointer.  */
                previous_mutex =  next_mutex -> tx_mutex_owned_previous;
 8009446:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009448:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800944a:	62bb      	str	r3, [r7, #40]	; 0x28

                /* Place the owned mutex in the list.  */
                next_mutex -> tx_mutex_owned_previous =  mutex_ptr;
 800944c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800944e:	687a      	ldr	r2, [r7, #4]
 8009450:	631a      	str	r2, [r3, #48]	; 0x30
                previous_mutex -> tx_mutex_owned_next =  mutex_ptr;
 8009452:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009454:	687a      	ldr	r2, [r7, #4]
 8009456:	62da      	str	r2, [r3, #44]	; 0x2c

                /* Setup this mutex's next and previous created links.  */
                mutex_ptr -> tx_mutex_owned_previous =  previous_mutex;
 8009458:	687b      	ldr	r3, [r7, #4]
 800945a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800945c:	631a      	str	r2, [r3, #48]	; 0x30
                mutex_ptr -> tx_mutex_owned_next =      next_mutex;
 800945e:	687b      	ldr	r3, [r7, #4]
 8009460:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8009462:	62da      	str	r2, [r3, #44]	; 0x2c
 8009464:	e009      	b.n	800947a <_tx_mutex_get+0x92>
            }
            else
            {

                /* The owned mutex list is empty.  Add mutex to empty list.  */
                thread_ptr -> tx_thread_owned_mutex_list =     mutex_ptr;
 8009466:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009468:	687a      	ldr	r2, [r7, #4]
 800946a:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
                mutex_ptr -> tx_mutex_owned_next =             mutex_ptr;
 800946e:	687b      	ldr	r3, [r7, #4]
 8009470:	687a      	ldr	r2, [r7, #4]
 8009472:	62da      	str	r2, [r3, #44]	; 0x2c
                mutex_ptr -> tx_mutex_owned_previous =         mutex_ptr;
 8009474:	687b      	ldr	r3, [r7, #4]
 8009476:	687a      	ldr	r2, [r7, #4]
 8009478:	631a      	str	r2, [r3, #48]	; 0x30
            }

            /* Increment the number of mutexes owned counter.  */
            thread_ptr -> tx_thread_owned_mutex_count++;
 800947a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800947c:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8009480:	1c5a      	adds	r2, r3, #1
 8009482:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009484:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
 8009488:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800948a:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800948c:	69fb      	ldr	r3, [r7, #28]
 800948e:	f383 8810 	msr	PRIMASK, r3
}
 8009492:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return success.  */
        status =  TX_SUCCESS;
 8009494:	2300      	movs	r3, #0
 8009496:	647b      	str	r3, [r7, #68]	; 0x44
 8009498:	e0a2      	b.n	80095e0 <_tx_mutex_get+0x1f8>
    }

    /* Otherwise, see if the owning thread is trying to obtain the same mutex.  */
    else if (mutex_ptr -> tx_mutex_owner == thread_ptr)
 800949a:	687b      	ldr	r3, [r7, #4]
 800949c:	68db      	ldr	r3, [r3, #12]
 800949e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80094a0:	429a      	cmp	r2, r3
 80094a2:	d10d      	bne.n	80094c0 <_tx_mutex_get+0xd8>
    {

        /* The owning thread is requesting the mutex again, just
           increment the ownership count.  */
        mutex_ptr -> tx_mutex_ownership_count++;
 80094a4:	687b      	ldr	r3, [r7, #4]
 80094a6:	689b      	ldr	r3, [r3, #8]
 80094a8:	1c5a      	adds	r2, r3, #1
 80094aa:	687b      	ldr	r3, [r7, #4]
 80094ac:	609a      	str	r2, [r3, #8]
 80094ae:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80094b0:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80094b2:	69bb      	ldr	r3, [r7, #24]
 80094b4:	f383 8810 	msr	PRIMASK, r3
}
 80094b8:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return success.  */
        status =  TX_SUCCESS;
 80094ba:	2300      	movs	r3, #0
 80094bc:	647b      	str	r3, [r7, #68]	; 0x44
 80094be:	e08f      	b.n	80095e0 <_tx_mutex_get+0x1f8>
    }
    else
    {

        /* Determine if the request specifies suspension.  */
        if (wait_option != TX_NO_WAIT)
 80094c0:	683b      	ldr	r3, [r7, #0]
 80094c2:	2b00      	cmp	r3, #0
 80094c4:	f000 8084 	beq.w	80095d0 <_tx_mutex_get+0x1e8>
        {

            /* Determine if the preempt disable flag is non-zero.  */
            if (_tx_thread_preempt_disable != ((UINT) 0))
 80094c8:	4b49      	ldr	r3, [pc, #292]	; (80095f0 <_tx_mutex_get+0x208>)
 80094ca:	681b      	ldr	r3, [r3, #0]
 80094cc:	2b00      	cmp	r3, #0
 80094ce:	d008      	beq.n	80094e2 <_tx_mutex_get+0xfa>
 80094d0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80094d2:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80094d4:	697b      	ldr	r3, [r7, #20]
 80094d6:	f383 8810 	msr	PRIMASK, r3
}
 80094da:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
                status =  TX_NOT_AVAILABLE;
 80094dc:	231d      	movs	r3, #29
 80094de:	647b      	str	r3, [r7, #68]	; 0x44
 80094e0:	e07e      	b.n	80095e0 <_tx_mutex_get+0x1f8>
            {

                /* Prepare for suspension of this thread.  */

                /* Pickup the mutex owner.  */
                mutex_owner =  mutex_ptr -> tx_mutex_owner;
 80094e2:	687b      	ldr	r3, [r7, #4]
 80094e4:	68db      	ldr	r3, [r3, #12]
 80094e6:	63bb      	str	r3, [r7, #56]	; 0x38
#endif
                }
#endif

                /* Setup cleanup routine pointer.  */
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_mutex_cleanup);
 80094e8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80094ea:	4a42      	ldr	r2, [pc, #264]	; (80095f4 <_tx_mutex_get+0x20c>)
 80094ec:	669a      	str	r2, [r3, #104]	; 0x68

                /* Setup cleanup information, i.e. this mutex control
                   block.  */
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) mutex_ptr;
 80094ee:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80094f0:	687a      	ldr	r2, [r7, #4]
 80094f2:	66da      	str	r2, [r3, #108]	; 0x6c

#ifndef TX_NOT_INTERRUPTABLE

                /* Increment the suspension sequence number, which is used to identify
                   this suspension event.  */
                thread_ptr -> tx_thread_suspension_sequence++;
 80094f4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80094f6:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 80094fa:	1c5a      	adds	r2, r3, #1
 80094fc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80094fe:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
#endif

                /* Setup suspension list.  */
                if (mutex_ptr -> tx_mutex_suspended_count == TX_NO_SUSPENSIONS)
 8009502:	687b      	ldr	r3, [r7, #4]
 8009504:	69db      	ldr	r3, [r3, #28]
 8009506:	2b00      	cmp	r3, #0
 8009508:	d109      	bne.n	800951e <_tx_mutex_get+0x136>
                {

                    /* No other threads are suspended.  Setup the head pointer and
                       just setup this threads pointers to itself.  */
                    mutex_ptr -> tx_mutex_suspension_list =         thread_ptr;
 800950a:	687b      	ldr	r3, [r7, #4]
 800950c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800950e:	619a      	str	r2, [r3, #24]
                    thread_ptr -> tx_thread_suspended_next =        thread_ptr;
 8009510:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009512:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009514:	671a      	str	r2, [r3, #112]	; 0x70
                    thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
 8009516:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009518:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800951a:	675a      	str	r2, [r3, #116]	; 0x74
 800951c:	e011      	b.n	8009542 <_tx_mutex_get+0x15a>
                }
                else
                {

                    /* This list is not NULL, add current thread to the end. */
                    next_thread =                                   mutex_ptr -> tx_mutex_suspension_list;
 800951e:	687b      	ldr	r3, [r7, #4]
 8009520:	699b      	ldr	r3, [r3, #24]
 8009522:	637b      	str	r3, [r7, #52]	; 0x34
                    thread_ptr -> tx_thread_suspended_next =        next_thread;
 8009524:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009526:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8009528:	671a      	str	r2, [r3, #112]	; 0x70
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
 800952a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800952c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800952e:	633b      	str	r3, [r7, #48]	; 0x30
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 8009530:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009532:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8009534:	675a      	str	r2, [r3, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
 8009536:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009538:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800953a:	671a      	str	r2, [r3, #112]	; 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
 800953c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800953e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009540:	675a      	str	r2, [r3, #116]	; 0x74
                }

                /* Increment the suspension count.  */
                mutex_ptr -> tx_mutex_suspended_count++;
 8009542:	687b      	ldr	r3, [r7, #4]
 8009544:	69db      	ldr	r3, [r3, #28]
 8009546:	1c5a      	adds	r2, r3, #1
 8009548:	687b      	ldr	r3, [r7, #4]
 800954a:	61da      	str	r2, [r3, #28]

                /* Set the state to suspended.  */
                thread_ptr -> tx_thread_state =    TX_MUTEX_SUSP;
 800954c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800954e:	220d      	movs	r2, #13
 8009550:	631a      	str	r2, [r3, #48]	; 0x30
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Set the suspending flag.  */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
 8009552:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009554:	2201      	movs	r2, #1
 8009556:	639a      	str	r2, [r3, #56]	; 0x38

                /* Setup the timeout period.  */
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 8009558:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800955a:	683a      	ldr	r2, [r7, #0]
 800955c:	64da      	str	r2, [r3, #76]	; 0x4c

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
 800955e:	4b24      	ldr	r3, [pc, #144]	; (80095f0 <_tx_mutex_get+0x208>)
 8009560:	681b      	ldr	r3, [r3, #0]
 8009562:	3301      	adds	r3, #1
 8009564:	4a22      	ldr	r2, [pc, #136]	; (80095f0 <_tx_mutex_get+0x208>)
 8009566:	6013      	str	r3, [r2, #0]
 8009568:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800956a:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800956c:	693b      	ldr	r3, [r7, #16]
 800956e:	f383 8810 	msr	PRIMASK, r3
}
 8009572:	bf00      	nop
                /* Restore interrupts.  */
                TX_RESTORE

                /* Determine if we need to raise the priority of the thread
                   owning the mutex.  */
                if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 8009574:	687b      	ldr	r3, [r7, #4]
 8009576:	691b      	ldr	r3, [r3, #16]
 8009578:	2b01      	cmp	r3, #1
 800957a:	d121      	bne.n	80095c0 <_tx_mutex_get+0x1d8>
                {

                    /* Determine if this is the highest priority to raise for this mutex.  */
                    if (mutex_ptr -> tx_mutex_highest_priority_waiting > thread_ptr -> tx_thread_priority)
 800957c:	687b      	ldr	r3, [r7, #4]
 800957e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8009580:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009582:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009584:	429a      	cmp	r2, r3
 8009586:	d903      	bls.n	8009590 <_tx_mutex_get+0x1a8>
                    {

                        /* Remember this priority.  */
                        mutex_ptr -> tx_mutex_highest_priority_waiting =  thread_ptr -> tx_thread_priority;
 8009588:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800958a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800958c:	687b      	ldr	r3, [r7, #4]
 800958e:	629a      	str	r2, [r3, #40]	; 0x28
                    }

                    /* Determine if we have to update inherit priority level of the mutex owner.  */
                    if (thread_ptr -> tx_thread_priority < mutex_owner -> tx_thread_inherit_priority)
 8009590:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009592:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8009594:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009596:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 800959a:	429a      	cmp	r2, r3
 800959c:	d204      	bcs.n	80095a8 <_tx_mutex_get+0x1c0>
                    {

                        /* Remember the new priority inheritance priority.  */
                        mutex_owner -> tx_thread_inherit_priority =  thread_ptr -> tx_thread_priority;
 800959e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80095a0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80095a2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80095a4:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
                    }

                    /* Priority inheritance is requested, check to see if the thread that owns the mutex is lower priority.  */
                    if (mutex_owner -> tx_thread_priority > thread_ptr -> tx_thread_priority)
 80095a8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80095aa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80095ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80095ae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80095b0:	429a      	cmp	r2, r3
 80095b2:	d905      	bls.n	80095c0 <_tx_mutex_get+0x1d8>
                    {

                        /* Yes, raise the suspended, owning thread's priority to that
                           of the current thread.  */
                        _tx_mutex_priority_change(mutex_owner, thread_ptr -> tx_thread_priority);
 80095b4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80095b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80095b8:	4619      	mov	r1, r3
 80095ba:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80095bc:	f000 f982 	bl	80098c4 <_tx_mutex_priority_change>
#endif
                    }
                }

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
 80095c0:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80095c2:	f003 f847 	bl	800c654 <_tx_thread_system_suspend>
#endif
                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
 80095c6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80095c8:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80095cc:	647b      	str	r3, [r7, #68]	; 0x44
 80095ce:	e007      	b.n	80095e0 <_tx_mutex_get+0x1f8>
 80095d0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80095d2:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80095d4:	68fb      	ldr	r3, [r7, #12]
 80095d6:	f383 8810 	msr	PRIMASK, r3
}
 80095da:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Immediate return, return error completion.  */
            status =  TX_NOT_AVAILABLE;
 80095dc:	231d      	movs	r3, #29
 80095de:	647b      	str	r3, [r7, #68]	; 0x44
        }
    }

    /* Return completion status.  */
    return(status);
 80095e0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 80095e2:	4618      	mov	r0, r3
 80095e4:	3748      	adds	r7, #72	; 0x48
 80095e6:	46bd      	mov	sp, r7
 80095e8:	bd80      	pop	{r7, pc}
 80095ea:	bf00      	nop
 80095ec:	2000efb8 	.word	0x2000efb8
 80095f0:	2000f054 	.word	0x2000f054
 80095f4:	08009061 	.word	0x08009061

080095f8 <_tx_mutex_info_get>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_info_get(TX_MUTEX *mutex_ptr, CHAR **name, ULONG *count, TX_THREAD **owner,
                    TX_THREAD **first_suspended, ULONG *suspended_count,
                    TX_MUTEX **next_mutex)
{
 80095f8:	b480      	push	{r7}
 80095fa:	b089      	sub	sp, #36	; 0x24
 80095fc:	af00      	add	r7, sp, #0
 80095fe:	60f8      	str	r0, [r7, #12]
 8009600:	60b9      	str	r1, [r7, #8]
 8009602:	607a      	str	r2, [r7, #4]
 8009604:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009606:	f3ef 8310 	mrs	r3, PRIMASK
 800960a:	61bb      	str	r3, [r7, #24]
    return(posture);
 800960c:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800960e:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8009610:	b672      	cpsid	i
    return(int_posture);
 8009612:	697b      	ldr	r3, [r7, #20]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts.  */
    TX_DISABLE
 8009614:	61fb      	str	r3, [r7, #28]

    /* Retrieve all the pertinent information and return it in the supplied
       destinations.  */

    /* Retrieve the name of the mutex.  */
    if (name != TX_NULL)
 8009616:	68bb      	ldr	r3, [r7, #8]
 8009618:	2b00      	cmp	r3, #0
 800961a:	d003      	beq.n	8009624 <_tx_mutex_info_get+0x2c>
    {

        *name =  mutex_ptr -> tx_mutex_name;
 800961c:	68fb      	ldr	r3, [r7, #12]
 800961e:	685a      	ldr	r2, [r3, #4]
 8009620:	68bb      	ldr	r3, [r7, #8]
 8009622:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the current ownership count of the mutex.  */
    if (count != TX_NULL)
 8009624:	687b      	ldr	r3, [r7, #4]
 8009626:	2b00      	cmp	r3, #0
 8009628:	d003      	beq.n	8009632 <_tx_mutex_info_get+0x3a>
    {

        *count =  ((ULONG) mutex_ptr -> tx_mutex_ownership_count);
 800962a:	68fb      	ldr	r3, [r7, #12]
 800962c:	689a      	ldr	r2, [r3, #8]
 800962e:	687b      	ldr	r3, [r7, #4]
 8009630:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the current owner of the mutex.  */
    if (owner != TX_NULL)
 8009632:	683b      	ldr	r3, [r7, #0]
 8009634:	2b00      	cmp	r3, #0
 8009636:	d003      	beq.n	8009640 <_tx_mutex_info_get+0x48>
    {

        *owner =  mutex_ptr -> tx_mutex_owner;
 8009638:	68fb      	ldr	r3, [r7, #12]
 800963a:	68da      	ldr	r2, [r3, #12]
 800963c:	683b      	ldr	r3, [r7, #0]
 800963e:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the first thread suspended on this mutex.  */
    if (first_suspended != TX_NULL)
 8009640:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009642:	2b00      	cmp	r3, #0
 8009644:	d003      	beq.n	800964e <_tx_mutex_info_get+0x56>
    {

        *first_suspended =  mutex_ptr -> tx_mutex_suspension_list;
 8009646:	68fb      	ldr	r3, [r7, #12]
 8009648:	699a      	ldr	r2, [r3, #24]
 800964a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800964c:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the number of threads suspended on this mutex.  */
    if (suspended_count != TX_NULL)
 800964e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009650:	2b00      	cmp	r3, #0
 8009652:	d003      	beq.n	800965c <_tx_mutex_info_get+0x64>
    {

        *suspended_count =  (ULONG) mutex_ptr -> tx_mutex_suspended_count;
 8009654:	68fb      	ldr	r3, [r7, #12]
 8009656:	69da      	ldr	r2, [r3, #28]
 8009658:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800965a:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the pointer to the next mutex created.  */
    if (next_mutex != TX_NULL)
 800965c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800965e:	2b00      	cmp	r3, #0
 8009660:	d003      	beq.n	800966a <_tx_mutex_info_get+0x72>
    {

        *next_mutex =  mutex_ptr -> tx_mutex_created_next;
 8009662:	68fb      	ldr	r3, [r7, #12]
 8009664:	6a1a      	ldr	r2, [r3, #32]
 8009666:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009668:	601a      	str	r2, [r3, #0]
 800966a:	69fb      	ldr	r3, [r7, #28]
 800966c:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800966e:	693b      	ldr	r3, [r7, #16]
 8009670:	f383 8810 	msr	PRIMASK, r3
}
 8009674:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(TX_SUCCESS);
 8009676:	2300      	movs	r3, #0
}
 8009678:	4618      	mov	r0, r3
 800967a:	3724      	adds	r7, #36	; 0x24
 800967c:	46bd      	mov	sp, r7
 800967e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009682:	4770      	bx	lr

08009684 <_tx_mutex_performance_info_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_performance_info_get(TX_MUTEX *mutex_ptr, ULONG *puts, ULONG *gets,
                    ULONG *suspensions, ULONG *timeouts, ULONG *inversions, ULONG *inheritances)
{
 8009684:	b480      	push	{r7}
 8009686:	b087      	sub	sp, #28
 8009688:	af00      	add	r7, sp, #0
 800968a:	60f8      	str	r0, [r7, #12]
 800968c:	60b9      	str	r1, [r7, #8]
 800968e:	607a      	str	r2, [r7, #4]
 8009690:	603b      	str	r3, [r7, #0]
#else
UINT                    status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (mutex_ptr != TX_NULL)
 8009692:	68fb      	ldr	r3, [r7, #12]
 8009694:	2b00      	cmp	r3, #0
 8009696:	d002      	beq.n	800969e <_tx_mutex_performance_info_get+0x1a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8009698:	23ff      	movs	r3, #255	; 0xff
 800969a:	617b      	str	r3, [r7, #20]
 800969c:	e025      	b.n	80096ea <_tx_mutex_performance_info_get+0x66>
    }
    else if (puts != TX_NULL)
 800969e:	68bb      	ldr	r3, [r7, #8]
 80096a0:	2b00      	cmp	r3, #0
 80096a2:	d002      	beq.n	80096aa <_tx_mutex_performance_info_get+0x26>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 80096a4:	23ff      	movs	r3, #255	; 0xff
 80096a6:	617b      	str	r3, [r7, #20]
 80096a8:	e01f      	b.n	80096ea <_tx_mutex_performance_info_get+0x66>
    }
    else if (gets != TX_NULL)
 80096aa:	687b      	ldr	r3, [r7, #4]
 80096ac:	2b00      	cmp	r3, #0
 80096ae:	d002      	beq.n	80096b6 <_tx_mutex_performance_info_get+0x32>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 80096b0:	23ff      	movs	r3, #255	; 0xff
 80096b2:	617b      	str	r3, [r7, #20]
 80096b4:	e019      	b.n	80096ea <_tx_mutex_performance_info_get+0x66>
    }
    else if (suspensions != TX_NULL)
 80096b6:	683b      	ldr	r3, [r7, #0]
 80096b8:	2b00      	cmp	r3, #0
 80096ba:	d002      	beq.n	80096c2 <_tx_mutex_performance_info_get+0x3e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 80096bc:	23ff      	movs	r3, #255	; 0xff
 80096be:	617b      	str	r3, [r7, #20]
 80096c0:	e013      	b.n	80096ea <_tx_mutex_performance_info_get+0x66>
    }
    else if (timeouts != TX_NULL)
 80096c2:	6a3b      	ldr	r3, [r7, #32]
 80096c4:	2b00      	cmp	r3, #0
 80096c6:	d002      	beq.n	80096ce <_tx_mutex_performance_info_get+0x4a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 80096c8:	23ff      	movs	r3, #255	; 0xff
 80096ca:	617b      	str	r3, [r7, #20]
 80096cc:	e00d      	b.n	80096ea <_tx_mutex_performance_info_get+0x66>
    }
    else if (inversions != TX_NULL)
 80096ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80096d0:	2b00      	cmp	r3, #0
 80096d2:	d002      	beq.n	80096da <_tx_mutex_performance_info_get+0x56>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 80096d4:	23ff      	movs	r3, #255	; 0xff
 80096d6:	617b      	str	r3, [r7, #20]
 80096d8:	e007      	b.n	80096ea <_tx_mutex_performance_info_get+0x66>
    }
    else if (inheritances != TX_NULL)
 80096da:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80096dc:	2b00      	cmp	r3, #0
 80096de:	d002      	beq.n	80096e6 <_tx_mutex_performance_info_get+0x62>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 80096e0:	23ff      	movs	r3, #255	; 0xff
 80096e2:	617b      	str	r3, [r7, #20]
 80096e4:	e001      	b.n	80096ea <_tx_mutex_performance_info_get+0x66>
    }
    else
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 80096e6:	23ff      	movs	r3, #255	; 0xff
 80096e8:	617b      	str	r3, [r7, #20]
    }
#endif

    /* Return completion status.  */
    return(status);
 80096ea:	697b      	ldr	r3, [r7, #20]
}
 80096ec:	4618      	mov	r0, r3
 80096ee:	371c      	adds	r7, #28
 80096f0:	46bd      	mov	sp, r7
 80096f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80096f6:	4770      	bx	lr

080096f8 <_tx_mutex_performance_system_info_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_performance_system_info_get(ULONG *puts, ULONG *gets, ULONG *suspensions,
                                ULONG *timeouts, ULONG *inversions, ULONG *inheritances)
{
 80096f8:	b480      	push	{r7}
 80096fa:	b087      	sub	sp, #28
 80096fc:	af00      	add	r7, sp, #0
 80096fe:	60f8      	str	r0, [r7, #12]
 8009700:	60b9      	str	r1, [r7, #8]
 8009702:	607a      	str	r2, [r7, #4]
 8009704:	603b      	str	r3, [r7, #0]

UINT        status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (puts != TX_NULL)
 8009706:	68fb      	ldr	r3, [r7, #12]
 8009708:	2b00      	cmp	r3, #0
 800970a:	d002      	beq.n	8009712 <_tx_mutex_performance_system_info_get+0x1a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800970c:	23ff      	movs	r3, #255	; 0xff
 800970e:	617b      	str	r3, [r7, #20]
 8009710:	e01f      	b.n	8009752 <_tx_mutex_performance_system_info_get+0x5a>
    }
    else if (gets != TX_NULL)
 8009712:	68bb      	ldr	r3, [r7, #8]
 8009714:	2b00      	cmp	r3, #0
 8009716:	d002      	beq.n	800971e <_tx_mutex_performance_system_info_get+0x26>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8009718:	23ff      	movs	r3, #255	; 0xff
 800971a:	617b      	str	r3, [r7, #20]
 800971c:	e019      	b.n	8009752 <_tx_mutex_performance_system_info_get+0x5a>
    }
    else if (suspensions != TX_NULL)
 800971e:	687b      	ldr	r3, [r7, #4]
 8009720:	2b00      	cmp	r3, #0
 8009722:	d002      	beq.n	800972a <_tx_mutex_performance_system_info_get+0x32>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8009724:	23ff      	movs	r3, #255	; 0xff
 8009726:	617b      	str	r3, [r7, #20]
 8009728:	e013      	b.n	8009752 <_tx_mutex_performance_system_info_get+0x5a>
    }
    else if (timeouts != TX_NULL)
 800972a:	683b      	ldr	r3, [r7, #0]
 800972c:	2b00      	cmp	r3, #0
 800972e:	d002      	beq.n	8009736 <_tx_mutex_performance_system_info_get+0x3e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8009730:	23ff      	movs	r3, #255	; 0xff
 8009732:	617b      	str	r3, [r7, #20]
 8009734:	e00d      	b.n	8009752 <_tx_mutex_performance_system_info_get+0x5a>
    }
    else if (inversions != TX_NULL)
 8009736:	6a3b      	ldr	r3, [r7, #32]
 8009738:	2b00      	cmp	r3, #0
 800973a:	d002      	beq.n	8009742 <_tx_mutex_performance_system_info_get+0x4a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800973c:	23ff      	movs	r3, #255	; 0xff
 800973e:	617b      	str	r3, [r7, #20]
 8009740:	e007      	b.n	8009752 <_tx_mutex_performance_system_info_get+0x5a>
    }
    else if (inheritances != TX_NULL)
 8009742:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009744:	2b00      	cmp	r3, #0
 8009746:	d002      	beq.n	800974e <_tx_mutex_performance_system_info_get+0x56>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 8009748:	23ff      	movs	r3, #255	; 0xff
 800974a:	617b      	str	r3, [r7, #20]
 800974c:	e001      	b.n	8009752 <_tx_mutex_performance_system_info_get+0x5a>
    }
    else
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800974e:	23ff      	movs	r3, #255	; 0xff
 8009750:	617b      	str	r3, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 8009752:	697b      	ldr	r3, [r7, #20]
#endif
}
 8009754:	4618      	mov	r0, r3
 8009756:	371c      	adds	r7, #28
 8009758:	46bd      	mov	sp, r7
 800975a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800975e:	4770      	bx	lr

08009760 <_tx_mutex_prioritize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_prioritize(TX_MUTEX *mutex_ptr)
{
 8009760:	b580      	push	{r7, lr}
 8009762:	b092      	sub	sp, #72	; 0x48
 8009764:	af00      	add	r7, sp, #0
 8009766:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009768:	f3ef 8310 	mrs	r3, PRIMASK
 800976c:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 800976e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 8009770:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 8009772:	b672      	cpsid	i
    return(int_posture);
 8009774:	6a3b      	ldr	r3, [r7, #32]
UINT            status;
#endif


    /* Disable interrupts.  */
    TX_DISABLE
 8009776:	647b      	str	r3, [r7, #68]	; 0x44

    /* Log this kernel call.  */
    TX_EL_MUTEX_PRIORITIZE_INSERT

    /* Pickup the suspended count.  */
    suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
 8009778:	687b      	ldr	r3, [r7, #4]
 800977a:	69db      	ldr	r3, [r3, #28]
 800977c:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if there are fewer than 2 suspended threads.  */
    if (suspended_count < ((UINT) 2))
 800977e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009780:	2b01      	cmp	r3, #1
 8009782:	d805      	bhi.n	8009790 <_tx_mutex_prioritize+0x30>
 8009784:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8009786:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009788:	69fb      	ldr	r3, [r7, #28]
 800978a:	f383 8810 	msr	PRIMASK, r3
}
 800978e:	e092      	b.n	80098b6 <_tx_mutex_prioritize+0x156>
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Determine if there how many threads are suspended on this mutex.  */
    else if (suspended_count == ((UINT) 2))
 8009790:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009792:	2b02      	cmp	r3, #2
 8009794:	d114      	bne.n	80097c0 <_tx_mutex_prioritize+0x60>
    {

        /* Pickup the head pointer and the next pointer.  */
        head_ptr =  mutex_ptr -> tx_mutex_suspension_list;
 8009796:	687b      	ldr	r3, [r7, #4]
 8009798:	699b      	ldr	r3, [r3, #24]
 800979a:	63bb      	str	r3, [r7, #56]	; 0x38
        next_thread =  head_ptr -> tx_thread_suspended_next;
 800979c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800979e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80097a0:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Determine if the next suspended thread has a higher priority.  */
        if ((next_thread -> tx_thread_priority) < (head_ptr -> tx_thread_priority))
 80097a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80097a4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80097a6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80097a8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80097aa:	429a      	cmp	r2, r3
 80097ac:	d202      	bcs.n	80097b4 <_tx_mutex_prioritize+0x54>
        {

            /* Yes, move the list head to the next thread.  */
            mutex_ptr -> tx_mutex_suspension_list =  next_thread;
 80097ae:	687b      	ldr	r3, [r7, #4]
 80097b0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80097b2:	619a      	str	r2, [r3, #24]
 80097b4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80097b6:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80097b8:	69bb      	ldr	r3, [r7, #24]
 80097ba:	f383 8810 	msr	PRIMASK, r3
}
 80097be:	e07a      	b.n	80098b6 <_tx_mutex_prioritize+0x156>
    }
    else
    {

        /* Remember the suspension count and head pointer.  */
        head_ptr =   mutex_ptr -> tx_mutex_suspension_list;
 80097c0:	687b      	ldr	r3, [r7, #4]
 80097c2:	699b      	ldr	r3, [r3, #24]
 80097c4:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Default the highest priority thread to the thread at the front of the list.  */
        priority_thread_ptr =  head_ptr;
 80097c6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80097c8:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Setup search pointer.  */
        thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
 80097ca:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80097cc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80097ce:	643b      	str	r3, [r7, #64]	; 0x40

        /* Disable preemption.  */
        _tx_thread_preempt_disable++;
 80097d0:	4b3b      	ldr	r3, [pc, #236]	; (80098c0 <_tx_mutex_prioritize+0x160>)
 80097d2:	681b      	ldr	r3, [r3, #0]
 80097d4:	3301      	adds	r3, #1
 80097d6:	4a3a      	ldr	r2, [pc, #232]	; (80098c0 <_tx_mutex_prioritize+0x160>)
 80097d8:	6013      	str	r3, [r2, #0]

        /* Set the list changed flag to false.  */
        list_changed =  TX_FALSE;
 80097da:	2300      	movs	r3, #0
 80097dc:	633b      	str	r3, [r7, #48]	; 0x30
        /* Search through the list to find the highest priority thread.  */
        do
        {

            /* Is the current thread higher priority?  */
            if (thread_ptr -> tx_thread_priority < priority_thread_ptr -> tx_thread_priority)
 80097de:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80097e0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80097e2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80097e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80097e6:	429a      	cmp	r2, r3
 80097e8:	d201      	bcs.n	80097ee <_tx_mutex_prioritize+0x8e>
            {

                /* Yes, remember that this thread is the highest priority.  */
                priority_thread_ptr =  thread_ptr;
 80097ea:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80097ec:	63fb      	str	r3, [r7, #60]	; 0x3c
 80097ee:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80097f0:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80097f2:	68fb      	ldr	r3, [r7, #12]
 80097f4:	f383 8810 	msr	PRIMASK, r3
}
 80097f8:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80097fa:	f3ef 8310 	mrs	r3, PRIMASK
 80097fe:	617b      	str	r3, [r7, #20]
    return(posture);
 8009800:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 8009802:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 8009804:	b672      	cpsid	i
    return(int_posture);
 8009806:	693b      	ldr	r3, [r7, #16]

            /* Restore interrupts temporarily.  */
            TX_RESTORE

            /* Disable interrupts again.  */
            TX_DISABLE
 8009808:	647b      	str	r3, [r7, #68]	; 0x44

            /* Determine if any changes to the list have occurred while
               interrupts were enabled.  */

            /* Is the list head the same?  */
            if (head_ptr != mutex_ptr -> tx_mutex_suspension_list)
 800980a:	687b      	ldr	r3, [r7, #4]
 800980c:	699b      	ldr	r3, [r3, #24]
 800980e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8009810:	429a      	cmp	r2, r3
 8009812:	d002      	beq.n	800981a <_tx_mutex_prioritize+0xba>
            {

                /* The list head has changed, set the list changed flag.  */
                list_changed =  TX_TRUE;
 8009814:	2301      	movs	r3, #1
 8009816:	633b      	str	r3, [r7, #48]	; 0x30
 8009818:	e006      	b.n	8009828 <_tx_mutex_prioritize+0xc8>
            }
            else
            {

                /* Is the suspended count the same?  */
                if (suspended_count != mutex_ptr -> tx_mutex_suspended_count)
 800981a:	687b      	ldr	r3, [r7, #4]
 800981c:	69db      	ldr	r3, [r3, #28]
 800981e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8009820:	429a      	cmp	r2, r3
 8009822:	d001      	beq.n	8009828 <_tx_mutex_prioritize+0xc8>
                {

                    /* The list head has changed, set the list changed flag.  */
                    list_changed =  TX_TRUE;
 8009824:	2301      	movs	r3, #1
 8009826:	633b      	str	r3, [r7, #48]	; 0x30
                }
            }

            /* Determine if the list has changed.  */
            if (list_changed == TX_FALSE)
 8009828:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800982a:	2b00      	cmp	r3, #0
 800982c:	d103      	bne.n	8009836 <_tx_mutex_prioritize+0xd6>
            {

                /* Move the thread pointer to the next thread.  */
                thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 800982e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009830:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8009832:	643b      	str	r3, [r7, #64]	; 0x40
 8009834:	e00c      	b.n	8009850 <_tx_mutex_prioritize+0xf0>
            }
            else
            {

                /* Remember the suspension count and head pointer.  */
                head_ptr =   mutex_ptr -> tx_mutex_suspension_list;
 8009836:	687b      	ldr	r3, [r7, #4]
 8009838:	699b      	ldr	r3, [r3, #24]
 800983a:	63bb      	str	r3, [r7, #56]	; 0x38
                suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
 800983c:	687b      	ldr	r3, [r7, #4]
 800983e:	69db      	ldr	r3, [r3, #28]
 8009840:	637b      	str	r3, [r7, #52]	; 0x34

                /* Default the highest priority thread to the thread at the front of the list.  */
                priority_thread_ptr =  head_ptr;
 8009842:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009844:	63fb      	str	r3, [r7, #60]	; 0x3c

                /* Setup search pointer.  */
                thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
 8009846:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009848:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800984a:	643b      	str	r3, [r7, #64]	; 0x40

                /* Reset the list changed flag.  */
                list_changed =  TX_FALSE;
 800984c:	2300      	movs	r3, #0
 800984e:	633b      	str	r3, [r7, #48]	; 0x30
            }

        } while (thread_ptr != head_ptr);
 8009850:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8009852:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009854:	429a      	cmp	r2, r3
 8009856:	d1c2      	bne.n	80097de <_tx_mutex_prioritize+0x7e>

        /* Release preemption.  */
        _tx_thread_preempt_disable--;
 8009858:	4b19      	ldr	r3, [pc, #100]	; (80098c0 <_tx_mutex_prioritize+0x160>)
 800985a:	681b      	ldr	r3, [r3, #0]
 800985c:	3b01      	subs	r3, #1
 800985e:	4a18      	ldr	r2, [pc, #96]	; (80098c0 <_tx_mutex_prioritize+0x160>)
 8009860:	6013      	str	r3, [r2, #0]

        /* Now determine if the highest priority thread is at the front
           of the list.  */
        if (priority_thread_ptr != head_ptr)
 8009862:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009864:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009866:	429a      	cmp	r2, r3
 8009868:	d01d      	beq.n	80098a6 <_tx_mutex_prioritize+0x146>
            /* No, we need to move the highest priority suspended thread to the
               front of the list.  */

            /* First, remove the highest priority thread by updating the
               adjacent suspended threads.  */
            next_thread =                                  priority_thread_ptr -> tx_thread_suspended_next;
 800986a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800986c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800986e:	62fb      	str	r3, [r7, #44]	; 0x2c
            previous_thread =                              priority_thread_ptr -> tx_thread_suspended_previous;
 8009870:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009872:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8009874:	62bb      	str	r3, [r7, #40]	; 0x28
            next_thread -> tx_thread_suspended_previous =  previous_thread;
 8009876:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009878:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800987a:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =  next_thread;
 800987c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800987e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8009880:	671a      	str	r2, [r3, #112]	; 0x70

            /* Now, link the highest priority thread at the front of the list.  */
            previous_thread =                                      head_ptr -> tx_thread_suspended_previous;
 8009882:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009884:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8009886:	62bb      	str	r3, [r7, #40]	; 0x28
            priority_thread_ptr -> tx_thread_suspended_next =      head_ptr;
 8009888:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800988a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800988c:	671a      	str	r2, [r3, #112]	; 0x70
            priority_thread_ptr -> tx_thread_suspended_previous =  previous_thread;
 800988e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009890:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8009892:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =          priority_thread_ptr;
 8009894:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009896:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009898:	671a      	str	r2, [r3, #112]	; 0x70
            head_ptr -> tx_thread_suspended_previous =             priority_thread_ptr;
 800989a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800989c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800989e:	675a      	str	r2, [r3, #116]	; 0x74

            /* Move the list head pointer to the highest priority suspended thread.  */
            mutex_ptr -> tx_mutex_suspension_list =  priority_thread_ptr;
 80098a0:	687b      	ldr	r3, [r7, #4]
 80098a2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80098a4:	619a      	str	r2, [r3, #24]
 80098a6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80098a8:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80098aa:	68bb      	ldr	r3, [r7, #8]
 80098ac:	f383 8810 	msr	PRIMASK, r3
}
 80098b0:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 80098b2:	f002 fd81 	bl	800c3b8 <_tx_thread_system_preempt_check>
    /* Return completion status.  */
    return(status);
#else

    /* Return successful completion.  */
    return(TX_SUCCESS);
 80098b6:	2300      	movs	r3, #0
#endif
}
 80098b8:	4618      	mov	r0, r3
 80098ba:	3748      	adds	r7, #72	; 0x48
 80098bc:	46bd      	mov	sp, r7
 80098be:	bd80      	pop	{r7, pc}
 80098c0:	2000f054 	.word	0x2000f054

080098c4 <_tx_mutex_priority_change>:
/*                                            priority rather than next,  */
/*                                            resulting in version 6.1.6  */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_priority_change(TX_THREAD *thread_ptr, UINT new_priority)
{
 80098c4:	b580      	push	{r7, lr}
 80098c6:	b092      	sub	sp, #72	; 0x48
 80098c8:	af00      	add	r7, sp, #0
 80098ca:	6078      	str	r0, [r7, #4]
 80098cc:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80098ce:	f3ef 8310 	mrs	r3, PRIMASK
 80098d2:	633b      	str	r3, [r7, #48]	; 0x30
    return(posture);
 80098d4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    int_posture = __get_interrupt_posture();
 80098d6:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("CPSID i" : : : "memory");
 80098d8:	b672      	cpsid	i
    return(int_posture);
 80098da:	6afb      	ldr	r3, [r7, #44]	; 0x2c


#ifndef TX_NOT_INTERRUPTABLE

    /* Lockout interrupts while the thread is being suspended.  */
    TX_DISABLE
 80098dc:	647b      	str	r3, [r7, #68]	; 0x44
#endif

    /* Determine if this thread is currently ready.  */
    if (thread_ptr -> tx_thread_state != TX_READY)
 80098de:	687b      	ldr	r3, [r7, #4]
 80098e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80098e2:	2b00      	cmp	r3, #0
 80098e4:	d017      	beq.n	8009916 <_tx_mutex_priority_change+0x52>
    {

        /* Change thread priority to the new mutex priority-inheritance priority.  */
        thread_ptr -> tx_thread_priority =  new_priority;
 80098e6:	687b      	ldr	r3, [r7, #4]
 80098e8:	683a      	ldr	r2, [r7, #0]
 80098ea:	62da      	str	r2, [r3, #44]	; 0x2c

        /* Determine how to setup the thread's preemption-threshold.  */
        if (thread_ptr -> tx_thread_user_preempt_threshold < new_priority)
 80098ec:	687b      	ldr	r3, [r7, #4]
 80098ee:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 80098f2:	683a      	ldr	r2, [r7, #0]
 80098f4:	429a      	cmp	r2, r3
 80098f6:	d905      	bls.n	8009904 <_tx_mutex_priority_change+0x40>
        {

            /* Change thread preemption-threshold to the user's preemption-threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
 80098f8:	687b      	ldr	r3, [r7, #4]
 80098fa:	f8d3 20cc 	ldr.w	r2, [r3, #204]	; 0xcc
 80098fe:	687b      	ldr	r3, [r7, #4]
 8009900:	63da      	str	r2, [r3, #60]	; 0x3c
 8009902:	e002      	b.n	800990a <_tx_mutex_priority_change+0x46>
        }
        else
        {

            /* Change the thread preemption-threshold to the new threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  new_priority;
 8009904:	687b      	ldr	r3, [r7, #4]
 8009906:	683a      	ldr	r2, [r7, #0]
 8009908:	63da      	str	r2, [r3, #60]	; 0x3c
 800990a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800990c:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800990e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009910:	f383 8810 	msr	PRIMASK, r3
}
 8009914:	e096      	b.n	8009a44 <_tx_mutex_priority_change+0x180>
    }
    else
    {

        /* Pickup the next thread to execute.  */
        execute_ptr =  _tx_thread_execute_ptr;
 8009916:	4b4d      	ldr	r3, [pc, #308]	; (8009a4c <_tx_mutex_priority_change+0x188>)
 8009918:	681b      	ldr	r3, [r3, #0]
 800991a:	643b      	str	r3, [r7, #64]	; 0x40

        /* Save the original priority.  */
        original_priority =  thread_ptr -> tx_thread_priority;
 800991c:	687b      	ldr	r3, [r7, #4]
 800991e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009920:	63fb      	str	r3, [r7, #60]	; 0x3c
        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
#else

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable =  _tx_thread_preempt_disable + ((UINT) 2);
 8009922:	4b4b      	ldr	r3, [pc, #300]	; (8009a50 <_tx_mutex_priority_change+0x18c>)
 8009924:	681b      	ldr	r3, [r3, #0]
 8009926:	3302      	adds	r3, #2
 8009928:	4a49      	ldr	r2, [pc, #292]	; (8009a50 <_tx_mutex_priority_change+0x18c>)
 800992a:	6013      	str	r3, [r2, #0]

        /* Set the state to priority change.  */
        thread_ptr -> tx_thread_state =    TX_PRIORITY_CHANGE;
 800992c:	687b      	ldr	r3, [r7, #4]
 800992e:	220e      	movs	r2, #14
 8009930:	631a      	str	r2, [r3, #48]	; 0x30

        /* Set the suspending flag. */
        thread_ptr -> tx_thread_suspending =  TX_TRUE;
 8009932:	687b      	ldr	r3, [r7, #4]
 8009934:	2201      	movs	r2, #1
 8009936:	639a      	str	r2, [r3, #56]	; 0x38

        /* Setup the timeout period.  */
        thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 8009938:	687b      	ldr	r3, [r7, #4]
 800993a:	2200      	movs	r2, #0
 800993c:	64da      	str	r2, [r3, #76]	; 0x4c
 800993e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8009940:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009942:	69fb      	ldr	r3, [r7, #28]
 8009944:	f383 8810 	msr	PRIMASK, r3
}
 8009948:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE

        /* The thread is ready and must first be removed from the list.  Call the
           system suspend function to accomplish this.  */
        _tx_thread_system_suspend(thread_ptr);
 800994a:	6878      	ldr	r0, [r7, #4]
 800994c:	f002 fe82 	bl	800c654 <_tx_thread_system_suspend>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009950:	f3ef 8310 	mrs	r3, PRIMASK
 8009954:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 8009956:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 8009958:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 800995a:	b672      	cpsid	i
    return(int_posture);
 800995c:	6a3b      	ldr	r3, [r7, #32]

        /* Disable interrupts.  */
        TX_DISABLE
 800995e:	647b      	str	r3, [r7, #68]	; 0x44

        /* At this point, the preempt disable flag is still set, so we still have
           protection against all preemption.  */

        /* Change thread priority to the new mutex priority-inheritance priority.  */
        thread_ptr -> tx_thread_priority =  new_priority;
 8009960:	687b      	ldr	r3, [r7, #4]
 8009962:	683a      	ldr	r2, [r7, #0]
 8009964:	62da      	str	r2, [r3, #44]	; 0x2c

        /* Determine how to setup the thread's preemption-threshold.  */
        if (thread_ptr -> tx_thread_user_preempt_threshold < new_priority)
 8009966:	687b      	ldr	r3, [r7, #4]
 8009968:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 800996c:	683a      	ldr	r2, [r7, #0]
 800996e:	429a      	cmp	r2, r3
 8009970:	d905      	bls.n	800997e <_tx_mutex_priority_change+0xba>
        {

            /* Change thread preemption-threshold to the user's preemption-threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
 8009972:	687b      	ldr	r3, [r7, #4]
 8009974:	f8d3 20cc 	ldr.w	r2, [r3, #204]	; 0xcc
 8009978:	687b      	ldr	r3, [r7, #4]
 800997a:	63da      	str	r2, [r3, #60]	; 0x3c
 800997c:	e002      	b.n	8009984 <_tx_mutex_priority_change+0xc0>
        }
        else
        {

            /* Change the thread preemption-threshold to the new threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  new_priority;
 800997e:	687b      	ldr	r3, [r7, #4]
 8009980:	683a      	ldr	r2, [r7, #0]
 8009982:	63da      	str	r2, [r3, #60]	; 0x3c
 8009984:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8009986:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009988:	693b      	ldr	r3, [r7, #16]
 800998a:	f383 8810 	msr	PRIMASK, r3
}
 800998e:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread with the new priority.  */
        _tx_thread_system_resume(thread_ptr);
 8009990:	6878      	ldr	r0, [r7, #4]
 8009992:	f002 fd4b 	bl	800c42c <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009996:	f3ef 8310 	mrs	r3, PRIMASK
 800999a:	61bb      	str	r3, [r7, #24]
    return(posture);
 800999c:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800999e:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 80099a0:	b672      	cpsid	i
    return(int_posture);
 80099a2:	697b      	ldr	r3, [r7, #20]
        TX_MUTEX_PRIORITY_CHANGE_EXTENSION

#ifndef TX_NOT_INTERRUPTABLE

        /* Disable interrupts.  */
        TX_DISABLE
 80099a4:	647b      	str	r3, [r7, #68]	; 0x44
#endif

        /* Pickup the next thread to execute.  */
        next_execute_ptr =  _tx_thread_execute_ptr;
 80099a6:	4b29      	ldr	r3, [pc, #164]	; (8009a4c <_tx_mutex_priority_change+0x188>)
 80099a8:	681b      	ldr	r3, [r3, #0]
 80099aa:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Determine if this thread is not the next thread to execute.  */
        if (thread_ptr != next_execute_ptr)
 80099ac:	687a      	ldr	r2, [r7, #4]
 80099ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80099b0:	429a      	cmp	r2, r3
 80099b2:	d041      	beq.n	8009a38 <_tx_mutex_priority_change+0x174>
        {

            /* Make sure the thread is still ready.  */
            if (thread_ptr -> tx_thread_state == TX_READY)
 80099b4:	687b      	ldr	r3, [r7, #4]
 80099b6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80099b8:	2b00      	cmp	r3, #0
 80099ba:	d13d      	bne.n	8009a38 <_tx_mutex_priority_change+0x174>
            {

                /* Now check and see if this thread has an equal or higher priority.  */
                if (thread_ptr -> tx_thread_priority <= next_execute_ptr -> tx_thread_priority)
 80099bc:	687b      	ldr	r3, [r7, #4]
 80099be:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80099c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80099c2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80099c4:	429a      	cmp	r2, r3
 80099c6:	d811      	bhi.n	80099ec <_tx_mutex_priority_change+0x128>
                {

                    /* Now determine if this thread was the previously executing thread.  */
                    if (thread_ptr == execute_ptr)
 80099c8:	687a      	ldr	r2, [r7, #4]
 80099ca:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80099cc:	429a      	cmp	r2, r3
 80099ce:	d133      	bne.n	8009a38 <_tx_mutex_priority_change+0x174>

                        /* Yes, this thread was previously executing before we temporarily suspended and resumed
                           it in order to change the priority. A lower or same priority thread cannot be the next thread
                           to execute in this case since this thread really didn't suspend.  Simply reset the execute
                           pointer to this thread.  */
                        _tx_thread_execute_ptr =  thread_ptr;
 80099d0:	4a1e      	ldr	r2, [pc, #120]	; (8009a4c <_tx_mutex_priority_change+0x188>)
 80099d2:	687b      	ldr	r3, [r7, #4]
 80099d4:	6013      	str	r3, [r2, #0]

                        /* Determine if we moved to a lower priority. If so, move the thread to the front of its priority list.  */
                        if (original_priority < new_priority)
 80099d6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80099d8:	683b      	ldr	r3, [r7, #0]
 80099da:	429a      	cmp	r2, r3
 80099dc:	d22c      	bcs.n	8009a38 <_tx_mutex_priority_change+0x174>
                        {

                            /* Ensure that this thread is placed at the front of the priority list.  */
                            _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr;
 80099de:	687b      	ldr	r3, [r7, #4]
 80099e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80099e2:	491c      	ldr	r1, [pc, #112]	; (8009a54 <_tx_mutex_priority_change+0x190>)
 80099e4:	687a      	ldr	r2, [r7, #4]
 80099e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 80099ea:	e025      	b.n	8009a38 <_tx_mutex_priority_change+0x174>
                }
                else
                {

                    /* Now determine if this thread's preemption-threshold needs to be enforced.  */
                    if (thread_ptr -> tx_thread_preempt_threshold < thread_ptr -> tx_thread_priority)
 80099ec:	687b      	ldr	r3, [r7, #4]
 80099ee:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80099f0:	687b      	ldr	r3, [r7, #4]
 80099f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80099f4:	429a      	cmp	r2, r3
 80099f6:	d21f      	bcs.n	8009a38 <_tx_mutex_priority_change+0x174>
                    {

                        /* Yes, preemption-threshold is in force for this thread. */

                        /* Compare the next thread to execute thread's priority against the thread's preemption-threshold.  */
                        if (thread_ptr -> tx_thread_preempt_threshold <= next_execute_ptr -> tx_thread_priority)
 80099f8:	687b      	ldr	r3, [r7, #4]
 80099fa:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80099fc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80099fe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009a00:	429a      	cmp	r2, r3
 8009a02:	d80d      	bhi.n	8009a20 <_tx_mutex_priority_change+0x15c>
                        {

                            /* We must swap execute pointers to enforce the preemption-threshold of a thread coming out of
                               priority inheritance.  */
                            _tx_thread_execute_ptr =  thread_ptr;
 8009a04:	4a11      	ldr	r2, [pc, #68]	; (8009a4c <_tx_mutex_priority_change+0x188>)
 8009a06:	687b      	ldr	r3, [r7, #4]
 8009a08:	6013      	str	r3, [r2, #0]

                            /* Determine if we moved to a lower priority. If so, move the thread to the front of its priority list.  */
                            if (original_priority < new_priority)
 8009a0a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009a0c:	683b      	ldr	r3, [r7, #0]
 8009a0e:	429a      	cmp	r2, r3
 8009a10:	d212      	bcs.n	8009a38 <_tx_mutex_priority_change+0x174>
                            {

                                /* Ensure that this thread is placed at the front of the priority list.  */
                                _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr;
 8009a12:	687b      	ldr	r3, [r7, #4]
 8009a14:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009a16:	490f      	ldr	r1, [pc, #60]	; (8009a54 <_tx_mutex_priority_change+0x190>)
 8009a18:	687a      	ldr	r2, [r7, #4]
 8009a1a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 8009a1e:	e00b      	b.n	8009a38 <_tx_mutex_priority_change+0x174>
                            TX_DIV32_BIT_SET(thread_ptr -> tx_thread_priority, priority_bit)
                            _tx_thread_preempted_map_active =  _tx_thread_preempted_map_active | priority_bit;
#endif

                            /* Remember that this thread was preempted by a thread above the thread's threshold.  */
                            TX_MOD32_BIT_SET(thread_ptr -> tx_thread_priority, priority_bit)
 8009a20:	687b      	ldr	r3, [r7, #4]
 8009a22:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009a24:	2201      	movs	r2, #1
 8009a26:	fa02 f303 	lsl.w	r3, r2, r3
 8009a2a:	637b      	str	r3, [r7, #52]	; 0x34
                            _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] | priority_bit;
 8009a2c:	4b0a      	ldr	r3, [pc, #40]	; (8009a58 <_tx_mutex_priority_change+0x194>)
 8009a2e:	681a      	ldr	r2, [r3, #0]
 8009a30:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009a32:	4313      	orrs	r3, r2
 8009a34:	4a08      	ldr	r2, [pc, #32]	; (8009a58 <_tx_mutex_priority_change+0x194>)
 8009a36:	6013      	str	r3, [r2, #0]
 8009a38:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8009a3a:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009a3c:	68fb      	ldr	r3, [r7, #12]
 8009a3e:	f383 8810 	msr	PRIMASK, r3
}
 8009a42:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
#endif
    }
}
 8009a44:	bf00      	nop
 8009a46:	3748      	adds	r7, #72	; 0x48
 8009a48:	46bd      	mov	sp, r7
 8009a4a:	bd80      	pop	{r7, pc}
 8009a4c:	2000efbc 	.word	0x2000efbc
 8009a50:	2000f054 	.word	0x2000f054
 8009a54:	2000efd4 	.word	0x2000efd4
 8009a58:	2000efcc 	.word	0x2000efcc

08009a5c <_tx_mutex_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_put(TX_MUTEX *mutex_ptr)
{
 8009a5c:	b580      	push	{r7, lr}
 8009a5e:	b0a6      	sub	sp, #152	; 0x98
 8009a60:	af00      	add	r7, sp, #0
 8009a62:	6078      	str	r0, [r7, #4]
TX_THREAD       *suspended_thread;
UINT            inheritance_priority;


    /* Setup status to indicate the processing is not complete.  */
    status =  TX_NOT_DONE;
 8009a64:	2320      	movs	r3, #32
 8009a66:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009a6a:	f3ef 8310 	mrs	r3, PRIMASK
 8009a6e:	65fb      	str	r3, [r7, #92]	; 0x5c
    return(posture);
 8009a70:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    int_posture = __get_interrupt_posture();
 8009a72:	65bb      	str	r3, [r7, #88]	; 0x58
    __asm__ volatile ("CPSID i" : : : "memory");
 8009a74:	b672      	cpsid	i
    return(int_posture);
 8009a76:	6dbb      	ldr	r3, [r7, #88]	; 0x58

    /* Disable interrupts to put an instance back to the mutex.  */
    TX_DISABLE
 8009a78:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

    /* Log this kernel call.  */
    TX_EL_MUTEX_PUT_INSERT

    /* Determine if this mutex is owned.  */
    if (mutex_ptr -> tx_mutex_ownership_count != ((UINT) 0))
 8009a7c:	687b      	ldr	r3, [r7, #4]
 8009a7e:	689b      	ldr	r3, [r3, #8]
 8009a80:	2b00      	cmp	r3, #0
 8009a82:	f000 81ff 	beq.w	8009e84 <_tx_mutex_put+0x428>
    {

        /* Pickup the owning thread pointer.  */
        thread_ptr =  mutex_ptr -> tx_mutex_owner;
 8009a86:	687b      	ldr	r3, [r7, #4]
 8009a88:	68db      	ldr	r3, [r3, #12]
 8009a8a:	67fb      	str	r3, [r7, #124]	; 0x7c

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(current_thread)
 8009a8c:	4ba3      	ldr	r3, [pc, #652]	; (8009d1c <_tx_mutex_put+0x2c0>)
 8009a8e:	681b      	ldr	r3, [r3, #0]
 8009a90:	67bb      	str	r3, [r7, #120]	; 0x78

        /* Check to see if the mutex is owned by the calling thread.  */
        if (mutex_ptr -> tx_mutex_owner != current_thread)
 8009a92:	687b      	ldr	r3, [r7, #4]
 8009a94:	68db      	ldr	r3, [r3, #12]
 8009a96:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8009a98:	429a      	cmp	r2, r3
 8009a9a:	d00d      	beq.n	8009ab8 <_tx_mutex_put+0x5c>
        {

            /* Determine if the preempt disable flag is set, indicating that
               the caller is not the application but from ThreadX. In such
               cases, the thread mutex owner does not need to match.  */
            if (_tx_thread_preempt_disable == ((UINT) 0))
 8009a9c:	4ba0      	ldr	r3, [pc, #640]	; (8009d20 <_tx_mutex_put+0x2c4>)
 8009a9e:	681b      	ldr	r3, [r3, #0]
 8009aa0:	2b00      	cmp	r3, #0
 8009aa2:	d109      	bne.n	8009ab8 <_tx_mutex_put+0x5c>
 8009aa4:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8009aa8:	657b      	str	r3, [r7, #84]	; 0x54
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009aaa:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8009aac:	f383 8810 	msr	PRIMASK, r3
}
 8009ab0:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Caller does not own the mutex.  */
                status =  TX_NOT_OWNED;
 8009ab2:	231e      	movs	r3, #30
 8009ab4:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
            }
        }

        /* Determine if we should continue.  */
        if (status == TX_NOT_DONE)
 8009ab8:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8009abc:	2b20      	cmp	r3, #32
 8009abe:	f040 81eb 	bne.w	8009e98 <_tx_mutex_put+0x43c>
        {

            /* Decrement the mutex ownership count.  */
            mutex_ptr -> tx_mutex_ownership_count--;
 8009ac2:	687b      	ldr	r3, [r7, #4]
 8009ac4:	689b      	ldr	r3, [r3, #8]
 8009ac6:	1e5a      	subs	r2, r3, #1
 8009ac8:	687b      	ldr	r3, [r7, #4]
 8009aca:	609a      	str	r2, [r3, #8]

            /* Determine if the mutex is still owned by the current thread.  */
            if (mutex_ptr -> tx_mutex_ownership_count != ((UINT) 0))
 8009acc:	687b      	ldr	r3, [r7, #4]
 8009ace:	689b      	ldr	r3, [r3, #8]
 8009ad0:	2b00      	cmp	r3, #0
 8009ad2:	d00a      	beq.n	8009aea <_tx_mutex_put+0x8e>
 8009ad4:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8009ad8:	653b      	str	r3, [r7, #80]	; 0x50
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009ada:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8009adc:	f383 8810 	msr	PRIMASK, r3
}
 8009ae0:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Mutex is still owned, just return successful status.  */
                status =  TX_SUCCESS;
 8009ae2:	2300      	movs	r3, #0
 8009ae4:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8009ae8:	e1d6      	b.n	8009e98 <_tx_mutex_put+0x43c>
            }
            else
            {

                /* Check for a NULL thread pointer, which can only happen during initialization.   */
                if (thread_ptr == TX_NULL)
 8009aea:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009aec:	2b00      	cmp	r3, #0
 8009aee:	d10a      	bne.n	8009b06 <_tx_mutex_put+0xaa>
 8009af0:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8009af4:	64fb      	str	r3, [r7, #76]	; 0x4c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009af6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8009af8:	f383 8810 	msr	PRIMASK, r3
}
 8009afc:	bf00      	nop

                    /* Restore interrupts.  */
                    TX_RESTORE

                    /* Mutex is now available, return successful status.  */
                    status =  TX_SUCCESS;
 8009afe:	2300      	movs	r3, #0
 8009b00:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8009b04:	e1c8      	b.n	8009e98 <_tx_mutex_put+0x43c>
                    /* The mutex is now available.   */

                    /* Remove this mutex from the owned mutex list.  */

                    /* Decrement the ownership count.  */
                    thread_ptr -> tx_thread_owned_mutex_count--;
 8009b06:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009b08:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8009b0c:	1e5a      	subs	r2, r3, #1
 8009b0e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009b10:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4

                    /* Determine if this mutex was the only one on the list.  */
                    if (thread_ptr -> tx_thread_owned_mutex_count == ((UINT) 0))
 8009b14:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009b16:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8009b1a:	2b00      	cmp	r3, #0
 8009b1c:	d104      	bne.n	8009b28 <_tx_mutex_put+0xcc>
                    {

                        /* Yes, the list is empty.  Simply set the head pointer to NULL.  */
                        thread_ptr -> tx_thread_owned_mutex_list =  TX_NULL;
 8009b1e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009b20:	2200      	movs	r2, #0
 8009b22:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
 8009b26:	e019      	b.n	8009b5c <_tx_mutex_put+0x100>
                    {

                        /* No, there are more mutexes on the list.  */

                        /* Link-up the neighbors.  */
                        next_mutex =                             mutex_ptr -> tx_mutex_owned_next;
 8009b28:	687b      	ldr	r3, [r7, #4]
 8009b2a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009b2c:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                        previous_mutex =                         mutex_ptr -> tx_mutex_owned_previous;
 8009b30:	687b      	ldr	r3, [r7, #4]
 8009b32:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009b34:	677b      	str	r3, [r7, #116]	; 0x74
                        next_mutex -> tx_mutex_owned_previous =  previous_mutex;
 8009b36:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8009b3a:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8009b3c:	631a      	str	r2, [r3, #48]	; 0x30
                        previous_mutex -> tx_mutex_owned_next =  next_mutex;
 8009b3e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8009b40:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8009b44:	62da      	str	r2, [r3, #44]	; 0x2c

                        /* See if we have to update the created list head pointer.  */
                        if (thread_ptr -> tx_thread_owned_mutex_list == mutex_ptr)
 8009b46:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009b48:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8009b4c:	687a      	ldr	r2, [r7, #4]
 8009b4e:	429a      	cmp	r2, r3
 8009b50:	d104      	bne.n	8009b5c <_tx_mutex_put+0x100>
                        {

                            /* Yes, move the head pointer to the next link. */
                            thread_ptr -> tx_thread_owned_mutex_list =  next_mutex;
 8009b52:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009b54:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8009b58:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
                        }
                    }

                    /* Determine if the simple, non-suspension, non-priority inheritance case is present.  */
                    if (mutex_ptr -> tx_mutex_suspension_list == TX_NULL)
 8009b5c:	687b      	ldr	r3, [r7, #4]
 8009b5e:	699b      	ldr	r3, [r3, #24]
 8009b60:	2b00      	cmp	r3, #0
 8009b62:	d110      	bne.n	8009b86 <_tx_mutex_put+0x12a>
                    {

                        /* Is this a priority inheritance mutex?  */
                        if (mutex_ptr -> tx_mutex_inherit == TX_FALSE)
 8009b64:	687b      	ldr	r3, [r7, #4]
 8009b66:	691b      	ldr	r3, [r3, #16]
 8009b68:	2b00      	cmp	r3, #0
 8009b6a:	d10c      	bne.n	8009b86 <_tx_mutex_put+0x12a>
                        {

                            /* Yes, we are done - set the mutex owner to NULL.   */
                            mutex_ptr -> tx_mutex_owner =  TX_NULL;
 8009b6c:	687b      	ldr	r3, [r7, #4]
 8009b6e:	2200      	movs	r2, #0
 8009b70:	60da      	str	r2, [r3, #12]
 8009b72:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8009b76:	64bb      	str	r3, [r7, #72]	; 0x48
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009b78:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8009b7a:	f383 8810 	msr	PRIMASK, r3
}
 8009b7e:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Mutex is now available, return successful status.  */
                            status =  TX_SUCCESS;
 8009b80:	2300      	movs	r3, #0
 8009b82:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
                        }
                    }

                    /* Determine if the processing is complete.  */
                    if (status == TX_NOT_DONE)
 8009b86:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8009b8a:	2b20      	cmp	r3, #32
 8009b8c:	f040 8184 	bne.w	8009e98 <_tx_mutex_put+0x43c>
                    {

                        /* Initialize original owner and thread priority.  */
                        old_owner =      TX_NULL;
 8009b90:	2300      	movs	r3, #0
 8009b92:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
                        old_priority =   thread_ptr -> tx_thread_user_priority;
 8009b96:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009b98:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 8009b9c:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c

                        /* Does this mutex support priority inheritance?  */
                        if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 8009ba0:	687b      	ldr	r3, [r7, #4]
 8009ba2:	691b      	ldr	r3, [r3, #16]
 8009ba4:	2b01      	cmp	r3, #1
 8009ba6:	d155      	bne.n	8009c54 <_tx_mutex_put+0x1f8>
                        {

#ifndef TX_NOT_INTERRUPTABLE

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 8009ba8:	4b5d      	ldr	r3, [pc, #372]	; (8009d20 <_tx_mutex_put+0x2c4>)
 8009baa:	681b      	ldr	r3, [r3, #0]
 8009bac:	3301      	adds	r3, #1
 8009bae:	4a5c      	ldr	r2, [pc, #368]	; (8009d20 <_tx_mutex_put+0x2c4>)
 8009bb0:	6013      	str	r3, [r2, #0]
 8009bb2:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8009bb6:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009bb8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8009bba:	f383 8810 	msr	PRIMASK, r3
}
 8009bbe:	bf00      	nop
                            /* Restore interrupts.  */
                            TX_RESTORE
#endif

                            /* Default the inheritance priority to disabled.  */
                            inheritance_priority =  ((UINT) TX_MAX_PRIORITIES);
 8009bc0:	2320      	movs	r3, #32
 8009bc2:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

                            /* Search the owned mutexes for this thread to determine the highest priority for this
                               former mutex owner to return to.  */
                            next_mutex =  thread_ptr -> tx_thread_owned_mutex_list;
 8009bc6:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009bc8:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8009bcc:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                            while (next_mutex != TX_NULL)
 8009bd0:	e01f      	b.n	8009c12 <_tx_mutex_put+0x1b6>
                            {

                                /* Does this mutex support priority inheritance?  */
                                if (next_mutex -> tx_mutex_inherit == TX_TRUE)
 8009bd2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8009bd6:	691b      	ldr	r3, [r3, #16]
 8009bd8:	2b01      	cmp	r3, #1
 8009bda:	d10b      	bne.n	8009bf4 <_tx_mutex_put+0x198>
                                {

                                    /* Determine if highest priority field of the mutex is higher than the priority to
                                       restore.  */
                                    if (next_mutex -> tx_mutex_highest_priority_waiting < inheritance_priority)
 8009bdc:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8009be0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009be2:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8009be6:	429a      	cmp	r2, r3
 8009be8:	d904      	bls.n	8009bf4 <_tx_mutex_put+0x198>
                                    {

                                        /* Use this priority to return releasing thread to.  */
                                        inheritance_priority =   next_mutex -> tx_mutex_highest_priority_waiting;
 8009bea:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8009bee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009bf0:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
                                    }
                                }

                                /* Move mutex pointer to the next mutex in the list.  */
                                next_mutex =  next_mutex -> tx_mutex_owned_next;
 8009bf4:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8009bf8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009bfa:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84

                                /* Are we at the end of the list?  */
                                if (next_mutex == thread_ptr -> tx_thread_owned_mutex_list)
 8009bfe:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009c00:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8009c04:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8009c08:	429a      	cmp	r2, r3
 8009c0a:	d102      	bne.n	8009c12 <_tx_mutex_put+0x1b6>
                                {

                                    /* Yes, set the next mutex to NULL.  */
                                    next_mutex =  TX_NULL;
 8009c0c:	2300      	movs	r3, #0
 8009c0e:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                            while (next_mutex != TX_NULL)
 8009c12:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8009c16:	2b00      	cmp	r3, #0
 8009c18:	d1db      	bne.n	8009bd2 <_tx_mutex_put+0x176>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009c1a:	f3ef 8310 	mrs	r3, PRIMASK
 8009c1e:	643b      	str	r3, [r7, #64]	; 0x40
    return(posture);
 8009c20:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    int_posture = __get_interrupt_posture();
 8009c22:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("CPSID i" : : : "memory");
 8009c24:	b672      	cpsid	i
    return(int_posture);
 8009c26:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
                            }

#ifndef TX_NOT_INTERRUPTABLE

                            /* Disable interrupts.  */
                            TX_DISABLE
 8009c28:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

                            /* Undo the temporarily preemption disable.  */
                            _tx_thread_preempt_disable--;
 8009c2c:	4b3c      	ldr	r3, [pc, #240]	; (8009d20 <_tx_mutex_put+0x2c4>)
 8009c2e:	681b      	ldr	r3, [r3, #0]
 8009c30:	3b01      	subs	r3, #1
 8009c32:	4a3b      	ldr	r2, [pc, #236]	; (8009d20 <_tx_mutex_put+0x2c4>)
 8009c34:	6013      	str	r3, [r2, #0]
#endif

                            /* Set the inherit priority to that of the highest priority thread waiting on the mutex.  */
                            thread_ptr -> tx_thread_inherit_priority =  inheritance_priority;
 8009c36:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009c38:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8009c3c:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0

                            /* Determine if the inheritance priority is less than the default old priority.  */
                            if (inheritance_priority < old_priority)
 8009c40:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8009c44:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8009c48:	429a      	cmp	r2, r3
 8009c4a:	d203      	bcs.n	8009c54 <_tx_mutex_put+0x1f8>
                            {

                                /* Yes, update the old priority.  */
                                old_priority =  inheritance_priority;
 8009c4c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8009c50:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
                            }
                        }

                        /* Determine if priority inheritance is in effect and there are one or more
                           threads suspended on the mutex.  */
                        if (mutex_ptr -> tx_mutex_suspended_count > ((UINT) 1))
 8009c54:	687b      	ldr	r3, [r7, #4]
 8009c56:	69db      	ldr	r3, [r3, #28]
 8009c58:	2b01      	cmp	r3, #1
 8009c5a:	d920      	bls.n	8009c9e <_tx_mutex_put+0x242>
                        {

                            /* Is priority inheritance in effect?  */
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 8009c5c:	687b      	ldr	r3, [r7, #4]
 8009c5e:	691b      	ldr	r3, [r3, #16]
 8009c60:	2b01      	cmp	r3, #1
 8009c62:	d11c      	bne.n	8009c9e <_tx_mutex_put+0x242>
                                   at the front of the suspension list.  */

#ifndef TX_NOT_INTERRUPTABLE

                                /* Temporarily disable preemption.  */
                                _tx_thread_preempt_disable++;
 8009c64:	4b2e      	ldr	r3, [pc, #184]	; (8009d20 <_tx_mutex_put+0x2c4>)
 8009c66:	681b      	ldr	r3, [r3, #0]
 8009c68:	3301      	adds	r3, #1
 8009c6a:	4a2d      	ldr	r2, [pc, #180]	; (8009d20 <_tx_mutex_put+0x2c4>)
 8009c6c:	6013      	str	r3, [r2, #0]
 8009c6e:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8009c72:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009c74:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009c76:	f383 8810 	msr	PRIMASK, r3
}
 8009c7a:	bf00      	nop
                                do
                                {
                                    status =  _tx_mutex_prioritize(mutex_ptr);
                                } while (status != TX_SUCCESS);
#else
                                _tx_mutex_prioritize(mutex_ptr);
 8009c7c:	6878      	ldr	r0, [r7, #4]
 8009c7e:	f7ff fd6f 	bl	8009760 <_tx_mutex_prioritize>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009c82:	f3ef 8310 	mrs	r3, PRIMASK
 8009c86:	63bb      	str	r3, [r7, #56]	; 0x38
    return(posture);
 8009c88:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    int_posture = __get_interrupt_posture();
 8009c8a:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile ("CPSID i" : : : "memory");
 8009c8c:	b672      	cpsid	i
    return(int_posture);
 8009c8e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
                                TX_MUTEX_PUT_EXTENSION_1

#ifndef TX_NOT_INTERRUPTABLE

                                /* Disable interrupts.  */
                                TX_DISABLE
 8009c90:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

                                /* Back off the preemption disable.  */
                                _tx_thread_preempt_disable--;
 8009c94:	4b22      	ldr	r3, [pc, #136]	; (8009d20 <_tx_mutex_put+0x2c4>)
 8009c96:	681b      	ldr	r3, [r3, #0]
 8009c98:	3b01      	subs	r3, #1
 8009c9a:	4a21      	ldr	r2, [pc, #132]	; (8009d20 <_tx_mutex_put+0x2c4>)
 8009c9c:	6013      	str	r3, [r2, #0]
#endif
                            }
                        }

                        /* Now determine if there are any threads still waiting on the mutex.  */
                        if (mutex_ptr -> tx_mutex_suspension_list == TX_NULL)
 8009c9e:	687b      	ldr	r3, [r7, #4]
 8009ca0:	699b      	ldr	r3, [r3, #24]
 8009ca2:	2b00      	cmp	r3, #0
 8009ca4:	d13e      	bne.n	8009d24 <_tx_mutex_put+0x2c8>
                            /* No, there are no longer any threads waiting on the mutex.  */

#ifndef TX_NOT_INTERRUPTABLE

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 8009ca6:	4b1e      	ldr	r3, [pc, #120]	; (8009d20 <_tx_mutex_put+0x2c4>)
 8009ca8:	681b      	ldr	r3, [r3, #0]
 8009caa:	3301      	adds	r3, #1
 8009cac:	4a1c      	ldr	r2, [pc, #112]	; (8009d20 <_tx_mutex_put+0x2c4>)
 8009cae:	6013      	str	r3, [r2, #0]
 8009cb0:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8009cb4:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009cb6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009cb8:	f383 8810 	msr	PRIMASK, r3
}
 8009cbc:	bf00      	nop
                            /* Mutex is not owned, but it is possible that a thread that
                               caused a priority inheritance to occur is no longer waiting
                               on the mutex.  */

                            /* Setup the highest priority waiting thread.  */
                            mutex_ptr -> tx_mutex_highest_priority_waiting =  (UINT) TX_MAX_PRIORITIES;
 8009cbe:	687b      	ldr	r3, [r7, #4]
 8009cc0:	2220      	movs	r2, #32
 8009cc2:	629a      	str	r2, [r3, #40]	; 0x28

                            /* Determine if we need to restore priority.  */
                            if ((mutex_ptr -> tx_mutex_owner) -> tx_thread_priority != old_priority)
 8009cc4:	687b      	ldr	r3, [r7, #4]
 8009cc6:	68db      	ldr	r3, [r3, #12]
 8009cc8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009cca:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 8009cce:	429a      	cmp	r2, r3
 8009cd0:	d006      	beq.n	8009ce0 <_tx_mutex_put+0x284>
                            {

                                /* Yes, restore the priority of thread.  */
                                _tx_mutex_priority_change(mutex_ptr -> tx_mutex_owner, old_priority);
 8009cd2:	687b      	ldr	r3, [r7, #4]
 8009cd4:	68db      	ldr	r3, [r3, #12]
 8009cd6:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
 8009cda:	4618      	mov	r0, r3
 8009cdc:	f7ff fdf2 	bl	80098c4 <_tx_mutex_priority_change>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009ce0:	f3ef 8310 	mrs	r3, PRIMASK
 8009ce4:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 8009ce6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 8009ce8:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 8009cea:	b672      	cpsid	i
    return(int_posture);
 8009cec:	6a3b      	ldr	r3, [r7, #32]
                            }

#ifndef TX_NOT_INTERRUPTABLE

                            /* Disable interrupts again.  */
                            TX_DISABLE
 8009cee:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

                            /* Back off the preemption disable.  */
                            _tx_thread_preempt_disable--;
 8009cf2:	4b0b      	ldr	r3, [pc, #44]	; (8009d20 <_tx_mutex_put+0x2c4>)
 8009cf4:	681b      	ldr	r3, [r3, #0]
 8009cf6:	3b01      	subs	r3, #1
 8009cf8:	4a09      	ldr	r2, [pc, #36]	; (8009d20 <_tx_mutex_put+0x2c4>)
 8009cfa:	6013      	str	r3, [r2, #0]
#endif

                            /* Set the mutex owner to NULL.  */
                            mutex_ptr -> tx_mutex_owner =  TX_NULL;
 8009cfc:	687b      	ldr	r3, [r7, #4]
 8009cfe:	2200      	movs	r2, #0
 8009d00:	60da      	str	r2, [r3, #12]
 8009d02:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8009d06:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009d08:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009d0a:	f383 8810 	msr	PRIMASK, r3
}
 8009d0e:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Check for preemption.  */
                            _tx_thread_system_preempt_check();
 8009d10:	f002 fb52 	bl	800c3b8 <_tx_thread_system_preempt_check>

                            /* Set status to success.  */
                            status =  TX_SUCCESS;
 8009d14:	2300      	movs	r3, #0
 8009d16:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8009d1a:	e0bd      	b.n	8009e98 <_tx_mutex_put+0x43c>
 8009d1c:	2000efb8 	.word	0x2000efb8
 8009d20:	2000f054 	.word	0x2000f054
                        }
                        else
                        {

                            /* Pickup the thread at the front of the suspension list.  */
                            thread_ptr =  mutex_ptr -> tx_mutex_suspension_list;
 8009d24:	687b      	ldr	r3, [r7, #4]
 8009d26:	699b      	ldr	r3, [r3, #24]
 8009d28:	67fb      	str	r3, [r7, #124]	; 0x7c

                            /* Save the previous ownership information, if inheritance is
                               in effect.  */
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 8009d2a:	687b      	ldr	r3, [r7, #4]
 8009d2c:	691b      	ldr	r3, [r3, #16]
 8009d2e:	2b01      	cmp	r3, #1
 8009d30:	d10a      	bne.n	8009d48 <_tx_mutex_put+0x2ec>
                            {

                                /* Remember the old mutex owner.  */
                                old_owner =  mutex_ptr -> tx_mutex_owner;
 8009d32:	687b      	ldr	r3, [r7, #4]
 8009d34:	68db      	ldr	r3, [r3, #12]
 8009d36:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

                                /* Setup owner thread priority information.  */
                                mutex_ptr -> tx_mutex_original_priority =   thread_ptr -> tx_thread_priority;
 8009d3a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009d3c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8009d3e:	687b      	ldr	r3, [r7, #4]
 8009d40:	615a      	str	r2, [r3, #20]

                                /* Setup the highest priority waiting thread.  */
                                mutex_ptr -> tx_mutex_highest_priority_waiting =  (UINT) TX_MAX_PRIORITIES;
 8009d42:	687b      	ldr	r3, [r7, #4]
 8009d44:	2220      	movs	r2, #32
 8009d46:	629a      	str	r2, [r3, #40]	; 0x28
                            }

                            /* Determine how many mutexes are owned by this thread.  */
                            owned_count =  thread_ptr -> tx_thread_owned_mutex_count;
 8009d48:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009d4a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8009d4e:	673b      	str	r3, [r7, #112]	; 0x70

                            /* Determine if this thread owns any other mutexes that have priority inheritance.  */
                            if (owned_count == ((UINT) 0))
 8009d50:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8009d52:	2b00      	cmp	r3, #0
 8009d54:	d10a      	bne.n	8009d6c <_tx_mutex_put+0x310>
                            {

                                /* The owned mutex list is empty.  Add mutex to empty list.  */
                                thread_ptr -> tx_thread_owned_mutex_list =     mutex_ptr;
 8009d56:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009d58:	687a      	ldr	r2, [r7, #4]
 8009d5a:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
                                mutex_ptr -> tx_mutex_owned_next =             mutex_ptr;
 8009d5e:	687b      	ldr	r3, [r7, #4]
 8009d60:	687a      	ldr	r2, [r7, #4]
 8009d62:	62da      	str	r2, [r3, #44]	; 0x2c
                                mutex_ptr -> tx_mutex_owned_previous =         mutex_ptr;
 8009d64:	687b      	ldr	r3, [r7, #4]
 8009d66:	687a      	ldr	r2, [r7, #4]
 8009d68:	631a      	str	r2, [r3, #48]	; 0x30
 8009d6a:	e016      	b.n	8009d9a <_tx_mutex_put+0x33e>
                            {

                                /* Non-empty list. Link up the mutex.  */

                                /* Pickup tail pointer.  */
                                next_mutex =                            thread_ptr -> tx_thread_owned_mutex_list;
 8009d6c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009d6e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8009d72:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                                previous_mutex =                        next_mutex -> tx_mutex_owned_previous;
 8009d76:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8009d7a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009d7c:	677b      	str	r3, [r7, #116]	; 0x74

                                /* Place the owned mutex in the list.  */
                                next_mutex -> tx_mutex_owned_previous =  mutex_ptr;
 8009d7e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8009d82:	687a      	ldr	r2, [r7, #4]
 8009d84:	631a      	str	r2, [r3, #48]	; 0x30
                                previous_mutex -> tx_mutex_owned_next =  mutex_ptr;
 8009d86:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8009d88:	687a      	ldr	r2, [r7, #4]
 8009d8a:	62da      	str	r2, [r3, #44]	; 0x2c

                                /* Setup this mutex's next and previous created links.  */
                                mutex_ptr -> tx_mutex_owned_previous =   previous_mutex;
 8009d8c:	687b      	ldr	r3, [r7, #4]
 8009d8e:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8009d90:	631a      	str	r2, [r3, #48]	; 0x30
                                mutex_ptr -> tx_mutex_owned_next =       next_mutex;
 8009d92:	687b      	ldr	r3, [r7, #4]
 8009d94:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8009d98:	62da      	str	r2, [r3, #44]	; 0x2c
                            }

                            /* Increment the number of mutexes owned counter.  */
                            thread_ptr -> tx_thread_owned_mutex_count =  owned_count + ((UINT) 1);
 8009d9a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8009d9c:	1c5a      	adds	r2, r3, #1
 8009d9e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009da0:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4

                            /* Mark the Mutex as owned and fill in the corresponding information.  */
                            mutex_ptr -> tx_mutex_ownership_count =  (UINT) 1;
 8009da4:	687b      	ldr	r3, [r7, #4]
 8009da6:	2201      	movs	r2, #1
 8009da8:	609a      	str	r2, [r3, #8]
                            mutex_ptr -> tx_mutex_owner =            thread_ptr;
 8009daa:	687b      	ldr	r3, [r7, #4]
 8009dac:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8009dae:	60da      	str	r2, [r3, #12]

                            /* Remove the suspended thread from the list.  */

                            /* Decrement the suspension count.  */
                            mutex_ptr -> tx_mutex_suspended_count--;
 8009db0:	687b      	ldr	r3, [r7, #4]
 8009db2:	69db      	ldr	r3, [r3, #28]
 8009db4:	1e5a      	subs	r2, r3, #1
 8009db6:	687b      	ldr	r3, [r7, #4]
 8009db8:	61da      	str	r2, [r3, #28]

                            /* Pickup the suspended count.  */
                            suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
 8009dba:	687b      	ldr	r3, [r7, #4]
 8009dbc:	69db      	ldr	r3, [r3, #28]
 8009dbe:	66fb      	str	r3, [r7, #108]	; 0x6c

                            /* See if this is the only suspended thread on the list.  */
                            if (suspended_count == TX_NO_SUSPENSIONS)
 8009dc0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8009dc2:	2b00      	cmp	r3, #0
 8009dc4:	d103      	bne.n	8009dce <_tx_mutex_put+0x372>
                            {

                                /* Yes, the only suspended thread.  */

                                /* Update the head pointer.  */
                                mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
 8009dc6:	687b      	ldr	r3, [r7, #4]
 8009dc8:	2200      	movs	r2, #0
 8009dca:	619a      	str	r2, [r3, #24]
 8009dcc:	e00e      	b.n	8009dec <_tx_mutex_put+0x390>
                            {

                                /* At least one more thread is on the same expiration list.  */

                                /* Update the list head pointer.  */
                                next_thread =                                  thread_ptr -> tx_thread_suspended_next;
 8009dce:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009dd0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8009dd2:	66bb      	str	r3, [r7, #104]	; 0x68
                                mutex_ptr -> tx_mutex_suspension_list =        next_thread;
 8009dd4:	687b      	ldr	r3, [r7, #4]
 8009dd6:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8009dd8:	619a      	str	r2, [r3, #24]

                                /* Update the links of the adjacent threads.  */
                                previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
 8009dda:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009ddc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8009dde:	667b      	str	r3, [r7, #100]	; 0x64
                                next_thread -> tx_thread_suspended_previous =  previous_thread;
 8009de0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8009de2:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8009de4:	675a      	str	r2, [r3, #116]	; 0x74
                                previous_thread -> tx_thread_suspended_next =  next_thread;
 8009de6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8009de8:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8009dea:	671a      	str	r2, [r3, #112]	; 0x70
                            }

                            /* Prepare for resumption of the first thread.  */

                            /* Clear cleanup routine to avoid timeout.  */
                            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8009dec:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009dee:	2200      	movs	r2, #0
 8009df0:	669a      	str	r2, [r3, #104]	; 0x68

                            /* Put return status into the thread control block.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 8009df2:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009df4:	2200      	movs	r2, #0
 8009df6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                            /* Restore interrupts.  */
                            TX_RESTORE
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 8009dfa:	4b2a      	ldr	r3, [pc, #168]	; (8009ea4 <_tx_mutex_put+0x448>)
 8009dfc:	681b      	ldr	r3, [r3, #0]
 8009dfe:	3301      	adds	r3, #1
 8009e00:	4a28      	ldr	r2, [pc, #160]	; (8009ea4 <_tx_mutex_put+0x448>)
 8009e02:	6013      	str	r3, [r2, #0]
 8009e04:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8009e08:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009e0a:	69fb      	ldr	r3, [r7, #28]
 8009e0c:	f383 8810 	msr	PRIMASK, r3
}
 8009e10:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Determine if priority inheritance is enabled for this mutex.  */
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 8009e12:	687b      	ldr	r3, [r7, #4]
 8009e14:	691b      	ldr	r3, [r3, #16]
 8009e16:	2b01      	cmp	r3, #1
 8009e18:	d12d      	bne.n	8009e76 <_tx_mutex_put+0x41a>
                            {

                                /* Yes, priority inheritance is requested.  */

                                /* Determine if there are any more threads still suspended on the mutex.  */
                                if (mutex_ptr -> tx_mutex_suspended_count != TX_NO_SUSPENSIONS)
 8009e1a:	687b      	ldr	r3, [r7, #4]
 8009e1c:	69db      	ldr	r3, [r3, #28]
 8009e1e:	2b00      	cmp	r3, #0
 8009e20:	d01c      	beq.n	8009e5c <_tx_mutex_put+0x400>
                                    do
                                    {
                                        status =  _tx_mutex_prioritize(mutex_ptr);
                                    } while (status != TX_SUCCESS);
#else
                                    _tx_mutex_prioritize(mutex_ptr);
 8009e22:	6878      	ldr	r0, [r7, #4]
 8009e24:	f7ff fc9c 	bl	8009760 <_tx_mutex_prioritize>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009e28:	f3ef 8310 	mrs	r3, PRIMASK
 8009e2c:	61bb      	str	r3, [r7, #24]
    return(posture);
 8009e2e:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8009e30:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8009e32:	b672      	cpsid	i
    return(int_posture);
 8009e34:	697b      	ldr	r3, [r7, #20]

                                    /* Optional processing extension.  */
                                    TX_MUTEX_PUT_EXTENSION_2

                                    /* Disable interrupts.  */
                                    TX_DISABLE
 8009e36:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

                                    /* Determine if there still are threads suspended for this mutex.  */
                                    suspended_thread =  mutex_ptr -> tx_mutex_suspension_list;
 8009e3a:	687b      	ldr	r3, [r7, #4]
 8009e3c:	699b      	ldr	r3, [r3, #24]
 8009e3e:	663b      	str	r3, [r7, #96]	; 0x60
                                    if (suspended_thread != TX_NULL)
 8009e40:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8009e42:	2b00      	cmp	r3, #0
 8009e44:	d003      	beq.n	8009e4e <_tx_mutex_put+0x3f2>
                                    {

                                        /* Setup the highest priority thread waiting on this mutex.  */
                                        mutex_ptr -> tx_mutex_highest_priority_waiting =  suspended_thread -> tx_thread_priority;
 8009e46:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8009e48:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8009e4a:	687b      	ldr	r3, [r7, #4]
 8009e4c:	629a      	str	r2, [r3, #40]	; 0x28
 8009e4e:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8009e52:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009e54:	693b      	ldr	r3, [r7, #16]
 8009e56:	f383 8810 	msr	PRIMASK, r3
}
 8009e5a:	bf00      	nop

                                /* Restore previous priority needs to be restored after priority
                                   inheritance.  */

                                /* Is the priority different?  */
                                if (old_owner -> tx_thread_priority != old_priority)
 8009e5c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8009e60:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009e62:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 8009e66:	429a      	cmp	r2, r3
 8009e68:	d005      	beq.n	8009e76 <_tx_mutex_put+0x41a>
                                {

                                    /* Restore the priority of thread.  */
                                    _tx_mutex_priority_change(old_owner, old_priority);
 8009e6a:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
 8009e6e:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 8009e72:	f7ff fd27 	bl	80098c4 <_tx_mutex_priority_change>
                                }
                            }

                            /* Resume thread.  */
                            _tx_thread_system_resume(thread_ptr);
 8009e76:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 8009e78:	f002 fad8 	bl	800c42c <_tx_thread_system_resume>
#endif

                            /* Return a successful status.  */
                            status =  TX_SUCCESS;
 8009e7c:	2300      	movs	r3, #0
 8009e7e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8009e82:	e009      	b.n	8009e98 <_tx_mutex_put+0x43c>
 8009e84:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8009e88:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009e8a:	68fb      	ldr	r3, [r7, #12]
 8009e8c:	f383 8810 	msr	PRIMASK, r3
}
 8009e90:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Caller does not own the mutex.  */
        status =  TX_NOT_OWNED;
 8009e92:	231e      	movs	r3, #30
 8009e94:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    }

    /* Return the completion status.  */
    return(status);
 8009e98:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
}
 8009e9c:	4618      	mov	r0, r3
 8009e9e:	3798      	adds	r7, #152	; 0x98
 8009ea0:	46bd      	mov	sp, r7
 8009ea2:	bd80      	pop	{r7, pc}
 8009ea4:	2000f054 	.word	0x2000f054

08009ea8 <_tx_queue_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_queue_cleanup(TX_THREAD  *thread_ptr, ULONG suspension_sequence)
{
 8009ea8:	b580      	push	{r7, lr}
 8009eaa:	b08e      	sub	sp, #56	; 0x38
 8009eac:	af00      	add	r7, sp, #0
 8009eae:	6078      	str	r0, [r7, #4]
 8009eb0:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009eb2:	f3ef 8310 	mrs	r3, PRIMASK
 8009eb6:	623b      	str	r3, [r7, #32]
    return(posture);
 8009eb8:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 8009eba:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 8009ebc:	b672      	cpsid	i
    return(int_posture);
 8009ebe:	69fb      	ldr	r3, [r7, #28]


#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the queue.  */
    TX_DISABLE
 8009ec0:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_queue_cleanup))
 8009ec2:	687b      	ldr	r3, [r7, #4]
 8009ec4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8009ec6:	4a37      	ldr	r2, [pc, #220]	; (8009fa4 <_tx_queue_cleanup+0xfc>)
 8009ec8:	4293      	cmp	r3, r2
 8009eca:	d161      	bne.n	8009f90 <_tx_queue_cleanup+0xe8>
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
 8009ecc:	687b      	ldr	r3, [r7, #4]
 8009ece:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 8009ed2:	683a      	ldr	r2, [r7, #0]
 8009ed4:	429a      	cmp	r2, r3
 8009ed6:	d15b      	bne.n	8009f90 <_tx_queue_cleanup+0xe8>
        {

            /* Setup pointer to queue control block.  */
            queue_ptr =  TX_VOID_TO_QUEUE_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
 8009ed8:	687b      	ldr	r3, [r7, #4]
 8009eda:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8009edc:	633b      	str	r3, [r7, #48]	; 0x30

            /* Check for NULL queue pointer.  */
            if (queue_ptr != TX_NULL)
 8009ede:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009ee0:	2b00      	cmp	r3, #0
 8009ee2:	d055      	beq.n	8009f90 <_tx_queue_cleanup+0xe8>
            {

                /* Is the queue ID valid?  */
                if (queue_ptr -> tx_queue_id == TX_QUEUE_ID)
 8009ee4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009ee6:	681b      	ldr	r3, [r3, #0]
 8009ee8:	4a2f      	ldr	r2, [pc, #188]	; (8009fa8 <_tx_queue_cleanup+0x100>)
 8009eea:	4293      	cmp	r3, r2
 8009eec:	d150      	bne.n	8009f90 <_tx_queue_cleanup+0xe8>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (queue_ptr -> tx_queue_suspended_count != TX_NO_SUSPENSIONS)
 8009eee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009ef0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009ef2:	2b00      	cmp	r3, #0
 8009ef4:	d04c      	beq.n	8009f90 <_tx_queue_cleanup+0xe8>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8009ef6:	687b      	ldr	r3, [r7, #4]
 8009ef8:	2200      	movs	r2, #0
 8009efa:	669a      	str	r2, [r3, #104]	; 0x68

                        /* Decrement the suspended count.  */
                        queue_ptr -> tx_queue_suspended_count--;
 8009efc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009efe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009f00:	1e5a      	subs	r2, r3, #1
 8009f02:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009f04:	62da      	str	r2, [r3, #44]	; 0x2c

                        /* Pickup the suspended count.  */
                        suspended_count =  queue_ptr -> tx_queue_suspended_count;
 8009f06:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009f08:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009f0a:	62fb      	str	r3, [r7, #44]	; 0x2c

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
 8009f0c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009f0e:	2b00      	cmp	r3, #0
 8009f10:	d103      	bne.n	8009f1a <_tx_queue_cleanup+0x72>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            queue_ptr -> tx_queue_suspension_list =  TX_NULL;
 8009f12:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009f14:	2200      	movs	r2, #0
 8009f16:	629a      	str	r2, [r3, #40]	; 0x28
 8009f18:	e013      	b.n	8009f42 <_tx_queue_cleanup+0x9a>
                        {

                            /* At least one more thread is on the same suspension list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
 8009f1a:	687b      	ldr	r3, [r7, #4]
 8009f1c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8009f1e:	62bb      	str	r3, [r7, #40]	; 0x28
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 8009f20:	687b      	ldr	r3, [r7, #4]
 8009f22:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8009f24:	627b      	str	r3, [r7, #36]	; 0x24
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
 8009f26:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009f28:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009f2a:	675a      	str	r2, [r3, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
 8009f2c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009f2e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8009f30:	671a      	str	r2, [r3, #112]	; 0x70

                            /* Determine if we need to update the head pointer.  */
                            if (queue_ptr -> tx_queue_suspension_list == thread_ptr)
 8009f32:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009f34:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009f36:	687a      	ldr	r2, [r7, #4]
 8009f38:	429a      	cmp	r2, r3
 8009f3a:	d102      	bne.n	8009f42 <_tx_queue_cleanup+0x9a>
                            {

                                /* Update the list head pointer.  */
                                queue_ptr -> tx_queue_suspension_list =         next_thread;
 8009f3c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009f3e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8009f40:	629a      	str	r2, [r3, #40]	; 0x28
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_QUEUE_SUSP)
 8009f42:	687b      	ldr	r3, [r7, #4]
 8009f44:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009f46:	2b05      	cmp	r3, #5
 8009f48:	d122      	bne.n	8009f90 <_tx_queue_cleanup+0xe8>
                            /* Increment the number of timeouts on this queue.  */
                            queue_ptr -> tx_queue_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            if (queue_ptr -> tx_queue_enqueued != TX_NO_MESSAGES)
 8009f4a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009f4c:	691b      	ldr	r3, [r3, #16]
 8009f4e:	2b00      	cmp	r3, #0
 8009f50:	d004      	beq.n	8009f5c <_tx_queue_cleanup+0xb4>
                            {

                                /* Queue full timeout!  */
                                thread_ptr -> tx_thread_suspend_status =  TX_QUEUE_FULL;
 8009f52:	687b      	ldr	r3, [r7, #4]
 8009f54:	220b      	movs	r2, #11
 8009f56:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
 8009f5a:	e003      	b.n	8009f64 <_tx_queue_cleanup+0xbc>
                            }
                            else
                            {

                                /* Queue empty timeout!  */
                                thread_ptr -> tx_thread_suspend_status =  TX_QUEUE_EMPTY;
 8009f5c:	687b      	ldr	r3, [r7, #4]
 8009f5e:	220a      	movs	r2, #10
 8009f60:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 8009f64:	4b11      	ldr	r3, [pc, #68]	; (8009fac <_tx_queue_cleanup+0x104>)
 8009f66:	681b      	ldr	r3, [r3, #0]
 8009f68:	3301      	adds	r3, #1
 8009f6a:	4a10      	ldr	r2, [pc, #64]	; (8009fac <_tx_queue_cleanup+0x104>)
 8009f6c:	6013      	str	r3, [r2, #0]
 8009f6e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009f70:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009f72:	693b      	ldr	r3, [r7, #16]
 8009f74:	f383 8810 	msr	PRIMASK, r3
}
 8009f78:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
 8009f7a:	6878      	ldr	r0, [r7, #4]
 8009f7c:	f002 fa56 	bl	800c42c <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009f80:	f3ef 8310 	mrs	r3, PRIMASK
 8009f84:	61bb      	str	r3, [r7, #24]
    return(posture);
 8009f86:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8009f88:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8009f8a:	b672      	cpsid	i
    return(int_posture);
 8009f8c:	697b      	ldr	r3, [r7, #20]

                            /* Disable interrupts.  */
                            TX_DISABLE
 8009f8e:	637b      	str	r3, [r7, #52]	; 0x34
 8009f90:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009f92:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009f94:	68fb      	ldr	r3, [r7, #12]
 8009f96:	f383 8810 	msr	PRIMASK, r3
}
 8009f9a:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 8009f9c:	bf00      	nop
 8009f9e:	3738      	adds	r7, #56	; 0x38
 8009fa0:	46bd      	mov	sp, r7
 8009fa2:	bd80      	pop	{r7, pc}
 8009fa4:	08009ea9 	.word	0x08009ea9
 8009fa8:	51554555 	.word	0x51554555
 8009fac:	2000f054 	.word	0x2000f054

08009fb0 <_tx_queue_create>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_create(TX_QUEUE *queue_ptr, CHAR *name_ptr, UINT message_size,
                        VOID *queue_start, ULONG queue_size)
{
 8009fb0:	b580      	push	{r7, lr}
 8009fb2:	b08c      	sub	sp, #48	; 0x30
 8009fb4:	af00      	add	r7, sp, #0
 8009fb6:	60f8      	str	r0, [r7, #12]
 8009fb8:	60b9      	str	r1, [r7, #8]
 8009fba:	607a      	str	r2, [r7, #4]
 8009fbc:	603b      	str	r3, [r7, #0]
TX_QUEUE        *next_queue;
TX_QUEUE        *previous_queue;


    /* Initialize queue control block to all zeros.  */
    TX_MEMSET(queue_ptr, 0, (sizeof(TX_QUEUE)));
 8009fbe:	2244      	movs	r2, #68	; 0x44
 8009fc0:	2100      	movs	r1, #0
 8009fc2:	68f8      	ldr	r0, [r7, #12]
 8009fc4:	f00c fd0e 	bl	80169e4 <memset>

    /* Setup the basic queue fields.  */
    queue_ptr -> tx_queue_name =             name_ptr;
 8009fc8:	68fb      	ldr	r3, [r7, #12]
 8009fca:	68ba      	ldr	r2, [r7, #8]
 8009fcc:	605a      	str	r2, [r3, #4]

    /* Save the message size in the control block.  */
    queue_ptr -> tx_queue_message_size =  message_size;
 8009fce:	68fb      	ldr	r3, [r7, #12]
 8009fd0:	687a      	ldr	r2, [r7, #4]
 8009fd2:	609a      	str	r2, [r3, #8]

    /* Determine how many messages will fit in the queue area and the number
       of ULONGs used.  */
    capacity =    (UINT) (queue_size / ((ULONG) (((ULONG) message_size) * (sizeof(ULONG)))));
 8009fd4:	687b      	ldr	r3, [r7, #4]
 8009fd6:	009b      	lsls	r3, r3, #2
 8009fd8:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8009fda:	fbb2 f3f3 	udiv	r3, r2, r3
 8009fde:	62fb      	str	r3, [r7, #44]	; 0x2c
    used_words =  capacity * message_size;
 8009fe0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009fe2:	687a      	ldr	r2, [r7, #4]
 8009fe4:	fb02 f303 	mul.w	r3, r2, r3
 8009fe8:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Save the starting address and calculate the ending address of
       the queue.  Note that the ending address is really one past the
       end!  */
    queue_ptr -> tx_queue_start =  TX_VOID_TO_ULONG_POINTER_CONVERT(queue_start);
 8009fea:	68fb      	ldr	r3, [r7, #12]
 8009fec:	683a      	ldr	r2, [r7, #0]
 8009fee:	619a      	str	r2, [r3, #24]
    queue_ptr -> tx_queue_end =    TX_ULONG_POINTER_ADD(queue_ptr -> tx_queue_start, used_words);
 8009ff0:	68fb      	ldr	r3, [r7, #12]
 8009ff2:	699a      	ldr	r2, [r3, #24]
 8009ff4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009ff6:	009b      	lsls	r3, r3, #2
 8009ff8:	441a      	add	r2, r3
 8009ffa:	68fb      	ldr	r3, [r7, #12]
 8009ffc:	61da      	str	r2, [r3, #28]

    /* Set the read and write pointers to the beginning of the queue
       area.  */
    queue_ptr -> tx_queue_read =   TX_VOID_TO_ULONG_POINTER_CONVERT(queue_start);
 8009ffe:	68fb      	ldr	r3, [r7, #12]
 800a000:	683a      	ldr	r2, [r7, #0]
 800a002:	621a      	str	r2, [r3, #32]
    queue_ptr -> tx_queue_write =  TX_VOID_TO_ULONG_POINTER_CONVERT(queue_start);
 800a004:	68fb      	ldr	r3, [r7, #12]
 800a006:	683a      	ldr	r2, [r7, #0]
 800a008:	625a      	str	r2, [r3, #36]	; 0x24

    /* Setup the number of enqueued messages and the number of message
       slots available in the queue.  */
    queue_ptr -> tx_queue_available_storage =  (UINT) capacity;
 800a00a:	68fb      	ldr	r3, [r7, #12]
 800a00c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800a00e:	615a      	str	r2, [r3, #20]
    queue_ptr -> tx_queue_capacity =           (UINT) capacity;
 800a010:	68fb      	ldr	r3, [r7, #12]
 800a012:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800a014:	60da      	str	r2, [r3, #12]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800a016:	f3ef 8310 	mrs	r3, PRIMASK
 800a01a:	61bb      	str	r3, [r7, #24]
    return(posture);
 800a01c:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800a01e:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800a020:	b672      	cpsid	i
    return(int_posture);
 800a022:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to put the queue on the created list.  */
    TX_DISABLE
 800a024:	627b      	str	r3, [r7, #36]	; 0x24

    /* Setup the queue ID to make it valid.  */
    queue_ptr -> tx_queue_id =  TX_QUEUE_ID;
 800a026:	68fb      	ldr	r3, [r7, #12]
 800a028:	4a18      	ldr	r2, [pc, #96]	; (800a08c <_tx_queue_create+0xdc>)
 800a02a:	601a      	str	r2, [r3, #0]

    /* Place the queue on the list of created queues.  First,
       check for an empty list.  */
    if (_tx_queue_created_count == TX_EMPTY)
 800a02c:	4b18      	ldr	r3, [pc, #96]	; (800a090 <_tx_queue_create+0xe0>)
 800a02e:	681b      	ldr	r3, [r3, #0]
 800a030:	2b00      	cmp	r3, #0
 800a032:	d109      	bne.n	800a048 <_tx_queue_create+0x98>
    {

        /* The created queue list is empty.  Add queue to empty list.  */
        _tx_queue_created_ptr =                   queue_ptr;
 800a034:	4a17      	ldr	r2, [pc, #92]	; (800a094 <_tx_queue_create+0xe4>)
 800a036:	68fb      	ldr	r3, [r7, #12]
 800a038:	6013      	str	r3, [r2, #0]
        queue_ptr -> tx_queue_created_next =      queue_ptr;
 800a03a:	68fb      	ldr	r3, [r7, #12]
 800a03c:	68fa      	ldr	r2, [r7, #12]
 800a03e:	631a      	str	r2, [r3, #48]	; 0x30
        queue_ptr -> tx_queue_created_previous =  queue_ptr;
 800a040:	68fb      	ldr	r3, [r7, #12]
 800a042:	68fa      	ldr	r2, [r7, #12]
 800a044:	635a      	str	r2, [r3, #52]	; 0x34
 800a046:	e011      	b.n	800a06c <_tx_queue_create+0xbc>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_queue =      _tx_queue_created_ptr;
 800a048:	4b12      	ldr	r3, [pc, #72]	; (800a094 <_tx_queue_create+0xe4>)
 800a04a:	681b      	ldr	r3, [r3, #0]
 800a04c:	623b      	str	r3, [r7, #32]
        previous_queue =  next_queue -> tx_queue_created_previous;
 800a04e:	6a3b      	ldr	r3, [r7, #32]
 800a050:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a052:	61fb      	str	r3, [r7, #28]

        /* Place the new queue in the list.  */
        next_queue -> tx_queue_created_previous =  queue_ptr;
 800a054:	6a3b      	ldr	r3, [r7, #32]
 800a056:	68fa      	ldr	r2, [r7, #12]
 800a058:	635a      	str	r2, [r3, #52]	; 0x34
        previous_queue -> tx_queue_created_next =  queue_ptr;
 800a05a:	69fb      	ldr	r3, [r7, #28]
 800a05c:	68fa      	ldr	r2, [r7, #12]
 800a05e:	631a      	str	r2, [r3, #48]	; 0x30

        /* Setup this queues's created links.  */
        queue_ptr -> tx_queue_created_previous =  previous_queue;
 800a060:	68fb      	ldr	r3, [r7, #12]
 800a062:	69fa      	ldr	r2, [r7, #28]
 800a064:	635a      	str	r2, [r3, #52]	; 0x34
        queue_ptr -> tx_queue_created_next =      next_queue;
 800a066:	68fb      	ldr	r3, [r7, #12]
 800a068:	6a3a      	ldr	r2, [r7, #32]
 800a06a:	631a      	str	r2, [r3, #48]	; 0x30
    }

    /* Increment the created queue count.  */
    _tx_queue_created_count++;
 800a06c:	4b08      	ldr	r3, [pc, #32]	; (800a090 <_tx_queue_create+0xe0>)
 800a06e:	681b      	ldr	r3, [r3, #0]
 800a070:	3301      	adds	r3, #1
 800a072:	4a07      	ldr	r2, [pc, #28]	; (800a090 <_tx_queue_create+0xe0>)
 800a074:	6013      	str	r3, [r2, #0]
 800a076:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a078:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a07a:	693b      	ldr	r3, [r7, #16]
 800a07c:	f383 8810 	msr	PRIMASK, r3
}
 800a080:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800a082:	2300      	movs	r3, #0
}
 800a084:	4618      	mov	r0, r3
 800a086:	3730      	adds	r7, #48	; 0x30
 800a088:	46bd      	mov	sp, r7
 800a08a:	bd80      	pop	{r7, pc}
 800a08c:	51554555 	.word	0x51554555
 800a090:	2000ef8c 	.word	0x2000ef8c
 800a094:	2000ef88 	.word	0x2000ef88

0800a098 <_tx_queue_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_delete(TX_QUEUE *queue_ptr)
{
 800a098:	b580      	push	{r7, lr}
 800a09a:	b092      	sub	sp, #72	; 0x48
 800a09c:	af00      	add	r7, sp, #0
 800a09e:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800a0a0:	f3ef 8310 	mrs	r3, PRIMASK
 800a0a4:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800a0a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800a0a8:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800a0aa:	b672      	cpsid	i
    return(int_posture);
 800a0ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
TX_QUEUE        *next_queue;
TX_QUEUE        *previous_queue;


    /* Disable interrupts to remove the queue from the created list.  */
    TX_DISABLE
 800a0ae:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Log this kernel call.  */
    TX_EL_QUEUE_DELETE_INSERT

    /* Clear the queue ID to make it invalid.  */
    queue_ptr -> tx_queue_id =  TX_CLEAR_ID;
 800a0b0:	687b      	ldr	r3, [r7, #4]
 800a0b2:	2200      	movs	r2, #0
 800a0b4:	601a      	str	r2, [r3, #0]

    /* Decrement the number of created queues.  */
    _tx_queue_created_count--;
 800a0b6:	4b3d      	ldr	r3, [pc, #244]	; (800a1ac <_tx_queue_delete+0x114>)
 800a0b8:	681b      	ldr	r3, [r3, #0]
 800a0ba:	3b01      	subs	r3, #1
 800a0bc:	4a3b      	ldr	r2, [pc, #236]	; (800a1ac <_tx_queue_delete+0x114>)
 800a0be:	6013      	str	r3, [r2, #0]

    /* See if the queue is the only one on the list.  */
    if (_tx_queue_created_count == TX_EMPTY)
 800a0c0:	4b3a      	ldr	r3, [pc, #232]	; (800a1ac <_tx_queue_delete+0x114>)
 800a0c2:	681b      	ldr	r3, [r3, #0]
 800a0c4:	2b00      	cmp	r3, #0
 800a0c6:	d103      	bne.n	800a0d0 <_tx_queue_delete+0x38>
    {

        /* Only created queue, just set the created list to NULL.  */
        _tx_queue_created_ptr =  TX_NULL;
 800a0c8:	4b39      	ldr	r3, [pc, #228]	; (800a1b0 <_tx_queue_delete+0x118>)
 800a0ca:	2200      	movs	r2, #0
 800a0cc:	601a      	str	r2, [r3, #0]
 800a0ce:	e013      	b.n	800a0f8 <_tx_queue_delete+0x60>
    }
    else
    {

        /* Link-up the neighbors.  */
        next_queue =                               queue_ptr -> tx_queue_created_next;
 800a0d0:	687b      	ldr	r3, [r7, #4]
 800a0d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a0d4:	63bb      	str	r3, [r7, #56]	; 0x38
        previous_queue =                           queue_ptr -> tx_queue_created_previous;
 800a0d6:	687b      	ldr	r3, [r7, #4]
 800a0d8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a0da:	637b      	str	r3, [r7, #52]	; 0x34
        next_queue -> tx_queue_created_previous =  previous_queue;
 800a0dc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a0de:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a0e0:	635a      	str	r2, [r3, #52]	; 0x34
        previous_queue -> tx_queue_created_next =  next_queue;
 800a0e2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a0e4:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800a0e6:	631a      	str	r2, [r3, #48]	; 0x30

        /* See if we have to update the created list head pointer.  */
        if (_tx_queue_created_ptr == queue_ptr)
 800a0e8:	4b31      	ldr	r3, [pc, #196]	; (800a1b0 <_tx_queue_delete+0x118>)
 800a0ea:	681b      	ldr	r3, [r3, #0]
 800a0ec:	687a      	ldr	r2, [r7, #4]
 800a0ee:	429a      	cmp	r2, r3
 800a0f0:	d102      	bne.n	800a0f8 <_tx_queue_delete+0x60>
        {

            /* Yes, move the head pointer to the next link. */
            _tx_queue_created_ptr =  next_queue;
 800a0f2:	4a2f      	ldr	r2, [pc, #188]	; (800a1b0 <_tx_queue_delete+0x118>)
 800a0f4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a0f6:	6013      	str	r3, [r2, #0]
        }
    }

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 800a0f8:	4b2e      	ldr	r3, [pc, #184]	; (800a1b4 <_tx_queue_delete+0x11c>)
 800a0fa:	681b      	ldr	r3, [r3, #0]
 800a0fc:	3301      	adds	r3, #1
 800a0fe:	4a2d      	ldr	r2, [pc, #180]	; (800a1b4 <_tx_queue_delete+0x11c>)
 800a100:	6013      	str	r3, [r2, #0]

    /* Pickup the suspension information.  */
    thread_ptr =                             queue_ptr -> tx_queue_suspension_list;
 800a102:	687b      	ldr	r3, [r7, #4]
 800a104:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a106:	647b      	str	r3, [r7, #68]	; 0x44
    queue_ptr -> tx_queue_suspension_list =  TX_NULL;
 800a108:	687b      	ldr	r3, [r7, #4]
 800a10a:	2200      	movs	r2, #0
 800a10c:	629a      	str	r2, [r3, #40]	; 0x28
    suspended_count =                        queue_ptr -> tx_queue_suspended_count;
 800a10e:	687b      	ldr	r3, [r7, #4]
 800a110:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a112:	643b      	str	r3, [r7, #64]	; 0x40
    queue_ptr -> tx_queue_suspended_count =  TX_NO_SUSPENSIONS;
 800a114:	687b      	ldr	r3, [r7, #4]
 800a116:	2200      	movs	r2, #0
 800a118:	62da      	str	r2, [r3, #44]	; 0x2c
 800a11a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a11c:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a11e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a120:	f383 8810 	msr	PRIMASK, r3
}
 800a124:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the queue list to resume any and all threads suspended
       on this queue.  */
    while (suspended_count != TX_NO_SUSPENSIONS)
 800a126:	e024      	b.n	800a172 <_tx_queue_delete+0xda>
    {

        /* Decrement the suspension count.  */
        suspended_count--;
 800a128:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a12a:	3b01      	subs	r3, #1
 800a12c:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800a12e:	f3ef 8310 	mrs	r3, PRIMASK
 800a132:	61fb      	str	r3, [r7, #28]
    return(posture);
 800a134:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800a136:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800a138:	b672      	cpsid	i
    return(int_posture);
 800a13a:	69bb      	ldr	r3, [r7, #24]

        /* Lockout interrupts.  */
        TX_DISABLE
 800a13c:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Clear the cleanup pointer, this prevents the timeout from doing
           anything.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800a13e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a140:	2200      	movs	r2, #0
 800a142:	669a      	str	r2, [r3, #104]	; 0x68

        /* Set the return status in the thread to TX_DELETED.  */
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
 800a144:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a146:	2201      	movs	r2, #1
 800a148:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Move the thread pointer ahead.  */
        next_thread =  thread_ptr -> tx_thread_suspended_next;
 800a14c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a14e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800a150:	633b      	str	r3, [r7, #48]	; 0x30
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption again.  */
        _tx_thread_preempt_disable++;
 800a152:	4b18      	ldr	r3, [pc, #96]	; (800a1b4 <_tx_queue_delete+0x11c>)
 800a154:	681b      	ldr	r3, [r3, #0]
 800a156:	3301      	adds	r3, #1
 800a158:	4a16      	ldr	r2, [pc, #88]	; (800a1b4 <_tx_queue_delete+0x11c>)
 800a15a:	6013      	str	r3, [r2, #0]
 800a15c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a15e:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a160:	6a3b      	ldr	r3, [r7, #32]
 800a162:	f383 8810 	msr	PRIMASK, r3
}
 800a166:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
 800a168:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800a16a:	f002 f95f 	bl	800c42c <_tx_thread_system_resume>
#endif

        /* Move to next thread.  */
        thread_ptr =  next_thread;
 800a16e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a170:	647b      	str	r3, [r7, #68]	; 0x44
    while (suspended_count != TX_NO_SUSPENSIONS)
 800a172:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a174:	2b00      	cmp	r3, #0
 800a176:	d1d7      	bne.n	800a128 <_tx_queue_delete+0x90>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800a178:	f3ef 8310 	mrs	r3, PRIMASK
 800a17c:	613b      	str	r3, [r7, #16]
    return(posture);
 800a17e:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 800a180:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 800a182:	b672      	cpsid	i
    return(int_posture);
 800a184:	68fb      	ldr	r3, [r7, #12]

    /* Execute Port-Specific completion processing. If needed, it is typically defined in tx_port.h.  */
    TX_QUEUE_DELETE_PORT_COMPLETION(queue_ptr)

    /* Disable interrupts.  */
    TX_DISABLE
 800a186:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Release previous preempt disable.  */
    _tx_thread_preempt_disable--;
 800a188:	4b0a      	ldr	r3, [pc, #40]	; (800a1b4 <_tx_queue_delete+0x11c>)
 800a18a:	681b      	ldr	r3, [r3, #0]
 800a18c:	3b01      	subs	r3, #1
 800a18e:	4a09      	ldr	r2, [pc, #36]	; (800a1b4 <_tx_queue_delete+0x11c>)
 800a190:	6013      	str	r3, [r2, #0]
 800a192:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a194:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a196:	697b      	ldr	r3, [r7, #20]
 800a198:	f383 8810 	msr	PRIMASK, r3
}
 800a19c:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 800a19e:	f002 f90b 	bl	800c3b8 <_tx_thread_system_preempt_check>

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800a1a2:	2300      	movs	r3, #0
}
 800a1a4:	4618      	mov	r0, r3
 800a1a6:	3748      	adds	r7, #72	; 0x48
 800a1a8:	46bd      	mov	sp, r7
 800a1aa:	bd80      	pop	{r7, pc}
 800a1ac:	2000ef8c 	.word	0x2000ef8c
 800a1b0:	2000ef88 	.word	0x2000ef88
 800a1b4:	2000f054 	.word	0x2000f054

0800a1b8 <_tx_queue_flush>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_flush(TX_QUEUE *queue_ptr)
{
 800a1b8:	b580      	push	{r7, lr}
 800a1ba:	b090      	sub	sp, #64	; 0x40
 800a1bc:	af00      	add	r7, sp, #0
 800a1be:	6078      	str	r0, [r7, #4]
UINT            suspended_count;
TX_THREAD       *thread_ptr;


    /* Initialize the suspended count and list.  */
    suspended_count =  TX_NO_SUSPENSIONS;
 800a1c0:	2300      	movs	r3, #0
 800a1c2:	63bb      	str	r3, [r7, #56]	; 0x38
    suspension_list =  TX_NULL;
 800a1c4:	2300      	movs	r3, #0
 800a1c6:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800a1c8:	f3ef 8310 	mrs	r3, PRIMASK
 800a1cc:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800a1ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800a1d0:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800a1d2:	b672      	cpsid	i
    return(int_posture);
 800a1d4:	6abb      	ldr	r3, [r7, #40]	; 0x28

    /* Disable interrupts to reset various queue parameters.  */
    TX_DISABLE
 800a1d6:	633b      	str	r3, [r7, #48]	; 0x30

    /* Log this kernel call.  */
    TX_EL_QUEUE_FLUSH_INSERT

    /* Determine if there is something on the queue.  */
    if (queue_ptr -> tx_queue_enqueued != TX_NO_MESSAGES)
 800a1d8:	687b      	ldr	r3, [r7, #4]
 800a1da:	691b      	ldr	r3, [r3, #16]
 800a1dc:	2b00      	cmp	r3, #0
 800a1de:	d023      	beq.n	800a228 <_tx_queue_flush+0x70>
    {

        /* Yes, there is something in the queue.  */

        /* Reset the queue parameters to erase all of the queued messages.  */
        queue_ptr -> tx_queue_enqueued =           TX_NO_MESSAGES;
 800a1e0:	687b      	ldr	r3, [r7, #4]
 800a1e2:	2200      	movs	r2, #0
 800a1e4:	611a      	str	r2, [r3, #16]
        queue_ptr -> tx_queue_available_storage =  queue_ptr -> tx_queue_capacity;
 800a1e6:	687b      	ldr	r3, [r7, #4]
 800a1e8:	68da      	ldr	r2, [r3, #12]
 800a1ea:	687b      	ldr	r3, [r7, #4]
 800a1ec:	615a      	str	r2, [r3, #20]
        queue_ptr -> tx_queue_read =               queue_ptr -> tx_queue_start;
 800a1ee:	687b      	ldr	r3, [r7, #4]
 800a1f0:	699a      	ldr	r2, [r3, #24]
 800a1f2:	687b      	ldr	r3, [r7, #4]
 800a1f4:	621a      	str	r2, [r3, #32]
        queue_ptr -> tx_queue_write =              queue_ptr -> tx_queue_start;
 800a1f6:	687b      	ldr	r3, [r7, #4]
 800a1f8:	699a      	ldr	r2, [r3, #24]
 800a1fa:	687b      	ldr	r3, [r7, #4]
 800a1fc:	625a      	str	r2, [r3, #36]	; 0x24

        /* Now determine if there are any threads suspended on a full queue.  */
        if (queue_ptr -> tx_queue_suspended_count != TX_NO_SUSPENSIONS)
 800a1fe:	687b      	ldr	r3, [r7, #4]
 800a200:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a202:	2b00      	cmp	r3, #0
 800a204:	d010      	beq.n	800a228 <_tx_queue_flush+0x70>

            /* Yes, there are threads suspended on this queue, they must be
               resumed!  */

            /* Copy the information into temporary variables.  */
            suspension_list =  queue_ptr -> tx_queue_suspension_list;
 800a206:	687b      	ldr	r3, [r7, #4]
 800a208:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a20a:	63fb      	str	r3, [r7, #60]	; 0x3c
            suspended_count =  queue_ptr -> tx_queue_suspended_count;
 800a20c:	687b      	ldr	r3, [r7, #4]
 800a20e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a210:	63bb      	str	r3, [r7, #56]	; 0x38

            /* Clear the queue variables.  */
            queue_ptr -> tx_queue_suspension_list =  TX_NULL;
 800a212:	687b      	ldr	r3, [r7, #4]
 800a214:	2200      	movs	r2, #0
 800a216:	629a      	str	r2, [r3, #40]	; 0x28
            queue_ptr -> tx_queue_suspended_count =  TX_NO_SUSPENSIONS;
 800a218:	687b      	ldr	r3, [r7, #4]
 800a21a:	2200      	movs	r2, #0
 800a21c:	62da      	str	r2, [r3, #44]	; 0x2c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800a21e:	4b2c      	ldr	r3, [pc, #176]	; (800a2d0 <_tx_queue_flush+0x118>)
 800a220:	681b      	ldr	r3, [r3, #0]
 800a222:	3301      	adds	r3, #1
 800a224:	4a2a      	ldr	r2, [pc, #168]	; (800a2d0 <_tx_queue_flush+0x118>)
 800a226:	6013      	str	r3, [r2, #0]
 800a228:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a22a:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a22c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a22e:	f383 8810 	msr	PRIMASK, r3
}
 800a232:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the queue list to resume any and all threads suspended
       on this queue.  */
    if (suspended_count != TX_NO_SUSPENSIONS)
 800a234:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a236:	2b00      	cmp	r3, #0
 800a238:	d044      	beq.n	800a2c4 <_tx_queue_flush+0x10c>
    {

        /* Pickup the thread to resume.  */
        thread_ptr =  suspension_list;
 800a23a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a23c:	637b      	str	r3, [r7, #52]	; 0x34
        while (suspended_count != ((ULONG) 0))
 800a23e:	e027      	b.n	800a290 <_tx_queue_flush+0xd8>
        {

            /* Decrement the suspension count.  */
            suspended_count--;
 800a240:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a242:	3b01      	subs	r3, #1
 800a244:	63bb      	str	r3, [r7, #56]	; 0x38

            /* Check for a NULL thread pointer.  */
            if (thread_ptr == TX_NULL)
 800a246:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a248:	2b00      	cmp	r3, #0
 800a24a:	d025      	beq.n	800a298 <_tx_queue_flush+0xe0>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800a24c:	f3ef 8310 	mrs	r3, PRIMASK
 800a250:	61fb      	str	r3, [r7, #28]
    return(posture);
 800a252:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800a254:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800a256:	b672      	cpsid	i
    return(int_posture);
 800a258:	69bb      	ldr	r3, [r7, #24]
            }

            /* Resume the next suspended thread.  */

            /* Lockout interrupts.  */
            TX_DISABLE
 800a25a:	633b      	str	r3, [r7, #48]	; 0x30

            /* Clear the cleanup pointer, this prevents the timeout from doing
               anything.  */
            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800a25c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a25e:	2200      	movs	r2, #0
 800a260:	669a      	str	r2, [r3, #104]	; 0x68

            /* Set the return status in the thread to TX_SUCCESS.  */
            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 800a262:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a264:	2200      	movs	r2, #0
 800a266:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

            /* Move the thread pointer ahead.  */
            thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 800a26a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a26c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800a26e:	637b      	str	r3, [r7, #52]	; 0x34
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Temporarily disable preemption again.  */
            _tx_thread_preempt_disable++;
 800a270:	4b17      	ldr	r3, [pc, #92]	; (800a2d0 <_tx_queue_flush+0x118>)
 800a272:	681b      	ldr	r3, [r3, #0]
 800a274:	3301      	adds	r3, #1
 800a276:	4a16      	ldr	r2, [pc, #88]	; (800a2d0 <_tx_queue_flush+0x118>)
 800a278:	6013      	str	r3, [r2, #0]
 800a27a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a27c:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a27e:	6a3b      	ldr	r3, [r7, #32]
 800a280:	f383 8810 	msr	PRIMASK, r3
}
 800a284:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Resume the thread.  */
            _tx_thread_system_resume(thread_ptr -> tx_thread_suspended_previous);
 800a286:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a288:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800a28a:	4618      	mov	r0, r3
 800a28c:	f002 f8ce 	bl	800c42c <_tx_thread_system_resume>
        while (suspended_count != ((ULONG) 0))
 800a290:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a292:	2b00      	cmp	r3, #0
 800a294:	d1d4      	bne.n	800a240 <_tx_queue_flush+0x88>
 800a296:	e000      	b.n	800a29a <_tx_queue_flush+0xe2>
                break;
 800a298:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800a29a:	f3ef 8310 	mrs	r3, PRIMASK
 800a29e:	613b      	str	r3, [r7, #16]
    return(posture);
 800a2a0:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 800a2a2:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 800a2a4:	b672      	cpsid	i
    return(int_posture);
 800a2a6:	68fb      	ldr	r3, [r7, #12]
#endif
        }

        /* Disable interrupts.  */
        TX_DISABLE
 800a2a8:	633b      	str	r3, [r7, #48]	; 0x30

        /* Restore previous preempt posture.  */
        _tx_thread_preempt_disable--;
 800a2aa:	4b09      	ldr	r3, [pc, #36]	; (800a2d0 <_tx_queue_flush+0x118>)
 800a2ac:	681b      	ldr	r3, [r3, #0]
 800a2ae:	3b01      	subs	r3, #1
 800a2b0:	4a07      	ldr	r2, [pc, #28]	; (800a2d0 <_tx_queue_flush+0x118>)
 800a2b2:	6013      	str	r3, [r2, #0]
 800a2b4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a2b6:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a2b8:	697b      	ldr	r3, [r7, #20]
 800a2ba:	f383 8810 	msr	PRIMASK, r3
}
 800a2be:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 800a2c0:	f002 f87a 	bl	800c3b8 <_tx_thread_system_preempt_check>
    }

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800a2c4:	2300      	movs	r3, #0
}
 800a2c6:	4618      	mov	r0, r3
 800a2c8:	3740      	adds	r7, #64	; 0x40
 800a2ca:	46bd      	mov	sp, r7
 800a2cc:	bd80      	pop	{r7, pc}
 800a2ce:	bf00      	nop
 800a2d0:	2000f054 	.word	0x2000f054

0800a2d4 <_tx_queue_front_send>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_front_send(TX_QUEUE *queue_ptr, VOID *source_ptr, ULONG wait_option)
{
 800a2d4:	b580      	push	{r7, lr}
 800a2d6:	b096      	sub	sp, #88	; 0x58
 800a2d8:	af00      	add	r7, sp, #0
 800a2da:	60f8      	str	r0, [r7, #12]
 800a2dc:	60b9      	str	r1, [r7, #8]
 800a2de:	607a      	str	r2, [r7, #4]
VOID            (*queue_send_notify)(struct TX_QUEUE_STRUCT *notify_queue_ptr);
#endif


    /* Default the status to TX_SUCCESS.  */
    status =  TX_SUCCESS;
 800a2e0:	2300      	movs	r3, #0
 800a2e2:	64bb      	str	r3, [r7, #72]	; 0x48
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800a2e4:	f3ef 8310 	mrs	r3, PRIMASK
 800a2e8:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800a2ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800a2ec:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800a2ee:	b672      	cpsid	i
    return(int_posture);
 800a2f0:	6abb      	ldr	r3, [r7, #40]	; 0x28

    /* Disable interrupts to place message in the queue.  */
    TX_DISABLE
 800a2f2:	647b      	str	r3, [r7, #68]	; 0x44

    /* Log this kernel call.  */
    TX_EL_QUEUE_FRONT_SEND_INSERT

    /* Pickup the suspended count.  */
    suspended_count =  queue_ptr -> tx_queue_suspended_count;
 800a2f4:	68fb      	ldr	r3, [r7, #12]
 800a2f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a2f8:	643b      	str	r3, [r7, #64]	; 0x40

    /* Now check for room in the queue for placing the new message in front.  */
    if (queue_ptr -> tx_queue_available_storage != ((UINT) 0))
 800a2fa:	68fb      	ldr	r3, [r7, #12]
 800a2fc:	695b      	ldr	r3, [r3, #20]
 800a2fe:	2b00      	cmp	r3, #0
 800a300:	f000 80be 	beq.w	800a480 <_tx_queue_front_send+0x1ac>
    {

        /* Yes there is room in the queue. Now determine if there is a thread waiting
           for a message.  */
        if (suspended_count == TX_NO_SUSPENSIONS)
 800a304:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a306:	2b00      	cmp	r3, #0
 800a308:	d155      	bne.n	800a3b6 <_tx_queue_front_send+0xe2>

            /* Adjust the read pointer since we are adding to the front of the
               queue.  */

            /* See if the read pointer is at the beginning of the queue area.  */
            if (queue_ptr -> tx_queue_read == queue_ptr -> tx_queue_start)
 800a30a:	68fb      	ldr	r3, [r7, #12]
 800a30c:	6a1a      	ldr	r2, [r3, #32]
 800a30e:	68fb      	ldr	r3, [r7, #12]
 800a310:	699b      	ldr	r3, [r3, #24]
 800a312:	429a      	cmp	r2, r3
 800a314:	d109      	bne.n	800a32a <_tx_queue_front_send+0x56>
            {

                /* Adjust the read pointer to the last message at the end of the
                   queue.  */
                queue_ptr -> tx_queue_read =  TX_ULONG_POINTER_SUB(queue_ptr -> tx_queue_end, queue_ptr -> tx_queue_message_size);
 800a316:	68fb      	ldr	r3, [r7, #12]
 800a318:	69da      	ldr	r2, [r3, #28]
 800a31a:	68fb      	ldr	r3, [r7, #12]
 800a31c:	689b      	ldr	r3, [r3, #8]
 800a31e:	009b      	lsls	r3, r3, #2
 800a320:	425b      	negs	r3, r3
 800a322:	441a      	add	r2, r3
 800a324:	68fb      	ldr	r3, [r7, #12]
 800a326:	621a      	str	r2, [r3, #32]
 800a328:	e008      	b.n	800a33c <_tx_queue_front_send+0x68>
            }
            else
            {

                /* Not at the beginning of the queue, just move back one message.  */
                queue_ptr -> tx_queue_read =  TX_ULONG_POINTER_SUB(queue_ptr -> tx_queue_read, queue_ptr -> tx_queue_message_size);
 800a32a:	68fb      	ldr	r3, [r7, #12]
 800a32c:	6a1a      	ldr	r2, [r3, #32]
 800a32e:	68fb      	ldr	r3, [r7, #12]
 800a330:	689b      	ldr	r3, [r3, #8]
 800a332:	009b      	lsls	r3, r3, #2
 800a334:	425b      	negs	r3, r3
 800a336:	441a      	add	r2, r3
 800a338:	68fb      	ldr	r3, [r7, #12]
 800a33a:	621a      	str	r2, [r3, #32]
            }

            /* Simply place the message in the queue.  */

            /* Reduce the amount of available storage.  */
            queue_ptr -> tx_queue_available_storage--;
 800a33c:	68fb      	ldr	r3, [r7, #12]
 800a33e:	695b      	ldr	r3, [r3, #20]
 800a340:	1e5a      	subs	r2, r3, #1
 800a342:	68fb      	ldr	r3, [r7, #12]
 800a344:	615a      	str	r2, [r3, #20]

            /* Increase the enqueued count.  */
            queue_ptr -> tx_queue_enqueued++;
 800a346:	68fb      	ldr	r3, [r7, #12]
 800a348:	691b      	ldr	r3, [r3, #16]
 800a34a:	1c5a      	adds	r2, r3, #1
 800a34c:	68fb      	ldr	r3, [r7, #12]
 800a34e:	611a      	str	r2, [r3, #16]

            /* Setup source and destination pointers.  */
            source =       TX_VOID_TO_ULONG_POINTER_CONVERT(source_ptr);
 800a350:	68bb      	ldr	r3, [r7, #8]
 800a352:	657b      	str	r3, [r7, #84]	; 0x54
            destination =  queue_ptr -> tx_queue_read;
 800a354:	68fb      	ldr	r3, [r7, #12]
 800a356:	6a1b      	ldr	r3, [r3, #32]
 800a358:	653b      	str	r3, [r7, #80]	; 0x50
            size =         queue_ptr -> tx_queue_message_size;
 800a35a:	68fb      	ldr	r3, [r7, #12]
 800a35c:	689b      	ldr	r3, [r3, #8]
 800a35e:	64fb      	str	r3, [r7, #76]	; 0x4c

            /* Copy message. Note that the source and destination pointers are
               incremented by the macro.  */
            TX_QUEUE_MESSAGE_COPY(source, destination, size)
 800a360:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800a362:	1d13      	adds	r3, r2, #4
 800a364:	657b      	str	r3, [r7, #84]	; 0x54
 800a366:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800a368:	1d19      	adds	r1, r3, #4
 800a36a:	6539      	str	r1, [r7, #80]	; 0x50
 800a36c:	6812      	ldr	r2, [r2, #0]
 800a36e:	601a      	str	r2, [r3, #0]
 800a370:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a372:	2b01      	cmp	r3, #1
 800a374:	d90e      	bls.n	800a394 <_tx_queue_front_send+0xc0>
 800a376:	e007      	b.n	800a388 <_tx_queue_front_send+0xb4>
 800a378:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800a37a:	1d13      	adds	r3, r2, #4
 800a37c:	657b      	str	r3, [r7, #84]	; 0x54
 800a37e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800a380:	1d19      	adds	r1, r3, #4
 800a382:	6539      	str	r1, [r7, #80]	; 0x50
 800a384:	6812      	ldr	r2, [r2, #0]
 800a386:	601a      	str	r2, [r3, #0]
 800a388:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a38a:	3b01      	subs	r3, #1
 800a38c:	64fb      	str	r3, [r7, #76]	; 0x4c
 800a38e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a390:	2b00      	cmp	r3, #0
 800a392:	d1f1      	bne.n	800a378 <_tx_queue_front_send+0xa4>

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Pickup the notify callback routine for this queue.  */
            queue_send_notify =  queue_ptr -> tx_queue_send_notify;
 800a394:	68fb      	ldr	r3, [r7, #12]
 800a396:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800a398:	633b      	str	r3, [r7, #48]	; 0x30
 800a39a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a39c:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a39e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a3a0:	f383 8810 	msr	PRIMASK, r3
}
 800a3a4:	bf00      	nop
            TX_RESTORE

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Determine if a notify callback is required.  */
            if (queue_send_notify != TX_NULL)
 800a3a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a3a8:	2b00      	cmp	r3, #0
 800a3aa:	f000 80e8 	beq.w	800a57e <_tx_queue_front_send+0x2aa>
            {

                /* Call application queue send notification.  */
                (queue_send_notify)(queue_ptr);
 800a3ae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a3b0:	68f8      	ldr	r0, [r7, #12]
 800a3b2:	4798      	blx	r3
 800a3b4:	e0e3      	b.n	800a57e <_tx_queue_front_send+0x2aa>
        else
        {

            /* Thread suspended waiting for a message.  Remove it and copy this message
               into its storage area.  */
            thread_ptr =  queue_ptr -> tx_queue_suspension_list;
 800a3b6:	68fb      	ldr	r3, [r7, #12]
 800a3b8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a3ba:	63fb      	str	r3, [r7, #60]	; 0x3c

            /* See if this is the only suspended thread on the list.  */
            suspended_count--;
 800a3bc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a3be:	3b01      	subs	r3, #1
 800a3c0:	643b      	str	r3, [r7, #64]	; 0x40
            if (suspended_count == TX_NO_SUSPENSIONS)
 800a3c2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a3c4:	2b00      	cmp	r3, #0
 800a3c6:	d103      	bne.n	800a3d0 <_tx_queue_front_send+0xfc>
            {

                /* Yes, the only suspended thread.  */

                /* Update the head pointer.  */
                queue_ptr -> tx_queue_suspension_list =  TX_NULL;
 800a3c8:	68fb      	ldr	r3, [r7, #12]
 800a3ca:	2200      	movs	r2, #0
 800a3cc:	629a      	str	r2, [r3, #40]	; 0x28
 800a3ce:	e012      	b.n	800a3f6 <_tx_queue_front_send+0x122>
            {

                /* At least one more thread is on the same expiration list.  */

                /* Update the list head pointer.  */
                queue_ptr -> tx_queue_suspension_list =  thread_ptr -> tx_thread_suspended_next;
 800a3d0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a3d2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800a3d4:	68fb      	ldr	r3, [r7, #12]
 800a3d6:	629a      	str	r2, [r3, #40]	; 0x28

                /* Update the links of the adjacent threads.  */
                next_thread =                            thread_ptr -> tx_thread_suspended_next;
 800a3d8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a3da:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800a3dc:	63bb      	str	r3, [r7, #56]	; 0x38
                queue_ptr -> tx_queue_suspension_list =  next_thread;
 800a3de:	68fb      	ldr	r3, [r7, #12]
 800a3e0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800a3e2:	629a      	str	r2, [r3, #40]	; 0x28

                /* Update the links of the adjacent threads.  */
                previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 800a3e4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a3e6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800a3e8:	637b      	str	r3, [r7, #52]	; 0x34
                next_thread -> tx_thread_suspended_previous =   previous_thread;
 800a3ea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a3ec:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a3ee:	675a      	str	r2, [r3, #116]	; 0x74
                previous_thread -> tx_thread_suspended_next =   next_thread;
 800a3f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a3f2:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800a3f4:	671a      	str	r2, [r3, #112]	; 0x70
            }

            /* Decrement the suspension count.  */
            queue_ptr -> tx_queue_suspended_count =  suspended_count;
 800a3f6:	68fb      	ldr	r3, [r7, #12]
 800a3f8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800a3fa:	62da      	str	r2, [r3, #44]	; 0x2c

            /* Prepare for resumption of the thread.  */

            /* Clear cleanup routine to avoid timeout.  */
            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800a3fc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a3fe:	2200      	movs	r2, #0
 800a400:	669a      	str	r2, [r3, #104]	; 0x68


#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Pickup the notify callback routine for this queue.  */
            queue_send_notify =  queue_ptr -> tx_queue_send_notify;
 800a402:	68fb      	ldr	r3, [r7, #12]
 800a404:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800a406:	633b      	str	r3, [r7, #48]	; 0x30
#endif

            /* Setup source and destination pointers.  */
            source =       TX_VOID_TO_ULONG_POINTER_CONVERT(source_ptr);
 800a408:	68bb      	ldr	r3, [r7, #8]
 800a40a:	657b      	str	r3, [r7, #84]	; 0x54
            destination =  TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
 800a40c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a40e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800a410:	653b      	str	r3, [r7, #80]	; 0x50
            size =         queue_ptr -> tx_queue_message_size;
 800a412:	68fb      	ldr	r3, [r7, #12]
 800a414:	689b      	ldr	r3, [r3, #8]
 800a416:	64fb      	str	r3, [r7, #76]	; 0x4c

            /* Copy message. Note that the source and destination pointers are
               incremented by the macro.  */
            TX_QUEUE_MESSAGE_COPY(source, destination, size)
 800a418:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800a41a:	1d13      	adds	r3, r2, #4
 800a41c:	657b      	str	r3, [r7, #84]	; 0x54
 800a41e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800a420:	1d19      	adds	r1, r3, #4
 800a422:	6539      	str	r1, [r7, #80]	; 0x50
 800a424:	6812      	ldr	r2, [r2, #0]
 800a426:	601a      	str	r2, [r3, #0]
 800a428:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a42a:	2b01      	cmp	r3, #1
 800a42c:	d90e      	bls.n	800a44c <_tx_queue_front_send+0x178>
 800a42e:	e007      	b.n	800a440 <_tx_queue_front_send+0x16c>
 800a430:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800a432:	1d13      	adds	r3, r2, #4
 800a434:	657b      	str	r3, [r7, #84]	; 0x54
 800a436:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800a438:	1d19      	adds	r1, r3, #4
 800a43a:	6539      	str	r1, [r7, #80]	; 0x50
 800a43c:	6812      	ldr	r2, [r2, #0]
 800a43e:	601a      	str	r2, [r3, #0]
 800a440:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a442:	3b01      	subs	r3, #1
 800a444:	64fb      	str	r3, [r7, #76]	; 0x4c
 800a446:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a448:	2b00      	cmp	r3, #0
 800a44a:	d1f1      	bne.n	800a430 <_tx_queue_front_send+0x15c>

            /* Put return status into the thread control block.  */
            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 800a44c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a44e:	2200      	movs	r2, #0
 800a450:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800a454:	4b4c      	ldr	r3, [pc, #304]	; (800a588 <_tx_queue_front_send+0x2b4>)
 800a456:	681b      	ldr	r3, [r3, #0]
 800a458:	3301      	adds	r3, #1
 800a45a:	4a4b      	ldr	r2, [pc, #300]	; (800a588 <_tx_queue_front_send+0x2b4>)
 800a45c:	6013      	str	r3, [r2, #0]
 800a45e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a460:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a462:	6a3b      	ldr	r3, [r7, #32]
 800a464:	f383 8810 	msr	PRIMASK, r3
}
 800a468:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Resume thread.  */
            _tx_thread_system_resume(thread_ptr);
 800a46a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800a46c:	f001 ffde 	bl	800c42c <_tx_thread_system_resume>
#endif

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Determine if a notify callback is required.  */
            if (queue_send_notify != TX_NULL)
 800a470:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a472:	2b00      	cmp	r3, #0
 800a474:	f000 8083 	beq.w	800a57e <_tx_queue_front_send+0x2aa>
            {

                /* Call application queue send notification.  */
                (queue_send_notify)(queue_ptr);
 800a478:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a47a:	68f8      	ldr	r0, [r7, #12]
 800a47c:	4798      	blx	r3
 800a47e:	e07e      	b.n	800a57e <_tx_queue_front_send+0x2aa>
#endif
        }
    }

    /* Determine if the caller has requested suspension.  */
    else if (wait_option != TX_NO_WAIT)
 800a480:	687b      	ldr	r3, [r7, #4]
 800a482:	2b00      	cmp	r3, #0
 800a484:	d073      	beq.n	800a56e <_tx_queue_front_send+0x29a>
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
 800a486:	4b40      	ldr	r3, [pc, #256]	; (800a588 <_tx_queue_front_send+0x2b4>)
 800a488:	681b      	ldr	r3, [r3, #0]
 800a48a:	2b00      	cmp	r3, #0
 800a48c:	d008      	beq.n	800a4a0 <_tx_queue_front_send+0x1cc>
 800a48e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a490:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a492:	69fb      	ldr	r3, [r7, #28]
 800a494:	f383 8810 	msr	PRIMASK, r3
}
 800a498:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
            status =  TX_QUEUE_FULL;
 800a49a:	230b      	movs	r3, #11
 800a49c:	64bb      	str	r3, [r7, #72]	; 0x48
 800a49e:	e06e      	b.n	800a57e <_tx_queue_front_send+0x2aa>
            /* Yes, suspension is requested.  */

            /* Prepare for suspension of this thread.  */

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 800a4a0:	4b3a      	ldr	r3, [pc, #232]	; (800a58c <_tx_queue_front_send+0x2b8>)
 800a4a2:	681b      	ldr	r3, [r3, #0]
 800a4a4:	63fb      	str	r3, [r7, #60]	; 0x3c

            /* Setup cleanup routine pointer.  */
            thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_queue_cleanup);
 800a4a6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a4a8:	4a39      	ldr	r2, [pc, #228]	; (800a590 <_tx_queue_front_send+0x2bc>)
 800a4aa:	669a      	str	r2, [r3, #104]	; 0x68

            /* Setup cleanup information, i.e. this queue control
               block and the source pointer.  */
            thread_ptr -> tx_thread_suspend_control_block =    (VOID *) queue_ptr;
 800a4ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a4ae:	68fa      	ldr	r2, [r7, #12]
 800a4b0:	66da      	str	r2, [r3, #108]	; 0x6c
            thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) source_ptr;
 800a4b2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a4b4:	68ba      	ldr	r2, [r7, #8]
 800a4b6:	67da      	str	r2, [r3, #124]	; 0x7c

            /* Set the flag to true to indicate a queue front send suspension.  */
            thread_ptr -> tx_thread_suspend_option =           TX_TRUE;
 800a4b8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a4ba:	2201      	movs	r2, #1
 800a4bc:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

#ifndef TX_NOT_INTERRUPTABLE

            /* Increment the suspension sequence number, which is used to identify
               this suspension event.  */
            thread_ptr -> tx_thread_suspension_sequence++;
 800a4c0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a4c2:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 800a4c6:	1c5a      	adds	r2, r3, #1
 800a4c8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a4ca:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
#endif

            /* Place this thread at the front of the suspension list, since it is a
               queue front send suspension.  */
            if (suspended_count == TX_NO_SUSPENSIONS)
 800a4ce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a4d0:	2b00      	cmp	r3, #0
 800a4d2:	d109      	bne.n	800a4e8 <_tx_queue_front_send+0x214>
            {

                /* No other threads are suspended.  Setup the head pointer and
                   just setup this threads pointers to itself.  */
                queue_ptr -> tx_queue_suspension_list =         thread_ptr;
 800a4d4:	68fb      	ldr	r3, [r7, #12]
 800a4d6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800a4d8:	629a      	str	r2, [r3, #40]	; 0x28
                thread_ptr -> tx_thread_suspended_next =        thread_ptr;
 800a4da:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a4dc:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800a4de:	671a      	str	r2, [r3, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
 800a4e0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a4e2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800a4e4:	675a      	str	r2, [r3, #116]	; 0x74
 800a4e6:	e014      	b.n	800a512 <_tx_queue_front_send+0x23e>
            }
            else
            {

                /* This list is not NULL, add current thread to the end. */
                next_thread =                                   queue_ptr -> tx_queue_suspension_list;
 800a4e8:	68fb      	ldr	r3, [r7, #12]
 800a4ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a4ec:	63bb      	str	r3, [r7, #56]	; 0x38
                thread_ptr -> tx_thread_suspended_next =        next_thread;
 800a4ee:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a4f0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800a4f2:	671a      	str	r2, [r3, #112]	; 0x70
                previous_thread =                               next_thread -> tx_thread_suspended_previous;
 800a4f4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a4f6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800a4f8:	637b      	str	r3, [r7, #52]	; 0x34
                thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 800a4fa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a4fc:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a4fe:	675a      	str	r2, [r3, #116]	; 0x74
                previous_thread -> tx_thread_suspended_next =   thread_ptr;
 800a500:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a502:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800a504:	671a      	str	r2, [r3, #112]	; 0x70
                next_thread -> tx_thread_suspended_previous =   thread_ptr;
 800a506:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a508:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800a50a:	675a      	str	r2, [r3, #116]	; 0x74

                /* Update the suspension list to put this thread in front, which will put
                   the message that was removed in the proper relative order when room is
                   made in the queue.  */
                queue_ptr -> tx_queue_suspension_list =         thread_ptr;
 800a50c:	68fb      	ldr	r3, [r7, #12]
 800a50e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800a510:	629a      	str	r2, [r3, #40]	; 0x28
            }

            /* Increment the suspended thread count.  */
            queue_ptr -> tx_queue_suspended_count =  suspended_count + ((UINT) 1);
 800a512:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a514:	1c5a      	adds	r2, r3, #1
 800a516:	68fb      	ldr	r3, [r7, #12]
 800a518:	62da      	str	r2, [r3, #44]	; 0x2c

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_QUEUE_SUSP;
 800a51a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a51c:	2205      	movs	r2, #5
 800a51e:	631a      	str	r2, [r3, #48]	; 0x30

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Pickup the notify callback routine for this queue.  */
            queue_send_notify =  queue_ptr -> tx_queue_send_notify;
 800a520:	68fb      	ldr	r3, [r7, #12]
 800a522:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800a524:	633b      	str	r3, [r7, #48]	; 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800a526:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a528:	2201      	movs	r2, #1
 800a52a:	639a      	str	r2, [r3, #56]	; 0x38

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 800a52c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a52e:	687a      	ldr	r2, [r7, #4]
 800a530:	64da      	str	r2, [r3, #76]	; 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800a532:	4b15      	ldr	r3, [pc, #84]	; (800a588 <_tx_queue_front_send+0x2b4>)
 800a534:	681b      	ldr	r3, [r3, #0]
 800a536:	3301      	adds	r3, #1
 800a538:	4a13      	ldr	r2, [pc, #76]	; (800a588 <_tx_queue_front_send+0x2b4>)
 800a53a:	6013      	str	r3, [r2, #0]
 800a53c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a53e:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a540:	69bb      	ldr	r3, [r7, #24]
 800a542:	f383 8810 	msr	PRIMASK, r3
}
 800a546:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
 800a548:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800a54a:	f002 f883 	bl	800c654 <_tx_thread_system_suspend>
#endif

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Determine if a notify callback is required.  */
            if (thread_ptr -> tx_thread_suspend_status == TX_SUCCESS)
 800a54e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a550:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800a554:	2b00      	cmp	r3, #0
 800a556:	d105      	bne.n	800a564 <_tx_queue_front_send+0x290>
            {

                /* Check for a notify callback.  */
                if (queue_send_notify != TX_NULL)
 800a558:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a55a:	2b00      	cmp	r3, #0
 800a55c:	d002      	beq.n	800a564 <_tx_queue_front_send+0x290>
                {

                    /* Call application queue send notification.  */
                    (queue_send_notify)(queue_ptr);
 800a55e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a560:	68f8      	ldr	r0, [r7, #12]
 800a562:	4798      	blx	r3
                }
            }
#endif

            /* Return the completion status.  */
            status =  thread_ptr -> tx_thread_suspend_status;
 800a564:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a566:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800a56a:	64bb      	str	r3, [r7, #72]	; 0x48
 800a56c:	e007      	b.n	800a57e <_tx_queue_front_send+0x2aa>
 800a56e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a570:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a572:	697b      	ldr	r3, [r7, #20]
 800a574:	f383 8810 	msr	PRIMASK, r3
}
 800a578:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* No room in queue and no suspension requested, return error completion.  */
        status =  TX_QUEUE_FULL;
 800a57a:	230b      	movs	r3, #11
 800a57c:	64bb      	str	r3, [r7, #72]	; 0x48
    }

    /* Return completion status.  */
    return(status);
 800a57e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
}
 800a580:	4618      	mov	r0, r3
 800a582:	3758      	adds	r7, #88	; 0x58
 800a584:	46bd      	mov	sp, r7
 800a586:	bd80      	pop	{r7, pc}
 800a588:	2000f054 	.word	0x2000f054
 800a58c:	2000efb8 	.word	0x2000efb8
 800a590:	08009ea9 	.word	0x08009ea9

0800a594 <_tx_queue_info_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_info_get(TX_QUEUE *queue_ptr, CHAR **name, ULONG *enqueued, ULONG *available_storage,
                    TX_THREAD **first_suspended, ULONG *suspended_count, TX_QUEUE **next_queue)
{
 800a594:	b480      	push	{r7}
 800a596:	b089      	sub	sp, #36	; 0x24
 800a598:	af00      	add	r7, sp, #0
 800a59a:	60f8      	str	r0, [r7, #12]
 800a59c:	60b9      	str	r1, [r7, #8]
 800a59e:	607a      	str	r2, [r7, #4]
 800a5a0:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800a5a2:	f3ef 8310 	mrs	r3, PRIMASK
 800a5a6:	61bb      	str	r3, [r7, #24]
    return(posture);
 800a5a8:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800a5aa:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800a5ac:	b672      	cpsid	i
    return(int_posture);
 800a5ae:	697b      	ldr	r3, [r7, #20]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts.  */
    TX_DISABLE
 800a5b0:	61fb      	str	r3, [r7, #28]

    /* Retrieve all the pertinent information and return it in the supplied
       destinations.  */

    /* Retrieve the name of the queue.  */
    if (name != TX_NULL)
 800a5b2:	68bb      	ldr	r3, [r7, #8]
 800a5b4:	2b00      	cmp	r3, #0
 800a5b6:	d003      	beq.n	800a5c0 <_tx_queue_info_get+0x2c>
    {

        *name =  queue_ptr -> tx_queue_name;
 800a5b8:	68fb      	ldr	r3, [r7, #12]
 800a5ba:	685a      	ldr	r2, [r3, #4]
 800a5bc:	68bb      	ldr	r3, [r7, #8]
 800a5be:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the number of messages currently in the queue.  */
    if (enqueued != TX_NULL)
 800a5c0:	687b      	ldr	r3, [r7, #4]
 800a5c2:	2b00      	cmp	r3, #0
 800a5c4:	d003      	beq.n	800a5ce <_tx_queue_info_get+0x3a>
    {

        *enqueued =  (ULONG) queue_ptr -> tx_queue_enqueued;
 800a5c6:	68fb      	ldr	r3, [r7, #12]
 800a5c8:	691a      	ldr	r2, [r3, #16]
 800a5ca:	687b      	ldr	r3, [r7, #4]
 800a5cc:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the number of messages that will still fit in the queue.  */
    if (available_storage != TX_NULL)
 800a5ce:	683b      	ldr	r3, [r7, #0]
 800a5d0:	2b00      	cmp	r3, #0
 800a5d2:	d003      	beq.n	800a5dc <_tx_queue_info_get+0x48>
    {

        *available_storage =  (ULONG) queue_ptr -> tx_queue_available_storage;
 800a5d4:	68fb      	ldr	r3, [r7, #12]
 800a5d6:	695a      	ldr	r2, [r3, #20]
 800a5d8:	683b      	ldr	r3, [r7, #0]
 800a5da:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the first thread suspended on this queue.  */
    if (first_suspended != TX_NULL)
 800a5dc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a5de:	2b00      	cmp	r3, #0
 800a5e0:	d003      	beq.n	800a5ea <_tx_queue_info_get+0x56>
    {

        *first_suspended =  queue_ptr -> tx_queue_suspension_list;
 800a5e2:	68fb      	ldr	r3, [r7, #12]
 800a5e4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800a5e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a5e8:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the number of threads suspended on this queue.  */
    if (suspended_count != TX_NULL)
 800a5ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a5ec:	2b00      	cmp	r3, #0
 800a5ee:	d003      	beq.n	800a5f8 <_tx_queue_info_get+0x64>
    {

        *suspended_count =  (ULONG) queue_ptr -> tx_queue_suspended_count;
 800a5f0:	68fb      	ldr	r3, [r7, #12]
 800a5f2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a5f4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a5f6:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the pointer to the next queue created.  */
    if (next_queue != TX_NULL)
 800a5f8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a5fa:	2b00      	cmp	r3, #0
 800a5fc:	d003      	beq.n	800a606 <_tx_queue_info_get+0x72>
    {

        *next_queue =  queue_ptr -> tx_queue_created_next;
 800a5fe:	68fb      	ldr	r3, [r7, #12]
 800a600:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a602:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a604:	601a      	str	r2, [r3, #0]
 800a606:	69fb      	ldr	r3, [r7, #28]
 800a608:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a60a:	693b      	ldr	r3, [r7, #16]
 800a60c:	f383 8810 	msr	PRIMASK, r3
}
 800a610:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(TX_SUCCESS);
 800a612:	2300      	movs	r3, #0
}
 800a614:	4618      	mov	r0, r3
 800a616:	3724      	adds	r7, #36	; 0x24
 800a618:	46bd      	mov	sp, r7
 800a61a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a61e:	4770      	bx	lr

0800a620 <_tx_queue_performance_info_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_performance_info_get(TX_QUEUE *queue_ptr, ULONG *messages_sent, ULONG *messages_received,
                    ULONG *empty_suspensions, ULONG *full_suspensions, ULONG *full_errors, ULONG *timeouts)
{
 800a620:	b480      	push	{r7}
 800a622:	b087      	sub	sp, #28
 800a624:	af00      	add	r7, sp, #0
 800a626:	60f8      	str	r0, [r7, #12]
 800a628:	60b9      	str	r1, [r7, #8]
 800a62a:	607a      	str	r2, [r7, #4]
 800a62c:	603b      	str	r3, [r7, #0]
#else
UINT                    status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (queue_ptr != TX_NULL)
 800a62e:	68fb      	ldr	r3, [r7, #12]
 800a630:	2b00      	cmp	r3, #0
 800a632:	d002      	beq.n	800a63a <_tx_queue_performance_info_get+0x1a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800a634:	23ff      	movs	r3, #255	; 0xff
 800a636:	617b      	str	r3, [r7, #20]
 800a638:	e025      	b.n	800a686 <_tx_queue_performance_info_get+0x66>
    }
    else if (messages_sent != TX_NULL)
 800a63a:	68bb      	ldr	r3, [r7, #8]
 800a63c:	2b00      	cmp	r3, #0
 800a63e:	d002      	beq.n	800a646 <_tx_queue_performance_info_get+0x26>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800a640:	23ff      	movs	r3, #255	; 0xff
 800a642:	617b      	str	r3, [r7, #20]
 800a644:	e01f      	b.n	800a686 <_tx_queue_performance_info_get+0x66>
    }
    else if (messages_received != TX_NULL)
 800a646:	687b      	ldr	r3, [r7, #4]
 800a648:	2b00      	cmp	r3, #0
 800a64a:	d002      	beq.n	800a652 <_tx_queue_performance_info_get+0x32>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800a64c:	23ff      	movs	r3, #255	; 0xff
 800a64e:	617b      	str	r3, [r7, #20]
 800a650:	e019      	b.n	800a686 <_tx_queue_performance_info_get+0x66>
    }
    else if (empty_suspensions != TX_NULL)
 800a652:	683b      	ldr	r3, [r7, #0]
 800a654:	2b00      	cmp	r3, #0
 800a656:	d002      	beq.n	800a65e <_tx_queue_performance_info_get+0x3e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800a658:	23ff      	movs	r3, #255	; 0xff
 800a65a:	617b      	str	r3, [r7, #20]
 800a65c:	e013      	b.n	800a686 <_tx_queue_performance_info_get+0x66>
    }
    else if (full_suspensions != TX_NULL)
 800a65e:	6a3b      	ldr	r3, [r7, #32]
 800a660:	2b00      	cmp	r3, #0
 800a662:	d002      	beq.n	800a66a <_tx_queue_performance_info_get+0x4a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800a664:	23ff      	movs	r3, #255	; 0xff
 800a666:	617b      	str	r3, [r7, #20]
 800a668:	e00d      	b.n	800a686 <_tx_queue_performance_info_get+0x66>
    }
    else if (full_errors != TX_NULL)
 800a66a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a66c:	2b00      	cmp	r3, #0
 800a66e:	d002      	beq.n	800a676 <_tx_queue_performance_info_get+0x56>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800a670:	23ff      	movs	r3, #255	; 0xff
 800a672:	617b      	str	r3, [r7, #20]
 800a674:	e007      	b.n	800a686 <_tx_queue_performance_info_get+0x66>
    }
    else if (timeouts != TX_NULL)
 800a676:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a678:	2b00      	cmp	r3, #0
 800a67a:	d002      	beq.n	800a682 <_tx_queue_performance_info_get+0x62>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800a67c:	23ff      	movs	r3, #255	; 0xff
 800a67e:	617b      	str	r3, [r7, #20]
 800a680:	e001      	b.n	800a686 <_tx_queue_performance_info_get+0x66>
    }
    else
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800a682:	23ff      	movs	r3, #255	; 0xff
 800a684:	617b      	str	r3, [r7, #20]
    }
#endif

    /* Return completion status.  */
    return(status);
 800a686:	697b      	ldr	r3, [r7, #20]
}
 800a688:	4618      	mov	r0, r3
 800a68a:	371c      	adds	r7, #28
 800a68c:	46bd      	mov	sp, r7
 800a68e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a692:	4770      	bx	lr

0800a694 <_tx_queue_performance_system_info_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_performance_system_info_get(ULONG *messages_sent, ULONG *messages_received,
                    ULONG *empty_suspensions, ULONG *full_suspensions, ULONG *full_errors, ULONG *timeouts)
{
 800a694:	b480      	push	{r7}
 800a696:	b087      	sub	sp, #28
 800a698:	af00      	add	r7, sp, #0
 800a69a:	60f8      	str	r0, [r7, #12]
 800a69c:	60b9      	str	r1, [r7, #8]
 800a69e:	607a      	str	r2, [r7, #4]
 800a6a0:	603b      	str	r3, [r7, #0]

UINT        status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (messages_sent != TX_NULL)
 800a6a2:	68fb      	ldr	r3, [r7, #12]
 800a6a4:	2b00      	cmp	r3, #0
 800a6a6:	d002      	beq.n	800a6ae <_tx_queue_performance_system_info_get+0x1a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800a6a8:	23ff      	movs	r3, #255	; 0xff
 800a6aa:	617b      	str	r3, [r7, #20]
 800a6ac:	e01f      	b.n	800a6ee <_tx_queue_performance_system_info_get+0x5a>
    }
    else if (messages_received != TX_NULL)
 800a6ae:	68bb      	ldr	r3, [r7, #8]
 800a6b0:	2b00      	cmp	r3, #0
 800a6b2:	d002      	beq.n	800a6ba <_tx_queue_performance_system_info_get+0x26>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800a6b4:	23ff      	movs	r3, #255	; 0xff
 800a6b6:	617b      	str	r3, [r7, #20]
 800a6b8:	e019      	b.n	800a6ee <_tx_queue_performance_system_info_get+0x5a>
    }
    else if (empty_suspensions != TX_NULL)
 800a6ba:	687b      	ldr	r3, [r7, #4]
 800a6bc:	2b00      	cmp	r3, #0
 800a6be:	d002      	beq.n	800a6c6 <_tx_queue_performance_system_info_get+0x32>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800a6c0:	23ff      	movs	r3, #255	; 0xff
 800a6c2:	617b      	str	r3, [r7, #20]
 800a6c4:	e013      	b.n	800a6ee <_tx_queue_performance_system_info_get+0x5a>
    }
    else if (full_suspensions != TX_NULL)
 800a6c6:	683b      	ldr	r3, [r7, #0]
 800a6c8:	2b00      	cmp	r3, #0
 800a6ca:	d002      	beq.n	800a6d2 <_tx_queue_performance_system_info_get+0x3e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800a6cc:	23ff      	movs	r3, #255	; 0xff
 800a6ce:	617b      	str	r3, [r7, #20]
 800a6d0:	e00d      	b.n	800a6ee <_tx_queue_performance_system_info_get+0x5a>
    }
    else if (full_errors != TX_NULL)
 800a6d2:	6a3b      	ldr	r3, [r7, #32]
 800a6d4:	2b00      	cmp	r3, #0
 800a6d6:	d002      	beq.n	800a6de <_tx_queue_performance_system_info_get+0x4a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800a6d8:	23ff      	movs	r3, #255	; 0xff
 800a6da:	617b      	str	r3, [r7, #20]
 800a6dc:	e007      	b.n	800a6ee <_tx_queue_performance_system_info_get+0x5a>
    }
    else if (timeouts != TX_NULL)
 800a6de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a6e0:	2b00      	cmp	r3, #0
 800a6e2:	d002      	beq.n	800a6ea <_tx_queue_performance_system_info_get+0x56>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800a6e4:	23ff      	movs	r3, #255	; 0xff
 800a6e6:	617b      	str	r3, [r7, #20]
 800a6e8:	e001      	b.n	800a6ee <_tx_queue_performance_system_info_get+0x5a>
    }
    else
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800a6ea:	23ff      	movs	r3, #255	; 0xff
 800a6ec:	617b      	str	r3, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 800a6ee:	697b      	ldr	r3, [r7, #20]
#endif
}
 800a6f0:	4618      	mov	r0, r3
 800a6f2:	371c      	adds	r7, #28
 800a6f4:	46bd      	mov	sp, r7
 800a6f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a6fa:	4770      	bx	lr

0800a6fc <_tx_queue_prioritize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_prioritize(TX_QUEUE *queue_ptr)
{
 800a6fc:	b580      	push	{r7, lr}
 800a6fe:	b092      	sub	sp, #72	; 0x48
 800a700:	af00      	add	r7, sp, #0
 800a702:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800a704:	f3ef 8310 	mrs	r3, PRIMASK
 800a708:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 800a70a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 800a70c:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 800a70e:	b672      	cpsid	i
    return(int_posture);
 800a710:	6a3b      	ldr	r3, [r7, #32]
TX_THREAD       *previous_thread;
UINT            list_changed;


    /* Disable interrupts to place message in the queue.  */
    TX_DISABLE
 800a712:	647b      	str	r3, [r7, #68]	; 0x44

    /* Log this kernel call.  */
    TX_EL_QUEUE_PRIORITIZE_INSERT

    /* Pickup the suspended count.  */
    suspended_count =  queue_ptr -> tx_queue_suspended_count;
 800a714:	687b      	ldr	r3, [r7, #4]
 800a716:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a718:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if there are fewer than 2 suspended threads.  */
    if (suspended_count < ((UINT) 2))
 800a71a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a71c:	2b01      	cmp	r3, #1
 800a71e:	d805      	bhi.n	800a72c <_tx_queue_prioritize+0x30>
 800a720:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a722:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a724:	69fb      	ldr	r3, [r7, #28]
 800a726:	f383 8810 	msr	PRIMASK, r3
}
 800a72a:	e092      	b.n	800a852 <_tx_queue_prioritize+0x156>
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Determine if there how many threads are suspended on this queue.  */
    else if (suspended_count == ((UINT) 2))
 800a72c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a72e:	2b02      	cmp	r3, #2
 800a730:	d114      	bne.n	800a75c <_tx_queue_prioritize+0x60>
    {

        /* Pickup the head pointer and the next pointer.  */
        head_ptr =  queue_ptr -> tx_queue_suspension_list;
 800a732:	687b      	ldr	r3, [r7, #4]
 800a734:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a736:	63bb      	str	r3, [r7, #56]	; 0x38
        next_thread =  head_ptr -> tx_thread_suspended_next;
 800a738:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a73a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800a73c:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Determine if the next suspended thread has a higher priority.  */
        if ((next_thread -> tx_thread_priority) < (head_ptr -> tx_thread_priority))
 800a73e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a740:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a742:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a744:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a746:	429a      	cmp	r2, r3
 800a748:	d202      	bcs.n	800a750 <_tx_queue_prioritize+0x54>
        {

            /* Yes, move the list head to the next thread.  */
            queue_ptr -> tx_queue_suspension_list =  next_thread;
 800a74a:	687b      	ldr	r3, [r7, #4]
 800a74c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800a74e:	629a      	str	r2, [r3, #40]	; 0x28
 800a750:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a752:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a754:	69bb      	ldr	r3, [r7, #24]
 800a756:	f383 8810 	msr	PRIMASK, r3
}
 800a75a:	e07a      	b.n	800a852 <_tx_queue_prioritize+0x156>
    }
    else
    {

        /* Remember the suspension count and head pointer.  */
        head_ptr =   queue_ptr -> tx_queue_suspension_list;
 800a75c:	687b      	ldr	r3, [r7, #4]
 800a75e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a760:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Default the highest priority thread to the thread at the front of the list.  */
        priority_thread_ptr =  head_ptr;
 800a762:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a764:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Setup search pointer.  */
        thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
 800a766:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a768:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800a76a:	643b      	str	r3, [r7, #64]	; 0x40

        /* Disable preemption.  */
        _tx_thread_preempt_disable++;
 800a76c:	4b3b      	ldr	r3, [pc, #236]	; (800a85c <_tx_queue_prioritize+0x160>)
 800a76e:	681b      	ldr	r3, [r3, #0]
 800a770:	3301      	adds	r3, #1
 800a772:	4a3a      	ldr	r2, [pc, #232]	; (800a85c <_tx_queue_prioritize+0x160>)
 800a774:	6013      	str	r3, [r2, #0]

        /* Set the list changed flag to false.  */
        list_changed =  TX_FALSE;
 800a776:	2300      	movs	r3, #0
 800a778:	633b      	str	r3, [r7, #48]	; 0x30
        /* Search through the list to find the highest priority thread.  */
        do
        {

            /* Is the current thread higher priority?  */
            if (thread_ptr -> tx_thread_priority < priority_thread_ptr -> tx_thread_priority)
 800a77a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a77c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a77e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a780:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a782:	429a      	cmp	r2, r3
 800a784:	d201      	bcs.n	800a78a <_tx_queue_prioritize+0x8e>
            {

                /* Yes, remember that this thread is the highest priority.  */
                priority_thread_ptr =  thread_ptr;
 800a786:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a788:	63fb      	str	r3, [r7, #60]	; 0x3c
 800a78a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a78c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a78e:	68fb      	ldr	r3, [r7, #12]
 800a790:	f383 8810 	msr	PRIMASK, r3
}
 800a794:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800a796:	f3ef 8310 	mrs	r3, PRIMASK
 800a79a:	617b      	str	r3, [r7, #20]
    return(posture);
 800a79c:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800a79e:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800a7a0:	b672      	cpsid	i
    return(int_posture);
 800a7a2:	693b      	ldr	r3, [r7, #16]

            /* Restore interrupts temporarily.  */
            TX_RESTORE

            /* Disable interrupts again.  */
            TX_DISABLE
 800a7a4:	647b      	str	r3, [r7, #68]	; 0x44

            /* Determine if any changes to the list have occurred while
               interrupts were enabled.  */

            /* Is the list head the same?  */
            if (head_ptr != queue_ptr -> tx_queue_suspension_list)
 800a7a6:	687b      	ldr	r3, [r7, #4]
 800a7a8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a7aa:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800a7ac:	429a      	cmp	r2, r3
 800a7ae:	d002      	beq.n	800a7b6 <_tx_queue_prioritize+0xba>
            {

                /* The list head has changed, set the list changed flag.  */
                list_changed =  TX_TRUE;
 800a7b0:	2301      	movs	r3, #1
 800a7b2:	633b      	str	r3, [r7, #48]	; 0x30
 800a7b4:	e006      	b.n	800a7c4 <_tx_queue_prioritize+0xc8>
            }
            else
            {

                /* Is the suspended count the same?  */
                if (suspended_count != queue_ptr -> tx_queue_suspended_count)
 800a7b6:	687b      	ldr	r3, [r7, #4]
 800a7b8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a7ba:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a7bc:	429a      	cmp	r2, r3
 800a7be:	d001      	beq.n	800a7c4 <_tx_queue_prioritize+0xc8>
                {

                    /* The list head has changed, set the list changed flag.  */
                    list_changed =  TX_TRUE;
 800a7c0:	2301      	movs	r3, #1
 800a7c2:	633b      	str	r3, [r7, #48]	; 0x30
                }
            }

            /* Determine if the list has changed.  */
            if (list_changed == TX_FALSE)
 800a7c4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a7c6:	2b00      	cmp	r3, #0
 800a7c8:	d103      	bne.n	800a7d2 <_tx_queue_prioritize+0xd6>
            {

                /* Move the thread pointer to the next thread.  */
                thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 800a7ca:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a7cc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800a7ce:	643b      	str	r3, [r7, #64]	; 0x40
 800a7d0:	e00c      	b.n	800a7ec <_tx_queue_prioritize+0xf0>
            }
            else
            {

                /* Save the suspension count and head pointer.  */
                head_ptr =   queue_ptr -> tx_queue_suspension_list;
 800a7d2:	687b      	ldr	r3, [r7, #4]
 800a7d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a7d6:	63bb      	str	r3, [r7, #56]	; 0x38
                suspended_count =  queue_ptr -> tx_queue_suspended_count;
 800a7d8:	687b      	ldr	r3, [r7, #4]
 800a7da:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a7dc:	637b      	str	r3, [r7, #52]	; 0x34

                /* Default the highest priority thread to the thread at the front of the list.  */
                priority_thread_ptr =  head_ptr;
 800a7de:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a7e0:	63fb      	str	r3, [r7, #60]	; 0x3c

                /* Setup search pointer.  */
                thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
 800a7e2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a7e4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800a7e6:	643b      	str	r3, [r7, #64]	; 0x40

                /* Reset the list changed flag.  */
                list_changed =  TX_FALSE;
 800a7e8:	2300      	movs	r3, #0
 800a7ea:	633b      	str	r3, [r7, #48]	; 0x30
            }

        } while (thread_ptr != head_ptr);
 800a7ec:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800a7ee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a7f0:	429a      	cmp	r2, r3
 800a7f2:	d1c2      	bne.n	800a77a <_tx_queue_prioritize+0x7e>

        /* Release preemption.  */
        _tx_thread_preempt_disable--;
 800a7f4:	4b19      	ldr	r3, [pc, #100]	; (800a85c <_tx_queue_prioritize+0x160>)
 800a7f6:	681b      	ldr	r3, [r3, #0]
 800a7f8:	3b01      	subs	r3, #1
 800a7fa:	4a18      	ldr	r2, [pc, #96]	; (800a85c <_tx_queue_prioritize+0x160>)
 800a7fc:	6013      	str	r3, [r2, #0]

        /* Now determine if the highest priority thread is at the front
           of the list.  */
        if (priority_thread_ptr != head_ptr)
 800a7fe:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800a800:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a802:	429a      	cmp	r2, r3
 800a804:	d01d      	beq.n	800a842 <_tx_queue_prioritize+0x146>
            /* No, we need to move the highest priority suspended thread to the
               front of the list.  */

            /* First, remove the highest priority thread by updating the
               adjacent suspended threads.  */
            next_thread =                                  priority_thread_ptr -> tx_thread_suspended_next;
 800a806:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a808:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800a80a:	62fb      	str	r3, [r7, #44]	; 0x2c
            previous_thread =                              priority_thread_ptr -> tx_thread_suspended_previous;
 800a80c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a80e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800a810:	62bb      	str	r3, [r7, #40]	; 0x28
            next_thread -> tx_thread_suspended_previous =  previous_thread;
 800a812:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a814:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800a816:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =  next_thread;
 800a818:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a81a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800a81c:	671a      	str	r2, [r3, #112]	; 0x70

            /* Now, link the highest priority thread at the front of the list.  */
            previous_thread =                                      head_ptr -> tx_thread_suspended_previous;
 800a81e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a820:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800a822:	62bb      	str	r3, [r7, #40]	; 0x28
            priority_thread_ptr -> tx_thread_suspended_next =      head_ptr;
 800a824:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a826:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800a828:	671a      	str	r2, [r3, #112]	; 0x70
            priority_thread_ptr -> tx_thread_suspended_previous =  previous_thread;
 800a82a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a82c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800a82e:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =          priority_thread_ptr;
 800a830:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a832:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800a834:	671a      	str	r2, [r3, #112]	; 0x70
            head_ptr -> tx_thread_suspended_previous =             priority_thread_ptr;
 800a836:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a838:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800a83a:	675a      	str	r2, [r3, #116]	; 0x74

            /* Move the list head pointer to the highest priority suspended thread.  */
            queue_ptr -> tx_queue_suspension_list =  priority_thread_ptr;
 800a83c:	687b      	ldr	r3, [r7, #4]
 800a83e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800a840:	629a      	str	r2, [r3, #40]	; 0x28
 800a842:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a844:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a846:	68bb      	ldr	r3, [r7, #8]
 800a848:	f383 8810 	msr	PRIMASK, r3
}
 800a84c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 800a84e:	f001 fdb3 	bl	800c3b8 <_tx_thread_system_preempt_check>
    }

    /* Return successful status.  */
    return(TX_SUCCESS);
 800a852:	2300      	movs	r3, #0
}
 800a854:	4618      	mov	r0, r3
 800a856:	3748      	adds	r7, #72	; 0x48
 800a858:	46bd      	mov	sp, r7
 800a85a:	bd80      	pop	{r7, pc}
 800a85c:	2000f054 	.word	0x2000f054

0800a860 <_tx_queue_receive>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_receive(TX_QUEUE *queue_ptr, VOID *destination_ptr, ULONG wait_option)
{
 800a860:	b580      	push	{r7, lr}
 800a862:	b096      	sub	sp, #88	; 0x58
 800a864:	af00      	add	r7, sp, #0
 800a866:	60f8      	str	r0, [r7, #12]
 800a868:	60b9      	str	r1, [r7, #8]
 800a86a:	607a      	str	r2, [r7, #4]
TX_THREAD       *previous_thread;
UINT            status;


    /* Default the status to TX_SUCCESS.  */
    status =  TX_SUCCESS;
 800a86c:	2300      	movs	r3, #0
 800a86e:	64bb      	str	r3, [r7, #72]	; 0x48
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800a870:	f3ef 8310 	mrs	r3, PRIMASK
 800a874:	633b      	str	r3, [r7, #48]	; 0x30
    return(posture);
 800a876:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    int_posture = __get_interrupt_posture();
 800a878:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("CPSID i" : : : "memory");
 800a87a:	b672      	cpsid	i
    return(int_posture);
 800a87c:	6afb      	ldr	r3, [r7, #44]	; 0x2c

    /* Disable interrupts to receive message from queue.  */
    TX_DISABLE
 800a87e:	647b      	str	r3, [r7, #68]	; 0x44

    /* Log this kernel call.  */
    TX_EL_QUEUE_RECEIVE_INSERT

    /* Pickup the thread suspension count.  */
    suspended_count =  queue_ptr -> tx_queue_suspended_count;
 800a880:	68fb      	ldr	r3, [r7, #12]
 800a882:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a884:	643b      	str	r3, [r7, #64]	; 0x40

    /* Determine if there is anything in the queue.  */
    if (queue_ptr -> tx_queue_enqueued != TX_NO_MESSAGES)
 800a886:	68fb      	ldr	r3, [r7, #12]
 800a888:	691b      	ldr	r3, [r3, #16]
 800a88a:	2b00      	cmp	r3, #0
 800a88c:	f000 8136 	beq.w	800aafc <_tx_queue_receive+0x29c>
    {

        /* Determine if there are any suspensions.  */
        if (suspended_count == TX_NO_SUSPENSIONS)
 800a890:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a892:	2b00      	cmp	r3, #0
 800a894:	d13c      	bne.n	800a910 <_tx_queue_receive+0xb0>
        {

            /* There is a message waiting in the queue and there are no suspensi.  */

            /* Setup source and destination pointers.  */
            source =       queue_ptr -> tx_queue_read;
 800a896:	68fb      	ldr	r3, [r7, #12]
 800a898:	6a1b      	ldr	r3, [r3, #32]
 800a89a:	657b      	str	r3, [r7, #84]	; 0x54
            destination =  TX_VOID_TO_ULONG_POINTER_CONVERT(destination_ptr);
 800a89c:	68bb      	ldr	r3, [r7, #8]
 800a89e:	653b      	str	r3, [r7, #80]	; 0x50
            size =         queue_ptr -> tx_queue_message_size;
 800a8a0:	68fb      	ldr	r3, [r7, #12]
 800a8a2:	689b      	ldr	r3, [r3, #8]
 800a8a4:	64fb      	str	r3, [r7, #76]	; 0x4c

            /* Copy message. Note that the source and destination pointers are
               incremented by the macro.  */
            TX_QUEUE_MESSAGE_COPY(source, destination, size)
 800a8a6:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800a8a8:	1d13      	adds	r3, r2, #4
 800a8aa:	657b      	str	r3, [r7, #84]	; 0x54
 800a8ac:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800a8ae:	1d19      	adds	r1, r3, #4
 800a8b0:	6539      	str	r1, [r7, #80]	; 0x50
 800a8b2:	6812      	ldr	r2, [r2, #0]
 800a8b4:	601a      	str	r2, [r3, #0]
 800a8b6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a8b8:	2b01      	cmp	r3, #1
 800a8ba:	d90e      	bls.n	800a8da <_tx_queue_receive+0x7a>
 800a8bc:	e007      	b.n	800a8ce <_tx_queue_receive+0x6e>
 800a8be:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800a8c0:	1d13      	adds	r3, r2, #4
 800a8c2:	657b      	str	r3, [r7, #84]	; 0x54
 800a8c4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800a8c6:	1d19      	adds	r1, r3, #4
 800a8c8:	6539      	str	r1, [r7, #80]	; 0x50
 800a8ca:	6812      	ldr	r2, [r2, #0]
 800a8cc:	601a      	str	r2, [r3, #0]
 800a8ce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a8d0:	3b01      	subs	r3, #1
 800a8d2:	64fb      	str	r3, [r7, #76]	; 0x4c
 800a8d4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a8d6:	2b00      	cmp	r3, #0
 800a8d8:	d1f1      	bne.n	800a8be <_tx_queue_receive+0x5e>

            /* Determine if we are at the end.  */
            if (source == queue_ptr -> tx_queue_end)
 800a8da:	68fb      	ldr	r3, [r7, #12]
 800a8dc:	69db      	ldr	r3, [r3, #28]
 800a8de:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800a8e0:	429a      	cmp	r2, r3
 800a8e2:	d102      	bne.n	800a8ea <_tx_queue_receive+0x8a>
            {

                /* Yes, wrap around to the beginning.  */
                source =  queue_ptr -> tx_queue_start;
 800a8e4:	68fb      	ldr	r3, [r7, #12]
 800a8e6:	699b      	ldr	r3, [r3, #24]
 800a8e8:	657b      	str	r3, [r7, #84]	; 0x54
            }

            /* Setup the queue read pointer.   */
            queue_ptr -> tx_queue_read =  source;
 800a8ea:	68fb      	ldr	r3, [r7, #12]
 800a8ec:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800a8ee:	621a      	str	r2, [r3, #32]

            /* Increase the amount of available storage.  */
            queue_ptr -> tx_queue_available_storage++;
 800a8f0:	68fb      	ldr	r3, [r7, #12]
 800a8f2:	695b      	ldr	r3, [r3, #20]
 800a8f4:	1c5a      	adds	r2, r3, #1
 800a8f6:	68fb      	ldr	r3, [r7, #12]
 800a8f8:	615a      	str	r2, [r3, #20]

            /* Decrease the enqueued count.  */
            queue_ptr -> tx_queue_enqueued--;
 800a8fa:	68fb      	ldr	r3, [r7, #12]
 800a8fc:	691b      	ldr	r3, [r3, #16]
 800a8fe:	1e5a      	subs	r2, r3, #1
 800a900:	68fb      	ldr	r3, [r7, #12]
 800a902:	611a      	str	r2, [r3, #16]
 800a904:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a906:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a908:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a90a:	f383 8810 	msr	PRIMASK, r3
}
 800a90e:	e163      	b.n	800abd8 <_tx_queue_receive+0x378>
        {

            /* At this point we know the queue is full.  */

            /* Pickup thread suspension list head pointer.  */
            thread_ptr =  queue_ptr -> tx_queue_suspension_list;
 800a910:	68fb      	ldr	r3, [r7, #12]
 800a912:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a914:	63fb      	str	r3, [r7, #60]	; 0x3c

            /* Now determine if there is a queue front suspension active.   */

            /* Is the front suspension flag set?  */
            if (thread_ptr -> tx_thread_suspend_option == TX_TRUE)
 800a916:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a918:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800a91c:	2b01      	cmp	r3, #1
 800a91e:	d153      	bne.n	800a9c8 <_tx_queue_receive+0x168>
                /* Yes, a queue front suspension is present.  */

                /* Return the message associated with this suspension.  */

                /* Setup source and destination pointers.  */
                source =       TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
 800a920:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a922:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800a924:	657b      	str	r3, [r7, #84]	; 0x54
                destination =  TX_VOID_TO_ULONG_POINTER_CONVERT(destination_ptr);
 800a926:	68bb      	ldr	r3, [r7, #8]
 800a928:	653b      	str	r3, [r7, #80]	; 0x50
                size =         queue_ptr -> tx_queue_message_size;
 800a92a:	68fb      	ldr	r3, [r7, #12]
 800a92c:	689b      	ldr	r3, [r3, #8]
 800a92e:	64fb      	str	r3, [r7, #76]	; 0x4c

                /* Copy message. Note that the source and destination pointers are
                   incremented by the macro.  */
                TX_QUEUE_MESSAGE_COPY(source, destination, size)
 800a930:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800a932:	1d13      	adds	r3, r2, #4
 800a934:	657b      	str	r3, [r7, #84]	; 0x54
 800a936:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800a938:	1d19      	adds	r1, r3, #4
 800a93a:	6539      	str	r1, [r7, #80]	; 0x50
 800a93c:	6812      	ldr	r2, [r2, #0]
 800a93e:	601a      	str	r2, [r3, #0]
 800a940:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a942:	2b01      	cmp	r3, #1
 800a944:	d90e      	bls.n	800a964 <_tx_queue_receive+0x104>
 800a946:	e007      	b.n	800a958 <_tx_queue_receive+0xf8>
 800a948:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800a94a:	1d13      	adds	r3, r2, #4
 800a94c:	657b      	str	r3, [r7, #84]	; 0x54
 800a94e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800a950:	1d19      	adds	r1, r3, #4
 800a952:	6539      	str	r1, [r7, #80]	; 0x50
 800a954:	6812      	ldr	r2, [r2, #0]
 800a956:	601a      	str	r2, [r3, #0]
 800a958:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a95a:	3b01      	subs	r3, #1
 800a95c:	64fb      	str	r3, [r7, #76]	; 0x4c
 800a95e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a960:	2b00      	cmp	r3, #0
 800a962:	d1f1      	bne.n	800a948 <_tx_queue_receive+0xe8>

                /* Message is now in the caller's destination. See if this is the only suspended thread
                   on the list.  */
                suspended_count--;
 800a964:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a966:	3b01      	subs	r3, #1
 800a968:	643b      	str	r3, [r7, #64]	; 0x40
                if (suspended_count == TX_NO_SUSPENSIONS)
 800a96a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a96c:	2b00      	cmp	r3, #0
 800a96e:	d103      	bne.n	800a978 <_tx_queue_receive+0x118>
                {

                    /* Yes, the only suspended thread.  */

                    /* Update the head pointer.  */
                    queue_ptr -> tx_queue_suspension_list =  TX_NULL;
 800a970:	68fb      	ldr	r3, [r7, #12]
 800a972:	2200      	movs	r2, #0
 800a974:	629a      	str	r2, [r3, #40]	; 0x28
 800a976:	e00e      	b.n	800a996 <_tx_queue_receive+0x136>
                {

                    /* At least one more thread is on the same expiration list.  */

                    /* Update the list head pointer.  */
                    next_thread =                            thread_ptr -> tx_thread_suspended_next;
 800a978:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a97a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800a97c:	63bb      	str	r3, [r7, #56]	; 0x38
                    queue_ptr -> tx_queue_suspension_list =  next_thread;
 800a97e:	68fb      	ldr	r3, [r7, #12]
 800a980:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800a982:	629a      	str	r2, [r3, #40]	; 0x28

                    /* Update the links of the adjacent threads.  */
                    previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
 800a984:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a986:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800a988:	637b      	str	r3, [r7, #52]	; 0x34
                    next_thread -> tx_thread_suspended_previous =  previous_thread;
 800a98a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a98c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a98e:	675a      	str	r2, [r3, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =  next_thread;
 800a990:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a992:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800a994:	671a      	str	r2, [r3, #112]	; 0x70
                }

                /* Decrement the suspension count.  */
                queue_ptr -> tx_queue_suspended_count =  suspended_count;
 800a996:	68fb      	ldr	r3, [r7, #12]
 800a998:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800a99a:	62da      	str	r2, [r3, #44]	; 0x2c

                /* Prepare for resumption of the first thread.  */

                /* Clear cleanup routine to avoid timeout.  */
                thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800a99c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a99e:	2200      	movs	r2, #0
 800a9a0:	669a      	str	r2, [r3, #104]	; 0x68

                /* Put return status into the thread control block.  */
                thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 800a9a2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a9a4:	2200      	movs	r2, #0
 800a9a6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
 800a9aa:	4b8e      	ldr	r3, [pc, #568]	; (800abe4 <_tx_queue_receive+0x384>)
 800a9ac:	681b      	ldr	r3, [r3, #0]
 800a9ae:	3301      	adds	r3, #1
 800a9b0:	4a8c      	ldr	r2, [pc, #560]	; (800abe4 <_tx_queue_receive+0x384>)
 800a9b2:	6013      	str	r3, [r2, #0]
 800a9b4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a9b6:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a9b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a9ba:	f383 8810 	msr	PRIMASK, r3
}
 800a9be:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Resume thread.  */
                _tx_thread_system_resume(thread_ptr);
 800a9c0:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800a9c2:	f001 fd33 	bl	800c42c <_tx_thread_system_resume>
 800a9c6:	e107      	b.n	800abd8 <_tx_queue_receive+0x378>
                /* At this point, we know that the queue is full and there
                   are one or more threads suspended trying to send another
                   message to this queue.  */

                /* Setup source and destination pointers.  */
                source =       queue_ptr -> tx_queue_read;
 800a9c8:	68fb      	ldr	r3, [r7, #12]
 800a9ca:	6a1b      	ldr	r3, [r3, #32]
 800a9cc:	657b      	str	r3, [r7, #84]	; 0x54
                destination =  TX_VOID_TO_ULONG_POINTER_CONVERT(destination_ptr);
 800a9ce:	68bb      	ldr	r3, [r7, #8]
 800a9d0:	653b      	str	r3, [r7, #80]	; 0x50
                size =         queue_ptr -> tx_queue_message_size;
 800a9d2:	68fb      	ldr	r3, [r7, #12]
 800a9d4:	689b      	ldr	r3, [r3, #8]
 800a9d6:	64fb      	str	r3, [r7, #76]	; 0x4c

                /* Copy message. Note that the source and destination pointers are
                   incremented by the macro.  */
                TX_QUEUE_MESSAGE_COPY(source, destination, size)
 800a9d8:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800a9da:	1d13      	adds	r3, r2, #4
 800a9dc:	657b      	str	r3, [r7, #84]	; 0x54
 800a9de:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800a9e0:	1d19      	adds	r1, r3, #4
 800a9e2:	6539      	str	r1, [r7, #80]	; 0x50
 800a9e4:	6812      	ldr	r2, [r2, #0]
 800a9e6:	601a      	str	r2, [r3, #0]
 800a9e8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a9ea:	2b01      	cmp	r3, #1
 800a9ec:	d90e      	bls.n	800aa0c <_tx_queue_receive+0x1ac>
 800a9ee:	e007      	b.n	800aa00 <_tx_queue_receive+0x1a0>
 800a9f0:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800a9f2:	1d13      	adds	r3, r2, #4
 800a9f4:	657b      	str	r3, [r7, #84]	; 0x54
 800a9f6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800a9f8:	1d19      	adds	r1, r3, #4
 800a9fa:	6539      	str	r1, [r7, #80]	; 0x50
 800a9fc:	6812      	ldr	r2, [r2, #0]
 800a9fe:	601a      	str	r2, [r3, #0]
 800aa00:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa02:	3b01      	subs	r3, #1
 800aa04:	64fb      	str	r3, [r7, #76]	; 0x4c
 800aa06:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa08:	2b00      	cmp	r3, #0
 800aa0a:	d1f1      	bne.n	800a9f0 <_tx_queue_receive+0x190>

                /* Determine if we are at the end.  */
                if (source == queue_ptr -> tx_queue_end)
 800aa0c:	68fb      	ldr	r3, [r7, #12]
 800aa0e:	69db      	ldr	r3, [r3, #28]
 800aa10:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800aa12:	429a      	cmp	r2, r3
 800aa14:	d102      	bne.n	800aa1c <_tx_queue_receive+0x1bc>
                {

                    /* Yes, wrap around to the beginning.  */
                    source =  queue_ptr -> tx_queue_start;
 800aa16:	68fb      	ldr	r3, [r7, #12]
 800aa18:	699b      	ldr	r3, [r3, #24]
 800aa1a:	657b      	str	r3, [r7, #84]	; 0x54
                }

                /* Setup the queue read pointer.   */
                queue_ptr -> tx_queue_read =  source;
 800aa1c:	68fb      	ldr	r3, [r7, #12]
 800aa1e:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800aa20:	621a      	str	r2, [r3, #32]

                /* Disable preemption.  */
                _tx_thread_preempt_disable++;
 800aa22:	4b70      	ldr	r3, [pc, #448]	; (800abe4 <_tx_queue_receive+0x384>)
 800aa24:	681b      	ldr	r3, [r3, #0]
 800aa26:	3301      	adds	r3, #1
 800aa28:	4a6e      	ldr	r2, [pc, #440]	; (800abe4 <_tx_queue_receive+0x384>)
 800aa2a:	6013      	str	r3, [r2, #0]
                /* Disable interrupts again.  */
                TX_DISABLE
#endif

                /* Decrement the preemption disable variable.  */
                _tx_thread_preempt_disable--;
 800aa2c:	4b6d      	ldr	r3, [pc, #436]	; (800abe4 <_tx_queue_receive+0x384>)
 800aa2e:	681b      	ldr	r3, [r3, #0]
 800aa30:	3b01      	subs	r3, #1
 800aa32:	4a6c      	ldr	r2, [pc, #432]	; (800abe4 <_tx_queue_receive+0x384>)
 800aa34:	6013      	str	r3, [r2, #0]

                /* Setup source and destination pointers.  */
                source =       TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
 800aa36:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800aa38:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800aa3a:	657b      	str	r3, [r7, #84]	; 0x54
                destination =  queue_ptr -> tx_queue_write;
 800aa3c:	68fb      	ldr	r3, [r7, #12]
 800aa3e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800aa40:	653b      	str	r3, [r7, #80]	; 0x50
                size =         queue_ptr -> tx_queue_message_size;
 800aa42:	68fb      	ldr	r3, [r7, #12]
 800aa44:	689b      	ldr	r3, [r3, #8]
 800aa46:	64fb      	str	r3, [r7, #76]	; 0x4c

                /* Copy message. Note that the source and destination pointers are
                   incremented by the macro.  */
                TX_QUEUE_MESSAGE_COPY(source, destination, size)
 800aa48:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800aa4a:	1d13      	adds	r3, r2, #4
 800aa4c:	657b      	str	r3, [r7, #84]	; 0x54
 800aa4e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800aa50:	1d19      	adds	r1, r3, #4
 800aa52:	6539      	str	r1, [r7, #80]	; 0x50
 800aa54:	6812      	ldr	r2, [r2, #0]
 800aa56:	601a      	str	r2, [r3, #0]
 800aa58:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa5a:	2b01      	cmp	r3, #1
 800aa5c:	d90e      	bls.n	800aa7c <_tx_queue_receive+0x21c>
 800aa5e:	e007      	b.n	800aa70 <_tx_queue_receive+0x210>
 800aa60:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800aa62:	1d13      	adds	r3, r2, #4
 800aa64:	657b      	str	r3, [r7, #84]	; 0x54
 800aa66:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800aa68:	1d19      	adds	r1, r3, #4
 800aa6a:	6539      	str	r1, [r7, #80]	; 0x50
 800aa6c:	6812      	ldr	r2, [r2, #0]
 800aa6e:	601a      	str	r2, [r3, #0]
 800aa70:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa72:	3b01      	subs	r3, #1
 800aa74:	64fb      	str	r3, [r7, #76]	; 0x4c
 800aa76:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa78:	2b00      	cmp	r3, #0
 800aa7a:	d1f1      	bne.n	800aa60 <_tx_queue_receive+0x200>

                /* Determine if we are at the end.  */
                if (destination == queue_ptr -> tx_queue_end)
 800aa7c:	68fb      	ldr	r3, [r7, #12]
 800aa7e:	69db      	ldr	r3, [r3, #28]
 800aa80:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800aa82:	429a      	cmp	r2, r3
 800aa84:	d102      	bne.n	800aa8c <_tx_queue_receive+0x22c>
                {

                    /* Yes, wrap around to the beginning.  */
                    destination =  queue_ptr -> tx_queue_start;
 800aa86:	68fb      	ldr	r3, [r7, #12]
 800aa88:	699b      	ldr	r3, [r3, #24]
 800aa8a:	653b      	str	r3, [r7, #80]	; 0x50
                }

                /* Adjust the write pointer.  */
                queue_ptr -> tx_queue_write =  destination;
 800aa8c:	68fb      	ldr	r3, [r7, #12]
 800aa8e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800aa90:	625a      	str	r2, [r3, #36]	; 0x24

                /* Pickup thread pointer.  */
                thread_ptr =  queue_ptr -> tx_queue_suspension_list;
 800aa92:	68fb      	ldr	r3, [r7, #12]
 800aa94:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800aa96:	63fb      	str	r3, [r7, #60]	; 0x3c

                /* Message is now in the queue.  See if this is the only suspended thread
                   on the list.  */
                suspended_count--;
 800aa98:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800aa9a:	3b01      	subs	r3, #1
 800aa9c:	643b      	str	r3, [r7, #64]	; 0x40
                if (suspended_count == TX_NO_SUSPENSIONS)
 800aa9e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800aaa0:	2b00      	cmp	r3, #0
 800aaa2:	d103      	bne.n	800aaac <_tx_queue_receive+0x24c>
                {

                  /* Yes, the only suspended thread.  */

                    /* Update the head pointer.  */
                    queue_ptr -> tx_queue_suspension_list =  TX_NULL;
 800aaa4:	68fb      	ldr	r3, [r7, #12]
 800aaa6:	2200      	movs	r2, #0
 800aaa8:	629a      	str	r2, [r3, #40]	; 0x28
 800aaaa:	e00e      	b.n	800aaca <_tx_queue_receive+0x26a>
                {

                    /* At least one more thread is on the same expiration list.  */

                    /* Update the list head pointer.  */
                    next_thread =                            thread_ptr -> tx_thread_suspended_next;
 800aaac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800aaae:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800aab0:	63bb      	str	r3, [r7, #56]	; 0x38
                    queue_ptr -> tx_queue_suspension_list =  next_thread;
 800aab2:	68fb      	ldr	r3, [r7, #12]
 800aab4:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800aab6:	629a      	str	r2, [r3, #40]	; 0x28

                    /* Update the links of the adjacent threads.  */
                    previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 800aab8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800aaba:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800aabc:	637b      	str	r3, [r7, #52]	; 0x34
                    next_thread -> tx_thread_suspended_previous =   previous_thread;
 800aabe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800aac0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800aac2:	675a      	str	r2, [r3, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =   next_thread;
 800aac4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800aac6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800aac8:	671a      	str	r2, [r3, #112]	; 0x70
                }

                /* Decrement the suspension count.  */
                queue_ptr -> tx_queue_suspended_count =  suspended_count;
 800aaca:	68fb      	ldr	r3, [r7, #12]
 800aacc:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800aace:	62da      	str	r2, [r3, #44]	; 0x2c

                /* Prepare for resumption of the first thread.  */

                /* Clear cleanup routine to avoid timeout.  */
                thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800aad0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800aad2:	2200      	movs	r2, #0
 800aad4:	669a      	str	r2, [r3, #104]	; 0x68

                /* Put return status into the thread control block.  */
                thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 800aad6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800aad8:	2200      	movs	r2, #0
 800aada:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
 800aade:	4b41      	ldr	r3, [pc, #260]	; (800abe4 <_tx_queue_receive+0x384>)
 800aae0:	681b      	ldr	r3, [r3, #0]
 800aae2:	3301      	adds	r3, #1
 800aae4:	4a3f      	ldr	r2, [pc, #252]	; (800abe4 <_tx_queue_receive+0x384>)
 800aae6:	6013      	str	r3, [r2, #0]
 800aae8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800aaea:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800aaec:	6a3b      	ldr	r3, [r7, #32]
 800aaee:	f383 8810 	msr	PRIMASK, r3
}
 800aaf2:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Resume thread.  */
                _tx_thread_system_resume(thread_ptr);
 800aaf4:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800aaf6:	f001 fc99 	bl	800c42c <_tx_thread_system_resume>
 800aafa:	e06d      	b.n	800abd8 <_tx_queue_receive+0x378>
            }
        }
    }

    /* Determine if the request specifies suspension.  */
    else if (wait_option != TX_NO_WAIT)
 800aafc:	687b      	ldr	r3, [r7, #4]
 800aafe:	2b00      	cmp	r3, #0
 800ab00:	d062      	beq.n	800abc8 <_tx_queue_receive+0x368>
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
 800ab02:	4b38      	ldr	r3, [pc, #224]	; (800abe4 <_tx_queue_receive+0x384>)
 800ab04:	681b      	ldr	r3, [r3, #0]
 800ab06:	2b00      	cmp	r3, #0
 800ab08:	d008      	beq.n	800ab1c <_tx_queue_receive+0x2bc>
 800ab0a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ab0c:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ab0e:	69fb      	ldr	r3, [r7, #28]
 800ab10:	f383 8810 	msr	PRIMASK, r3
}
 800ab14:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
            status =  TX_QUEUE_EMPTY;
 800ab16:	230a      	movs	r3, #10
 800ab18:	64bb      	str	r3, [r7, #72]	; 0x48
 800ab1a:	e05d      	b.n	800abd8 <_tx_queue_receive+0x378>
            /* Increment the number of empty suspensions on this queue.  */
            queue_ptr -> tx_queue_performance_empty_suspension_count++;
#endif

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 800ab1c:	4b32      	ldr	r3, [pc, #200]	; (800abe8 <_tx_queue_receive+0x388>)
 800ab1e:	681b      	ldr	r3, [r3, #0]
 800ab20:	63fb      	str	r3, [r7, #60]	; 0x3c

            /* Setup cleanup routine pointer.  */
            thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_queue_cleanup);
 800ab22:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ab24:	4a31      	ldr	r2, [pc, #196]	; (800abec <_tx_queue_receive+0x38c>)
 800ab26:	669a      	str	r2, [r3, #104]	; 0x68

            /* Setup cleanup information, i.e. this queue control
               block and the source pointer.  */
            thread_ptr -> tx_thread_suspend_control_block =    (VOID *) queue_ptr;
 800ab28:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ab2a:	68fa      	ldr	r2, [r7, #12]
 800ab2c:	66da      	str	r2, [r3, #108]	; 0x6c
            thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) destination_ptr;
 800ab2e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ab30:	68ba      	ldr	r2, [r7, #8]
 800ab32:	67da      	str	r2, [r3, #124]	; 0x7c
            thread_ptr -> tx_thread_suspend_option =           TX_FALSE;
 800ab34:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ab36:	2200      	movs	r2, #0
 800ab38:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

#ifndef TX_NOT_INTERRUPTABLE

            /* Increment the suspension sequence number, which is used to identify
               this suspension event.  */
            thread_ptr -> tx_thread_suspension_sequence++;
 800ab3c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ab3e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 800ab42:	1c5a      	adds	r2, r3, #1
 800ab44:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ab46:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
#endif

            /* Setup suspension list.  */
            if (suspended_count == TX_NO_SUSPENSIONS)
 800ab4a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ab4c:	2b00      	cmp	r3, #0
 800ab4e:	d109      	bne.n	800ab64 <_tx_queue_receive+0x304>
            {

                /* No other threads are suspended.  Setup the head pointer and
                   just setup this threads pointers to itself.  */
                queue_ptr -> tx_queue_suspension_list =         thread_ptr;
 800ab50:	68fb      	ldr	r3, [r7, #12]
 800ab52:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800ab54:	629a      	str	r2, [r3, #40]	; 0x28
                thread_ptr -> tx_thread_suspended_next =        thread_ptr;
 800ab56:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ab58:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800ab5a:	671a      	str	r2, [r3, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
 800ab5c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ab5e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800ab60:	675a      	str	r2, [r3, #116]	; 0x74
 800ab62:	e011      	b.n	800ab88 <_tx_queue_receive+0x328>
            }
            else
            {

                /* This list is not NULL, add current thread to the end. */
                next_thread =                                   queue_ptr -> tx_queue_suspension_list;
 800ab64:	68fb      	ldr	r3, [r7, #12]
 800ab66:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ab68:	63bb      	str	r3, [r7, #56]	; 0x38
                thread_ptr -> tx_thread_suspended_next =        next_thread;
 800ab6a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ab6c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800ab6e:	671a      	str	r2, [r3, #112]	; 0x70
                previous_thread =                               next_thread -> tx_thread_suspended_previous;
 800ab70:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ab72:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800ab74:	637b      	str	r3, [r7, #52]	; 0x34
                thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 800ab76:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ab78:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800ab7a:	675a      	str	r2, [r3, #116]	; 0x74
                previous_thread -> tx_thread_suspended_next =   thread_ptr;
 800ab7c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ab7e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800ab80:	671a      	str	r2, [r3, #112]	; 0x70
                next_thread -> tx_thread_suspended_previous =   thread_ptr;
 800ab82:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ab84:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800ab86:	675a      	str	r2, [r3, #116]	; 0x74
            }

            /* Increment the suspended thread count.  */
            queue_ptr -> tx_queue_suspended_count =  suspended_count + ((UINT) 1);
 800ab88:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ab8a:	1c5a      	adds	r2, r3, #1
 800ab8c:	68fb      	ldr	r3, [r7, #12]
 800ab8e:	62da      	str	r2, [r3, #44]	; 0x2c

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_QUEUE_SUSP;
 800ab90:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ab92:	2205      	movs	r2, #5
 800ab94:	631a      	str	r2, [r3, #48]	; 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800ab96:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ab98:	2201      	movs	r2, #1
 800ab9a:	639a      	str	r2, [r3, #56]	; 0x38

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 800ab9c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ab9e:	687a      	ldr	r2, [r7, #4]
 800aba0:	64da      	str	r2, [r3, #76]	; 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800aba2:	4b10      	ldr	r3, [pc, #64]	; (800abe4 <_tx_queue_receive+0x384>)
 800aba4:	681b      	ldr	r3, [r3, #0]
 800aba6:	3301      	adds	r3, #1
 800aba8:	4a0e      	ldr	r2, [pc, #56]	; (800abe4 <_tx_queue_receive+0x384>)
 800abaa:	6013      	str	r3, [r2, #0]
 800abac:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800abae:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800abb0:	69bb      	ldr	r3, [r7, #24]
 800abb2:	f383 8810 	msr	PRIMASK, r3
}
 800abb6:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
 800abb8:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800abba:	f001 fd4b 	bl	800c654 <_tx_thread_system_suspend>
#endif

            /* Return the completion status.  */
            status =  thread_ptr -> tx_thread_suspend_status;
 800abbe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800abc0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800abc4:	64bb      	str	r3, [r7, #72]	; 0x48
 800abc6:	e007      	b.n	800abd8 <_tx_queue_receive+0x378>
 800abc8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800abca:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800abcc:	697b      	ldr	r3, [r7, #20]
 800abce:	f383 8810 	msr	PRIMASK, r3
}
 800abd2:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Immediate return, return error completion.  */
        status =  TX_QUEUE_EMPTY;
 800abd4:	230a      	movs	r3, #10
 800abd6:	64bb      	str	r3, [r7, #72]	; 0x48
    }

    /* Return completion status.  */
    return(status);
 800abd8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
}
 800abda:	4618      	mov	r0, r3
 800abdc:	3758      	adds	r7, #88	; 0x58
 800abde:	46bd      	mov	sp, r7
 800abe0:	bd80      	pop	{r7, pc}
 800abe2:	bf00      	nop
 800abe4:	2000f054 	.word	0x2000f054
 800abe8:	2000efb8 	.word	0x2000efb8
 800abec:	08009ea9 	.word	0x08009ea9

0800abf0 <_tx_queue_send>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_send(TX_QUEUE *queue_ptr, VOID *source_ptr, ULONG wait_option)
{
 800abf0:	b580      	push	{r7, lr}
 800abf2:	b096      	sub	sp, #88	; 0x58
 800abf4:	af00      	add	r7, sp, #0
 800abf6:	60f8      	str	r0, [r7, #12]
 800abf8:	60b9      	str	r1, [r7, #8]
 800abfa:	607a      	str	r2, [r7, #4]
VOID            (*queue_send_notify)(struct TX_QUEUE_STRUCT *notify_queue_ptr);
#endif


    /* Default the status to TX_SUCCESS.  */
    status =  TX_SUCCESS;
 800abfc:	2300      	movs	r3, #0
 800abfe:	64bb      	str	r3, [r7, #72]	; 0x48
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800ac00:	f3ef 8310 	mrs	r3, PRIMASK
 800ac04:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800ac06:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800ac08:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800ac0a:	b672      	cpsid	i
    return(int_posture);
 800ac0c:	6abb      	ldr	r3, [r7, #40]	; 0x28

    /* Disable interrupts to place message in the queue.  */
    TX_DISABLE
 800ac0e:	647b      	str	r3, [r7, #68]	; 0x44

    /* Log this kernel call.  */
    TX_EL_QUEUE_SEND_INSERT

    /* Pickup the thread suspension count.  */
    suspended_count =  queue_ptr -> tx_queue_suspended_count;
 800ac10:	68fb      	ldr	r3, [r7, #12]
 800ac12:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ac14:	643b      	str	r3, [r7, #64]	; 0x40

    /* Determine if there is room in the queue.  */
    if (queue_ptr -> tx_queue_available_storage != TX_NO_MESSAGES)
 800ac16:	68fb      	ldr	r3, [r7, #12]
 800ac18:	695b      	ldr	r3, [r3, #20]
 800ac1a:	2b00      	cmp	r3, #0
 800ac1c:	f000 80af 	beq.w	800ad7e <_tx_queue_send+0x18e>
    {

        /* There is room for the message in the queue.  */

        /* Determine if there are suspended on this queue.  */
        if (suspended_count == TX_NO_SUSPENSIONS)
 800ac20:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ac22:	2b00      	cmp	r3, #0
 800ac24:	d147      	bne.n	800acb6 <_tx_queue_send+0xc6>
        {

            /* No suspended threads, simply place the message in the queue.  */

            /* Reduce the amount of available storage.  */
            queue_ptr -> tx_queue_available_storage--;
 800ac26:	68fb      	ldr	r3, [r7, #12]
 800ac28:	695b      	ldr	r3, [r3, #20]
 800ac2a:	1e5a      	subs	r2, r3, #1
 800ac2c:	68fb      	ldr	r3, [r7, #12]
 800ac2e:	615a      	str	r2, [r3, #20]

            /* Increase the enqueued count.  */
            queue_ptr -> tx_queue_enqueued++;
 800ac30:	68fb      	ldr	r3, [r7, #12]
 800ac32:	691b      	ldr	r3, [r3, #16]
 800ac34:	1c5a      	adds	r2, r3, #1
 800ac36:	68fb      	ldr	r3, [r7, #12]
 800ac38:	611a      	str	r2, [r3, #16]

            /* Setup source and destination pointers.  */
            source =       TX_VOID_TO_ULONG_POINTER_CONVERT(source_ptr);
 800ac3a:	68bb      	ldr	r3, [r7, #8]
 800ac3c:	657b      	str	r3, [r7, #84]	; 0x54
            destination =  queue_ptr -> tx_queue_write;
 800ac3e:	68fb      	ldr	r3, [r7, #12]
 800ac40:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ac42:	653b      	str	r3, [r7, #80]	; 0x50
            size =         queue_ptr -> tx_queue_message_size;
 800ac44:	68fb      	ldr	r3, [r7, #12]
 800ac46:	689b      	ldr	r3, [r3, #8]
 800ac48:	64fb      	str	r3, [r7, #76]	; 0x4c

            /* Copy message. Note that the source and destination pointers are
               incremented by the macro.  */
            TX_QUEUE_MESSAGE_COPY(source, destination, size)
 800ac4a:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800ac4c:	1d13      	adds	r3, r2, #4
 800ac4e:	657b      	str	r3, [r7, #84]	; 0x54
 800ac50:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ac52:	1d19      	adds	r1, r3, #4
 800ac54:	6539      	str	r1, [r7, #80]	; 0x50
 800ac56:	6812      	ldr	r2, [r2, #0]
 800ac58:	601a      	str	r2, [r3, #0]
 800ac5a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ac5c:	2b01      	cmp	r3, #1
 800ac5e:	d90e      	bls.n	800ac7e <_tx_queue_send+0x8e>
 800ac60:	e007      	b.n	800ac72 <_tx_queue_send+0x82>
 800ac62:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800ac64:	1d13      	adds	r3, r2, #4
 800ac66:	657b      	str	r3, [r7, #84]	; 0x54
 800ac68:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ac6a:	1d19      	adds	r1, r3, #4
 800ac6c:	6539      	str	r1, [r7, #80]	; 0x50
 800ac6e:	6812      	ldr	r2, [r2, #0]
 800ac70:	601a      	str	r2, [r3, #0]
 800ac72:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ac74:	3b01      	subs	r3, #1
 800ac76:	64fb      	str	r3, [r7, #76]	; 0x4c
 800ac78:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ac7a:	2b00      	cmp	r3, #0
 800ac7c:	d1f1      	bne.n	800ac62 <_tx_queue_send+0x72>

            /* Determine if we are at the end.  */
            if (destination == queue_ptr -> tx_queue_end)
 800ac7e:	68fb      	ldr	r3, [r7, #12]
 800ac80:	69db      	ldr	r3, [r3, #28]
 800ac82:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800ac84:	429a      	cmp	r2, r3
 800ac86:	d102      	bne.n	800ac8e <_tx_queue_send+0x9e>
            {

                /* Yes, wrap around to the beginning.  */
                destination =  queue_ptr -> tx_queue_start;
 800ac88:	68fb      	ldr	r3, [r7, #12]
 800ac8a:	699b      	ldr	r3, [r3, #24]
 800ac8c:	653b      	str	r3, [r7, #80]	; 0x50
            }

            /* Adjust the write pointer.  */
            queue_ptr -> tx_queue_write =  destination;
 800ac8e:	68fb      	ldr	r3, [r7, #12]
 800ac90:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800ac92:	625a      	str	r2, [r3, #36]	; 0x24

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Pickup the notify callback routine for this queue.  */
            queue_send_notify =  queue_ptr -> tx_queue_send_notify;
 800ac94:	68fb      	ldr	r3, [r7, #12]
 800ac96:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ac98:	633b      	str	r3, [r7, #48]	; 0x30
 800ac9a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ac9c:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ac9e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800aca0:	f383 8810 	msr	PRIMASK, r3
}
 800aca4:	bf00      	nop
            TX_RESTORE

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Determine if a notify callback is required.  */
            if (queue_send_notify != TX_NULL)
 800aca6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800aca8:	2b00      	cmp	r3, #0
 800acaa:	f000 80e4 	beq.w	800ae76 <_tx_queue_send+0x286>
            {

                /* Call application queue send notification.  */
                (queue_send_notify)(queue_ptr);
 800acae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800acb0:	68f8      	ldr	r0, [r7, #12]
 800acb2:	4798      	blx	r3
 800acb4:	e0df      	b.n	800ae76 <_tx_queue_send+0x286>
            /* There is a thread suspended on an empty queue. Simply
               copy the message to the suspended thread's destination
               pointer.  */

            /* Pickup the head of the suspension list.  */
            thread_ptr =  queue_ptr -> tx_queue_suspension_list;
 800acb6:	68fb      	ldr	r3, [r7, #12]
 800acb8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800acba:	63fb      	str	r3, [r7, #60]	; 0x3c

            /* See if this is the only suspended thread on the list.  */
            suspended_count--;
 800acbc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800acbe:	3b01      	subs	r3, #1
 800acc0:	643b      	str	r3, [r7, #64]	; 0x40
            if (suspended_count == TX_NO_SUSPENSIONS)
 800acc2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800acc4:	2b00      	cmp	r3, #0
 800acc6:	d103      	bne.n	800acd0 <_tx_queue_send+0xe0>
            {

                /* Yes, the only suspended thread.  */

                /* Update the head pointer.  */
                queue_ptr -> tx_queue_suspension_list =  TX_NULL;
 800acc8:	68fb      	ldr	r3, [r7, #12]
 800acca:	2200      	movs	r2, #0
 800accc:	629a      	str	r2, [r3, #40]	; 0x28
 800acce:	e012      	b.n	800acf6 <_tx_queue_send+0x106>
            {

                /* At least one more thread is on the same expiration list.  */

                /* Update the list head pointer.  */
                queue_ptr -> tx_queue_suspension_list =  thread_ptr -> tx_thread_suspended_next;
 800acd0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800acd2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800acd4:	68fb      	ldr	r3, [r7, #12]
 800acd6:	629a      	str	r2, [r3, #40]	; 0x28

                /* Update the links of the adjacent threads.  */
                next_thread =                            thread_ptr -> tx_thread_suspended_next;
 800acd8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800acda:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800acdc:	63bb      	str	r3, [r7, #56]	; 0x38
                queue_ptr -> tx_queue_suspension_list =  next_thread;
 800acde:	68fb      	ldr	r3, [r7, #12]
 800ace0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800ace2:	629a      	str	r2, [r3, #40]	; 0x28

                /* Update the links of the adjacent threads.  */
                previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 800ace4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ace6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800ace8:	637b      	str	r3, [r7, #52]	; 0x34
                next_thread -> tx_thread_suspended_previous =   previous_thread;
 800acea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800acec:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800acee:	675a      	str	r2, [r3, #116]	; 0x74
                previous_thread -> tx_thread_suspended_next =   next_thread;
 800acf0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800acf2:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800acf4:	671a      	str	r2, [r3, #112]	; 0x70
            }

            /* Decrement the suspension count.  */
            queue_ptr -> tx_queue_suspended_count =  suspended_count;
 800acf6:	68fb      	ldr	r3, [r7, #12]
 800acf8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800acfa:	62da      	str	r2, [r3, #44]	; 0x2c

            /* Prepare for resumption of the thread.  */

            /* Clear cleanup routine to avoid timeout.  */
            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800acfc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800acfe:	2200      	movs	r2, #0
 800ad00:	669a      	str	r2, [r3, #104]	; 0x68

            /* Setup source and destination pointers.  */
            source =       TX_VOID_TO_ULONG_POINTER_CONVERT(source_ptr);
 800ad02:	68bb      	ldr	r3, [r7, #8]
 800ad04:	657b      	str	r3, [r7, #84]	; 0x54
            destination =  TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
 800ad06:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ad08:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800ad0a:	653b      	str	r3, [r7, #80]	; 0x50
            size =         queue_ptr -> tx_queue_message_size;
 800ad0c:	68fb      	ldr	r3, [r7, #12]
 800ad0e:	689b      	ldr	r3, [r3, #8]
 800ad10:	64fb      	str	r3, [r7, #76]	; 0x4c

            /* Copy message. Note that the source and destination pointers are
               incremented by the macro.  */
            TX_QUEUE_MESSAGE_COPY(source, destination, size)
 800ad12:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800ad14:	1d13      	adds	r3, r2, #4
 800ad16:	657b      	str	r3, [r7, #84]	; 0x54
 800ad18:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ad1a:	1d19      	adds	r1, r3, #4
 800ad1c:	6539      	str	r1, [r7, #80]	; 0x50
 800ad1e:	6812      	ldr	r2, [r2, #0]
 800ad20:	601a      	str	r2, [r3, #0]
 800ad22:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ad24:	2b01      	cmp	r3, #1
 800ad26:	d90e      	bls.n	800ad46 <_tx_queue_send+0x156>
 800ad28:	e007      	b.n	800ad3a <_tx_queue_send+0x14a>
 800ad2a:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800ad2c:	1d13      	adds	r3, r2, #4
 800ad2e:	657b      	str	r3, [r7, #84]	; 0x54
 800ad30:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ad32:	1d19      	adds	r1, r3, #4
 800ad34:	6539      	str	r1, [r7, #80]	; 0x50
 800ad36:	6812      	ldr	r2, [r2, #0]
 800ad38:	601a      	str	r2, [r3, #0]
 800ad3a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ad3c:	3b01      	subs	r3, #1
 800ad3e:	64fb      	str	r3, [r7, #76]	; 0x4c
 800ad40:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ad42:	2b00      	cmp	r3, #0
 800ad44:	d1f1      	bne.n	800ad2a <_tx_queue_send+0x13a>

            /* Put return status into the thread control block.  */
            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 800ad46:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ad48:	2200      	movs	r2, #0
 800ad4a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Pickup the notify callback routine for this queue.  */
            queue_send_notify =  queue_ptr -> tx_queue_send_notify;
 800ad4e:	68fb      	ldr	r3, [r7, #12]
 800ad50:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ad52:	633b      	str	r3, [r7, #48]	; 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800ad54:	4b4a      	ldr	r3, [pc, #296]	; (800ae80 <_tx_queue_send+0x290>)
 800ad56:	681b      	ldr	r3, [r3, #0]
 800ad58:	3301      	adds	r3, #1
 800ad5a:	4a49      	ldr	r2, [pc, #292]	; (800ae80 <_tx_queue_send+0x290>)
 800ad5c:	6013      	str	r3, [r2, #0]
 800ad5e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ad60:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ad62:	6a3b      	ldr	r3, [r7, #32]
 800ad64:	f383 8810 	msr	PRIMASK, r3
}
 800ad68:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Resume thread.  */
            _tx_thread_system_resume(thread_ptr);
 800ad6a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800ad6c:	f001 fb5e 	bl	800c42c <_tx_thread_system_resume>
#endif

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Determine if a notify callback is required.  */
            if (queue_send_notify != TX_NULL)
 800ad70:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ad72:	2b00      	cmp	r3, #0
 800ad74:	d07f      	beq.n	800ae76 <_tx_queue_send+0x286>
            {

                /* Call application queue send notification.  */
                (queue_send_notify)(queue_ptr);
 800ad76:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ad78:	68f8      	ldr	r0, [r7, #12]
 800ad7a:	4798      	blx	r3
 800ad7c:	e07b      	b.n	800ae76 <_tx_queue_send+0x286>
#endif
        }
    }

    /* At this point, the queue is full. Determine if suspension is requested.  */
    else if (wait_option != TX_NO_WAIT)
 800ad7e:	687b      	ldr	r3, [r7, #4]
 800ad80:	2b00      	cmp	r3, #0
 800ad82:	d070      	beq.n	800ae66 <_tx_queue_send+0x276>
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
 800ad84:	4b3e      	ldr	r3, [pc, #248]	; (800ae80 <_tx_queue_send+0x290>)
 800ad86:	681b      	ldr	r3, [r3, #0]
 800ad88:	2b00      	cmp	r3, #0
 800ad8a:	d008      	beq.n	800ad9e <_tx_queue_send+0x1ae>
 800ad8c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ad8e:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ad90:	69fb      	ldr	r3, [r7, #28]
 800ad92:	f383 8810 	msr	PRIMASK, r3
}
 800ad96:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
            status =  TX_QUEUE_FULL;
 800ad98:	230b      	movs	r3, #11
 800ad9a:	64bb      	str	r3, [r7, #72]	; 0x48
 800ad9c:	e06b      	b.n	800ae76 <_tx_queue_send+0x286>
            /* Increment the number of full suspensions on this queue.  */
            queue_ptr -> tx_queue_performance_full_suspension_count++;
#endif

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 800ad9e:	4b39      	ldr	r3, [pc, #228]	; (800ae84 <_tx_queue_send+0x294>)
 800ada0:	681b      	ldr	r3, [r3, #0]
 800ada2:	63fb      	str	r3, [r7, #60]	; 0x3c

            /* Setup cleanup routine pointer.  */
            thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_queue_cleanup);
 800ada4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ada6:	4a38      	ldr	r2, [pc, #224]	; (800ae88 <_tx_queue_send+0x298>)
 800ada8:	669a      	str	r2, [r3, #104]	; 0x68

            /* Setup cleanup information, i.e. this queue control
               block and the source pointer.  */
            thread_ptr -> tx_thread_suspend_control_block =    (VOID *) queue_ptr;
 800adaa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800adac:	68fa      	ldr	r2, [r7, #12]
 800adae:	66da      	str	r2, [r3, #108]	; 0x6c
            thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) source_ptr;
 800adb0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800adb2:	68ba      	ldr	r2, [r7, #8]
 800adb4:	67da      	str	r2, [r3, #124]	; 0x7c
            thread_ptr -> tx_thread_suspend_option =           TX_FALSE;
 800adb6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800adb8:	2200      	movs	r2, #0
 800adba:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

#ifndef TX_NOT_INTERRUPTABLE

            /* Increment the suspension sequence number, which is used to identify
               this suspension event.  */
            thread_ptr -> tx_thread_suspension_sequence++;
 800adbe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800adc0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 800adc4:	1c5a      	adds	r2, r3, #1
 800adc6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800adc8:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
#endif

            /* Setup suspension list.  */
            if (suspended_count == TX_NO_SUSPENSIONS)
 800adcc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800adce:	2b00      	cmp	r3, #0
 800add0:	d109      	bne.n	800ade6 <_tx_queue_send+0x1f6>
            {

                /* No other threads are suspended.  Setup the head pointer and
                   just setup this threads pointers to itself.  */
                queue_ptr -> tx_queue_suspension_list =         thread_ptr;
 800add2:	68fb      	ldr	r3, [r7, #12]
 800add4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800add6:	629a      	str	r2, [r3, #40]	; 0x28
                thread_ptr -> tx_thread_suspended_next =        thread_ptr;
 800add8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800adda:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800addc:	671a      	str	r2, [r3, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
 800adde:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ade0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800ade2:	675a      	str	r2, [r3, #116]	; 0x74
 800ade4:	e011      	b.n	800ae0a <_tx_queue_send+0x21a>
            }
            else
            {

                /* This list is not NULL, add current thread to the end. */
                next_thread =                                   queue_ptr -> tx_queue_suspension_list;
 800ade6:	68fb      	ldr	r3, [r7, #12]
 800ade8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800adea:	63bb      	str	r3, [r7, #56]	; 0x38
                thread_ptr -> tx_thread_suspended_next =        next_thread;
 800adec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800adee:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800adf0:	671a      	str	r2, [r3, #112]	; 0x70
                previous_thread =                               next_thread -> tx_thread_suspended_previous;
 800adf2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800adf4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800adf6:	637b      	str	r3, [r7, #52]	; 0x34
                thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 800adf8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800adfa:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800adfc:	675a      	str	r2, [r3, #116]	; 0x74
                previous_thread -> tx_thread_suspended_next =   thread_ptr;
 800adfe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ae00:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800ae02:	671a      	str	r2, [r3, #112]	; 0x70
                next_thread -> tx_thread_suspended_previous =   thread_ptr;
 800ae04:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ae06:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800ae08:	675a      	str	r2, [r3, #116]	; 0x74
            }

            /* Increment the suspended thread count.  */
            queue_ptr -> tx_queue_suspended_count =  suspended_count + ((UINT) 1);
 800ae0a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ae0c:	1c5a      	adds	r2, r3, #1
 800ae0e:	68fb      	ldr	r3, [r7, #12]
 800ae10:	62da      	str	r2, [r3, #44]	; 0x2c

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_QUEUE_SUSP;
 800ae12:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ae14:	2205      	movs	r2, #5
 800ae16:	631a      	str	r2, [r3, #48]	; 0x30

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Pickup the notify callback routine for this queue.  */
            queue_send_notify =  queue_ptr -> tx_queue_send_notify;
 800ae18:	68fb      	ldr	r3, [r7, #12]
 800ae1a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ae1c:	633b      	str	r3, [r7, #48]	; 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800ae1e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ae20:	2201      	movs	r2, #1
 800ae22:	639a      	str	r2, [r3, #56]	; 0x38

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 800ae24:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ae26:	687a      	ldr	r2, [r7, #4]
 800ae28:	64da      	str	r2, [r3, #76]	; 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800ae2a:	4b15      	ldr	r3, [pc, #84]	; (800ae80 <_tx_queue_send+0x290>)
 800ae2c:	681b      	ldr	r3, [r3, #0]
 800ae2e:	3301      	adds	r3, #1
 800ae30:	4a13      	ldr	r2, [pc, #76]	; (800ae80 <_tx_queue_send+0x290>)
 800ae32:	6013      	str	r3, [r2, #0]
 800ae34:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ae36:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ae38:	69bb      	ldr	r3, [r7, #24]
 800ae3a:	f383 8810 	msr	PRIMASK, r3
}
 800ae3e:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
 800ae40:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800ae42:	f001 fc07 	bl	800c654 <_tx_thread_system_suspend>
#endif

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Determine if a notify callback is required.  */
            if (thread_ptr -> tx_thread_suspend_status == TX_SUCCESS)
 800ae46:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ae48:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800ae4c:	2b00      	cmp	r3, #0
 800ae4e:	d105      	bne.n	800ae5c <_tx_queue_send+0x26c>
            {

                /* Determine if there is a notify callback.  */
                if (queue_send_notify != TX_NULL)
 800ae50:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ae52:	2b00      	cmp	r3, #0
 800ae54:	d002      	beq.n	800ae5c <_tx_queue_send+0x26c>
                {

                    /* Call application queue send notification.  */
                    (queue_send_notify)(queue_ptr);
 800ae56:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ae58:	68f8      	ldr	r0, [r7, #12]
 800ae5a:	4798      	blx	r3
                }
            }
#endif

            /* Return the completion status.  */
            status =  thread_ptr -> tx_thread_suspend_status;
 800ae5c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ae5e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800ae62:	64bb      	str	r3, [r7, #72]	; 0x48
 800ae64:	e007      	b.n	800ae76 <_tx_queue_send+0x286>
 800ae66:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ae68:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ae6a:	697b      	ldr	r3, [r7, #20]
 800ae6c:	f383 8810 	msr	PRIMASK, r3
}
 800ae70:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return error completion.  */
        status =  TX_QUEUE_FULL;
 800ae72:	230b      	movs	r3, #11
 800ae74:	64bb      	str	r3, [r7, #72]	; 0x48
    }

    /* Return completion status.  */
    return(status);
 800ae76:	6cbb      	ldr	r3, [r7, #72]	; 0x48
}
 800ae78:	4618      	mov	r0, r3
 800ae7a:	3758      	adds	r7, #88	; 0x58
 800ae7c:	46bd      	mov	sp, r7
 800ae7e:	bd80      	pop	{r7, pc}
 800ae80:	2000f054 	.word	0x2000f054
 800ae84:	2000efb8 	.word	0x2000efb8
 800ae88:	08009ea9 	.word	0x08009ea9

0800ae8c <_tx_queue_send_notify>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_send_notify(TX_QUEUE *queue_ptr, VOID (*queue_send_notify)(TX_QUEUE *notify_queue_ptr))
{
 800ae8c:	b480      	push	{r7}
 800ae8e:	b087      	sub	sp, #28
 800ae90:	af00      	add	r7, sp, #0
 800ae92:	6078      	str	r0, [r7, #4]
 800ae94:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800ae96:	f3ef 8310 	mrs	r3, PRIMASK
 800ae9a:	60fb      	str	r3, [r7, #12]
    return(posture);
 800ae9c:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 800ae9e:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 800aea0:	b672      	cpsid	i
    return(int_posture);
 800aea2:	68bb      	ldr	r3, [r7, #8]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts.  */
    TX_DISABLE
 800aea4:	617b      	str	r3, [r7, #20]

    /* Make entry in event log.  */
    TX_EL_QUEUE_SEND_NOTIFY_INSERT

    /* Setup queue send notification callback function.  */
    queue_ptr -> tx_queue_send_notify =  queue_send_notify;
 800aea6:	687b      	ldr	r3, [r7, #4]
 800aea8:	683a      	ldr	r2, [r7, #0]
 800aeaa:	639a      	str	r2, [r3, #56]	; 0x38
 800aeac:	697b      	ldr	r3, [r7, #20]
 800aeae:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800aeb0:	693b      	ldr	r3, [r7, #16]
 800aeb2:	f383 8810 	msr	PRIMASK, r3
}
 800aeb6:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return success to caller.  */
    return(TX_SUCCESS);
 800aeb8:	2300      	movs	r3, #0
#endif
}
 800aeba:	4618      	mov	r0, r3
 800aebc:	371c      	adds	r7, #28
 800aebe:	46bd      	mov	sp, r7
 800aec0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aec4:	4770      	bx	lr
	...

0800aec8 <_tx_semaphore_ceiling_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_ceiling_put(TX_SEMAPHORE *semaphore_ptr, ULONG ceiling)
{
 800aec8:	b580      	push	{r7, lr}
 800aeca:	b08e      	sub	sp, #56	; 0x38
 800aecc:	af00      	add	r7, sp, #0
 800aece:	6078      	str	r0, [r7, #4]
 800aed0:	6039      	str	r1, [r7, #0]
TX_THREAD       *previous_thread;
UINT            status;


    /* Default the status to TX_SUCCESS.  */
    status =  TX_SUCCESS;
 800aed2:	2300      	movs	r3, #0
 800aed4:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800aed6:	f3ef 8310 	mrs	r3, PRIMASK
 800aeda:	61bb      	str	r3, [r7, #24]
    return(posture);
 800aedc:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800aede:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800aee0:	b672      	cpsid	i
    return(int_posture);
 800aee2:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to put an instance back to the semaphore.  */
    TX_DISABLE
 800aee4:	633b      	str	r3, [r7, #48]	; 0x30

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_CEILING_PUT_INSERT

    /* Pickup the number of suspended threads.  */
    suspended_count =  semaphore_ptr -> tx_semaphore_suspended_count;
 800aee6:	687b      	ldr	r3, [r7, #4]
 800aee8:	691b      	ldr	r3, [r3, #16]
 800aeea:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Determine if there are any threads suspended on the semaphore.  */
    if (suspended_count == TX_NO_SUSPENSIONS)
 800aeec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800aeee:	2b00      	cmp	r3, #0
 800aef0:	d124      	bne.n	800af3c <_tx_semaphore_ceiling_put+0x74>
    {

        /* Determine if the ceiling has been exceeded.  */
        if (semaphore_ptr -> tx_semaphore_count >= ceiling)
 800aef2:	687b      	ldr	r3, [r7, #4]
 800aef4:	689b      	ldr	r3, [r3, #8]
 800aef6:	683a      	ldr	r2, [r7, #0]
 800aef8:	429a      	cmp	r2, r3
 800aefa:	d808      	bhi.n	800af0e <_tx_semaphore_ceiling_put+0x46>
 800aefc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800aefe:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800af00:	693b      	ldr	r3, [r7, #16]
 800af02:	f383 8810 	msr	PRIMASK, r3
}
 800af06:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Return an error.  */
            status =  TX_CEILING_EXCEEDED;
 800af08:	2321      	movs	r3, #33	; 0x21
 800af0a:	637b      	str	r3, [r7, #52]	; 0x34
 800af0c:	e053      	b.n	800afb6 <_tx_semaphore_ceiling_put+0xee>
        }
        else
        {

            /* Increment the semaphore count.  */
            semaphore_ptr -> tx_semaphore_count++;
 800af0e:	687b      	ldr	r3, [r7, #4]
 800af10:	689b      	ldr	r3, [r3, #8]
 800af12:	1c5a      	adds	r2, r3, #1
 800af14:	687b      	ldr	r3, [r7, #4]
 800af16:	609a      	str	r2, [r3, #8]

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Pickup the application notify function.  */
            semaphore_put_notify =  semaphore_ptr -> tx_semaphore_put_notify;
 800af18:	687b      	ldr	r3, [r7, #4]
 800af1a:	69db      	ldr	r3, [r3, #28]
 800af1c:	61fb      	str	r3, [r7, #28]
 800af1e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800af20:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800af22:	68fb      	ldr	r3, [r7, #12]
 800af24:	f383 8810 	msr	PRIMASK, r3
}
 800af28:	bf00      	nop
            TX_RESTORE

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Determine if notification is required.  */
            if (semaphore_put_notify != TX_NULL)
 800af2a:	69fb      	ldr	r3, [r7, #28]
 800af2c:	2b00      	cmp	r3, #0
 800af2e:	d002      	beq.n	800af36 <_tx_semaphore_ceiling_put+0x6e>
            {

                /* Yes, call the appropriate notify callback function.  */
                (semaphore_put_notify)(semaphore_ptr);
 800af30:	69fb      	ldr	r3, [r7, #28]
 800af32:	6878      	ldr	r0, [r7, #4]
 800af34:	4798      	blx	r3
            }
#endif

            /* Return successful completion status.  */
            status =  TX_SUCCESS;
 800af36:	2300      	movs	r3, #0
 800af38:	637b      	str	r3, [r7, #52]	; 0x34
 800af3a:	e03c      	b.n	800afb6 <_tx_semaphore_ceiling_put+0xee>
    {

        /* Remove the suspended thread from the list.  */

        /* Pickup the pointer to the first suspended thread.  */
        thread_ptr =  semaphore_ptr -> tx_semaphore_suspension_list;
 800af3c:	687b      	ldr	r3, [r7, #4]
 800af3e:	68db      	ldr	r3, [r3, #12]
 800af40:	62bb      	str	r3, [r7, #40]	; 0x28

        /* See if this is the only suspended thread on the list.  */
        suspended_count--;
 800af42:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af44:	3b01      	subs	r3, #1
 800af46:	62fb      	str	r3, [r7, #44]	; 0x2c
        if (suspended_count == TX_NO_SUSPENSIONS)
 800af48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af4a:	2b00      	cmp	r3, #0
 800af4c:	d103      	bne.n	800af56 <_tx_semaphore_ceiling_put+0x8e>
        {

            /* Yes, the only suspended thread.  */

            /* Update the head pointer.  */
            semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
 800af4e:	687b      	ldr	r3, [r7, #4]
 800af50:	2200      	movs	r2, #0
 800af52:	60da      	str	r2, [r3, #12]
 800af54:	e00e      	b.n	800af74 <_tx_semaphore_ceiling_put+0xac>
        {

            /* At least one more thread is on the same expiration list.  */

            /* Update the list head pointer.  */
            next_thread =                                     thread_ptr -> tx_thread_suspended_next;
 800af56:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800af58:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800af5a:	627b      	str	r3, [r7, #36]	; 0x24
            semaphore_ptr -> tx_semaphore_suspension_list =   next_thread;
 800af5c:	687b      	ldr	r3, [r7, #4]
 800af5e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800af60:	60da      	str	r2, [r3, #12]

            /* Update the links of the adjacent threads.  */
            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 800af62:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800af64:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800af66:	623b      	str	r3, [r7, #32]
            next_thread -> tx_thread_suspended_previous =   previous_thread;
 800af68:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800af6a:	6a3a      	ldr	r2, [r7, #32]
 800af6c:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =   next_thread;
 800af6e:	6a3b      	ldr	r3, [r7, #32]
 800af70:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800af72:	671a      	str	r2, [r3, #112]	; 0x70
        }

        /* Decrement the suspension count.  */
        semaphore_ptr -> tx_semaphore_suspended_count =  suspended_count;
 800af74:	687b      	ldr	r3, [r7, #4]
 800af76:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800af78:	611a      	str	r2, [r3, #16]

        /* Prepare for resumption of the first thread.  */

        /* Clear cleanup routine to avoid timeout.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800af7a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800af7c:	2200      	movs	r2, #0
 800af7e:	669a      	str	r2, [r3, #104]	; 0x68

        /* Put return status into the thread control block.  */
        thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 800af80:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800af82:	2200      	movs	r2, #0
 800af84:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Pickup the application notify function.  */
        semaphore_put_notify =  semaphore_ptr -> tx_semaphore_put_notify;
 800af88:	687b      	ldr	r3, [r7, #4]
 800af8a:	69db      	ldr	r3, [r3, #28]
 800af8c:	61fb      	str	r3, [r7, #28]
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption.  */
        _tx_thread_preempt_disable++;
 800af8e:	4b0c      	ldr	r3, [pc, #48]	; (800afc0 <_tx_semaphore_ceiling_put+0xf8>)
 800af90:	681b      	ldr	r3, [r3, #0]
 800af92:	3301      	adds	r3, #1
 800af94:	4a0a      	ldr	r2, [pc, #40]	; (800afc0 <_tx_semaphore_ceiling_put+0xf8>)
 800af96:	6013      	str	r3, [r2, #0]
 800af98:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800af9a:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800af9c:	68bb      	ldr	r3, [r7, #8]
 800af9e:	f383 8810 	msr	PRIMASK, r3
}
 800afa2:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume thread.  */
        _tx_thread_system_resume(thread_ptr);
 800afa4:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800afa6:	f001 fa41 	bl	800c42c <_tx_thread_system_resume>
#endif

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Determine if notification is required.  */
        if (semaphore_put_notify != TX_NULL)
 800afaa:	69fb      	ldr	r3, [r7, #28]
 800afac:	2b00      	cmp	r3, #0
 800afae:	d002      	beq.n	800afb6 <_tx_semaphore_ceiling_put+0xee>
        {

            /* Yes, call the appropriate notify callback function.  */
            (semaphore_put_notify)(semaphore_ptr);
 800afb0:	69fb      	ldr	r3, [r7, #28]
 800afb2:	6878      	ldr	r0, [r7, #4]
 800afb4:	4798      	blx	r3
        }
#endif
    }

    /* Return successful completion.  */
    return(status);
 800afb6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 800afb8:	4618      	mov	r0, r3
 800afba:	3738      	adds	r7, #56	; 0x38
 800afbc:	46bd      	mov	sp, r7
 800afbe:	bd80      	pop	{r7, pc}
 800afc0:	2000f054 	.word	0x2000f054

0800afc4 <_tx_semaphore_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_semaphore_cleanup(TX_THREAD *thread_ptr, ULONG suspension_sequence)
{
 800afc4:	b580      	push	{r7, lr}
 800afc6:	b08e      	sub	sp, #56	; 0x38
 800afc8:	af00      	add	r7, sp, #0
 800afca:	6078      	str	r0, [r7, #4]
 800afcc:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800afce:	f3ef 8310 	mrs	r3, PRIMASK
 800afd2:	623b      	str	r3, [r7, #32]
    return(posture);
 800afd4:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 800afd6:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 800afd8:	b672      	cpsid	i
    return(int_posture);
 800afda:	69fb      	ldr	r3, [r7, #28]


#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the semaphore.  */
    TX_DISABLE
 800afdc:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_semaphore_cleanup))
 800afde:	687b      	ldr	r3, [r7, #4]
 800afe0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800afe2:	4a33      	ldr	r2, [pc, #204]	; (800b0b0 <_tx_semaphore_cleanup+0xec>)
 800afe4:	4293      	cmp	r3, r2
 800afe6:	d158      	bne.n	800b09a <_tx_semaphore_cleanup+0xd6>
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
 800afe8:	687b      	ldr	r3, [r7, #4]
 800afea:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 800afee:	683a      	ldr	r2, [r7, #0]
 800aff0:	429a      	cmp	r2, r3
 800aff2:	d152      	bne.n	800b09a <_tx_semaphore_cleanup+0xd6>
        {

            /* Setup pointer to semaphore control block.  */
            semaphore_ptr =  TX_VOID_TO_SEMAPHORE_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
 800aff4:	687b      	ldr	r3, [r7, #4]
 800aff6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800aff8:	633b      	str	r3, [r7, #48]	; 0x30

            /* Check for a NULL semaphore pointer.  */
            if (semaphore_ptr != TX_NULL)
 800affa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800affc:	2b00      	cmp	r3, #0
 800affe:	d04c      	beq.n	800b09a <_tx_semaphore_cleanup+0xd6>
            {

                /* Check for a valid semaphore ID.  */
                if (semaphore_ptr -> tx_semaphore_id == TX_SEMAPHORE_ID)
 800b000:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b002:	681b      	ldr	r3, [r3, #0]
 800b004:	4a2b      	ldr	r2, [pc, #172]	; (800b0b4 <_tx_semaphore_cleanup+0xf0>)
 800b006:	4293      	cmp	r3, r2
 800b008:	d147      	bne.n	800b09a <_tx_semaphore_cleanup+0xd6>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (semaphore_ptr -> tx_semaphore_suspended_count != TX_NO_SUSPENSIONS)
 800b00a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b00c:	691b      	ldr	r3, [r3, #16]
 800b00e:	2b00      	cmp	r3, #0
 800b010:	d043      	beq.n	800b09a <_tx_semaphore_cleanup+0xd6>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800b012:	687b      	ldr	r3, [r7, #4]
 800b014:	2200      	movs	r2, #0
 800b016:	669a      	str	r2, [r3, #104]	; 0x68

                        /* Decrement the suspended count.  */
                        semaphore_ptr -> tx_semaphore_suspended_count--;
 800b018:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b01a:	691b      	ldr	r3, [r3, #16]
 800b01c:	1e5a      	subs	r2, r3, #1
 800b01e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b020:	611a      	str	r2, [r3, #16]

                        /* Pickup the suspended count.  */
                        suspended_count =  semaphore_ptr -> tx_semaphore_suspended_count;
 800b022:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b024:	691b      	ldr	r3, [r3, #16]
 800b026:	62fb      	str	r3, [r7, #44]	; 0x2c

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
 800b028:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b02a:	2b00      	cmp	r3, #0
 800b02c:	d103      	bne.n	800b036 <_tx_semaphore_cleanup+0x72>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
 800b02e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b030:	2200      	movs	r2, #0
 800b032:	60da      	str	r2, [r3, #12]
 800b034:	e013      	b.n	800b05e <_tx_semaphore_cleanup+0x9a>
                        {

                            /* At least one more thread is on the same suspension list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
 800b036:	687b      	ldr	r3, [r7, #4]
 800b038:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b03a:	62bb      	str	r3, [r7, #40]	; 0x28
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 800b03c:	687b      	ldr	r3, [r7, #4]
 800b03e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b040:	627b      	str	r3, [r7, #36]	; 0x24
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
 800b042:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b044:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b046:	675a      	str	r2, [r3, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
 800b048:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b04a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800b04c:	671a      	str	r2, [r3, #112]	; 0x70

                            /* Determine if we need to update the head pointer.  */
                            if (semaphore_ptr -> tx_semaphore_suspension_list == thread_ptr)
 800b04e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b050:	68db      	ldr	r3, [r3, #12]
 800b052:	687a      	ldr	r2, [r7, #4]
 800b054:	429a      	cmp	r2, r3
 800b056:	d102      	bne.n	800b05e <_tx_semaphore_cleanup+0x9a>
                            {

                                /* Update the list head pointer.  */
                                semaphore_ptr -> tx_semaphore_suspension_list =   next_thread;
 800b058:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b05a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800b05c:	60da      	str	r2, [r3, #12]
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_SEMAPHORE_SUSP)
 800b05e:	687b      	ldr	r3, [r7, #4]
 800b060:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b062:	2b06      	cmp	r3, #6
 800b064:	d119      	bne.n	800b09a <_tx_semaphore_cleanup+0xd6>
                            /* Increment the number of timeouts on this semaphore.  */
                            semaphore_ptr -> tx_semaphore_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_INSTANCE;
 800b066:	687b      	ldr	r3, [r7, #4]
 800b068:	220d      	movs	r2, #13
 800b06a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 800b06e:	4b12      	ldr	r3, [pc, #72]	; (800b0b8 <_tx_semaphore_cleanup+0xf4>)
 800b070:	681b      	ldr	r3, [r3, #0]
 800b072:	3301      	adds	r3, #1
 800b074:	4a10      	ldr	r2, [pc, #64]	; (800b0b8 <_tx_semaphore_cleanup+0xf4>)
 800b076:	6013      	str	r3, [r2, #0]
 800b078:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b07a:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b07c:	693b      	ldr	r3, [r7, #16]
 800b07e:	f383 8810 	msr	PRIMASK, r3
}
 800b082:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
 800b084:	6878      	ldr	r0, [r7, #4]
 800b086:	f001 f9d1 	bl	800c42c <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b08a:	f3ef 8310 	mrs	r3, PRIMASK
 800b08e:	61bb      	str	r3, [r7, #24]
    return(posture);
 800b090:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800b092:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b094:	b672      	cpsid	i
    return(int_posture);
 800b096:	697b      	ldr	r3, [r7, #20]

                            /* Disable interrupts.  */
                            TX_DISABLE
 800b098:	637b      	str	r3, [r7, #52]	; 0x34
 800b09a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b09c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b09e:	68fb      	ldr	r3, [r7, #12]
 800b0a0:	f383 8810 	msr	PRIMASK, r3
}
 800b0a4:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 800b0a6:	bf00      	nop
 800b0a8:	3738      	adds	r7, #56	; 0x38
 800b0aa:	46bd      	mov	sp, r7
 800b0ac:	bd80      	pop	{r7, pc}
 800b0ae:	bf00      	nop
 800b0b0:	0800afc5 	.word	0x0800afc5
 800b0b4:	53454d41 	.word	0x53454d41
 800b0b8:	2000f054 	.word	0x2000f054

0800b0bc <_tx_semaphore_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_create(TX_SEMAPHORE *semaphore_ptr, CHAR *name_ptr, ULONG initial_count)
{
 800b0bc:	b580      	push	{r7, lr}
 800b0be:	b08a      	sub	sp, #40	; 0x28
 800b0c0:	af00      	add	r7, sp, #0
 800b0c2:	60f8      	str	r0, [r7, #12]
 800b0c4:	60b9      	str	r1, [r7, #8]
 800b0c6:	607a      	str	r2, [r7, #4]
TX_SEMAPHORE    *next_semaphore;
TX_SEMAPHORE    *previous_semaphore;


    /* Initialize semaphore control block to all zeros.  */
    TX_MEMSET(semaphore_ptr, 0, (sizeof(TX_SEMAPHORE)));
 800b0c8:	2228      	movs	r2, #40	; 0x28
 800b0ca:	2100      	movs	r1, #0
 800b0cc:	68f8      	ldr	r0, [r7, #12]
 800b0ce:	f00b fc89 	bl	80169e4 <memset>

    /* Setup the basic semaphore fields.  */
    semaphore_ptr -> tx_semaphore_name =             name_ptr;
 800b0d2:	68fb      	ldr	r3, [r7, #12]
 800b0d4:	68ba      	ldr	r2, [r7, #8]
 800b0d6:	605a      	str	r2, [r3, #4]
    semaphore_ptr -> tx_semaphore_count =            initial_count;
 800b0d8:	68fb      	ldr	r3, [r7, #12]
 800b0da:	687a      	ldr	r2, [r7, #4]
 800b0dc:	609a      	str	r2, [r3, #8]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b0de:	f3ef 8310 	mrs	r3, PRIMASK
 800b0e2:	61bb      	str	r3, [r7, #24]
    return(posture);
 800b0e4:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800b0e6:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b0e8:	b672      	cpsid	i
    return(int_posture);
 800b0ea:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to place the semaphore on the created list.  */
    TX_DISABLE
 800b0ec:	627b      	str	r3, [r7, #36]	; 0x24

    /* Setup the semaphore ID to make it valid.  */
    semaphore_ptr -> tx_semaphore_id =  TX_SEMAPHORE_ID;
 800b0ee:	68fb      	ldr	r3, [r7, #12]
 800b0f0:	4a18      	ldr	r2, [pc, #96]	; (800b154 <_tx_semaphore_create+0x98>)
 800b0f2:	601a      	str	r2, [r3, #0]

    /* Place the semaphore on the list of created semaphores.  First,
       check for an empty list.  */
    if (_tx_semaphore_created_count == TX_EMPTY)
 800b0f4:	4b18      	ldr	r3, [pc, #96]	; (800b158 <_tx_semaphore_create+0x9c>)
 800b0f6:	681b      	ldr	r3, [r3, #0]
 800b0f8:	2b00      	cmp	r3, #0
 800b0fa:	d109      	bne.n	800b110 <_tx_semaphore_create+0x54>
    {

        /* The created semaphore list is empty.  Add semaphore to empty list.  */
        _tx_semaphore_created_ptr =                       semaphore_ptr;
 800b0fc:	4a17      	ldr	r2, [pc, #92]	; (800b15c <_tx_semaphore_create+0xa0>)
 800b0fe:	68fb      	ldr	r3, [r7, #12]
 800b100:	6013      	str	r3, [r2, #0]
        semaphore_ptr -> tx_semaphore_created_next =      semaphore_ptr;
 800b102:	68fb      	ldr	r3, [r7, #12]
 800b104:	68fa      	ldr	r2, [r7, #12]
 800b106:	615a      	str	r2, [r3, #20]
        semaphore_ptr -> tx_semaphore_created_previous =  semaphore_ptr;
 800b108:	68fb      	ldr	r3, [r7, #12]
 800b10a:	68fa      	ldr	r2, [r7, #12]
 800b10c:	619a      	str	r2, [r3, #24]
 800b10e:	e011      	b.n	800b134 <_tx_semaphore_create+0x78>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_semaphore =      _tx_semaphore_created_ptr;
 800b110:	4b12      	ldr	r3, [pc, #72]	; (800b15c <_tx_semaphore_create+0xa0>)
 800b112:	681b      	ldr	r3, [r3, #0]
 800b114:	623b      	str	r3, [r7, #32]
        previous_semaphore =  next_semaphore -> tx_semaphore_created_previous;
 800b116:	6a3b      	ldr	r3, [r7, #32]
 800b118:	699b      	ldr	r3, [r3, #24]
 800b11a:	61fb      	str	r3, [r7, #28]

        /* Place the new semaphore in the list.  */
        next_semaphore -> tx_semaphore_created_previous =  semaphore_ptr;
 800b11c:	6a3b      	ldr	r3, [r7, #32]
 800b11e:	68fa      	ldr	r2, [r7, #12]
 800b120:	619a      	str	r2, [r3, #24]
        previous_semaphore -> tx_semaphore_created_next =  semaphore_ptr;
 800b122:	69fb      	ldr	r3, [r7, #28]
 800b124:	68fa      	ldr	r2, [r7, #12]
 800b126:	615a      	str	r2, [r3, #20]

        /* Setup this semaphore's next and previous created links.  */
        semaphore_ptr -> tx_semaphore_created_previous =  previous_semaphore;
 800b128:	68fb      	ldr	r3, [r7, #12]
 800b12a:	69fa      	ldr	r2, [r7, #28]
 800b12c:	619a      	str	r2, [r3, #24]
        semaphore_ptr -> tx_semaphore_created_next =      next_semaphore;
 800b12e:	68fb      	ldr	r3, [r7, #12]
 800b130:	6a3a      	ldr	r2, [r7, #32]
 800b132:	615a      	str	r2, [r3, #20]
    }

    /* Increment the created count.  */
    _tx_semaphore_created_count++;
 800b134:	4b08      	ldr	r3, [pc, #32]	; (800b158 <_tx_semaphore_create+0x9c>)
 800b136:	681b      	ldr	r3, [r3, #0]
 800b138:	3301      	adds	r3, #1
 800b13a:	4a07      	ldr	r2, [pc, #28]	; (800b158 <_tx_semaphore_create+0x9c>)
 800b13c:	6013      	str	r3, [r2, #0]
 800b13e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b140:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b142:	693b      	ldr	r3, [r7, #16]
 800b144:	f383 8810 	msr	PRIMASK, r3
}
 800b148:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800b14a:	2300      	movs	r3, #0
}
 800b14c:	4618      	mov	r0, r3
 800b14e:	3728      	adds	r7, #40	; 0x28
 800b150:	46bd      	mov	sp, r7
 800b152:	bd80      	pop	{r7, pc}
 800b154:	53454d41 	.word	0x53454d41
 800b158:	2000ef84 	.word	0x2000ef84
 800b15c:	2000ef80 	.word	0x2000ef80

0800b160 <_tx_semaphore_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_delete(TX_SEMAPHORE *semaphore_ptr)
{
 800b160:	b580      	push	{r7, lr}
 800b162:	b092      	sub	sp, #72	; 0x48
 800b164:	af00      	add	r7, sp, #0
 800b166:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b168:	f3ef 8310 	mrs	r3, PRIMASK
 800b16c:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800b16e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800b170:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800b172:	b672      	cpsid	i
    return(int_posture);
 800b174:	6abb      	ldr	r3, [r7, #40]	; 0x28
TX_SEMAPHORE    *next_semaphore;
TX_SEMAPHORE    *previous_semaphore;


    /* Disable interrupts to remove the semaphore from the created list.  */
    TX_DISABLE
 800b176:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_DELETE_INSERT

    /* Clear the semaphore ID to make it invalid.  */
    semaphore_ptr -> tx_semaphore_id =  TX_CLEAR_ID;
 800b178:	687b      	ldr	r3, [r7, #4]
 800b17a:	2200      	movs	r2, #0
 800b17c:	601a      	str	r2, [r3, #0]

    /* Decrement the number of semaphores.  */
    _tx_semaphore_created_count--;
 800b17e:	4b3d      	ldr	r3, [pc, #244]	; (800b274 <_tx_semaphore_delete+0x114>)
 800b180:	681b      	ldr	r3, [r3, #0]
 800b182:	3b01      	subs	r3, #1
 800b184:	4a3b      	ldr	r2, [pc, #236]	; (800b274 <_tx_semaphore_delete+0x114>)
 800b186:	6013      	str	r3, [r2, #0]

    /* See if the semaphore is the only one on the list.  */
    if (_tx_semaphore_created_count == TX_EMPTY)
 800b188:	4b3a      	ldr	r3, [pc, #232]	; (800b274 <_tx_semaphore_delete+0x114>)
 800b18a:	681b      	ldr	r3, [r3, #0]
 800b18c:	2b00      	cmp	r3, #0
 800b18e:	d103      	bne.n	800b198 <_tx_semaphore_delete+0x38>
    {

        /* Only created semaphore, just set the created list to NULL.  */
        _tx_semaphore_created_ptr =  TX_NULL;
 800b190:	4b39      	ldr	r3, [pc, #228]	; (800b278 <_tx_semaphore_delete+0x118>)
 800b192:	2200      	movs	r2, #0
 800b194:	601a      	str	r2, [r3, #0]
 800b196:	e013      	b.n	800b1c0 <_tx_semaphore_delete+0x60>
    }
    else
    {

        /* Link-up the neighbors.  */
        next_semaphore =                                   semaphore_ptr -> tx_semaphore_created_next;
 800b198:	687b      	ldr	r3, [r7, #4]
 800b19a:	695b      	ldr	r3, [r3, #20]
 800b19c:	63bb      	str	r3, [r7, #56]	; 0x38
        previous_semaphore =                               semaphore_ptr -> tx_semaphore_created_previous;
 800b19e:	687b      	ldr	r3, [r7, #4]
 800b1a0:	699b      	ldr	r3, [r3, #24]
 800b1a2:	637b      	str	r3, [r7, #52]	; 0x34
        next_semaphore -> tx_semaphore_created_previous =  previous_semaphore;
 800b1a4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b1a6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800b1a8:	619a      	str	r2, [r3, #24]
        previous_semaphore -> tx_semaphore_created_next =  next_semaphore;
 800b1aa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b1ac:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800b1ae:	615a      	str	r2, [r3, #20]

        /* See if we have to update the created list head pointer.  */
        if (_tx_semaphore_created_ptr == semaphore_ptr)
 800b1b0:	4b31      	ldr	r3, [pc, #196]	; (800b278 <_tx_semaphore_delete+0x118>)
 800b1b2:	681b      	ldr	r3, [r3, #0]
 800b1b4:	687a      	ldr	r2, [r7, #4]
 800b1b6:	429a      	cmp	r2, r3
 800b1b8:	d102      	bne.n	800b1c0 <_tx_semaphore_delete+0x60>
        {

            /* Yes, move the head pointer to the next link. */
            _tx_semaphore_created_ptr =  next_semaphore;
 800b1ba:	4a2f      	ldr	r2, [pc, #188]	; (800b278 <_tx_semaphore_delete+0x118>)
 800b1bc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b1be:	6013      	str	r3, [r2, #0]
        }
    }

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 800b1c0:	4b2e      	ldr	r3, [pc, #184]	; (800b27c <_tx_semaphore_delete+0x11c>)
 800b1c2:	681b      	ldr	r3, [r3, #0]
 800b1c4:	3301      	adds	r3, #1
 800b1c6:	4a2d      	ldr	r2, [pc, #180]	; (800b27c <_tx_semaphore_delete+0x11c>)
 800b1c8:	6013      	str	r3, [r2, #0]

    /* Pickup the suspension information.  */
    thread_ptr =                                     semaphore_ptr -> tx_semaphore_suspension_list;
 800b1ca:	687b      	ldr	r3, [r7, #4]
 800b1cc:	68db      	ldr	r3, [r3, #12]
 800b1ce:	647b      	str	r3, [r7, #68]	; 0x44
    semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
 800b1d0:	687b      	ldr	r3, [r7, #4]
 800b1d2:	2200      	movs	r2, #0
 800b1d4:	60da      	str	r2, [r3, #12]
    suspended_count =                                semaphore_ptr -> tx_semaphore_suspended_count;
 800b1d6:	687b      	ldr	r3, [r7, #4]
 800b1d8:	691b      	ldr	r3, [r3, #16]
 800b1da:	643b      	str	r3, [r7, #64]	; 0x40
    semaphore_ptr -> tx_semaphore_suspended_count =  TX_NO_SUSPENSIONS;
 800b1dc:	687b      	ldr	r3, [r7, #4]
 800b1de:	2200      	movs	r2, #0
 800b1e0:	611a      	str	r2, [r3, #16]
 800b1e2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b1e4:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b1e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b1e8:	f383 8810 	msr	PRIMASK, r3
}
 800b1ec:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the semaphore list to resume any and all threads suspended
       on this semaphore.  */
    while (suspended_count != TX_NO_SUSPENSIONS)
 800b1ee:	e024      	b.n	800b23a <_tx_semaphore_delete+0xda>
    {

        /* Decrement the suspension count.  */
        suspended_count--;
 800b1f0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b1f2:	3b01      	subs	r3, #1
 800b1f4:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b1f6:	f3ef 8310 	mrs	r3, PRIMASK
 800b1fa:	61fb      	str	r3, [r7, #28]
    return(posture);
 800b1fc:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800b1fe:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b200:	b672      	cpsid	i
    return(int_posture);
 800b202:	69bb      	ldr	r3, [r7, #24]

        /* Lockout interrupts.  */
        TX_DISABLE
 800b204:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Clear the cleanup pointer, this prevents the timeout from doing
           anything.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800b206:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b208:	2200      	movs	r2, #0
 800b20a:	669a      	str	r2, [r3, #104]	; 0x68

        /* Set the return status in the thread to TX_DELETED.  */
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
 800b20c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b20e:	2201      	movs	r2, #1
 800b210:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Move the thread pointer ahead.  */
        next_thread =  thread_ptr -> tx_thread_suspended_next;
 800b214:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b216:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b218:	633b      	str	r3, [r7, #48]	; 0x30
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption again.  */
        _tx_thread_preempt_disable++;
 800b21a:	4b18      	ldr	r3, [pc, #96]	; (800b27c <_tx_semaphore_delete+0x11c>)
 800b21c:	681b      	ldr	r3, [r3, #0]
 800b21e:	3301      	adds	r3, #1
 800b220:	4a16      	ldr	r2, [pc, #88]	; (800b27c <_tx_semaphore_delete+0x11c>)
 800b222:	6013      	str	r3, [r2, #0]
 800b224:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b226:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b228:	6a3b      	ldr	r3, [r7, #32]
 800b22a:	f383 8810 	msr	PRIMASK, r3
}
 800b22e:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
 800b230:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800b232:	f001 f8fb 	bl	800c42c <_tx_thread_system_resume>
#endif

        /* Move to next thread.  */
        thread_ptr =  next_thread;
 800b236:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b238:	647b      	str	r3, [r7, #68]	; 0x44
    while (suspended_count != TX_NO_SUSPENSIONS)
 800b23a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b23c:	2b00      	cmp	r3, #0
 800b23e:	d1d7      	bne.n	800b1f0 <_tx_semaphore_delete+0x90>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b240:	f3ef 8310 	mrs	r3, PRIMASK
 800b244:	613b      	str	r3, [r7, #16]
    return(posture);
 800b246:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 800b248:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b24a:	b672      	cpsid	i
    return(int_posture);
 800b24c:	68fb      	ldr	r3, [r7, #12]

    /* Execute Port-Specific completion processing. If needed, it is typically defined in tx_port.h.  */
    TX_SEMAPHORE_DELETE_PORT_COMPLETION(semaphore_ptr)

    /* Disable interrupts.  */
    TX_DISABLE
 800b24e:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Release previous preempt disable.  */
    _tx_thread_preempt_disable--;
 800b250:	4b0a      	ldr	r3, [pc, #40]	; (800b27c <_tx_semaphore_delete+0x11c>)
 800b252:	681b      	ldr	r3, [r3, #0]
 800b254:	3b01      	subs	r3, #1
 800b256:	4a09      	ldr	r2, [pc, #36]	; (800b27c <_tx_semaphore_delete+0x11c>)
 800b258:	6013      	str	r3, [r2, #0]
 800b25a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b25c:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b25e:	697b      	ldr	r3, [r7, #20]
 800b260:	f383 8810 	msr	PRIMASK, r3
}
 800b264:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 800b266:	f001 f8a7 	bl	800c3b8 <_tx_thread_system_preempt_check>

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800b26a:	2300      	movs	r3, #0
}
 800b26c:	4618      	mov	r0, r3
 800b26e:	3748      	adds	r7, #72	; 0x48
 800b270:	46bd      	mov	sp, r7
 800b272:	bd80      	pop	{r7, pc}
 800b274:	2000ef84 	.word	0x2000ef84
 800b278:	2000ef80 	.word	0x2000ef80
 800b27c:	2000f054 	.word	0x2000f054

0800b280 <_tx_semaphore_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_get(TX_SEMAPHORE *semaphore_ptr, ULONG wait_option)
{
 800b280:	b580      	push	{r7, lr}
 800b282:	b08e      	sub	sp, #56	; 0x38
 800b284:	af00      	add	r7, sp, #0
 800b286:	6078      	str	r0, [r7, #4]
 800b288:	6039      	str	r1, [r7, #0]
TX_THREAD       *previous_thread;
UINT            status;


    /* Default the status to TX_SUCCESS.  */
    status =  TX_SUCCESS;
 800b28a:	2300      	movs	r3, #0
 800b28c:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b28e:	f3ef 8310 	mrs	r3, PRIMASK
 800b292:	623b      	str	r3, [r7, #32]
    return(posture);
 800b294:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 800b296:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b298:	b672      	cpsid	i
    return(int_posture);
 800b29a:	69fb      	ldr	r3, [r7, #28]

    /* Disable interrupts to get an instance from the semaphore.  */
    TX_DISABLE
 800b29c:	633b      	str	r3, [r7, #48]	; 0x30

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_GET_INSERT

    /* Determine if there is an instance of the semaphore.  */
    if (semaphore_ptr -> tx_semaphore_count != ((ULONG) 0))
 800b29e:	687b      	ldr	r3, [r7, #4]
 800b2a0:	689b      	ldr	r3, [r3, #8]
 800b2a2:	2b00      	cmp	r3, #0
 800b2a4:	d00a      	beq.n	800b2bc <_tx_semaphore_get+0x3c>
    {

        /* Decrement the semaphore count.  */
        semaphore_ptr -> tx_semaphore_count--;
 800b2a6:	687b      	ldr	r3, [r7, #4]
 800b2a8:	689b      	ldr	r3, [r3, #8]
 800b2aa:	1e5a      	subs	r2, r3, #1
 800b2ac:	687b      	ldr	r3, [r7, #4]
 800b2ae:	609a      	str	r2, [r3, #8]
 800b2b0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b2b2:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b2b4:	69bb      	ldr	r3, [r7, #24]
 800b2b6:	f383 8810 	msr	PRIMASK, r3
}
 800b2ba:	e068      	b.n	800b38e <_tx_semaphore_get+0x10e>
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Determine if the request specifies suspension.  */
    else if (wait_option != TX_NO_WAIT)
 800b2bc:	683b      	ldr	r3, [r7, #0]
 800b2be:	2b00      	cmp	r3, #0
 800b2c0:	d05d      	beq.n	800b37e <_tx_semaphore_get+0xfe>
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
 800b2c2:	4b35      	ldr	r3, [pc, #212]	; (800b398 <_tx_semaphore_get+0x118>)
 800b2c4:	681b      	ldr	r3, [r3, #0]
 800b2c6:	2b00      	cmp	r3, #0
 800b2c8:	d008      	beq.n	800b2dc <_tx_semaphore_get+0x5c>
 800b2ca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b2cc:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b2ce:	697b      	ldr	r3, [r7, #20]
 800b2d0:	f383 8810 	msr	PRIMASK, r3
}
 800b2d4:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
            status =  TX_NO_INSTANCE;
 800b2d6:	230d      	movs	r3, #13
 800b2d8:	637b      	str	r3, [r7, #52]	; 0x34
 800b2da:	e058      	b.n	800b38e <_tx_semaphore_get+0x10e>
            /* Increment the number of suspensions on this semaphore.  */
            semaphore_ptr -> tx_semaphore_performance_suspension_count++;
#endif

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 800b2dc:	4b2f      	ldr	r3, [pc, #188]	; (800b39c <_tx_semaphore_get+0x11c>)
 800b2de:	681b      	ldr	r3, [r3, #0]
 800b2e0:	62fb      	str	r3, [r7, #44]	; 0x2c

            /* Setup cleanup routine pointer.  */
            thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_semaphore_cleanup);
 800b2e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b2e4:	4a2e      	ldr	r2, [pc, #184]	; (800b3a0 <_tx_semaphore_get+0x120>)
 800b2e6:	669a      	str	r2, [r3, #104]	; 0x68

            /* Setup cleanup information, i.e. this semaphore control
               block.  */
            thread_ptr -> tx_thread_suspend_control_block =  (VOID *) semaphore_ptr;
 800b2e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b2ea:	687a      	ldr	r2, [r7, #4]
 800b2ec:	66da      	str	r2, [r3, #108]	; 0x6c

#ifndef TX_NOT_INTERRUPTABLE

            /* Increment the suspension sequence number, which is used to identify
               this suspension event.  */
            thread_ptr -> tx_thread_suspension_sequence++;
 800b2ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b2f0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 800b2f4:	1c5a      	adds	r2, r3, #1
 800b2f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b2f8:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
#endif

            /* Setup suspension list.  */
            if (semaphore_ptr -> tx_semaphore_suspended_count == TX_NO_SUSPENSIONS)
 800b2fc:	687b      	ldr	r3, [r7, #4]
 800b2fe:	691b      	ldr	r3, [r3, #16]
 800b300:	2b00      	cmp	r3, #0
 800b302:	d109      	bne.n	800b318 <_tx_semaphore_get+0x98>
            {

                /* No other threads are suspended.  Setup the head pointer and
                   just setup this threads pointers to itself.  */
                semaphore_ptr -> tx_semaphore_suspension_list =         thread_ptr;
 800b304:	687b      	ldr	r3, [r7, #4]
 800b306:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b308:	60da      	str	r2, [r3, #12]
                thread_ptr -> tx_thread_suspended_next =                thread_ptr;
 800b30a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b30c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b30e:	671a      	str	r2, [r3, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous =            thread_ptr;
 800b310:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b312:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b314:	675a      	str	r2, [r3, #116]	; 0x74
 800b316:	e011      	b.n	800b33c <_tx_semaphore_get+0xbc>
            }
            else
            {

                /* This list is not NULL, add current thread to the end. */
                next_thread =                                   semaphore_ptr -> tx_semaphore_suspension_list;
 800b318:	687b      	ldr	r3, [r7, #4]
 800b31a:	68db      	ldr	r3, [r3, #12]
 800b31c:	62bb      	str	r3, [r7, #40]	; 0x28
                thread_ptr -> tx_thread_suspended_next =        next_thread;
 800b31e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b320:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800b322:	671a      	str	r2, [r3, #112]	; 0x70
                previous_thread =                               next_thread -> tx_thread_suspended_previous;
 800b324:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b326:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b328:	627b      	str	r3, [r7, #36]	; 0x24
                thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 800b32a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b32c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b32e:	675a      	str	r2, [r3, #116]	; 0x74
                previous_thread -> tx_thread_suspended_next =   thread_ptr;
 800b330:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b332:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b334:	671a      	str	r2, [r3, #112]	; 0x70
                next_thread -> tx_thread_suspended_previous =   thread_ptr;
 800b336:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b338:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b33a:	675a      	str	r2, [r3, #116]	; 0x74
            }

            /* Increment the number of suspensions.  */
            semaphore_ptr -> tx_semaphore_suspended_count++;
 800b33c:	687b      	ldr	r3, [r7, #4]
 800b33e:	691b      	ldr	r3, [r3, #16]
 800b340:	1c5a      	adds	r2, r3, #1
 800b342:	687b      	ldr	r3, [r7, #4]
 800b344:	611a      	str	r2, [r3, #16]

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_SEMAPHORE_SUSP;
 800b346:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b348:	2206      	movs	r2, #6
 800b34a:	631a      	str	r2, [r3, #48]	; 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800b34c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b34e:	2201      	movs	r2, #1
 800b350:	639a      	str	r2, [r3, #56]	; 0x38

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 800b352:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b354:	683a      	ldr	r2, [r7, #0]
 800b356:	64da      	str	r2, [r3, #76]	; 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800b358:	4b0f      	ldr	r3, [pc, #60]	; (800b398 <_tx_semaphore_get+0x118>)
 800b35a:	681b      	ldr	r3, [r3, #0]
 800b35c:	3301      	adds	r3, #1
 800b35e:	4a0e      	ldr	r2, [pc, #56]	; (800b398 <_tx_semaphore_get+0x118>)
 800b360:	6013      	str	r3, [r2, #0]
 800b362:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b364:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b366:	693b      	ldr	r3, [r7, #16]
 800b368:	f383 8810 	msr	PRIMASK, r3
}
 800b36c:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
 800b36e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b370:	f001 f970 	bl	800c654 <_tx_thread_system_suspend>
#endif

            /* Return the completion status.  */
            status =  thread_ptr -> tx_thread_suspend_status;
 800b374:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b376:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800b37a:	637b      	str	r3, [r7, #52]	; 0x34
 800b37c:	e007      	b.n	800b38e <_tx_semaphore_get+0x10e>
 800b37e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b380:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b382:	68fb      	ldr	r3, [r7, #12]
 800b384:	f383 8810 	msr	PRIMASK, r3
}
 800b388:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Immediate return, return error completion.  */
        status =  TX_NO_INSTANCE;
 800b38a:	230d      	movs	r3, #13
 800b38c:	637b      	str	r3, [r7, #52]	; 0x34
    }

    /* Return completion status.  */
    return(status);
 800b38e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 800b390:	4618      	mov	r0, r3
 800b392:	3738      	adds	r7, #56	; 0x38
 800b394:	46bd      	mov	sp, r7
 800b396:	bd80      	pop	{r7, pc}
 800b398:	2000f054 	.word	0x2000f054
 800b39c:	2000efb8 	.word	0x2000efb8
 800b3a0:	0800afc5 	.word	0x0800afc5

0800b3a4 <_tx_semaphore_info_get>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_info_get(TX_SEMAPHORE *semaphore_ptr, CHAR **name, ULONG *current_value,
                    TX_THREAD **first_suspended, ULONG *suspended_count,
                    TX_SEMAPHORE **next_semaphore)
{
 800b3a4:	b480      	push	{r7}
 800b3a6:	b089      	sub	sp, #36	; 0x24
 800b3a8:	af00      	add	r7, sp, #0
 800b3aa:	60f8      	str	r0, [r7, #12]
 800b3ac:	60b9      	str	r1, [r7, #8]
 800b3ae:	607a      	str	r2, [r7, #4]
 800b3b0:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b3b2:	f3ef 8310 	mrs	r3, PRIMASK
 800b3b6:	61bb      	str	r3, [r7, #24]
    return(posture);
 800b3b8:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800b3ba:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b3bc:	b672      	cpsid	i
    return(int_posture);
 800b3be:	697b      	ldr	r3, [r7, #20]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts.  */
    TX_DISABLE
 800b3c0:	61fb      	str	r3, [r7, #28]

    /* Retrieve all the pertinent information and return it in the supplied
       destinations.  */

    /* Retrieve the name of the semaphore.  */
    if (name != TX_NULL)
 800b3c2:	68bb      	ldr	r3, [r7, #8]
 800b3c4:	2b00      	cmp	r3, #0
 800b3c6:	d003      	beq.n	800b3d0 <_tx_semaphore_info_get+0x2c>
    {

        *name =  semaphore_ptr -> tx_semaphore_name;
 800b3c8:	68fb      	ldr	r3, [r7, #12]
 800b3ca:	685a      	ldr	r2, [r3, #4]
 800b3cc:	68bb      	ldr	r3, [r7, #8]
 800b3ce:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the current value of the semaphore.  */
    if (current_value != TX_NULL)
 800b3d0:	687b      	ldr	r3, [r7, #4]
 800b3d2:	2b00      	cmp	r3, #0
 800b3d4:	d003      	beq.n	800b3de <_tx_semaphore_info_get+0x3a>
    {

        *current_value =  semaphore_ptr -> tx_semaphore_count;
 800b3d6:	68fb      	ldr	r3, [r7, #12]
 800b3d8:	689a      	ldr	r2, [r3, #8]
 800b3da:	687b      	ldr	r3, [r7, #4]
 800b3dc:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the first thread suspended on this semaphore.  */
    if (first_suspended != TX_NULL)
 800b3de:	683b      	ldr	r3, [r7, #0]
 800b3e0:	2b00      	cmp	r3, #0
 800b3e2:	d003      	beq.n	800b3ec <_tx_semaphore_info_get+0x48>
    {

        *first_suspended =  semaphore_ptr -> tx_semaphore_suspension_list;
 800b3e4:	68fb      	ldr	r3, [r7, #12]
 800b3e6:	68da      	ldr	r2, [r3, #12]
 800b3e8:	683b      	ldr	r3, [r7, #0]
 800b3ea:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the number of threads suspended on this semaphore.  */
    if (suspended_count != TX_NULL)
 800b3ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b3ee:	2b00      	cmp	r3, #0
 800b3f0:	d003      	beq.n	800b3fa <_tx_semaphore_info_get+0x56>
    {

        *suspended_count =  (ULONG) semaphore_ptr -> tx_semaphore_suspended_count;
 800b3f2:	68fb      	ldr	r3, [r7, #12]
 800b3f4:	691a      	ldr	r2, [r3, #16]
 800b3f6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b3f8:	601a      	str	r2, [r3, #0]
    }

    /* Retrieve the pointer to the next semaphore created.  */
    if (next_semaphore != TX_NULL)
 800b3fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b3fc:	2b00      	cmp	r3, #0
 800b3fe:	d003      	beq.n	800b408 <_tx_semaphore_info_get+0x64>
    {

        *next_semaphore =  semaphore_ptr -> tx_semaphore_created_next;
 800b400:	68fb      	ldr	r3, [r7, #12]
 800b402:	695a      	ldr	r2, [r3, #20]
 800b404:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b406:	601a      	str	r2, [r3, #0]
 800b408:	69fb      	ldr	r3, [r7, #28]
 800b40a:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b40c:	693b      	ldr	r3, [r7, #16]
 800b40e:	f383 8810 	msr	PRIMASK, r3
}
 800b412:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(TX_SUCCESS);
 800b414:	2300      	movs	r3, #0
}
 800b416:	4618      	mov	r0, r3
 800b418:	3724      	adds	r7, #36	; 0x24
 800b41a:	46bd      	mov	sp, r7
 800b41c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b420:	4770      	bx	lr

0800b422 <_tx_semaphore_performance_info_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_performance_info_get(TX_SEMAPHORE *semaphore_ptr, ULONG *puts, ULONG *gets,
                    ULONG *suspensions, ULONG *timeouts)
{
 800b422:	b480      	push	{r7}
 800b424:	b087      	sub	sp, #28
 800b426:	af00      	add	r7, sp, #0
 800b428:	60f8      	str	r0, [r7, #12]
 800b42a:	60b9      	str	r1, [r7, #8]
 800b42c:	607a      	str	r2, [r7, #4]
 800b42e:	603b      	str	r3, [r7, #0]
#else
UINT                    status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (semaphore_ptr != TX_NULL)
 800b430:	68fb      	ldr	r3, [r7, #12]
 800b432:	2b00      	cmp	r3, #0
 800b434:	d002      	beq.n	800b43c <_tx_semaphore_performance_info_get+0x1a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800b436:	23ff      	movs	r3, #255	; 0xff
 800b438:	617b      	str	r3, [r7, #20]
 800b43a:	e019      	b.n	800b470 <_tx_semaphore_performance_info_get+0x4e>
    }
    else if (puts != TX_NULL)
 800b43c:	68bb      	ldr	r3, [r7, #8]
 800b43e:	2b00      	cmp	r3, #0
 800b440:	d002      	beq.n	800b448 <_tx_semaphore_performance_info_get+0x26>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800b442:	23ff      	movs	r3, #255	; 0xff
 800b444:	617b      	str	r3, [r7, #20]
 800b446:	e013      	b.n	800b470 <_tx_semaphore_performance_info_get+0x4e>
    }
    else if (gets != TX_NULL)
 800b448:	687b      	ldr	r3, [r7, #4]
 800b44a:	2b00      	cmp	r3, #0
 800b44c:	d002      	beq.n	800b454 <_tx_semaphore_performance_info_get+0x32>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800b44e:	23ff      	movs	r3, #255	; 0xff
 800b450:	617b      	str	r3, [r7, #20]
 800b452:	e00d      	b.n	800b470 <_tx_semaphore_performance_info_get+0x4e>
    }
    else if (suspensions != TX_NULL)
 800b454:	683b      	ldr	r3, [r7, #0]
 800b456:	2b00      	cmp	r3, #0
 800b458:	d002      	beq.n	800b460 <_tx_semaphore_performance_info_get+0x3e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800b45a:	23ff      	movs	r3, #255	; 0xff
 800b45c:	617b      	str	r3, [r7, #20]
 800b45e:	e007      	b.n	800b470 <_tx_semaphore_performance_info_get+0x4e>
    }
    else if (timeouts != TX_NULL)
 800b460:	6a3b      	ldr	r3, [r7, #32]
 800b462:	2b00      	cmp	r3, #0
 800b464:	d002      	beq.n	800b46c <_tx_semaphore_performance_info_get+0x4a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800b466:	23ff      	movs	r3, #255	; 0xff
 800b468:	617b      	str	r3, [r7, #20]
 800b46a:	e001      	b.n	800b470 <_tx_semaphore_performance_info_get+0x4e>
    }
    else
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800b46c:	23ff      	movs	r3, #255	; 0xff
 800b46e:	617b      	str	r3, [r7, #20]
    }
#endif

    /* Return completion status.  */
    return(status);
 800b470:	697b      	ldr	r3, [r7, #20]
}
 800b472:	4618      	mov	r0, r3
 800b474:	371c      	adds	r7, #28
 800b476:	46bd      	mov	sp, r7
 800b478:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b47c:	4770      	bx	lr

0800b47e <_tx_semaphore_performance_system_info_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_performance_system_info_get(ULONG *puts, ULONG *gets, ULONG *suspensions, ULONG *timeouts)
{
 800b47e:	b480      	push	{r7}
 800b480:	b087      	sub	sp, #28
 800b482:	af00      	add	r7, sp, #0
 800b484:	60f8      	str	r0, [r7, #12]
 800b486:	60b9      	str	r1, [r7, #8]
 800b488:	607a      	str	r2, [r7, #4]
 800b48a:	603b      	str	r3, [r7, #0]

UINT        status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (puts != TX_NULL)
 800b48c:	68fb      	ldr	r3, [r7, #12]
 800b48e:	2b00      	cmp	r3, #0
 800b490:	d002      	beq.n	800b498 <_tx_semaphore_performance_system_info_get+0x1a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800b492:	23ff      	movs	r3, #255	; 0xff
 800b494:	617b      	str	r3, [r7, #20]
 800b496:	e013      	b.n	800b4c0 <_tx_semaphore_performance_system_info_get+0x42>
    }
    else if (gets != TX_NULL)
 800b498:	68bb      	ldr	r3, [r7, #8]
 800b49a:	2b00      	cmp	r3, #0
 800b49c:	d002      	beq.n	800b4a4 <_tx_semaphore_performance_system_info_get+0x26>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800b49e:	23ff      	movs	r3, #255	; 0xff
 800b4a0:	617b      	str	r3, [r7, #20]
 800b4a2:	e00d      	b.n	800b4c0 <_tx_semaphore_performance_system_info_get+0x42>
    }
    else if (suspensions != TX_NULL)
 800b4a4:	687b      	ldr	r3, [r7, #4]
 800b4a6:	2b00      	cmp	r3, #0
 800b4a8:	d002      	beq.n	800b4b0 <_tx_semaphore_performance_system_info_get+0x32>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800b4aa:	23ff      	movs	r3, #255	; 0xff
 800b4ac:	617b      	str	r3, [r7, #20]
 800b4ae:	e007      	b.n	800b4c0 <_tx_semaphore_performance_system_info_get+0x42>
    }
    else if (timeouts != TX_NULL)
 800b4b0:	683b      	ldr	r3, [r7, #0]
 800b4b2:	2b00      	cmp	r3, #0
 800b4b4:	d002      	beq.n	800b4bc <_tx_semaphore_performance_system_info_get+0x3e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800b4b6:	23ff      	movs	r3, #255	; 0xff
 800b4b8:	617b      	str	r3, [r7, #20]
 800b4ba:	e001      	b.n	800b4c0 <_tx_semaphore_performance_system_info_get+0x42>
    }
    else
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800b4bc:	23ff      	movs	r3, #255	; 0xff
 800b4be:	617b      	str	r3, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 800b4c0:	697b      	ldr	r3, [r7, #20]
#endif
}
 800b4c2:	4618      	mov	r0, r3
 800b4c4:	371c      	adds	r7, #28
 800b4c6:	46bd      	mov	sp, r7
 800b4c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b4cc:	4770      	bx	lr
	...

0800b4d0 <_tx_semaphore_prioritize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_prioritize(TX_SEMAPHORE *semaphore_ptr)
{
 800b4d0:	b580      	push	{r7, lr}
 800b4d2:	b092      	sub	sp, #72	; 0x48
 800b4d4:	af00      	add	r7, sp, #0
 800b4d6:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b4d8:	f3ef 8310 	mrs	r3, PRIMASK
 800b4dc:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 800b4de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 800b4e0:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b4e2:	b672      	cpsid	i
    return(int_posture);
 800b4e4:	6a3b      	ldr	r3, [r7, #32]
TX_THREAD       *previous_thread;
UINT            list_changed;


    /* Disable interrupts.  */
    TX_DISABLE
 800b4e6:	647b      	str	r3, [r7, #68]	; 0x44

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_PRIORITIZE_INSERT

    /* Pickup the suspended count.  */
    suspended_count =  semaphore_ptr -> tx_semaphore_suspended_count;
 800b4e8:	687b      	ldr	r3, [r7, #4]
 800b4ea:	691b      	ldr	r3, [r3, #16]
 800b4ec:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if there are fewer than 2 suspended threads.  */
    if (suspended_count < ((UINT) 2))
 800b4ee:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b4f0:	2b01      	cmp	r3, #1
 800b4f2:	d805      	bhi.n	800b500 <_tx_semaphore_prioritize+0x30>
 800b4f4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b4f6:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b4f8:	69fb      	ldr	r3, [r7, #28]
 800b4fa:	f383 8810 	msr	PRIMASK, r3
}
 800b4fe:	e092      	b.n	800b626 <_tx_semaphore_prioritize+0x156>
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Determine if there how many threads are suspended on this semaphore.  */
    else if (suspended_count == ((UINT) 2))
 800b500:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b502:	2b02      	cmp	r3, #2
 800b504:	d114      	bne.n	800b530 <_tx_semaphore_prioritize+0x60>
    {

        /* Pickup the head pointer and the next pointer.  */
        head_ptr =  semaphore_ptr -> tx_semaphore_suspension_list;
 800b506:	687b      	ldr	r3, [r7, #4]
 800b508:	68db      	ldr	r3, [r3, #12]
 800b50a:	63bb      	str	r3, [r7, #56]	; 0x38
        next_thread =  head_ptr -> tx_thread_suspended_next;
 800b50c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b50e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b510:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Determine if the next suspended thread has a higher priority.  */
        if ((next_thread -> tx_thread_priority) < (head_ptr -> tx_thread_priority))
 800b512:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b514:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b516:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b518:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b51a:	429a      	cmp	r2, r3
 800b51c:	d202      	bcs.n	800b524 <_tx_semaphore_prioritize+0x54>
        {

            /* Yes, move the list head to the next thread.  */
            semaphore_ptr -> tx_semaphore_suspension_list =  next_thread;
 800b51e:	687b      	ldr	r3, [r7, #4]
 800b520:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b522:	60da      	str	r2, [r3, #12]
 800b524:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b526:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b528:	69bb      	ldr	r3, [r7, #24]
 800b52a:	f383 8810 	msr	PRIMASK, r3
}
 800b52e:	e07a      	b.n	800b626 <_tx_semaphore_prioritize+0x156>
    }
    else
    {

        /* Remember the suspension count and head pointer.  */
        head_ptr =   semaphore_ptr -> tx_semaphore_suspension_list;
 800b530:	687b      	ldr	r3, [r7, #4]
 800b532:	68db      	ldr	r3, [r3, #12]
 800b534:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Default the highest priority thread to the thread at the front of the list.  */
        priority_thread_ptr =  head_ptr;
 800b536:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b538:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Setup search pointer.  */
        thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
 800b53a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b53c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b53e:	643b      	str	r3, [r7, #64]	; 0x40

        /* Disable preemption.  */
        _tx_thread_preempt_disable++;
 800b540:	4b3b      	ldr	r3, [pc, #236]	; (800b630 <_tx_semaphore_prioritize+0x160>)
 800b542:	681b      	ldr	r3, [r3, #0]
 800b544:	3301      	adds	r3, #1
 800b546:	4a3a      	ldr	r2, [pc, #232]	; (800b630 <_tx_semaphore_prioritize+0x160>)
 800b548:	6013      	str	r3, [r2, #0]

        /* Set the list changed flag to false.  */
        list_changed =  TX_FALSE;
 800b54a:	2300      	movs	r3, #0
 800b54c:	633b      	str	r3, [r7, #48]	; 0x30
        /* Search through the list to find the highest priority thread.  */
        do
        {

            /* Is the current thread higher priority?  */
            if (thread_ptr -> tx_thread_priority < priority_thread_ptr -> tx_thread_priority)
 800b54e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b550:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b552:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b554:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b556:	429a      	cmp	r2, r3
 800b558:	d201      	bcs.n	800b55e <_tx_semaphore_prioritize+0x8e>
            {

                /* Yes, remember that this thread is the highest priority.  */
                priority_thread_ptr =  thread_ptr;
 800b55a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b55c:	63fb      	str	r3, [r7, #60]	; 0x3c
 800b55e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b560:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b562:	68fb      	ldr	r3, [r7, #12]
 800b564:	f383 8810 	msr	PRIMASK, r3
}
 800b568:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b56a:	f3ef 8310 	mrs	r3, PRIMASK
 800b56e:	617b      	str	r3, [r7, #20]
    return(posture);
 800b570:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800b572:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b574:	b672      	cpsid	i
    return(int_posture);
 800b576:	693b      	ldr	r3, [r7, #16]

            /* Restore interrupts temporarily.  */
            TX_RESTORE

            /* Disable interrupts again.  */
            TX_DISABLE
 800b578:	647b      	str	r3, [r7, #68]	; 0x44

            /* Determine if any changes to the list have occurred while
               interrupts were enabled.  */

            /* Is the list head the same?  */
            if (head_ptr != semaphore_ptr -> tx_semaphore_suspension_list)
 800b57a:	687b      	ldr	r3, [r7, #4]
 800b57c:	68db      	ldr	r3, [r3, #12]
 800b57e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800b580:	429a      	cmp	r2, r3
 800b582:	d002      	beq.n	800b58a <_tx_semaphore_prioritize+0xba>
            {

                /* The list head has changed, set the list changed flag.  */
                list_changed =  TX_TRUE;
 800b584:	2301      	movs	r3, #1
 800b586:	633b      	str	r3, [r7, #48]	; 0x30
 800b588:	e006      	b.n	800b598 <_tx_semaphore_prioritize+0xc8>
            }
            else
            {

                /* Is the suspended count the same?  */
                if (suspended_count != semaphore_ptr -> tx_semaphore_suspended_count)
 800b58a:	687b      	ldr	r3, [r7, #4]
 800b58c:	691b      	ldr	r3, [r3, #16]
 800b58e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800b590:	429a      	cmp	r2, r3
 800b592:	d001      	beq.n	800b598 <_tx_semaphore_prioritize+0xc8>
                {

                    /* The list head has changed, set the list changed flag.  */
                    list_changed =  TX_TRUE;
 800b594:	2301      	movs	r3, #1
 800b596:	633b      	str	r3, [r7, #48]	; 0x30
                }
            }

            /* Determine if the list has changed.  */
            if (list_changed == TX_FALSE)
 800b598:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b59a:	2b00      	cmp	r3, #0
 800b59c:	d103      	bne.n	800b5a6 <_tx_semaphore_prioritize+0xd6>
            {

                /* Yes, everything is the same... move the thread pointer to the next thread.  */
                thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 800b59e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b5a0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b5a2:	643b      	str	r3, [r7, #64]	; 0x40
 800b5a4:	e00c      	b.n	800b5c0 <_tx_semaphore_prioritize+0xf0>
            {

                /* No, the list is been modified so we need to start the search over.  */

                /* Save the suspension count and head pointer.  */
                head_ptr =   semaphore_ptr -> tx_semaphore_suspension_list;
 800b5a6:	687b      	ldr	r3, [r7, #4]
 800b5a8:	68db      	ldr	r3, [r3, #12]
 800b5aa:	63bb      	str	r3, [r7, #56]	; 0x38
                suspended_count =  semaphore_ptr -> tx_semaphore_suspended_count;
 800b5ac:	687b      	ldr	r3, [r7, #4]
 800b5ae:	691b      	ldr	r3, [r3, #16]
 800b5b0:	637b      	str	r3, [r7, #52]	; 0x34

                /* Default the highest priority thread to the thread at the front of the list.  */
                priority_thread_ptr =  head_ptr;
 800b5b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b5b4:	63fb      	str	r3, [r7, #60]	; 0x3c

                /* Setup search pointer.  */
                thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
 800b5b6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b5b8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b5ba:	643b      	str	r3, [r7, #64]	; 0x40

                /* Reset the list changed flag.  */
                list_changed =  TX_FALSE;
 800b5bc:	2300      	movs	r3, #0
 800b5be:	633b      	str	r3, [r7, #48]	; 0x30
            }

        } while (thread_ptr != head_ptr);
 800b5c0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800b5c2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b5c4:	429a      	cmp	r2, r3
 800b5c6:	d1c2      	bne.n	800b54e <_tx_semaphore_prioritize+0x7e>

        /* Release preemption.  */
        _tx_thread_preempt_disable--;
 800b5c8:	4b19      	ldr	r3, [pc, #100]	; (800b630 <_tx_semaphore_prioritize+0x160>)
 800b5ca:	681b      	ldr	r3, [r3, #0]
 800b5cc:	3b01      	subs	r3, #1
 800b5ce:	4a18      	ldr	r2, [pc, #96]	; (800b630 <_tx_semaphore_prioritize+0x160>)
 800b5d0:	6013      	str	r3, [r2, #0]

        /* Now determine if the highest priority thread is at the front
           of the list.  */
        if (priority_thread_ptr != head_ptr)
 800b5d2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800b5d4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b5d6:	429a      	cmp	r2, r3
 800b5d8:	d01d      	beq.n	800b616 <_tx_semaphore_prioritize+0x146>
            /* No, we need to move the highest priority suspended thread to the
               front of the list.  */

            /* First, remove the highest priority thread by updating the
               adjacent suspended threads.  */
            next_thread =                                  priority_thread_ptr -> tx_thread_suspended_next;
 800b5da:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b5dc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b5de:	62fb      	str	r3, [r7, #44]	; 0x2c
            previous_thread =                              priority_thread_ptr -> tx_thread_suspended_previous;
 800b5e0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b5e2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b5e4:	62bb      	str	r3, [r7, #40]	; 0x28
            next_thread -> tx_thread_suspended_previous =  previous_thread;
 800b5e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b5e8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800b5ea:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =  next_thread;
 800b5ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b5ee:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b5f0:	671a      	str	r2, [r3, #112]	; 0x70

            /* Now, link the highest priority thread at the front of the list.  */
            previous_thread =                                      head_ptr -> tx_thread_suspended_previous;
 800b5f2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b5f4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b5f6:	62bb      	str	r3, [r7, #40]	; 0x28
            priority_thread_ptr -> tx_thread_suspended_next =      head_ptr;
 800b5f8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b5fa:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800b5fc:	671a      	str	r2, [r3, #112]	; 0x70
            priority_thread_ptr -> tx_thread_suspended_previous =  previous_thread;
 800b5fe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b600:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800b602:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =          priority_thread_ptr;
 800b604:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b606:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800b608:	671a      	str	r2, [r3, #112]	; 0x70
            head_ptr -> tx_thread_suspended_previous =             priority_thread_ptr;
 800b60a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b60c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800b60e:	675a      	str	r2, [r3, #116]	; 0x74

            /* Move the list head pointer to the highest priority suspended thread.  */
            semaphore_ptr -> tx_semaphore_suspension_list =  priority_thread_ptr;
 800b610:	687b      	ldr	r3, [r7, #4]
 800b612:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800b614:	60da      	str	r2, [r3, #12]
 800b616:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b618:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b61a:	68bb      	ldr	r3, [r7, #8]
 800b61c:	f383 8810 	msr	PRIMASK, r3
}
 800b620:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 800b622:	f000 fec9 	bl	800c3b8 <_tx_thread_system_preempt_check>
    }

    /* Return completion status.  */
    return(TX_SUCCESS);
 800b626:	2300      	movs	r3, #0
}
 800b628:	4618      	mov	r0, r3
 800b62a:	3748      	adds	r7, #72	; 0x48
 800b62c:	46bd      	mov	sp, r7
 800b62e:	bd80      	pop	{r7, pc}
 800b630:	2000f054 	.word	0x2000f054

0800b634 <_tx_semaphore_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_put(TX_SEMAPHORE *semaphore_ptr)
{
 800b634:	b580      	push	{r7, lr}
 800b636:	b08c      	sub	sp, #48	; 0x30
 800b638:	af00      	add	r7, sp, #0
 800b63a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b63c:	f3ef 8310 	mrs	r3, PRIMASK
 800b640:	617b      	str	r3, [r7, #20]
    return(posture);
 800b642:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800b644:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b646:	b672      	cpsid	i
    return(int_posture);
 800b648:	693b      	ldr	r3, [r7, #16]
TX_THREAD       *next_thread;
TX_THREAD       *previous_thread;


    /* Disable interrupts to put an instance back to the semaphore.  */
    TX_DISABLE
 800b64a:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_PUT_INSERT

    /* Pickup the number of suspended threads.  */
    suspended_count =  semaphore_ptr -> tx_semaphore_suspended_count;
 800b64c:	687b      	ldr	r3, [r7, #4]
 800b64e:	691b      	ldr	r3, [r3, #16]
 800b650:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Determine if there are any threads suspended on the semaphore.  */
    if (suspended_count == TX_NO_SUSPENSIONS)
 800b652:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b654:	2b00      	cmp	r3, #0
 800b656:	d114      	bne.n	800b682 <_tx_semaphore_put+0x4e>
    {

        /* Increment the semaphore count.  */
        semaphore_ptr -> tx_semaphore_count++;
 800b658:	687b      	ldr	r3, [r7, #4]
 800b65a:	689b      	ldr	r3, [r3, #8]
 800b65c:	1c5a      	adds	r2, r3, #1
 800b65e:	687b      	ldr	r3, [r7, #4]
 800b660:	609a      	str	r2, [r3, #8]

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Pickup the application notify function.  */
        semaphore_put_notify =  semaphore_ptr -> tx_semaphore_put_notify;
 800b662:	687b      	ldr	r3, [r7, #4]
 800b664:	69db      	ldr	r3, [r3, #28]
 800b666:	61bb      	str	r3, [r7, #24]
 800b668:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b66a:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b66c:	68fb      	ldr	r3, [r7, #12]
 800b66e:	f383 8810 	msr	PRIMASK, r3
}
 800b672:	bf00      	nop
        TX_RESTORE

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Determine if notification is required.  */
        if (semaphore_put_notify != TX_NULL)
 800b674:	69bb      	ldr	r3, [r7, #24]
 800b676:	2b00      	cmp	r3, #0
 800b678:	d040      	beq.n	800b6fc <_tx_semaphore_put+0xc8>
        {

            /* Yes, call the appropriate notify callback function.  */
            (semaphore_put_notify)(semaphore_ptr);
 800b67a:	69bb      	ldr	r3, [r7, #24]
 800b67c:	6878      	ldr	r0, [r7, #4]
 800b67e:	4798      	blx	r3
 800b680:	e03c      	b.n	800b6fc <_tx_semaphore_put+0xc8>
    {

        /* A thread is suspended on this semaphore.  */

        /* Pickup the pointer to the first suspended thread.  */
        thread_ptr =  semaphore_ptr -> tx_semaphore_suspension_list;
 800b682:	687b      	ldr	r3, [r7, #4]
 800b684:	68db      	ldr	r3, [r3, #12]
 800b686:	627b      	str	r3, [r7, #36]	; 0x24

        /* Remove the suspended thread from the list.  */

        /* See if this is the only suspended thread on the list.  */
        suspended_count--;
 800b688:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b68a:	3b01      	subs	r3, #1
 800b68c:	62bb      	str	r3, [r7, #40]	; 0x28
        if (suspended_count == TX_NO_SUSPENSIONS)
 800b68e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b690:	2b00      	cmp	r3, #0
 800b692:	d103      	bne.n	800b69c <_tx_semaphore_put+0x68>
        {

            /* Yes, the only suspended thread.  */

            /* Update the head pointer.  */
            semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
 800b694:	687b      	ldr	r3, [r7, #4]
 800b696:	2200      	movs	r2, #0
 800b698:	60da      	str	r2, [r3, #12]
 800b69a:	e00e      	b.n	800b6ba <_tx_semaphore_put+0x86>
        {

            /* At least one more thread is on the same expiration list.  */

            /* Update the list head pointer.  */
            next_thread =                                     thread_ptr -> tx_thread_suspended_next;
 800b69c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b69e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b6a0:	623b      	str	r3, [r7, #32]
            semaphore_ptr -> tx_semaphore_suspension_list =   next_thread;
 800b6a2:	687b      	ldr	r3, [r7, #4]
 800b6a4:	6a3a      	ldr	r2, [r7, #32]
 800b6a6:	60da      	str	r2, [r3, #12]

            /* Update the links of the adjacent threads.  */
            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 800b6a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b6aa:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b6ac:	61fb      	str	r3, [r7, #28]
            next_thread -> tx_thread_suspended_previous =   previous_thread;
 800b6ae:	6a3b      	ldr	r3, [r7, #32]
 800b6b0:	69fa      	ldr	r2, [r7, #28]
 800b6b2:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =   next_thread;
 800b6b4:	69fb      	ldr	r3, [r7, #28]
 800b6b6:	6a3a      	ldr	r2, [r7, #32]
 800b6b8:	671a      	str	r2, [r3, #112]	; 0x70
        }

        /* Decrement the suspension count.  */
        semaphore_ptr -> tx_semaphore_suspended_count =  suspended_count;
 800b6ba:	687b      	ldr	r3, [r7, #4]
 800b6bc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800b6be:	611a      	str	r2, [r3, #16]

        /* Prepare for resumption of the first thread.  */

        /* Clear cleanup routine to avoid timeout.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800b6c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b6c2:	2200      	movs	r2, #0
 800b6c4:	669a      	str	r2, [r3, #104]	; 0x68

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Pickup the application notify function.  */
        semaphore_put_notify =  semaphore_ptr -> tx_semaphore_put_notify;
 800b6c6:	687b      	ldr	r3, [r7, #4]
 800b6c8:	69db      	ldr	r3, [r3, #28]
 800b6ca:	61bb      	str	r3, [r7, #24]
#endif

        /* Put return status into the thread control block.  */
        thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 800b6cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b6ce:	2200      	movs	r2, #0
 800b6d0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption.  */
        _tx_thread_preempt_disable++;
 800b6d4:	4b0c      	ldr	r3, [pc, #48]	; (800b708 <_tx_semaphore_put+0xd4>)
 800b6d6:	681b      	ldr	r3, [r3, #0]
 800b6d8:	3301      	adds	r3, #1
 800b6da:	4a0b      	ldr	r2, [pc, #44]	; (800b708 <_tx_semaphore_put+0xd4>)
 800b6dc:	6013      	str	r3, [r2, #0]
 800b6de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b6e0:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b6e2:	68bb      	ldr	r3, [r7, #8]
 800b6e4:	f383 8810 	msr	PRIMASK, r3
}
 800b6e8:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume thread.  */
        _tx_thread_system_resume(thread_ptr);
 800b6ea:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800b6ec:	f000 fe9e 	bl	800c42c <_tx_thread_system_resume>
#endif

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Determine if notification is required.  */
        if (semaphore_put_notify != TX_NULL)
 800b6f0:	69bb      	ldr	r3, [r7, #24]
 800b6f2:	2b00      	cmp	r3, #0
 800b6f4:	d002      	beq.n	800b6fc <_tx_semaphore_put+0xc8>
        {

            /* Yes, call the appropriate notify callback function.  */
            (semaphore_put_notify)(semaphore_ptr);
 800b6f6:	69bb      	ldr	r3, [r7, #24]
 800b6f8:	6878      	ldr	r0, [r7, #4]
 800b6fa:	4798      	blx	r3
        }
#endif
    }

    /* Return successful completion.  */
    return(TX_SUCCESS);
 800b6fc:	2300      	movs	r3, #0
}
 800b6fe:	4618      	mov	r0, r3
 800b700:	3730      	adds	r7, #48	; 0x30
 800b702:	46bd      	mov	sp, r7
 800b704:	bd80      	pop	{r7, pc}
 800b706:	bf00      	nop
 800b708:	2000f054 	.word	0x2000f054

0800b70c <_tx_semaphore_put_notify>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_put_notify(TX_SEMAPHORE *semaphore_ptr, VOID (*semaphore_put_notify)(TX_SEMAPHORE *notify_semaphore_ptr))
{
 800b70c:	b480      	push	{r7}
 800b70e:	b087      	sub	sp, #28
 800b710:	af00      	add	r7, sp, #0
 800b712:	6078      	str	r0, [r7, #4]
 800b714:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b716:	f3ef 8310 	mrs	r3, PRIMASK
 800b71a:	60fb      	str	r3, [r7, #12]
    return(posture);
 800b71c:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 800b71e:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b720:	b672      	cpsid	i
    return(int_posture);
 800b722:	68bb      	ldr	r3, [r7, #8]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts.  */
    TX_DISABLE
 800b724:	617b      	str	r3, [r7, #20]

    /* Make entry in event log.  */
    TX_EL_SEMAPHORE_PUT_NOTIFY_INSERT

    /* Setup semaphore put notification callback function.  */
    semaphore_ptr -> tx_semaphore_put_notify =  semaphore_put_notify;
 800b726:	687b      	ldr	r3, [r7, #4]
 800b728:	683a      	ldr	r2, [r7, #0]
 800b72a:	61da      	str	r2, [r3, #28]
 800b72c:	697b      	ldr	r3, [r7, #20]
 800b72e:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b730:	693b      	ldr	r3, [r7, #16]
 800b732:	f383 8810 	msr	PRIMASK, r3
}
 800b736:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return success to caller.  */
    return(TX_SUCCESS);
 800b738:	2300      	movs	r3, #0
#endif
}
 800b73a:	4618      	mov	r0, r3
 800b73c:	371c      	adds	r7, #28
 800b73e:	46bd      	mov	sp, r7
 800b740:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b744:	4770      	bx	lr
	...

0800b748 <_tx_thread_create>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_create(TX_THREAD *thread_ptr, CHAR *name_ptr, VOID (*entry_function)(ULONG id), ULONG entry_input,
                            VOID *stack_start, ULONG stack_size, UINT priority, UINT preempt_threshold,
                            ULONG time_slice, UINT auto_start)
{
 800b748:	b580      	push	{r7, lr}
 800b74a:	b092      	sub	sp, #72	; 0x48
 800b74c:	af00      	add	r7, sp, #0
 800b74e:	60f8      	str	r0, [r7, #12]
 800b750:	60b9      	str	r1, [r7, #8]
 800b752:	607a      	str	r2, [r7, #4]
 800b754:	603b      	str	r3, [r7, #0]
TX_INTERRUPT_SAVE_AREA

TX_THREAD               *next_thread;
TX_THREAD               *previous_thread;
TX_THREAD               *saved_thread_ptr;
UINT                    saved_threshold =  ((UINT) 0);
 800b756:	2300      	movs	r3, #0
 800b758:	643b      	str	r3, [r7, #64]	; 0x40
#ifndef TX_DISABLE_STACK_FILLING

    /* Set the thread stack to a pattern prior to creating the initial
       stack frame.  This pattern is used by the stack checking routines
       to see how much has been used.  */
    TX_MEMSET(stack_start, ((UCHAR) TX_STACK_FILL), stack_size);
 800b75a:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800b75c:	21ef      	movs	r1, #239	; 0xef
 800b75e:	6d38      	ldr	r0, [r7, #80]	; 0x50
 800b760:	f00b f940 	bl	80169e4 <memset>

    /* Prepare the thread control block prior to placing it on the created
       list.  */

    /* Initialize thread control block to all zeros.  */
    TX_MEMSET(thread_ptr, 0, (sizeof(TX_THREAD)));
 800b764:	22e8      	movs	r2, #232	; 0xe8
 800b766:	2100      	movs	r1, #0
 800b768:	68f8      	ldr	r0, [r7, #12]
 800b76a:	f00b f93b 	bl	80169e4 <memset>

    /* Place the supplied parameters into the thread's control block.  */
    thread_ptr -> tx_thread_name =              name_ptr;
 800b76e:	68fb      	ldr	r3, [r7, #12]
 800b770:	68ba      	ldr	r2, [r7, #8]
 800b772:	629a      	str	r2, [r3, #40]	; 0x28
    thread_ptr -> tx_thread_entry =             entry_function;
 800b774:	68fb      	ldr	r3, [r7, #12]
 800b776:	687a      	ldr	r2, [r7, #4]
 800b778:	645a      	str	r2, [r3, #68]	; 0x44
    thread_ptr -> tx_thread_entry_parameter =   entry_input;
 800b77a:	68fb      	ldr	r3, [r7, #12]
 800b77c:	683a      	ldr	r2, [r7, #0]
 800b77e:	649a      	str	r2, [r3, #72]	; 0x48
    thread_ptr -> tx_thread_stack_start =       stack_start;
 800b780:	68fb      	ldr	r3, [r7, #12]
 800b782:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800b784:	60da      	str	r2, [r3, #12]
    thread_ptr -> tx_thread_stack_size =        stack_size;
 800b786:	68fb      	ldr	r3, [r7, #12]
 800b788:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800b78a:	615a      	str	r2, [r3, #20]
    thread_ptr -> tx_thread_priority =          priority;
 800b78c:	68fb      	ldr	r3, [r7, #12]
 800b78e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800b790:	62da      	str	r2, [r3, #44]	; 0x2c
    thread_ptr -> tx_thread_user_priority =     priority;
 800b792:	68fb      	ldr	r3, [r7, #12]
 800b794:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800b796:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    thread_ptr -> tx_thread_time_slice =        time_slice;
 800b79a:	68fb      	ldr	r3, [r7, #12]
 800b79c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800b79e:	619a      	str	r2, [r3, #24]
    thread_ptr -> tx_thread_new_time_slice =    time_slice;
 800b7a0:	68fb      	ldr	r3, [r7, #12]
 800b7a2:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800b7a4:	61da      	str	r2, [r3, #28]
    thread_ptr -> tx_thread_inherit_priority =  ((UINT) TX_MAX_PRIORITIES);
 800b7a6:	68fb      	ldr	r3, [r7, #12]
 800b7a8:	2220      	movs	r2, #32
 800b7aa:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0

    /* Calculate the end of the thread's stack area.  */
    temp_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(stack_start);
 800b7ae:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800b7b0:	63fb      	str	r3, [r7, #60]	; 0x3c
    temp_ptr =  (TX_UCHAR_POINTER_ADD(temp_ptr, (stack_size - ((ULONG) 1))));
 800b7b2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b7b4:	3b01      	subs	r3, #1
 800b7b6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800b7b8:	4413      	add	r3, r2
 800b7ba:	63fb      	str	r3, [r7, #60]	; 0x3c
    thread_ptr -> tx_thread_stack_end =         TX_UCHAR_TO_VOID_POINTER_CONVERT(temp_ptr);
 800b7bc:	68fb      	ldr	r3, [r7, #12]
 800b7be:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800b7c0:	611a      	str	r2, [r3, #16]

#ifndef TX_DISABLE_PREEMPTION_THRESHOLD

    /* Preemption-threshold is enabled, setup accordingly.  */
    thread_ptr -> tx_thread_preempt_threshold =       preempt_threshold;
 800b7c2:	68fb      	ldr	r3, [r7, #12]
 800b7c4:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800b7c6:	63da      	str	r2, [r3, #60]	; 0x3c
    thread_ptr -> tx_thread_user_preempt_threshold =  preempt_threshold;
 800b7c8:	68fb      	ldr	r3, [r7, #12]
 800b7ca:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800b7cc:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
        thread_ptr -> tx_thread_user_preempt_threshold =  priority;
    }
#endif

    /* Now fill in the values that are required for thread initialization.  */
    thread_ptr -> tx_thread_state =  TX_SUSPENDED;
 800b7d0:	68fb      	ldr	r3, [r7, #12]
 800b7d2:	2203      	movs	r2, #3
 800b7d4:	631a      	str	r2, [r3, #48]	; 0x30

    /* Setup the necessary fields in the thread timer block.  */
    TX_THREAD_CREATE_TIMEOUT_SETUP(thread_ptr)
 800b7d6:	68fb      	ldr	r3, [r7, #12]
 800b7d8:	4a48      	ldr	r2, [pc, #288]	; (800b8fc <_tx_thread_create+0x1b4>)
 800b7da:	655a      	str	r2, [r3, #84]	; 0x54
 800b7dc:	68fa      	ldr	r2, [r7, #12]
 800b7de:	68fb      	ldr	r3, [r7, #12]
 800b7e0:	659a      	str	r2, [r3, #88]	; 0x58
    TX_THREAD_CREATE_INTERNAL_EXTENSION(thread_ptr)

    /* Call the target specific stack frame building routine to build the
       thread's initial stack and to setup the actual stack pointer in the
       control block.  */
    _tx_thread_stack_build(thread_ptr, _tx_thread_shell_entry);
 800b7e2:	4947      	ldr	r1, [pc, #284]	; (800b900 <_tx_thread_create+0x1b8>)
 800b7e4:	68f8      	ldr	r0, [r7, #12]
 800b7e6:	f7f4 ffad 	bl	8000744 <_tx_thread_stack_build>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b7ea:	f3ef 8310 	mrs	r3, PRIMASK
 800b7ee:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800b7f0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800b7f2:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800b7f4:	b672      	cpsid	i
    return(int_posture);
 800b7f6:	6abb      	ldr	r3, [r7, #40]	; 0x28
    /* Setup the highest usage stack pointer.  */
    thread_ptr -> tx_thread_stack_highest_ptr =  thread_ptr -> tx_thread_stack_ptr;
#endif

    /* Prepare to make this thread a member of the created thread list.  */
    TX_DISABLE
 800b7f8:	63bb      	str	r3, [r7, #56]	; 0x38

    /* Load the thread ID field in the thread control block.  */
    thread_ptr -> tx_thread_id =  TX_THREAD_ID;
 800b7fa:	68fb      	ldr	r3, [r7, #12]
 800b7fc:	4a41      	ldr	r2, [pc, #260]	; (800b904 <_tx_thread_create+0x1bc>)
 800b7fe:	601a      	str	r2, [r3, #0]

    /* Place the thread on the list of created threads.  First,
       check for an empty list.  */
    if (_tx_thread_created_count == TX_EMPTY)
 800b800:	4b41      	ldr	r3, [pc, #260]	; (800b908 <_tx_thread_create+0x1c0>)
 800b802:	681b      	ldr	r3, [r3, #0]
 800b804:	2b00      	cmp	r3, #0
 800b806:	d10b      	bne.n	800b820 <_tx_thread_create+0xd8>
    {

        /* The created thread list is empty.  Add thread to empty list.  */
        _tx_thread_created_ptr =                    thread_ptr;
 800b808:	4a40      	ldr	r2, [pc, #256]	; (800b90c <_tx_thread_create+0x1c4>)
 800b80a:	68fb      	ldr	r3, [r7, #12]
 800b80c:	6013      	str	r3, [r2, #0]
        thread_ptr -> tx_thread_created_next =      thread_ptr;
 800b80e:	68fb      	ldr	r3, [r7, #12]
 800b810:	68fa      	ldr	r2, [r7, #12]
 800b812:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        thread_ptr -> tx_thread_created_previous =  thread_ptr;
 800b816:	68fb      	ldr	r3, [r7, #12]
 800b818:	68fa      	ldr	r2, [r7, #12]
 800b81a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
 800b81e:	e016      	b.n	800b84e <_tx_thread_create+0x106>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_thread =  _tx_thread_created_ptr;
 800b820:	4b3a      	ldr	r3, [pc, #232]	; (800b90c <_tx_thread_create+0x1c4>)
 800b822:	681b      	ldr	r3, [r3, #0]
 800b824:	637b      	str	r3, [r7, #52]	; 0x34
        previous_thread =  next_thread -> tx_thread_created_previous;
 800b826:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b828:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800b82c:	633b      	str	r3, [r7, #48]	; 0x30

        /* Place the new thread in the list.  */
        next_thread -> tx_thread_created_previous =  thread_ptr;
 800b82e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b830:	68fa      	ldr	r2, [r7, #12]
 800b832:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        previous_thread -> tx_thread_created_next =  thread_ptr;
 800b836:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b838:	68fa      	ldr	r2, [r7, #12]
 800b83a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

        /* Setup this thread's created links.  */
        thread_ptr -> tx_thread_created_previous =  previous_thread;
 800b83e:	68fb      	ldr	r3, [r7, #12]
 800b840:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800b842:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        thread_ptr -> tx_thread_created_next =      next_thread;
 800b846:	68fb      	ldr	r3, [r7, #12]
 800b848:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800b84a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    }

    /* Increment the thread created count.  */
    _tx_thread_created_count++;
 800b84e:	4b2e      	ldr	r3, [pc, #184]	; (800b908 <_tx_thread_create+0x1c0>)
 800b850:	681b      	ldr	r3, [r3, #0]
 800b852:	3301      	adds	r3, #1
 800b854:	4a2c      	ldr	r2, [pc, #176]	; (800b908 <_tx_thread_create+0x1c0>)
 800b856:	6013      	str	r3, [r2, #0]
    TX_EL_THREAD_CREATE_INSERT

#ifndef TX_NOT_INTERRUPTABLE

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 800b858:	4b2d      	ldr	r3, [pc, #180]	; (800b910 <_tx_thread_create+0x1c8>)
 800b85a:	681b      	ldr	r3, [r3, #0]
 800b85c:	3301      	adds	r3, #1
 800b85e:	4a2c      	ldr	r2, [pc, #176]	; (800b910 <_tx_thread_create+0x1c8>)
 800b860:	6013      	str	r3, [r2, #0]
#endif

    /* Determine if an automatic start was requested.  If so, call the resume
       thread function and then check for a preemption condition.  */
    if (auto_start == TX_AUTO_START)
 800b862:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800b864:	2b01      	cmp	r3, #1
 800b866:	d129      	bne.n	800b8bc <_tx_thread_create+0x174>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800b868:	f3ef 8305 	mrs	r3, IPSR
 800b86c:	627b      	str	r3, [r7, #36]	; 0x24
    return(ipsr_value);
 800b86e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    {

        /* Determine if the create call is being called from initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() >= TX_INITIALIZE_IN_PROGRESS)
 800b870:	4b28      	ldr	r3, [pc, #160]	; (800b914 <_tx_thread_create+0x1cc>)
 800b872:	681b      	ldr	r3, [r3, #0]
 800b874:	4313      	orrs	r3, r2
 800b876:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800b87a:	d30d      	bcc.n	800b898 <_tx_thread_create+0x150>

            /* Pickup the current thread execute pointer, which corresponds to the
               highest priority thread ready to execute.  Interrupt lockout is
               not required, since interrupts are assumed to be disabled during
               initialization.  */
            saved_thread_ptr =  _tx_thread_execute_ptr;
 800b87c:	4b26      	ldr	r3, [pc, #152]	; (800b918 <_tx_thread_create+0x1d0>)
 800b87e:	681b      	ldr	r3, [r3, #0]
 800b880:	647b      	str	r3, [r7, #68]	; 0x44

            /* Determine if there is thread ready for execution.  */
            if (saved_thread_ptr != TX_NULL)
 800b882:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b884:	2b00      	cmp	r3, #0
 800b886:	d009      	beq.n	800b89c <_tx_thread_create+0x154>
            {

                /* Yes, a thread is ready for execution when initialization completes.  */

                /* Save the current preemption-threshold.  */
                saved_threshold =  saved_thread_ptr -> tx_thread_preempt_threshold;
 800b888:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b88a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b88c:	643b      	str	r3, [r7, #64]	; 0x40

                /* For initialization, temporarily set the preemption-threshold to the
                   priority level to make sure the highest-priority thread runs once
                   initialization is complete.  */
                saved_thread_ptr -> tx_thread_preempt_threshold =  saved_thread_ptr -> tx_thread_priority;
 800b88e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b890:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b892:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b894:	63da      	str	r2, [r3, #60]	; 0x3c
 800b896:	e001      	b.n	800b89c <_tx_thread_create+0x154>
        }
        else
        {

            /* Simply set the saved thread pointer to NULL.  */
            saved_thread_ptr =  TX_NULL;
 800b898:	2300      	movs	r3, #0
 800b89a:	647b      	str	r3, [r7, #68]	; 0x44
 800b89c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b89e:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b8a0:	6a3b      	ldr	r3, [r7, #32]
 800b8a2:	f383 8810 	msr	PRIMASK, r3
}
 800b8a6:	bf00      	nop

        /* Perform any additional activities for tool or user purpose.  */
        TX_THREAD_CREATE_EXTENSION(thread_ptr)

        /* Call the resume thread function to make this thread ready.  */
        _tx_thread_system_resume(thread_ptr);
 800b8a8:	68f8      	ldr	r0, [r7, #12]
 800b8aa:	f000 fdbf 	bl	800c42c <_tx_thread_system_resume>
#endif

        /* Determine if the thread's preemption-threshold needs to be restored.  */
        if (saved_thread_ptr != TX_NULL)
 800b8ae:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b8b0:	2b00      	cmp	r3, #0
 800b8b2:	d01e      	beq.n	800b8f2 <_tx_thread_create+0x1aa>
        {

            /* Yes, restore the previous highest-priority thread's preemption-threshold. This
               can only happen if this routine is called from initialization.  */
            saved_thread_ptr -> tx_thread_preempt_threshold =  saved_threshold;
 800b8b4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b8b6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800b8b8:	63da      	str	r2, [r3, #60]	; 0x3c
 800b8ba:	e01a      	b.n	800b8f2 <_tx_thread_create+0x1aa>
 800b8bc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b8be:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b8c0:	693b      	ldr	r3, [r7, #16]
 800b8c2:	f383 8810 	msr	PRIMASK, r3
}
 800b8c6:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b8c8:	f3ef 8310 	mrs	r3, PRIMASK
 800b8cc:	61bb      	str	r3, [r7, #24]
    return(posture);
 800b8ce:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800b8d0:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b8d2:	b672      	cpsid	i
    return(int_posture);
 800b8d4:	697b      	ldr	r3, [r7, #20]

        /* Perform any additional activities for tool or user purpose.  */
        TX_THREAD_CREATE_EXTENSION(thread_ptr)

        /* Disable interrupts.  */
        TX_DISABLE
 800b8d6:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Re-enable preemption.  */
        _tx_thread_preempt_disable--;
 800b8d8:	4b0d      	ldr	r3, [pc, #52]	; (800b910 <_tx_thread_create+0x1c8>)
 800b8da:	681b      	ldr	r3, [r3, #0]
 800b8dc:	3b01      	subs	r3, #1
 800b8de:	4a0c      	ldr	r2, [pc, #48]	; (800b910 <_tx_thread_create+0x1c8>)
 800b8e0:	6013      	str	r3, [r2, #0]
 800b8e2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b8e4:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b8e6:	69fb      	ldr	r3, [r7, #28]
 800b8e8:	f383 8810 	msr	PRIMASK, r3
}
 800b8ec:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 800b8ee:	f000 fd63 	bl	800c3b8 <_tx_thread_system_preempt_check>
#endif
    }

    /* Always return a success.  */
    return(TX_SUCCESS);
 800b8f2:	2300      	movs	r3, #0
}
 800b8f4:	4618      	mov	r0, r3
 800b8f6:	3748      	adds	r7, #72	; 0x48
 800b8f8:	46bd      	mov	sp, r7
 800b8fa:	bd80      	pop	{r7, pc}
 800b8fc:	0800cd9d 	.word	0x0800cd9d
 800b900:	0800c0f9 	.word	0x0800c0f9
 800b904:	54485244 	.word	0x54485244
 800b908:	2000efc4 	.word	0x2000efc4
 800b90c:	2000efc0 	.word	0x2000efc0
 800b910:	2000f054 	.word	0x2000f054
 800b914:	2000000c 	.word	0x2000000c
 800b918:	2000efbc 	.word	0x2000efbc

0800b91c <_tx_thread_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_delete(TX_THREAD *thread_ptr)
{
 800b91c:	b480      	push	{r7}
 800b91e:	b08b      	sub	sp, #44	; 0x2c
 800b920:	af00      	add	r7, sp, #0
 800b922:	6078      	str	r0, [r7, #4]
TX_THREAD       *previous_thread;
UINT            status;


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800b924:	2300      	movs	r3, #0
 800b926:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b928:	f3ef 8310 	mrs	r3, PRIMASK
 800b92c:	617b      	str	r3, [r7, #20]
    return(posture);
 800b92e:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800b930:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b932:	b672      	cpsid	i
    return(int_posture);
 800b934:	693b      	ldr	r3, [r7, #16]

    /* Lockout interrupts while the thread is being deleted.  */
    TX_DISABLE
 800b936:	623b      	str	r3, [r7, #32]

    /* Check for proper status of this thread to delete.  */
    if (thread_ptr -> tx_thread_state != TX_COMPLETED)
 800b938:	687b      	ldr	r3, [r7, #4]
 800b93a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b93c:	2b01      	cmp	r3, #1
 800b93e:	d00b      	beq.n	800b958 <_tx_thread_delete+0x3c>
    {

        /* Now check for terminated state.  */
        if (thread_ptr -> tx_thread_state != TX_TERMINATED)
 800b940:	687b      	ldr	r3, [r7, #4]
 800b942:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b944:	2b02      	cmp	r3, #2
 800b946:	d007      	beq.n	800b958 <_tx_thread_delete+0x3c>
 800b948:	6a3b      	ldr	r3, [r7, #32]
 800b94a:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b94c:	68fb      	ldr	r3, [r7, #12]
 800b94e:	f383 8810 	msr	PRIMASK, r3
}
 800b952:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Thread not completed or terminated - return an error!  */
            status =  TX_DELETE_ERROR;
 800b954:	2311      	movs	r3, #17
 800b956:	627b      	str	r3, [r7, #36]	; 0x24
        }
    }

    /* Determine if the delete operation is okay.  */
    if (status == TX_SUCCESS)
 800b958:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b95a:	2b00      	cmp	r3, #0
 800b95c:	d12d      	bne.n	800b9ba <_tx_thread_delete+0x9e>

        /* Unregister thread in the thread array structure.  */
        TX_EL_THREAD_UNREGISTER(thread_ptr)

        /* Clear the thread ID to make it invalid.  */
        thread_ptr -> tx_thread_id =  TX_CLEAR_ID;
 800b95e:	687b      	ldr	r3, [r7, #4]
 800b960:	2200      	movs	r2, #0
 800b962:	601a      	str	r2, [r3, #0]

        /* Decrement the number of created threads.  */
        _tx_thread_created_count--;
 800b964:	4b18      	ldr	r3, [pc, #96]	; (800b9c8 <_tx_thread_delete+0xac>)
 800b966:	681b      	ldr	r3, [r3, #0]
 800b968:	3b01      	subs	r3, #1
 800b96a:	4a17      	ldr	r2, [pc, #92]	; (800b9c8 <_tx_thread_delete+0xac>)
 800b96c:	6013      	str	r3, [r2, #0]

        /* See if the thread is the only one on the list.  */
        if (_tx_thread_created_count == TX_EMPTY)
 800b96e:	4b16      	ldr	r3, [pc, #88]	; (800b9c8 <_tx_thread_delete+0xac>)
 800b970:	681b      	ldr	r3, [r3, #0]
 800b972:	2b00      	cmp	r3, #0
 800b974:	d103      	bne.n	800b97e <_tx_thread_delete+0x62>
        {

            /* Only created thread, just set the created list to NULL.  */
            _tx_thread_created_ptr =  TX_NULL;
 800b976:	4b15      	ldr	r3, [pc, #84]	; (800b9cc <_tx_thread_delete+0xb0>)
 800b978:	2200      	movs	r2, #0
 800b97a:	601a      	str	r2, [r3, #0]
 800b97c:	e017      	b.n	800b9ae <_tx_thread_delete+0x92>
        }
        else
        {

            /* Otherwise, not the only created thread, link-up the neighbors.  */
            next_thread =                                thread_ptr -> tx_thread_created_next;
 800b97e:	687b      	ldr	r3, [r7, #4]
 800b980:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800b984:	61fb      	str	r3, [r7, #28]
            previous_thread =                            thread_ptr -> tx_thread_created_previous;
 800b986:	687b      	ldr	r3, [r7, #4]
 800b988:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800b98c:	61bb      	str	r3, [r7, #24]
            next_thread -> tx_thread_created_previous =  previous_thread;
 800b98e:	69fb      	ldr	r3, [r7, #28]
 800b990:	69ba      	ldr	r2, [r7, #24]
 800b992:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
            previous_thread -> tx_thread_created_next =  next_thread;
 800b996:	69bb      	ldr	r3, [r7, #24]
 800b998:	69fa      	ldr	r2, [r7, #28]
 800b99a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

            /* See if we have to update the created list head pointer.  */
            if (_tx_thread_created_ptr == thread_ptr)
 800b99e:	4b0b      	ldr	r3, [pc, #44]	; (800b9cc <_tx_thread_delete+0xb0>)
 800b9a0:	681b      	ldr	r3, [r3, #0]
 800b9a2:	687a      	ldr	r2, [r7, #4]
 800b9a4:	429a      	cmp	r2, r3
 800b9a6:	d102      	bne.n	800b9ae <_tx_thread_delete+0x92>
            {

                /* Yes, move the head pointer to the next link. */
                _tx_thread_created_ptr =  next_thread;
 800b9a8:	4a08      	ldr	r2, [pc, #32]	; (800b9cc <_tx_thread_delete+0xb0>)
 800b9aa:	69fb      	ldr	r3, [r7, #28]
 800b9ac:	6013      	str	r3, [r2, #0]
 800b9ae:	6a3b      	ldr	r3, [r7, #32]
 800b9b0:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b9b2:	68bb      	ldr	r3, [r7, #8]
 800b9b4:	f383 8810 	msr	PRIMASK, r3
}
 800b9b8:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Return completion status.  */
    return(status);
 800b9ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 800b9bc:	4618      	mov	r0, r3
 800b9be:	372c      	adds	r7, #44	; 0x2c
 800b9c0:	46bd      	mov	sp, r7
 800b9c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b9c6:	4770      	bx	lr
 800b9c8:	2000efc4 	.word	0x2000efc4
 800b9cc:	2000efc0 	.word	0x2000efc0

0800b9d0 <_tx_thread_entry_exit_notify>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_entry_exit_notify(TX_THREAD *thread_ptr, VOID (*thread_entry_exit_notify)(TX_THREAD *notify_thread_ptr, UINT id))
{
 800b9d0:	b480      	push	{r7}
 800b9d2:	b087      	sub	sp, #28
 800b9d4:	af00      	add	r7, sp, #0
 800b9d6:	6078      	str	r0, [r7, #4]
 800b9d8:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b9da:	f3ef 8310 	mrs	r3, PRIMASK
 800b9de:	60fb      	str	r3, [r7, #12]
    return(posture);
 800b9e0:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 800b9e2:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b9e4:	b672      	cpsid	i
    return(int_posture);
 800b9e6:	68bb      	ldr	r3, [r7, #8]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts.  */
    TX_DISABLE
 800b9e8:	617b      	str	r3, [r7, #20]

    /* Make entry in event log.  */
    TX_EL_THREAD_ENTRY_EXIT_NOTIFY_INSERT

    /* Setup thread entry/exit notification callback function.  */
    thread_ptr -> tx_thread_entry_exit_notify =  thread_entry_exit_notify;
 800b9ea:	687b      	ldr	r3, [r7, #4]
 800b9ec:	683a      	ldr	r2, [r7, #0]
 800b9ee:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 800b9f2:	697b      	ldr	r3, [r7, #20]
 800b9f4:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b9f6:	693b      	ldr	r3, [r7, #16]
 800b9f8:	f383 8810 	msr	PRIMASK, r3
}
 800b9fc:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return success to caller.  */
    return(TX_SUCCESS);
 800b9fe:	2300      	movs	r3, #0
#endif
}
 800ba00:	4618      	mov	r0, r3
 800ba02:	371c      	adds	r7, #28
 800ba04:	46bd      	mov	sp, r7
 800ba06:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ba0a:	4770      	bx	lr

0800ba0c <_tx_thread_identify>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
TX_THREAD  *_tx_thread_identify(VOID)
{
 800ba0c:	b480      	push	{r7}
 800ba0e:	b087      	sub	sp, #28
 800ba10:	af00      	add	r7, sp, #0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800ba12:	f3ef 8310 	mrs	r3, PRIMASK
 800ba16:	60bb      	str	r3, [r7, #8]
    return(posture);
 800ba18:	68bb      	ldr	r3, [r7, #8]
    int_posture = __get_interrupt_posture();
 800ba1a:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("CPSID i" : : : "memory");
 800ba1c:	b672      	cpsid	i
    return(int_posture);
 800ba1e:	687b      	ldr	r3, [r7, #4]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts to put the timer on the created list.  */
    TX_DISABLE
 800ba20:	617b      	str	r3, [r7, #20]

   /* Log this kernel call.  */
    TX_EL_THREAD_IDENTIFY_INSERT

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800ba22:	4b08      	ldr	r3, [pc, #32]	; (800ba44 <_tx_thread_identify+0x38>)
 800ba24:	681b      	ldr	r3, [r3, #0]
 800ba26:	613b      	str	r3, [r7, #16]
 800ba28:	697b      	ldr	r3, [r7, #20]
 800ba2a:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ba2c:	68fb      	ldr	r3, [r7, #12]
 800ba2e:	f383 8810 	msr	PRIMASK, r3
}
 800ba32:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return the current thread pointer.  */
    return(thread_ptr);
 800ba34:	693b      	ldr	r3, [r7, #16]
}
 800ba36:	4618      	mov	r0, r3
 800ba38:	371c      	adds	r7, #28
 800ba3a:	46bd      	mov	sp, r7
 800ba3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ba40:	4770      	bx	lr
 800ba42:	bf00      	nop
 800ba44:	2000efb8 	.word	0x2000efb8

0800ba48 <_tx_thread_info_get>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_info_get(TX_THREAD *thread_ptr, CHAR **name, UINT *state, ULONG *run_count,
                UINT *priority, UINT *preemption_threshold, ULONG *time_slice,
                TX_THREAD **next_thread, TX_THREAD **next_suspended_thread)
{
 800ba48:	b480      	push	{r7}
 800ba4a:	b089      	sub	sp, #36	; 0x24
 800ba4c:	af00      	add	r7, sp, #0
 800ba4e:	60f8      	str	r0, [r7, #12]
 800ba50:	60b9      	str	r1, [r7, #8]
 800ba52:	607a      	str	r2, [r7, #4]
 800ba54:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800ba56:	f3ef 8310 	mrs	r3, PRIMASK
 800ba5a:	61bb      	str	r3, [r7, #24]
    return(posture);
 800ba5c:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800ba5e:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800ba60:	b672      	cpsid	i
    return(int_posture);
 800ba62:	697b      	ldr	r3, [r7, #20]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts.  */
    TX_DISABLE
 800ba64:	61fb      	str	r3, [r7, #28]

    /* Retrieve all the pertinent information and return it in the supplied
       destinations.  */

    /* Retrieve the name of the thread.  */
    if (name != TX_NULL)
 800ba66:	68bb      	ldr	r3, [r7, #8]
 800ba68:	2b00      	cmp	r3, #0
 800ba6a:	d003      	beq.n	800ba74 <_tx_thread_info_get+0x2c>
    {

        *name =  thread_ptr -> tx_thread_name;
 800ba6c:	68fb      	ldr	r3, [r7, #12]
 800ba6e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800ba70:	68bb      	ldr	r3, [r7, #8]
 800ba72:	601a      	str	r2, [r3, #0]
    }

    /* Pickup the thread's current state.  */
    if (state != TX_NULL)
 800ba74:	687b      	ldr	r3, [r7, #4]
 800ba76:	2b00      	cmp	r3, #0
 800ba78:	d003      	beq.n	800ba82 <_tx_thread_info_get+0x3a>
    {

        *state =  thread_ptr -> tx_thread_state;
 800ba7a:	68fb      	ldr	r3, [r7, #12]
 800ba7c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ba7e:	687b      	ldr	r3, [r7, #4]
 800ba80:	601a      	str	r2, [r3, #0]
    }

    /* Pickup the number of times the thread has been scheduled.  */
    if (run_count != TX_NULL)
 800ba82:	683b      	ldr	r3, [r7, #0]
 800ba84:	2b00      	cmp	r3, #0
 800ba86:	d003      	beq.n	800ba90 <_tx_thread_info_get+0x48>
    {

        *run_count =  thread_ptr -> tx_thread_run_count;
 800ba88:	68fb      	ldr	r3, [r7, #12]
 800ba8a:	685a      	ldr	r2, [r3, #4]
 800ba8c:	683b      	ldr	r3, [r7, #0]
 800ba8e:	601a      	str	r2, [r3, #0]
    }

    /* Pickup the thread's priority.  */
    if (priority != TX_NULL)
 800ba90:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ba92:	2b00      	cmp	r3, #0
 800ba94:	d004      	beq.n	800baa0 <_tx_thread_info_get+0x58>
    {

        *priority =  thread_ptr -> tx_thread_user_priority;
 800ba96:	68fb      	ldr	r3, [r7, #12]
 800ba98:	f8d3 20c8 	ldr.w	r2, [r3, #200]	; 0xc8
 800ba9c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ba9e:	601a      	str	r2, [r3, #0]
    }

    /* Pickup the thread's preemption-threshold.  */
    if (preemption_threshold != TX_NULL)
 800baa0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800baa2:	2b00      	cmp	r3, #0
 800baa4:	d004      	beq.n	800bab0 <_tx_thread_info_get+0x68>
    {

        *preemption_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
 800baa6:	68fb      	ldr	r3, [r7, #12]
 800baa8:	f8d3 20cc 	ldr.w	r2, [r3, #204]	; 0xcc
 800baac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800baae:	601a      	str	r2, [r3, #0]
    }

    /* Pickup the thread's current time-slice.  */
    if (time_slice != TX_NULL)
 800bab0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bab2:	2b00      	cmp	r3, #0
 800bab4:	d003      	beq.n	800babe <_tx_thread_info_get+0x76>
    {

        *time_slice =  thread_ptr -> tx_thread_time_slice;
 800bab6:	68fb      	ldr	r3, [r7, #12]
 800bab8:	699a      	ldr	r2, [r3, #24]
 800baba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800babc:	601a      	str	r2, [r3, #0]
    }

    /* Pickup the next created thread.  */
    if (next_thread != TX_NULL)
 800babe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bac0:	2b00      	cmp	r3, #0
 800bac2:	d004      	beq.n	800bace <_tx_thread_info_get+0x86>
    {

        *next_thread =  thread_ptr -> tx_thread_created_next;
 800bac4:	68fb      	ldr	r3, [r7, #12]
 800bac6:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800baca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bacc:	601a      	str	r2, [r3, #0]
    }

    /* Pickup the next thread suspended.  */
    if (next_suspended_thread != TX_NULL)
 800bace:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bad0:	2b00      	cmp	r3, #0
 800bad2:	d003      	beq.n	800badc <_tx_thread_info_get+0x94>
    {

        *next_suspended_thread =  thread_ptr -> tx_thread_suspended_next;
 800bad4:	68fb      	ldr	r3, [r7, #12]
 800bad6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800bad8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bada:	601a      	str	r2, [r3, #0]
 800badc:	69fb      	ldr	r3, [r7, #28]
 800bade:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800bae0:	693b      	ldr	r3, [r7, #16]
 800bae2:	f383 8810 	msr	PRIMASK, r3
}
 800bae6:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(TX_SUCCESS);
 800bae8:	2300      	movs	r3, #0
}
 800baea:	4618      	mov	r0, r3
 800baec:	3724      	adds	r7, #36	; 0x24
 800baee:	46bd      	mov	sp, r7
 800baf0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800baf4:	4770      	bx	lr
	...

0800baf8 <_tx_thread_initialize>:
/*                                            stack check error handling, */
/*                                            resulting in version 6.1.9  */   
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_initialize(VOID)
{
 800baf8:	b580      	push	{r7, lr}
 800bafa:	af00      	add	r7, sp, #0
       respectively.  */

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Set current thread pointer to NULL.  */
    TX_THREAD_SET_CURRENT(TX_NULL)
 800bafc:	4b13      	ldr	r3, [pc, #76]	; (800bb4c <_tx_thread_initialize+0x54>)
 800bafe:	2200      	movs	r2, #0
 800bb00:	601a      	str	r2, [r3, #0]

    /* Initialize the execute thread pointer to NULL.  */
    _tx_thread_execute_ptr =  TX_NULL;
 800bb02:	4b13      	ldr	r3, [pc, #76]	; (800bb50 <_tx_thread_initialize+0x58>)
 800bb04:	2200      	movs	r2, #0
 800bb06:	601a      	str	r2, [r3, #0]
 800bb08:	4b12      	ldr	r3, [pc, #72]	; (800bb54 <_tx_thread_initialize+0x5c>)
 800bb0a:	2200      	movs	r2, #0
 800bb0c:	601a      	str	r2, [r3, #0]
 800bb0e:	4b12      	ldr	r3, [pc, #72]	; (800bb58 <_tx_thread_initialize+0x60>)
 800bb10:	2200      	movs	r2, #0
 800bb12:	601a      	str	r2, [r3, #0]
#endif
#endif

    /* Setup the highest priority variable to the max, indicating no thread is currently
       ready.  */
    _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
 800bb14:	4b11      	ldr	r3, [pc, #68]	; (800bb5c <_tx_thread_initialize+0x64>)
 800bb16:	2220      	movs	r2, #32
 800bb18:	601a      	str	r2, [r3, #0]


#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Initialize the array of priority head pointers.  */
    TX_MEMSET(&_tx_thread_priority_list[0], 0, (sizeof(_tx_thread_priority_list)));
 800bb1a:	2280      	movs	r2, #128	; 0x80
 800bb1c:	2100      	movs	r1, #0
 800bb1e:	4810      	ldr	r0, [pc, #64]	; (800bb60 <_tx_thread_initialize+0x68>)
 800bb20:	f00a ff60 	bl	80169e4 <memset>

    /* Initialize the head pointer of the created threads list and the
       number of threads created.  */
    _tx_thread_created_ptr =        TX_NULL;
 800bb24:	4b0f      	ldr	r3, [pc, #60]	; (800bb64 <_tx_thread_initialize+0x6c>)
 800bb26:	2200      	movs	r2, #0
 800bb28:	601a      	str	r2, [r3, #0]
    _tx_thread_created_count =      TX_EMPTY;
 800bb2a:	4b0f      	ldr	r3, [pc, #60]	; (800bb68 <_tx_thread_initialize+0x70>)
 800bb2c:	2200      	movs	r2, #0
 800bb2e:	601a      	str	r2, [r3, #0]

    /* Clear the global preempt disable variable.  */
    _tx_thread_preempt_disable =    ((UINT) 0);
 800bb30:	4b0e      	ldr	r3, [pc, #56]	; (800bb6c <_tx_thread_initialize+0x74>)
 800bb32:	2200      	movs	r2, #0
 800bb34:	601a      	str	r2, [r3, #0]

    /* Initialize the thread mutex release function pointer.  */
    _tx_thread_mutex_release =      TX_NULL;
 800bb36:	4b0e      	ldr	r3, [pc, #56]	; (800bb70 <_tx_thread_initialize+0x78>)
 800bb38:	2200      	movs	r2, #0
 800bb3a:	601a      	str	r2, [r3, #0]
#endif
#endif

    /* Setup the build options flag. This is used to identify how the ThreadX library was constructed.  */
    _tx_build_options =  _tx_build_options 
                            | (((ULONG) (TX_MAX_PRIORITIES/32)) << 24) 
 800bb3c:	4b0d      	ldr	r3, [pc, #52]	; (800bb74 <_tx_thread_initialize+0x7c>)
 800bb3e:	681b      	ldr	r3, [r3, #0]
 800bb40:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    _tx_build_options =  _tx_build_options 
 800bb44:	4a0b      	ldr	r2, [pc, #44]	; (800bb74 <_tx_thread_initialize+0x7c>)
 800bb46:	6013      	str	r3, [r2, #0]
#endif
#if TX_PORT_SPECIFIC_BUILD_OPTIONS != 0
                            | TX_PORT_SPECIFIC_BUILD_OPTIONS
#endif
                            ;
}
 800bb48:	bf00      	nop
 800bb4a:	bd80      	pop	{r7, pc}
 800bb4c:	2000efb8 	.word	0x2000efb8
 800bb50:	2000efbc 	.word	0x2000efbc
 800bb54:	2000efc8 	.word	0x2000efc8
 800bb58:	2000efcc 	.word	0x2000efcc
 800bb5c:	2000efd0 	.word	0x2000efd0
 800bb60:	2000efd4 	.word	0x2000efd4
 800bb64:	2000efc0 	.word	0x2000efc0
 800bb68:	2000efc4 	.word	0x2000efc4
 800bb6c:	2000f054 	.word	0x2000f054
 800bb70:	2000f058 	.word	0x2000f058
 800bb74:	2000f05c 	.word	0x2000f05c

0800bb78 <_tx_thread_performance_info_get>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_performance_info_get(TX_THREAD *thread_ptr, ULONG *resumptions, ULONG *suspensions,
                ULONG *solicited_preemptions, ULONG *interrupt_preemptions, ULONG *priority_inversions,
                ULONG *time_slices, ULONG *relinquishes, ULONG *timeouts, ULONG *wait_aborts, TX_THREAD **last_preempted_by)
{
 800bb78:	b480      	push	{r7}
 800bb7a:	b087      	sub	sp, #28
 800bb7c:	af00      	add	r7, sp, #0
 800bb7e:	60f8      	str	r0, [r7, #12]
 800bb80:	60b9      	str	r1, [r7, #8]
 800bb82:	607a      	str	r2, [r7, #4]
 800bb84:	603b      	str	r3, [r7, #0]
#else
UINT                    status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (thread_ptr != TX_NULL)
 800bb86:	68fb      	ldr	r3, [r7, #12]
 800bb88:	2b00      	cmp	r3, #0
 800bb8a:	d002      	beq.n	800bb92 <_tx_thread_performance_info_get+0x1a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bb8c:	23ff      	movs	r3, #255	; 0xff
 800bb8e:	617b      	str	r3, [r7, #20]
 800bb90:	e03d      	b.n	800bc0e <_tx_thread_performance_info_get+0x96>
    }
    else if (resumptions != TX_NULL)
 800bb92:	68bb      	ldr	r3, [r7, #8]
 800bb94:	2b00      	cmp	r3, #0
 800bb96:	d002      	beq.n	800bb9e <_tx_thread_performance_info_get+0x26>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bb98:	23ff      	movs	r3, #255	; 0xff
 800bb9a:	617b      	str	r3, [r7, #20]
 800bb9c:	e037      	b.n	800bc0e <_tx_thread_performance_info_get+0x96>
    }
    else if (suspensions != TX_NULL)
 800bb9e:	687b      	ldr	r3, [r7, #4]
 800bba0:	2b00      	cmp	r3, #0
 800bba2:	d002      	beq.n	800bbaa <_tx_thread_performance_info_get+0x32>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bba4:	23ff      	movs	r3, #255	; 0xff
 800bba6:	617b      	str	r3, [r7, #20]
 800bba8:	e031      	b.n	800bc0e <_tx_thread_performance_info_get+0x96>
    }
    else if (solicited_preemptions != TX_NULL)
 800bbaa:	683b      	ldr	r3, [r7, #0]
 800bbac:	2b00      	cmp	r3, #0
 800bbae:	d002      	beq.n	800bbb6 <_tx_thread_performance_info_get+0x3e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bbb0:	23ff      	movs	r3, #255	; 0xff
 800bbb2:	617b      	str	r3, [r7, #20]
 800bbb4:	e02b      	b.n	800bc0e <_tx_thread_performance_info_get+0x96>
    }
    else if (interrupt_preemptions != TX_NULL)
 800bbb6:	6a3b      	ldr	r3, [r7, #32]
 800bbb8:	2b00      	cmp	r3, #0
 800bbba:	d002      	beq.n	800bbc2 <_tx_thread_performance_info_get+0x4a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bbbc:	23ff      	movs	r3, #255	; 0xff
 800bbbe:	617b      	str	r3, [r7, #20]
 800bbc0:	e025      	b.n	800bc0e <_tx_thread_performance_info_get+0x96>
    }
    else if (priority_inversions != TX_NULL)
 800bbc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bbc4:	2b00      	cmp	r3, #0
 800bbc6:	d002      	beq.n	800bbce <_tx_thread_performance_info_get+0x56>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bbc8:	23ff      	movs	r3, #255	; 0xff
 800bbca:	617b      	str	r3, [r7, #20]
 800bbcc:	e01f      	b.n	800bc0e <_tx_thread_performance_info_get+0x96>
    }
    else if (time_slices != TX_NULL)
 800bbce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bbd0:	2b00      	cmp	r3, #0
 800bbd2:	d002      	beq.n	800bbda <_tx_thread_performance_info_get+0x62>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bbd4:	23ff      	movs	r3, #255	; 0xff
 800bbd6:	617b      	str	r3, [r7, #20]
 800bbd8:	e019      	b.n	800bc0e <_tx_thread_performance_info_get+0x96>
    }
    else if (relinquishes != TX_NULL)
 800bbda:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bbdc:	2b00      	cmp	r3, #0
 800bbde:	d002      	beq.n	800bbe6 <_tx_thread_performance_info_get+0x6e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bbe0:	23ff      	movs	r3, #255	; 0xff
 800bbe2:	617b      	str	r3, [r7, #20]
 800bbe4:	e013      	b.n	800bc0e <_tx_thread_performance_info_get+0x96>
    }
    else if (timeouts != TX_NULL)
 800bbe6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bbe8:	2b00      	cmp	r3, #0
 800bbea:	d002      	beq.n	800bbf2 <_tx_thread_performance_info_get+0x7a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bbec:	23ff      	movs	r3, #255	; 0xff
 800bbee:	617b      	str	r3, [r7, #20]
 800bbf0:	e00d      	b.n	800bc0e <_tx_thread_performance_info_get+0x96>
    }
    else if (wait_aborts != TX_NULL)
 800bbf2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bbf4:	2b00      	cmp	r3, #0
 800bbf6:	d002      	beq.n	800bbfe <_tx_thread_performance_info_get+0x86>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bbf8:	23ff      	movs	r3, #255	; 0xff
 800bbfa:	617b      	str	r3, [r7, #20]
 800bbfc:	e007      	b.n	800bc0e <_tx_thread_performance_info_get+0x96>
    }
    else if (last_preempted_by != TX_NULL)
 800bbfe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bc00:	2b00      	cmp	r3, #0
 800bc02:	d002      	beq.n	800bc0a <_tx_thread_performance_info_get+0x92>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bc04:	23ff      	movs	r3, #255	; 0xff
 800bc06:	617b      	str	r3, [r7, #20]
 800bc08:	e001      	b.n	800bc0e <_tx_thread_performance_info_get+0x96>
    }
    else
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bc0a:	23ff      	movs	r3, #255	; 0xff
 800bc0c:	617b      	str	r3, [r7, #20]
    }
#endif

    /* Return completion status.  */
    return(status);
 800bc0e:	697b      	ldr	r3, [r7, #20]
}
 800bc10:	4618      	mov	r0, r3
 800bc12:	371c      	adds	r7, #28
 800bc14:	46bd      	mov	sp, r7
 800bc16:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bc1a:	4770      	bx	lr

0800bc1c <_tx_thread_performance_system_info_get>:
/**************************************************************************/
UINT  _tx_thread_performance_system_info_get(ULONG *resumptions, ULONG *suspensions,
                ULONG *solicited_preemptions, ULONG *interrupt_preemptions, ULONG *priority_inversions,
                ULONG *time_slices, ULONG *relinquishes, ULONG *timeouts, ULONG *wait_aborts,
                ULONG *non_idle_returns, ULONG *idle_returns)
{
 800bc1c:	b480      	push	{r7}
 800bc1e:	b087      	sub	sp, #28
 800bc20:	af00      	add	r7, sp, #0
 800bc22:	60f8      	str	r0, [r7, #12]
 800bc24:	60b9      	str	r1, [r7, #8]
 800bc26:	607a      	str	r2, [r7, #4]
 800bc28:	603b      	str	r3, [r7, #0]

UINT        status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (resumptions != TX_NULL)
 800bc2a:	68fb      	ldr	r3, [r7, #12]
 800bc2c:	2b00      	cmp	r3, #0
 800bc2e:	d002      	beq.n	800bc36 <_tx_thread_performance_system_info_get+0x1a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bc30:	23ff      	movs	r3, #255	; 0xff
 800bc32:	617b      	str	r3, [r7, #20]
 800bc34:	e03d      	b.n	800bcb2 <_tx_thread_performance_system_info_get+0x96>
    }
    else if (suspensions != TX_NULL)
 800bc36:	68bb      	ldr	r3, [r7, #8]
 800bc38:	2b00      	cmp	r3, #0
 800bc3a:	d002      	beq.n	800bc42 <_tx_thread_performance_system_info_get+0x26>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bc3c:	23ff      	movs	r3, #255	; 0xff
 800bc3e:	617b      	str	r3, [r7, #20]
 800bc40:	e037      	b.n	800bcb2 <_tx_thread_performance_system_info_get+0x96>
    }
    else if (solicited_preemptions != TX_NULL)
 800bc42:	687b      	ldr	r3, [r7, #4]
 800bc44:	2b00      	cmp	r3, #0
 800bc46:	d002      	beq.n	800bc4e <_tx_thread_performance_system_info_get+0x32>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bc48:	23ff      	movs	r3, #255	; 0xff
 800bc4a:	617b      	str	r3, [r7, #20]
 800bc4c:	e031      	b.n	800bcb2 <_tx_thread_performance_system_info_get+0x96>
    }
    else if (interrupt_preemptions != TX_NULL)
 800bc4e:	683b      	ldr	r3, [r7, #0]
 800bc50:	2b00      	cmp	r3, #0
 800bc52:	d002      	beq.n	800bc5a <_tx_thread_performance_system_info_get+0x3e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bc54:	23ff      	movs	r3, #255	; 0xff
 800bc56:	617b      	str	r3, [r7, #20]
 800bc58:	e02b      	b.n	800bcb2 <_tx_thread_performance_system_info_get+0x96>
    }
    else if (priority_inversions != TX_NULL)
 800bc5a:	6a3b      	ldr	r3, [r7, #32]
 800bc5c:	2b00      	cmp	r3, #0
 800bc5e:	d002      	beq.n	800bc66 <_tx_thread_performance_system_info_get+0x4a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bc60:	23ff      	movs	r3, #255	; 0xff
 800bc62:	617b      	str	r3, [r7, #20]
 800bc64:	e025      	b.n	800bcb2 <_tx_thread_performance_system_info_get+0x96>
    }
    else if (time_slices != TX_NULL)
 800bc66:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bc68:	2b00      	cmp	r3, #0
 800bc6a:	d002      	beq.n	800bc72 <_tx_thread_performance_system_info_get+0x56>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bc6c:	23ff      	movs	r3, #255	; 0xff
 800bc6e:	617b      	str	r3, [r7, #20]
 800bc70:	e01f      	b.n	800bcb2 <_tx_thread_performance_system_info_get+0x96>
    }
    else if (relinquishes != TX_NULL)
 800bc72:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bc74:	2b00      	cmp	r3, #0
 800bc76:	d002      	beq.n	800bc7e <_tx_thread_performance_system_info_get+0x62>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bc78:	23ff      	movs	r3, #255	; 0xff
 800bc7a:	617b      	str	r3, [r7, #20]
 800bc7c:	e019      	b.n	800bcb2 <_tx_thread_performance_system_info_get+0x96>
    }
    else if (timeouts != TX_NULL)
 800bc7e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bc80:	2b00      	cmp	r3, #0
 800bc82:	d002      	beq.n	800bc8a <_tx_thread_performance_system_info_get+0x6e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bc84:	23ff      	movs	r3, #255	; 0xff
 800bc86:	617b      	str	r3, [r7, #20]
 800bc88:	e013      	b.n	800bcb2 <_tx_thread_performance_system_info_get+0x96>
    }
    else if (wait_aborts != TX_NULL)
 800bc8a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bc8c:	2b00      	cmp	r3, #0
 800bc8e:	d002      	beq.n	800bc96 <_tx_thread_performance_system_info_get+0x7a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bc90:	23ff      	movs	r3, #255	; 0xff
 800bc92:	617b      	str	r3, [r7, #20]
 800bc94:	e00d      	b.n	800bcb2 <_tx_thread_performance_system_info_get+0x96>
    }
    else if (non_idle_returns != TX_NULL)
 800bc96:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bc98:	2b00      	cmp	r3, #0
 800bc9a:	d002      	beq.n	800bca2 <_tx_thread_performance_system_info_get+0x86>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bc9c:	23ff      	movs	r3, #255	; 0xff
 800bc9e:	617b      	str	r3, [r7, #20]
 800bca0:	e007      	b.n	800bcb2 <_tx_thread_performance_system_info_get+0x96>
    }
    else if (idle_returns != TX_NULL)
 800bca2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bca4:	2b00      	cmp	r3, #0
 800bca6:	d002      	beq.n	800bcae <_tx_thread_performance_system_info_get+0x92>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bca8:	23ff      	movs	r3, #255	; 0xff
 800bcaa:	617b      	str	r3, [r7, #20]
 800bcac:	e001      	b.n	800bcb2 <_tx_thread_performance_system_info_get+0x96>
    }
    else
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800bcae:	23ff      	movs	r3, #255	; 0xff
 800bcb0:	617b      	str	r3, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 800bcb2:	697b      	ldr	r3, [r7, #20]
#endif
}
 800bcb4:	4618      	mov	r0, r3
 800bcb6:	371c      	adds	r7, #28
 800bcb8:	46bd      	mov	sp, r7
 800bcba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bcbe:	4770      	bx	lr

0800bcc0 <_tx_thread_preemption_change>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_preemption_change(TX_THREAD *thread_ptr, UINT new_threshold, UINT *old_threshold)
{
 800bcc0:	b580      	push	{r7, lr}
 800bcc2:	b08e      	sub	sp, #56	; 0x38
 800bcc4:	af00      	add	r7, sp, #0
 800bcc6:	60f8      	str	r0, [r7, #12]
 800bcc8:	60b9      	str	r1, [r7, #8]
 800bcca:	607a      	str	r2, [r7, #4]
#endif
UINT        status;


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800bccc:	2300      	movs	r3, #0
 800bcce:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800bcd0:	f3ef 8310 	mrs	r3, PRIMASK
 800bcd4:	62bb      	str	r3, [r7, #40]	; 0x28
    return(posture);
 800bcd6:	6abb      	ldr	r3, [r7, #40]	; 0x28
    int_posture = __get_interrupt_posture();
 800bcd8:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
 800bcda:	b672      	cpsid	i
    return(int_posture);
 800bcdc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
        }
    }
#endif

    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
 800bcde:	637b      	str	r3, [r7, #52]	; 0x34

    /* Log this kernel call.  */
    TX_EL_THREAD_PREEMPTION_CHANGE_INSERT

    /* Determine if the new threshold is greater than the current user priority.  */
    if (new_threshold > thread_ptr -> tx_thread_user_priority)
 800bce0:	68fb      	ldr	r3, [r7, #12]
 800bce2:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 800bce6:	68ba      	ldr	r2, [r7, #8]
 800bce8:	429a      	cmp	r2, r3
 800bcea:	d902      	bls.n	800bcf2 <_tx_thread_preemption_change+0x32>
    {

        /* Return error.  */
        status =  TX_THRESH_ERROR;
 800bcec:	2318      	movs	r3, #24
 800bcee:	633b      	str	r3, [r7, #48]	; 0x30
 800bcf0:	e06b      	b.n	800bdca <_tx_thread_preemption_change+0x10a>
    {

#ifndef TX_DISABLE_PREEMPTION_THRESHOLD

        /* Determine if the new threshold is the same as the priority.  */
        if (thread_ptr -> tx_thread_user_priority == new_threshold)
 800bcf2:	68fb      	ldr	r3, [r7, #12]
 800bcf4:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 800bcf8:	68ba      	ldr	r2, [r7, #8]
 800bcfa:	429a      	cmp	r2, r3
 800bcfc:	d114      	bne.n	800bd28 <_tx_thread_preemption_change+0x68>
        {

            /* Determine if this thread is at the head of the list.  */
            if (_tx_thread_priority_list[thread_ptr -> tx_thread_priority] == thread_ptr)
 800bcfe:	68fb      	ldr	r3, [r7, #12]
 800bd00:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bd02:	4a37      	ldr	r2, [pc, #220]	; (800bde0 <_tx_thread_preemption_change+0x120>)
 800bd04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800bd08:	68fa      	ldr	r2, [r7, #12]
 800bd0a:	429a      	cmp	r2, r3
 800bd0c:	d10c      	bne.n	800bd28 <_tx_thread_preemption_change+0x68>
                map_index =  (thread_ptr -> tx_thread_priority)/((UINT) 32);
#endif

                /* Yes, this thread is at the front of the list.  Make sure
                   the preempted bit is cleared for this thread.  */
                TX_MOD32_BIT_SET(thread_ptr -> tx_thread_priority, priority_bit)
 800bd0e:	68fb      	ldr	r3, [r7, #12]
 800bd10:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bd12:	2201      	movs	r2, #1
 800bd14:	fa02 f303 	lsl.w	r3, r2, r3
 800bd18:	62fb      	str	r3, [r7, #44]	; 0x2c
                _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] & (~(priority_bit));
 800bd1a:	4b32      	ldr	r3, [pc, #200]	; (800bde4 <_tx_thread_preemption_change+0x124>)
 800bd1c:	681a      	ldr	r2, [r3, #0]
 800bd1e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd20:	43db      	mvns	r3, r3
 800bd22:	4013      	ands	r3, r2
 800bd24:	4a2f      	ldr	r2, [pc, #188]	; (800bde4 <_tx_thread_preemption_change+0x124>)
 800bd26:	6013      	str	r3, [r2, #0]
            }
        }
#endif

        /* Return the user's preemption-threshold.   */
        *old_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
 800bd28:	68fb      	ldr	r3, [r7, #12]
 800bd2a:	f8d3 20cc 	ldr.w	r2, [r3, #204]	; 0xcc
 800bd2e:	687b      	ldr	r3, [r7, #4]
 800bd30:	601a      	str	r2, [r3, #0]

        /* Setup the new threshold.  */
        thread_ptr -> tx_thread_user_preempt_threshold =  new_threshold;
 800bd32:	68fb      	ldr	r3, [r7, #12]
 800bd34:	68ba      	ldr	r2, [r7, #8]
 800bd36:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc

        /* Determine if the new threshold represents a higher priority than the priority inheritance threshold.  */
        if (new_threshold < thread_ptr -> tx_thread_inherit_priority)
 800bd3a:	68fb      	ldr	r3, [r7, #12]
 800bd3c:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 800bd40:	68ba      	ldr	r2, [r7, #8]
 800bd42:	429a      	cmp	r2, r3
 800bd44:	d203      	bcs.n	800bd4e <_tx_thread_preemption_change+0x8e>
        {

            /* Update the actual preemption-threshold with the new threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  new_threshold;
 800bd46:	68fb      	ldr	r3, [r7, #12]
 800bd48:	68ba      	ldr	r2, [r7, #8]
 800bd4a:	63da      	str	r2, [r3, #60]	; 0x3c
 800bd4c:	e004      	b.n	800bd58 <_tx_thread_preemption_change+0x98>
        }
        else
        {

            /* Update the actual preemption-threshold with the priority inheritance.  */
            thread_ptr -> tx_thread_preempt_threshold =  thread_ptr -> tx_thread_inherit_priority;
 800bd4e:	68fb      	ldr	r3, [r7, #12]
 800bd50:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
 800bd54:	68fb      	ldr	r3, [r7, #12]
 800bd56:	63da      	str	r2, [r3, #60]	; 0x3c
        }

        /* Is the thread priority less than the current highest priority?  If not, no preemption is required.  */
        if (_tx_thread_highest_priority < thread_ptr -> tx_thread_priority)
 800bd58:	68fb      	ldr	r3, [r7, #12]
 800bd5a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800bd5c:	4b22      	ldr	r3, [pc, #136]	; (800bde8 <_tx_thread_preemption_change+0x128>)
 800bd5e:	681b      	ldr	r3, [r3, #0]
 800bd60:	429a      	cmp	r2, r3
 800bd62:	d932      	bls.n	800bdca <_tx_thread_preemption_change+0x10a>
        {

            /* Is the new thread preemption-threshold less than the current highest priority?  If not, no preemption is required.  */
            if (_tx_thread_highest_priority < new_threshold)
 800bd64:	4b20      	ldr	r3, [pc, #128]	; (800bde8 <_tx_thread_preemption_change+0x128>)
 800bd66:	681b      	ldr	r3, [r3, #0]
 800bd68:	68ba      	ldr	r2, [r7, #8]
 800bd6a:	429a      	cmp	r2, r3
 800bd6c:	d92d      	bls.n	800bdca <_tx_thread_preemption_change+0x10a>
            {

                /* If the current execute pointer is the same at this thread, preemption needs to take place.  */
                if (_tx_thread_execute_ptr == thread_ptr)
 800bd6e:	4b1f      	ldr	r3, [pc, #124]	; (800bdec <_tx_thread_preemption_change+0x12c>)
 800bd70:	681b      	ldr	r3, [r3, #0]
 800bd72:	68fa      	ldr	r2, [r7, #12]
 800bd74:	429a      	cmp	r2, r3
 800bd76:	d128      	bne.n	800bdca <_tx_thread_preemption_change+0x10a>
                    /* Preemption needs to take place.  */

#ifndef TX_DISABLE_PREEMPTION_THRESHOLD

                    /* Determine if this thread has preemption threshold set.  */
                    if (thread_ptr -> tx_thread_preempt_threshold != thread_ptr -> tx_thread_priority)
 800bd78:	68fb      	ldr	r3, [r7, #12]
 800bd7a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800bd7c:	68fb      	ldr	r3, [r7, #12]
 800bd7e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bd80:	429a      	cmp	r2, r3
 800bd82:	d00b      	beq.n	800bd9c <_tx_thread_preemption_change+0xdc>
                        TX_DIV32_BIT_SET(thread_ptr -> tx_thread_priority, priority_bit)
                        _tx_thread_preempted_map_active =  _tx_thread_preempted_map_active | priority_bit;
#endif

                        /* Remember that this thread was preempted by a thread above the thread's threshold.  */
                        TX_MOD32_BIT_SET(thread_ptr -> tx_thread_priority, priority_bit)
 800bd84:	68fb      	ldr	r3, [r7, #12]
 800bd86:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bd88:	2201      	movs	r2, #1
 800bd8a:	fa02 f303 	lsl.w	r3, r2, r3
 800bd8e:	62fb      	str	r3, [r7, #44]	; 0x2c
                        _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] | priority_bit;
 800bd90:	4b14      	ldr	r3, [pc, #80]	; (800bde4 <_tx_thread_preemption_change+0x124>)
 800bd92:	681a      	ldr	r2, [r3, #0]
 800bd94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd96:	4313      	orrs	r3, r2
 800bd98:	4a12      	ldr	r2, [pc, #72]	; (800bde4 <_tx_thread_preemption_change+0x124>)
 800bd9a:	6013      	str	r3, [r2, #0]
                        _tx_thread_performance_execute_log[_tx_thread_performance__execute_log_index] =  _tx_thread_execute_ptr;
                    }
#endif

                    /* Setup the highest priority thread to execute.  */
                    _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 800bd9c:	4b12      	ldr	r3, [pc, #72]	; (800bde8 <_tx_thread_preemption_change+0x128>)
 800bd9e:	681b      	ldr	r3, [r3, #0]
 800bda0:	4a0f      	ldr	r2, [pc, #60]	; (800bde0 <_tx_thread_preemption_change+0x120>)
 800bda2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800bda6:	4a11      	ldr	r2, [pc, #68]	; (800bdec <_tx_thread_preemption_change+0x12c>)
 800bda8:	6013      	str	r3, [r2, #0]
 800bdaa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bdac:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800bdae:	69bb      	ldr	r3, [r7, #24]
 800bdb0:	f383 8810 	msr	PRIMASK, r3
}
 800bdb4:	bf00      	nop

                    /* Restore interrupts.  */
                    TX_RESTORE

                    /* Check for preemption.  */
                    _tx_thread_system_preempt_check();
 800bdb6:	f000 faff 	bl	800c3b8 <_tx_thread_system_preempt_check>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800bdba:	f3ef 8310 	mrs	r3, PRIMASK
 800bdbe:	623b      	str	r3, [r7, #32]
    return(posture);
 800bdc0:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 800bdc2:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 800bdc4:	b672      	cpsid	i
    return(int_posture);
 800bdc6:	69fb      	ldr	r3, [r7, #28]

                    /* Disable interrupts.  */
                    TX_DISABLE
 800bdc8:	637b      	str	r3, [r7, #52]	; 0x34
 800bdca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bdcc:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800bdce:	697b      	ldr	r3, [r7, #20]
 800bdd0:	f383 8810 	msr	PRIMASK, r3
}
 800bdd4:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(status);
 800bdd6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
}
 800bdd8:	4618      	mov	r0, r3
 800bdda:	3738      	adds	r7, #56	; 0x38
 800bddc:	46bd      	mov	sp, r7
 800bdde:	bd80      	pop	{r7, pc}
 800bde0:	2000efd4 	.word	0x2000efd4
 800bde4:	2000efcc 	.word	0x2000efcc
 800bde8:	2000efd0 	.word	0x2000efd0
 800bdec:	2000efbc 	.word	0x2000efbc

0800bdf0 <_tx_thread_priority_change>:
/*                                            _tx_thread_system_suspend,  */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_priority_change(TX_THREAD *thread_ptr, UINT new_priority, UINT *old_priority)
{
 800bdf0:	b580      	push	{r7, lr}
 800bdf2:	b090      	sub	sp, #64	; 0x40
 800bdf4:	af00      	add	r7, sp, #0
 800bdf6:	60f8      	str	r0, [r7, #12]
 800bdf8:	60b9      	str	r1, [r7, #8]
 800bdfa:	607a      	str	r2, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800bdfc:	f3ef 8310 	mrs	r3, PRIMASK
 800be00:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800be02:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800be04:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800be06:	b672      	cpsid	i
    return(int_posture);
 800be08:	6abb      	ldr	r3, [r7, #40]	; 0x28
TX_THREAD       *next_execute_ptr;
UINT            original_priority;


    /* Lockout interrupts while the thread is being suspended.  */
    TX_DISABLE
 800be0a:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Save the previous priority.  */
    *old_priority =  thread_ptr -> tx_thread_user_priority;
 800be0c:	68fb      	ldr	r3, [r7, #12]
 800be0e:	f8d3 20c8 	ldr.w	r2, [r3, #200]	; 0xc8
 800be12:	687b      	ldr	r3, [r7, #4]
 800be14:	601a      	str	r2, [r3, #0]

    /* Log this kernel call.  */
    TX_EL_THREAD_PRIORITY_CHANGE_INSERT

    /* Determine if this thread is currently ready.  */
    if (thread_ptr -> tx_thread_state != TX_READY)
 800be16:	68fb      	ldr	r3, [r7, #12]
 800be18:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800be1a:	2b00      	cmp	r3, #0
 800be1c:	d024      	beq.n	800be68 <_tx_thread_priority_change+0x78>
    {

        /* Setup the user priority and threshold in the thread's control
           block.  */
        thread_ptr -> tx_thread_user_priority =               new_priority;
 800be1e:	68fb      	ldr	r3, [r7, #12]
 800be20:	68ba      	ldr	r2, [r7, #8]
 800be22:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
        thread_ptr -> tx_thread_user_preempt_threshold =      new_priority;
 800be26:	68fb      	ldr	r3, [r7, #12]
 800be28:	68ba      	ldr	r2, [r7, #8]
 800be2a:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc

        /* Determine if the actual thread priority should be setup, which is the
           case if the new priority is higher than the priority inheritance.  */
        if (new_priority < thread_ptr -> tx_thread_inherit_priority)
 800be2e:	68fb      	ldr	r3, [r7, #12]
 800be30:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 800be34:	68ba      	ldr	r2, [r7, #8]
 800be36:	429a      	cmp	r2, r3
 800be38:	d206      	bcs.n	800be48 <_tx_thread_priority_change+0x58>
        {

            /* Change thread priority to the new user's priority.  */
            thread_ptr -> tx_thread_priority =           new_priority;
 800be3a:	68fb      	ldr	r3, [r7, #12]
 800be3c:	68ba      	ldr	r2, [r7, #8]
 800be3e:	62da      	str	r2, [r3, #44]	; 0x2c
            thread_ptr -> tx_thread_preempt_threshold =  new_priority;
 800be40:	68fb      	ldr	r3, [r7, #12]
 800be42:	68ba      	ldr	r2, [r7, #8]
 800be44:	63da      	str	r2, [r3, #60]	; 0x3c
 800be46:	e009      	b.n	800be5c <_tx_thread_priority_change+0x6c>
        }
        else
        {

            /* Change thread priority to the priority inheritance.  */
            thread_ptr -> tx_thread_priority =           thread_ptr -> tx_thread_inherit_priority;
 800be48:	68fb      	ldr	r3, [r7, #12]
 800be4a:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
 800be4e:	68fb      	ldr	r3, [r7, #12]
 800be50:	62da      	str	r2, [r3, #44]	; 0x2c
            thread_ptr -> tx_thread_preempt_threshold =  thread_ptr -> tx_thread_inherit_priority;
 800be52:	68fb      	ldr	r3, [r7, #12]
 800be54:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
 800be58:	68fb      	ldr	r3, [r7, #12]
 800be5a:	63da      	str	r2, [r3, #60]	; 0x3c
 800be5c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800be5e:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800be60:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800be62:	f383 8810 	msr	PRIMASK, r3
}
 800be66:	e075      	b.n	800bf54 <_tx_thread_priority_change+0x164>
    }
    else
    {

        /* Set the state to priority change.  */
        thread_ptr -> tx_thread_state =    TX_PRIORITY_CHANGE;
 800be68:	68fb      	ldr	r3, [r7, #12]
 800be6a:	220e      	movs	r2, #14
 800be6c:	631a      	str	r2, [r3, #48]	; 0x30

        /* Pickup the next thread to execute.  */
        execute_ptr =  _tx_thread_execute_ptr;
 800be6e:	4b3c      	ldr	r3, [pc, #240]	; (800bf60 <_tx_thread_priority_change+0x170>)
 800be70:	681b      	ldr	r3, [r3, #0]
 800be72:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Save the original priority.  */
        original_priority =  thread_ptr -> tx_thread_priority;
 800be74:	68fb      	ldr	r3, [r7, #12]
 800be76:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800be78:	637b      	str	r3, [r7, #52]	; 0x34

#else

        /* Increment the preempt disable flag by 2 to prevent system suspend from
           returning to the system.  */
        _tx_thread_preempt_disable =  _tx_thread_preempt_disable + ((UINT) 3);
 800be7a:	4b3a      	ldr	r3, [pc, #232]	; (800bf64 <_tx_thread_priority_change+0x174>)
 800be7c:	681b      	ldr	r3, [r3, #0]
 800be7e:	3303      	adds	r3, #3
 800be80:	4a38      	ldr	r2, [pc, #224]	; (800bf64 <_tx_thread_priority_change+0x174>)
 800be82:	6013      	str	r3, [r2, #0]

        /* Set the suspending flag. */
        thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800be84:	68fb      	ldr	r3, [r7, #12]
 800be86:	2201      	movs	r2, #1
 800be88:	639a      	str	r2, [r3, #56]	; 0x38

        /* Setup the timeout period.  */
        thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 800be8a:	68fb      	ldr	r3, [r7, #12]
 800be8c:	2200      	movs	r2, #0
 800be8e:	64da      	str	r2, [r3, #76]	; 0x4c
 800be90:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800be92:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800be94:	6a3b      	ldr	r3, [r7, #32]
 800be96:	f383 8810 	msr	PRIMASK, r3
}
 800be9a:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE

        /* The thread is ready and must first be removed from the list.  Call the
           system suspend function to accomplish this.  */
        _tx_thread_system_suspend(thread_ptr);
 800be9c:	68f8      	ldr	r0, [r7, #12]
 800be9e:	f000 fbd9 	bl	800c654 <_tx_thread_system_suspend>

        /* At this point, the preempt disable flag is still set, so we still have
           protection against all preemption.  */

        /* Setup the new priority for this thread.  */
        thread_ptr -> tx_thread_user_priority =           new_priority;
 800bea2:	68fb      	ldr	r3, [r7, #12]
 800bea4:	68ba      	ldr	r2, [r7, #8]
 800bea6:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
        thread_ptr -> tx_thread_user_preempt_threshold =  new_priority;
 800beaa:	68fb      	ldr	r3, [r7, #12]
 800beac:	68ba      	ldr	r2, [r7, #8]
 800beae:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc

        /* Determine if the actual thread priority should be setup, which is the
           case if the new priority is higher than the priority inheritance.  */
        if (new_priority < thread_ptr -> tx_thread_inherit_priority)
 800beb2:	68fb      	ldr	r3, [r7, #12]
 800beb4:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 800beb8:	68ba      	ldr	r2, [r7, #8]
 800beba:	429a      	cmp	r2, r3
 800bebc:	d206      	bcs.n	800becc <_tx_thread_priority_change+0xdc>
        {

            /* Change thread priority to the new user's priority.  */
            thread_ptr -> tx_thread_priority =           new_priority;
 800bebe:	68fb      	ldr	r3, [r7, #12]
 800bec0:	68ba      	ldr	r2, [r7, #8]
 800bec2:	62da      	str	r2, [r3, #44]	; 0x2c
            thread_ptr -> tx_thread_preempt_threshold =  new_priority;
 800bec4:	68fb      	ldr	r3, [r7, #12]
 800bec6:	68ba      	ldr	r2, [r7, #8]
 800bec8:	63da      	str	r2, [r3, #60]	; 0x3c
 800beca:	e009      	b.n	800bee0 <_tx_thread_priority_change+0xf0>
        }
        else
        {

            /* Change thread priority to the priority inheritance.  */
            thread_ptr -> tx_thread_priority =           thread_ptr -> tx_thread_inherit_priority;
 800becc:	68fb      	ldr	r3, [r7, #12]
 800bece:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
 800bed2:	68fb      	ldr	r3, [r7, #12]
 800bed4:	62da      	str	r2, [r3, #44]	; 0x2c
            thread_ptr -> tx_thread_preempt_threshold =  thread_ptr -> tx_thread_inherit_priority;
 800bed6:	68fb      	ldr	r3, [r7, #12]
 800bed8:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
 800bedc:	68fb      	ldr	r3, [r7, #12]
 800bede:	63da      	str	r2, [r3, #60]	; 0x3c
        }

        /* Resume the thread with the new priority.  */
        _tx_thread_system_resume(thread_ptr);
 800bee0:	68f8      	ldr	r0, [r7, #12]
 800bee2:	f000 faa3 	bl	800c42c <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800bee6:	f3ef 8310 	mrs	r3, PRIMASK
 800beea:	61fb      	str	r3, [r7, #28]
    return(posture);
 800beec:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800beee:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800bef0:	b672      	cpsid	i
    return(int_posture);
 800bef2:	69bb      	ldr	r3, [r7, #24]

        /* Disable interrupts.  */
        TX_DISABLE
 800bef4:	63fb      	str	r3, [r7, #60]	; 0x3c
#endif

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
 800bef6:	4b1b      	ldr	r3, [pc, #108]	; (800bf64 <_tx_thread_priority_change+0x174>)
 800bef8:	681b      	ldr	r3, [r3, #0]
 800befa:	3b01      	subs	r3, #1
 800befc:	4a19      	ldr	r2, [pc, #100]	; (800bf64 <_tx_thread_priority_change+0x174>)
 800befe:	6013      	str	r3, [r2, #0]

        /* Pickup the next thread to execute.  */
        next_execute_ptr =  _tx_thread_execute_ptr;
 800bf00:	4b17      	ldr	r3, [pc, #92]	; (800bf60 <_tx_thread_priority_change+0x170>)
 800bf02:	681b      	ldr	r3, [r3, #0]
 800bf04:	633b      	str	r3, [r7, #48]	; 0x30

        /* Determine if this thread is not the next thread to execute.  */
        if (thread_ptr != next_execute_ptr)
 800bf06:	68fa      	ldr	r2, [r7, #12]
 800bf08:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bf0a:	429a      	cmp	r2, r3
 800bf0c:	d01a      	beq.n	800bf44 <_tx_thread_priority_change+0x154>
        {

            /* Make sure the thread is still ready.  */
            if (thread_ptr -> tx_thread_state == TX_READY)
 800bf0e:	68fb      	ldr	r3, [r7, #12]
 800bf10:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bf12:	2b00      	cmp	r3, #0
 800bf14:	d116      	bne.n	800bf44 <_tx_thread_priority_change+0x154>
            {

                /* Now check and see if this thread has an equal or higher priority.  */
                if (thread_ptr -> tx_thread_priority <= next_execute_ptr -> tx_thread_priority)
 800bf16:	68fb      	ldr	r3, [r7, #12]
 800bf18:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800bf1a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bf1c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bf1e:	429a      	cmp	r2, r3
 800bf20:	d810      	bhi.n	800bf44 <_tx_thread_priority_change+0x154>
                {

                    /* Now determine if this thread was the previously executing thread.  */
                    if (thread_ptr == execute_ptr)
 800bf22:	68fa      	ldr	r2, [r7, #12]
 800bf24:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bf26:	429a      	cmp	r2, r3
 800bf28:	d10c      	bne.n	800bf44 <_tx_thread_priority_change+0x154>

                        /* Yes, this thread was previously executing before we temporarily suspended and resumed
                           it in order to change the priority. A lower or same priority thread cannot be the next thread
                           to execute in this case since this thread really didn't suspend.  Simply reset the execute
                           pointer to this thread.  */
                        _tx_thread_execute_ptr =  thread_ptr;
 800bf2a:	4a0d      	ldr	r2, [pc, #52]	; (800bf60 <_tx_thread_priority_change+0x170>)
 800bf2c:	68fb      	ldr	r3, [r7, #12]
 800bf2e:	6013      	str	r3, [r2, #0]

                        /* Determine if we moved to a lower priority. If so, move the thread to the front of its priority list.  */
                        if (original_priority < new_priority)
 800bf30:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800bf32:	68bb      	ldr	r3, [r7, #8]
 800bf34:	429a      	cmp	r2, r3
 800bf36:	d205      	bcs.n	800bf44 <_tx_thread_priority_change+0x154>
                        {

                            /* Ensure that this thread is placed at the front of the priority list.  */
                            _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr;
 800bf38:	68fb      	ldr	r3, [r7, #12]
 800bf3a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bf3c:	490a      	ldr	r1, [pc, #40]	; (800bf68 <_tx_thread_priority_change+0x178>)
 800bf3e:	68fa      	ldr	r2, [r7, #12]
 800bf40:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 800bf44:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800bf46:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800bf48:	697b      	ldr	r3, [r7, #20]
 800bf4a:	f383 8810 	msr	PRIMASK, r3
}
 800bf4e:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 800bf50:	f000 fa32 	bl	800c3b8 <_tx_thread_system_preempt_check>
    }

    /* Return success if we get here!  */
    return(TX_SUCCESS);
 800bf54:	2300      	movs	r3, #0
}
 800bf56:	4618      	mov	r0, r3
 800bf58:	3740      	adds	r7, #64	; 0x40
 800bf5a:	46bd      	mov	sp, r7
 800bf5c:	bd80      	pop	{r7, pc}
 800bf5e:	bf00      	nop
 800bf60:	2000efbc 	.word	0x2000efbc
 800bf64:	2000f054 	.word	0x2000f054
 800bf68:	2000efd4 	.word	0x2000efd4

0800bf6c <_tx_thread_relinquish>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_relinquish(VOID)
{
 800bf6c:	b480      	push	{r7}
 800bf6e:	b08b      	sub	sp, #44	; 0x2c
 800bf70:	af00      	add	r7, sp, #0
UINT            priority;
TX_THREAD       *thread_ptr;


    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800bf72:	4b2b      	ldr	r3, [pc, #172]	; (800c020 <_tx_thread_relinquish+0xb4>)
 800bf74:	681b      	ldr	r3, [r3, #0]
 800bf76:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800bf78:	f3ef 8310 	mrs	r3, PRIMASK
 800bf7c:	61bb      	str	r3, [r7, #24]
    return(posture);
 800bf7e:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800bf80:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800bf82:	b672      	cpsid	i
    return(int_posture);
 800bf84:	697b      	ldr	r3, [r7, #20]
    /* Check this thread's stack.  */
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif

    /* Disable interrupts.  */
    TX_DISABLE
 800bf86:	623b      	str	r3, [r7, #32]

#ifndef TX_NO_TIMER

    /* Reset time slice for current thread.  */
    _tx_timer_time_slice =  thread_ptr -> tx_thread_new_time_slice;
 800bf88:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bf8a:	69db      	ldr	r3, [r3, #28]
 800bf8c:	4a25      	ldr	r2, [pc, #148]	; (800c024 <_tx_thread_relinquish+0xb8>)
 800bf8e:	6013      	str	r3, [r2, #0]
#endif

    /* Pickup the thread's priority.  */
    priority =  thread_ptr -> tx_thread_priority;
 800bf90:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bf92:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bf94:	61fb      	str	r3, [r7, #28]

    /* Determine if there is another thread at the same priority.  */
    if (thread_ptr -> tx_thread_ready_next != thread_ptr)
 800bf96:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bf98:	6a1b      	ldr	r3, [r3, #32]
 800bf9a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800bf9c:	429a      	cmp	r2, r3
 800bf9e:	d009      	beq.n	800bfb4 <_tx_thread_relinquish+0x48>
    {

        /* Yes, there is another thread at this priority, make it the highest at
           this priority level.  */
        _tx_thread_priority_list[priority] =  thread_ptr -> tx_thread_ready_next;
 800bfa0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bfa2:	6a1a      	ldr	r2, [r3, #32]
 800bfa4:	4920      	ldr	r1, [pc, #128]	; (800c028 <_tx_thread_relinquish+0xbc>)
 800bfa6:	69fb      	ldr	r3, [r7, #28]
 800bfa8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Mark the new thread as the one to execute.  */
        _tx_thread_execute_ptr = thread_ptr -> tx_thread_ready_next;
 800bfac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bfae:	6a1b      	ldr	r3, [r3, #32]
 800bfb0:	4a1e      	ldr	r2, [pc, #120]	; (800c02c <_tx_thread_relinquish+0xc0>)
 800bfb2:	6013      	str	r3, [r2, #0]
    }

    /* Determine if there is a higher-priority thread ready.  */
    if (_tx_thread_highest_priority < priority)
 800bfb4:	4b1e      	ldr	r3, [pc, #120]	; (800c030 <_tx_thread_relinquish+0xc4>)
 800bfb6:	681b      	ldr	r3, [r3, #0]
 800bfb8:	69fa      	ldr	r2, [r7, #28]
 800bfba:	429a      	cmp	r2, r3
 800bfbc:	d906      	bls.n	800bfcc <_tx_thread_relinquish+0x60>
    {

        /* Yes, there is a higher priority thread ready to execute.  Make
           it visible to the thread scheduler.  */
        _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 800bfbe:	4b1c      	ldr	r3, [pc, #112]	; (800c030 <_tx_thread_relinquish+0xc4>)
 800bfc0:	681b      	ldr	r3, [r3, #0]
 800bfc2:	4a19      	ldr	r2, [pc, #100]	; (800c028 <_tx_thread_relinquish+0xbc>)
 800bfc4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800bfc8:	4a18      	ldr	r2, [pc, #96]	; (800c02c <_tx_thread_relinquish+0xc0>)
 800bfca:	6013      	str	r3, [r2, #0]
 800bfcc:	6a3b      	ldr	r3, [r7, #32]
 800bfce:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800bfd0:	693b      	ldr	r3, [r7, #16]
 800bfd2:	f383 8810 	msr	PRIMASK, r3
}
 800bfd6:	bf00      	nop

    /* Restore previous interrupt posture.  */
    TX_RESTORE

    /* Determine if this thread needs to return to the system.  */
    if (_tx_thread_execute_ptr != thread_ptr)
 800bfd8:	4b14      	ldr	r3, [pc, #80]	; (800c02c <_tx_thread_relinquish+0xc0>)
 800bfda:	681b      	ldr	r3, [r3, #0]
 800bfdc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800bfde:	429a      	cmp	r2, r3
 800bfe0:	d017      	beq.n	800c012 <_tx_thread_relinquish+0xa6>
__attribute__( ( always_inline ) ) static inline void _tx_thread_system_return_inline(void)
{
UINT interrupt_save;

    /* Set PendSV to invoke ThreadX scheduler.  */
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800bfe2:	4b14      	ldr	r3, [pc, #80]	; (800c034 <_tx_thread_relinquish+0xc8>)
 800bfe4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800bfe8:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800bfea:	f3ef 8305 	mrs	r3, IPSR
 800bfee:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 800bff0:	68fb      	ldr	r3, [r7, #12]
    if (_tx_ipsr_get() == 0)
 800bff2:	2b00      	cmp	r3, #0
 800bff4:	d10c      	bne.n	800c010 <_tx_thread_relinquish+0xa4>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800bff6:	f3ef 8310 	mrs	r3, PRIMASK
 800bffa:	60bb      	str	r3, [r7, #8]
    return(posture);
 800bffc:	68bb      	ldr	r3, [r7, #8]
    {
        interrupt_save = __get_interrupt_posture();
 800bffe:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("CPSIE  i": : : "memory");
 800c000:	b662      	cpsie	i
}
 800c002:	bf00      	nop
 800c004:	687b      	ldr	r3, [r7, #4]
 800c006:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c008:	683b      	ldr	r3, [r7, #0]
 800c00a:	f383 8810 	msr	PRIMASK, r3
}
 800c00e:	bf00      	nop
#else
        __enable_interrupts();
#endif
        __restore_interrupt(interrupt_save);
    }
}
 800c010:	bf00      	nop

        /* Transfer control to the system so the scheduler can execute
           the next thread.  */
        _tx_thread_system_return();
    }
}
 800c012:	bf00      	nop
 800c014:	372c      	adds	r7, #44	; 0x2c
 800c016:	46bd      	mov	sp, r7
 800c018:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c01c:	4770      	bx	lr
 800c01e:	bf00      	nop
 800c020:	2000efb8 	.word	0x2000efb8
 800c024:	2000f5fc 	.word	0x2000f5fc
 800c028:	2000efd4 	.word	0x2000efd4
 800c02c:	2000efbc 	.word	0x2000efbc
 800c030:	2000efd0 	.word	0x2000efd0
 800c034:	e000ed04 	.word	0xe000ed04

0800c038 <_tx_thread_resume>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_resume(TX_THREAD *thread_ptr)
{
 800c038:	b580      	push	{r7, lr}
 800c03a:	b08c      	sub	sp, #48	; 0x30
 800c03c:	af00      	add	r7, sp, #0
 800c03e:	6078      	str	r0, [r7, #4]

TX_INTERRUPT_SAVE_AREA

UINT        status;
TX_THREAD   *saved_thread_ptr;
UINT        saved_threshold =  ((UINT) 0);
 800c040:	2300      	movs	r3, #0
 800c042:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c044:	f3ef 8310 	mrs	r3, PRIMASK
 800c048:	61fb      	str	r3, [r7, #28]
    return(posture);
 800c04a:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800c04c:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c04e:	b672      	cpsid	i
    return(int_posture);
 800c050:	69bb      	ldr	r3, [r7, #24]
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif
#endif

    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
 800c052:	623b      	str	r3, [r7, #32]
    /* Log this kernel call.  */
    TX_EL_THREAD_RESUME_INSERT

    /* Determine if the thread is suspended or in the process of suspending.
       If so, call the thread resume processing.  */
    if (thread_ptr -> tx_thread_state == TX_SUSPENDED)
 800c054:	687b      	ldr	r3, [r7, #4]
 800c056:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c058:	2b03      	cmp	r3, #3
 800c05a:	d12f      	bne.n	800c0bc <_tx_thread_resume+0x84>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800c05c:	f3ef 8305 	mrs	r3, IPSR
 800c060:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800c062:	697a      	ldr	r2, [r7, #20]
    {

        /* Determine if the create call is being called from initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() >= TX_INITIALIZE_IN_PROGRESS)
 800c064:	4b21      	ldr	r3, [pc, #132]	; (800c0ec <_tx_thread_resume+0xb4>)
 800c066:	681b      	ldr	r3, [r3, #0]
 800c068:	4313      	orrs	r3, r2
 800c06a:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800c06e:	d30d      	bcc.n	800c08c <_tx_thread_resume+0x54>

            /* Pickup the current thread execute pointer, which corresponds to the
               highest priority thread ready to execute.  Interrupt lockout is
               not required, since interrupts are assumed to be disabled during
               initialization.  */
            saved_thread_ptr =  _tx_thread_execute_ptr;
 800c070:	4b1f      	ldr	r3, [pc, #124]	; (800c0f0 <_tx_thread_resume+0xb8>)
 800c072:	681b      	ldr	r3, [r3, #0]
 800c074:	62bb      	str	r3, [r7, #40]	; 0x28

            /* Determine if there is thread ready for execution.  */
            if (saved_thread_ptr != TX_NULL)
 800c076:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c078:	2b00      	cmp	r3, #0
 800c07a:	d009      	beq.n	800c090 <_tx_thread_resume+0x58>
            {

                /* Yes, a thread is ready for execution when initialization completes.  */

                /* Save the current preemption-threshold.  */
                saved_threshold =  saved_thread_ptr -> tx_thread_preempt_threshold;
 800c07c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c07e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c080:	627b      	str	r3, [r7, #36]	; 0x24

                /* For initialization, temporarily set the preemption-threshold to the
                   priority level to make sure the highest-priority thread runs once
                   initialization is complete.  */
                saved_thread_ptr -> tx_thread_preempt_threshold =  saved_thread_ptr -> tx_thread_priority;
 800c082:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c084:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c086:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c088:	63da      	str	r2, [r3, #60]	; 0x3c
 800c08a:	e001      	b.n	800c090 <_tx_thread_resume+0x58>
        }
        else
        {

            /* Simply set the saved thread pointer to NULL.  */
            saved_thread_ptr =  TX_NULL;
 800c08c:	2300      	movs	r3, #0
 800c08e:	62bb      	str	r3, [r7, #40]	; 0x28
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption.  */
        _tx_thread_preempt_disable++;
 800c090:	4b18      	ldr	r3, [pc, #96]	; (800c0f4 <_tx_thread_resume+0xbc>)
 800c092:	681b      	ldr	r3, [r3, #0]
 800c094:	3301      	adds	r3, #1
 800c096:	4a17      	ldr	r2, [pc, #92]	; (800c0f4 <_tx_thread_resume+0xbc>)
 800c098:	6013      	str	r3, [r2, #0]
 800c09a:	6a3b      	ldr	r3, [r7, #32]
 800c09c:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c09e:	693b      	ldr	r3, [r7, #16]
 800c0a0:	f383 8810 	msr	PRIMASK, r3
}
 800c0a4:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Call the actual resume service to resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
 800c0a6:	6878      	ldr	r0, [r7, #4]
 800c0a8:	f000 f9c0 	bl	800c42c <_tx_thread_system_resume>
#endif

        /* Determine if the thread's preemption-threshold needs to be restored.  */
        if (saved_thread_ptr != TX_NULL)
 800c0ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c0ae:	2b00      	cmp	r3, #0
 800c0b0:	d002      	beq.n	800c0b8 <_tx_thread_resume+0x80>
        {

            /* Yes, restore the previous highest-priority thread's preemption-threshold. This
               can only happen if this routine is called from initialization.  */
            saved_thread_ptr -> tx_thread_preempt_threshold =  saved_threshold;
 800c0b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c0b4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800c0b6:	63da      	str	r2, [r3, #60]	; 0x3c
        /* Setup successful return status.  */
        status =  TX_SUCCESS;
#else

        /* Return successful completion.  */
        return(TX_SUCCESS);
 800c0b8:	2300      	movs	r3, #0
 800c0ba:	e012      	b.n	800c0e2 <_tx_thread_resume+0xaa>

        /* Setup successful return status.  */
        status =  TX_SUCCESS;
#endif
    }
    else if (thread_ptr -> tx_thread_delayed_suspend == TX_TRUE)
 800c0bc:	687b      	ldr	r3, [r7, #4]
 800c0be:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c0c0:	2b01      	cmp	r3, #1
 800c0c2:	d105      	bne.n	800c0d0 <_tx_thread_resume+0x98>
    {

        /* Clear the delayed suspension.  */
        thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
 800c0c4:	687b      	ldr	r3, [r7, #4]
 800c0c6:	2200      	movs	r2, #0
 800c0c8:	635a      	str	r2, [r3, #52]	; 0x34

        /* Setup delayed suspend lifted return status.  */
        status =  TX_SUSPEND_LIFTED;
 800c0ca:	2319      	movs	r3, #25
 800c0cc:	62fb      	str	r3, [r7, #44]	; 0x2c
 800c0ce:	e001      	b.n	800c0d4 <_tx_thread_resume+0x9c>
    }
    else
    {

        /* Setup invalid resume return status.  */
        status =  TX_RESUME_ERROR;
 800c0d0:	2312      	movs	r3, #18
 800c0d2:	62fb      	str	r3, [r7, #44]	; 0x2c
 800c0d4:	6a3b      	ldr	r3, [r7, #32]
 800c0d6:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c0d8:	68fb      	ldr	r3, [r7, #12]
 800c0da:	f383 8810 	msr	PRIMASK, r3
}
 800c0de:	bf00      	nop
        }
    }
#endif

    /* Return completion status. */
    return(status);
 800c0e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 800c0e2:	4618      	mov	r0, r3
 800c0e4:	3730      	adds	r7, #48	; 0x30
 800c0e6:	46bd      	mov	sp, r7
 800c0e8:	bd80      	pop	{r7, pc}
 800c0ea:	bf00      	nop
 800c0ec:	2000000c 	.word	0x2000000c
 800c0f0:	2000efbc 	.word	0x2000efbc
 800c0f4:	2000f054 	.word	0x2000f054

0800c0f8 <_tx_thread_shell_entry>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_shell_entry(VOID)
{
 800c0f8:	b580      	push	{r7, lr}
 800c0fa:	b08c      	sub	sp, #48	; 0x30
 800c0fc:	af00      	add	r7, sp, #0
VOID            (*entry_exit_notify)(TX_THREAD *notify_thread_ptr, UINT type);
#endif


    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800c0fe:	4b33      	ldr	r3, [pc, #204]	; (800c1cc <_tx_thread_shell_entry+0xd4>)
 800c100:	681b      	ldr	r3, [r3, #0]
 800c102:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c104:	f3ef 8310 	mrs	r3, PRIMASK
 800c108:	61bb      	str	r3, [r7, #24]
    return(posture);
 800c10a:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800c10c:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c10e:	b672      	cpsid	i
    return(int_posture);
 800c110:	697b      	ldr	r3, [r7, #20]
    TX_THREAD_STARTED_EXTENSION(thread_ptr)

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

    /* Disable interrupts.  */
    TX_DISABLE
 800c112:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Pickup the entry/exit application callback routine.  */
    entry_exit_notify =  thread_ptr -> tx_thread_entry_exit_notify;
 800c114:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c116:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800c11a:	627b      	str	r3, [r7, #36]	; 0x24
 800c11c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c11e:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c120:	69fb      	ldr	r3, [r7, #28]
 800c122:	f383 8810 	msr	PRIMASK, r3
}
 800c126:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if an application callback routine is specified.  */
    if (entry_exit_notify != TX_NULL)
 800c128:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c12a:	2b00      	cmp	r3, #0
 800c12c:	d003      	beq.n	800c136 <_tx_thread_shell_entry+0x3e>
    {

        /* Yes, notify application that this thread has been entered!  */
        (entry_exit_notify)(thread_ptr, TX_THREAD_ENTRY);
 800c12e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c130:	2100      	movs	r1, #0
 800c132:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800c134:	4798      	blx	r3
    }
#endif

    /* Call current thread's entry function.  */
    (thread_ptr -> tx_thread_entry) (thread_ptr -> tx_thread_entry_parameter);
 800c136:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c138:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c13a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c13c:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800c13e:	4610      	mov	r0, r2
 800c140:	4798      	blx	r3

    /* Suspend thread with a "completed" state.  */

    /* Determine if the application is using mutexes.  */
    if (_tx_thread_mutex_release != TX_NULL)
 800c142:	4b23      	ldr	r3, [pc, #140]	; (800c1d0 <_tx_thread_shell_entry+0xd8>)
 800c144:	681b      	ldr	r3, [r3, #0]
 800c146:	2b00      	cmp	r3, #0
 800c148:	d003      	beq.n	800c152 <_tx_thread_shell_entry+0x5a>
    {

        /* Yes, call the mutex release function via a function pointer that
           is setup during mutex initialization.  */
        (_tx_thread_mutex_release)(thread_ptr);
 800c14a:	4b21      	ldr	r3, [pc, #132]	; (800c1d0 <_tx_thread_shell_entry+0xd8>)
 800c14c:	681b      	ldr	r3, [r3, #0]
 800c14e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800c150:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c152:	f3ef 8310 	mrs	r3, PRIMASK
 800c156:	607b      	str	r3, [r7, #4]
    return(posture);
 800c158:	687b      	ldr	r3, [r7, #4]
    int_posture = __get_interrupt_posture();
 800c15a:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c15c:	b672      	cpsid	i
    return(int_posture);
 800c15e:	683b      	ldr	r3, [r7, #0]
    }

    /* Lockout interrupts while the thread state is setup.  */
    TX_DISABLE
 800c160:	62bb      	str	r3, [r7, #40]	; 0x28

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

    /* Pickup the entry/exit application callback routine again.  */
    entry_exit_notify =  thread_ptr -> tx_thread_entry_exit_notify;
 800c162:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c164:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800c168:	627b      	str	r3, [r7, #36]	; 0x24
#endif

    /* Set the status to suspending, in order to indicate the suspension
       is in progress.  */
    thread_ptr -> tx_thread_state =  TX_COMPLETED;
 800c16a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c16c:	2201      	movs	r2, #1
 800c16e:	631a      	str	r2, [r3, #48]	; 0x30
    /* Restore interrupts.  */
    TX_RESTORE
#else

    /* Set the suspending flag. */
    thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800c170:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c172:	2201      	movs	r2, #1
 800c174:	639a      	str	r2, [r3, #56]	; 0x38

    /* Setup for no timeout period.  */
    thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 800c176:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c178:	2200      	movs	r2, #0
 800c17a:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 800c17c:	4b15      	ldr	r3, [pc, #84]	; (800c1d4 <_tx_thread_shell_entry+0xdc>)
 800c17e:	681b      	ldr	r3, [r3, #0]
 800c180:	3301      	adds	r3, #1
 800c182:	4a14      	ldr	r2, [pc, #80]	; (800c1d4 <_tx_thread_shell_entry+0xdc>)
 800c184:	6013      	str	r3, [r2, #0]
 800c186:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c188:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c18a:	68bb      	ldr	r3, [r7, #8]
 800c18c:	f383 8810 	msr	PRIMASK, r3
}
 800c190:	bf00      	nop
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 800c192:	f3ef 8314 	mrs	r3, CONTROL
 800c196:	60fb      	str	r3, [r7, #12]
    return(control_value);
 800c198:	68fb      	ldr	r3, [r7, #12]

    /* Restore interrupts.  */
    TX_RESTORE

    /* Perform any additional activities for tool or user purpose.  */
    TX_THREAD_COMPLETED_EXTENSION(thread_ptr)
 800c19a:	623b      	str	r3, [r7, #32]
 800c19c:	6a3b      	ldr	r3, [r7, #32]
 800c19e:	f023 0304 	bic.w	r3, r3, #4
 800c1a2:	623b      	str	r3, [r7, #32]
 800c1a4:	6a3b      	ldr	r3, [r7, #32]
 800c1a6:	613b      	str	r3, [r7, #16]
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
 800c1a8:	693b      	ldr	r3, [r7, #16]
 800c1aa:	f383 8814 	msr	CONTROL, r3
}
 800c1ae:	bf00      	nop

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

    /* Determine if an application callback routine is specified.  */
    if (entry_exit_notify != TX_NULL)
 800c1b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c1b2:	2b00      	cmp	r3, #0
 800c1b4:	d003      	beq.n	800c1be <_tx_thread_shell_entry+0xc6>
    {

        /* Yes, notify application that this thread has exited!  */
        (entry_exit_notify)(thread_ptr, TX_THREAD_EXIT);
 800c1b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c1b8:	2101      	movs	r1, #1
 800c1ba:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800c1bc:	4798      	blx	r3
    }
#endif

    /* Call actual thread suspension routine.  */
    _tx_thread_system_suspend(thread_ptr);
 800c1be:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800c1c0:	f000 fa48 	bl	800c654 <_tx_thread_system_suspend>
#ifdef TX_SAFETY_CRITICAL

    /* If we ever get here, raise safety critical exception.  */
    TX_SAFETY_CRITICAL_EXCEPTION(__FILE__, __LINE__, 0);
#endif
}
 800c1c4:	bf00      	nop
 800c1c6:	3730      	adds	r7, #48	; 0x30
 800c1c8:	46bd      	mov	sp, r7
 800c1ca:	bd80      	pop	{r7, pc}
 800c1cc:	2000efb8 	.word	0x2000efb8
 800c1d0:	2000f058 	.word	0x2000f058
 800c1d4:	2000f054 	.word	0x2000f054

0800c1d8 <_tx_thread_sleep>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_sleep(ULONG timer_ticks)
{
 800c1d8:	b580      	push	{r7, lr}
 800c1da:	b08e      	sub	sp, #56	; 0x38
 800c1dc:	af00      	add	r7, sp, #0
 800c1de:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c1e0:	f3ef 8310 	mrs	r3, PRIMASK
 800c1e4:	62bb      	str	r3, [r7, #40]	; 0x28
    return(posture);
 800c1e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
    int_posture = __get_interrupt_posture();
 800c1e8:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
 800c1ea:	b672      	cpsid	i
    return(int_posture);
 800c1ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
UINT            status;
TX_THREAD       *thread_ptr;


    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
 800c1ee:	633b      	str	r3, [r7, #48]	; 0x30

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800c1f0:	4b35      	ldr	r3, [pc, #212]	; (800c2c8 <_tx_thread_sleep+0xf0>)
 800c1f2:	681b      	ldr	r3, [r3, #0]
 800c1f4:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Determine if this is a legal request.  */

    /* Is there a current thread?  */
    if (thread_ptr == TX_NULL)
 800c1f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c1f8:	2b00      	cmp	r3, #0
 800c1fa:	d108      	bne.n	800c20e <_tx_thread_sleep+0x36>
 800c1fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c1fe:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c200:	6a3b      	ldr	r3, [r7, #32]
 800c202:	f383 8810 	msr	PRIMASK, r3
}
 800c206:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Illegal caller of this service.  */
        status =  TX_CALLER_ERROR;
 800c208:	2313      	movs	r3, #19
 800c20a:	637b      	str	r3, [r7, #52]	; 0x34
 800c20c:	e056      	b.n	800c2bc <_tx_thread_sleep+0xe4>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800c20e:	f3ef 8305 	mrs	r3, IPSR
 800c212:	61fb      	str	r3, [r7, #28]
    return(ipsr_value);
 800c214:	69fa      	ldr	r2, [r7, #28]
    }

    /* Is the caller an ISR or Initialization?  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800c216:	4b2d      	ldr	r3, [pc, #180]	; (800c2cc <_tx_thread_sleep+0xf4>)
 800c218:	681b      	ldr	r3, [r3, #0]
 800c21a:	4313      	orrs	r3, r2
 800c21c:	2b00      	cmp	r3, #0
 800c21e:	d008      	beq.n	800c232 <_tx_thread_sleep+0x5a>
 800c220:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c222:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c224:	69bb      	ldr	r3, [r7, #24]
 800c226:	f383 8810 	msr	PRIMASK, r3
}
 800c22a:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Illegal caller of this service.  */
        status =  TX_CALLER_ERROR;
 800c22c:	2313      	movs	r3, #19
 800c22e:	637b      	str	r3, [r7, #52]	; 0x34
 800c230:	e044      	b.n	800c2bc <_tx_thread_sleep+0xe4>
    }

#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Is the caller the system timer thread?  */
    else if (thread_ptr == &_tx_timer_thread)
 800c232:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c234:	4a26      	ldr	r2, [pc, #152]	; (800c2d0 <_tx_thread_sleep+0xf8>)
 800c236:	4293      	cmp	r3, r2
 800c238:	d108      	bne.n	800c24c <_tx_thread_sleep+0x74>
 800c23a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c23c:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c23e:	697b      	ldr	r3, [r7, #20]
 800c240:	f383 8810 	msr	PRIMASK, r3
}
 800c244:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Illegal caller of this service.  */
        status =  TX_CALLER_ERROR;
 800c246:	2313      	movs	r3, #19
 800c248:	637b      	str	r3, [r7, #52]	; 0x34
 800c24a:	e037      	b.n	800c2bc <_tx_thread_sleep+0xe4>
    }
#endif

    /* Determine if the requested number of ticks is zero.  */
    else if (timer_ticks == ((ULONG) 0))
 800c24c:	687b      	ldr	r3, [r7, #4]
 800c24e:	2b00      	cmp	r3, #0
 800c250:	d108      	bne.n	800c264 <_tx_thread_sleep+0x8c>
 800c252:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c254:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c256:	693b      	ldr	r3, [r7, #16]
 800c258:	f383 8810 	msr	PRIMASK, r3
}
 800c25c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Just return with a successful status.  */
        status =  TX_SUCCESS;
 800c25e:	2300      	movs	r3, #0
 800c260:	637b      	str	r3, [r7, #52]	; 0x34
 800c262:	e02b      	b.n	800c2bc <_tx_thread_sleep+0xe4>
    }
    else
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
 800c264:	4b1b      	ldr	r3, [pc, #108]	; (800c2d4 <_tx_thread_sleep+0xfc>)
 800c266:	681b      	ldr	r3, [r3, #0]
 800c268:	2b00      	cmp	r3, #0
 800c26a:	d008      	beq.n	800c27e <_tx_thread_sleep+0xa6>
 800c26c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c26e:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c270:	68fb      	ldr	r3, [r7, #12]
 800c272:	f383 8810 	msr	PRIMASK, r3
}
 800c276:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
            status =  TX_CALLER_ERROR;
 800c278:	2313      	movs	r3, #19
 800c27a:	637b      	str	r3, [r7, #52]	; 0x34
 800c27c:	e01e      	b.n	800c2bc <_tx_thread_sleep+0xe4>
            TX_EL_THREAD_SLEEP_INSERT

            /* Suspend the current thread.  */

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_SLEEP;
 800c27e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c280:	2204      	movs	r2, #4
 800c282:	631a      	str	r2, [r3, #48]	; 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag. */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800c284:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c286:	2201      	movs	r2, #1
 800c288:	639a      	str	r2, [r3, #56]	; 0x38

            /* Initialize the status to successful.  */
            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 800c28a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c28c:	2200      	movs	r2, #0
 800c28e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  timer_ticks;
 800c292:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c294:	687a      	ldr	r2, [r7, #4]
 800c296:	64da      	str	r2, [r3, #76]	; 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800c298:	4b0e      	ldr	r3, [pc, #56]	; (800c2d4 <_tx_thread_sleep+0xfc>)
 800c29a:	681b      	ldr	r3, [r3, #0]
 800c29c:	3301      	adds	r3, #1
 800c29e:	4a0d      	ldr	r2, [pc, #52]	; (800c2d4 <_tx_thread_sleep+0xfc>)
 800c2a0:	6013      	str	r3, [r2, #0]
 800c2a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c2a4:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c2a6:	68bb      	ldr	r3, [r7, #8]
 800c2a8:	f383 8810 	msr	PRIMASK, r3
}
 800c2ac:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
 800c2ae:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800c2b0:	f000 f9d0 	bl	800c654 <_tx_thread_system_suspend>
#endif

            /* Return status to the caller.  */
            status =  thread_ptr -> tx_thread_suspend_status;
 800c2b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c2b6:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800c2ba:	637b      	str	r3, [r7, #52]	; 0x34
        }
    }

    /* Return completion status.  */
    return(status);
 800c2bc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 800c2be:	4618      	mov	r0, r3
 800c2c0:	3738      	adds	r7, #56	; 0x38
 800c2c2:	46bd      	mov	sp, r7
 800c2c4:	bd80      	pop	{r7, pc}
 800c2c6:	bf00      	nop
 800c2c8:	2000efb8 	.word	0x2000efb8
 800c2cc:	2000000c 	.word	0x2000000c
 800c2d0:	2000f108 	.word	0x2000f108
 800c2d4:	2000f054 	.word	0x2000f054

0800c2d8 <_tx_thread_suspend>:
/*                                            a MISRA compliance issue,   */
/*                                            resulting in version 6.1.1  */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_suspend(TX_THREAD *thread_ptr)
{
 800c2d8:	b580      	push	{r7, lr}
 800c2da:	b08a      	sub	sp, #40	; 0x28
 800c2dc:	af00      	add	r7, sp, #0
 800c2de:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c2e0:	f3ef 8310 	mrs	r3, PRIMASK
 800c2e4:	61bb      	str	r3, [r7, #24]
    return(posture);
 800c2e6:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800c2e8:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c2ea:	b672      	cpsid	i
    return(int_posture);
 800c2ec:	697b      	ldr	r3, [r7, #20]


#ifndef TX_INLINE_THREAD_RESUME_SUSPEND

    /* Lockout interrupts while the thread is being suspended.  */
    TX_DISABLE
 800c2ee:	623b      	str	r3, [r7, #32]

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
 800c2f0:	4b2e      	ldr	r3, [pc, #184]	; (800c3ac <_tx_thread_suspend+0xd4>)
 800c2f2:	681b      	ldr	r3, [r3, #0]
 800c2f4:	61fb      	str	r3, [r7, #28]

    /* Log this kernel call.  */
    TX_EL_THREAD_SUSPEND_INSERT

    /* Check the specified thread's current status.  */
    if (thread_ptr -> tx_thread_state == TX_READY)
 800c2f6:	687b      	ldr	r3, [r7, #4]
 800c2f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c2fa:	2b00      	cmp	r3, #0
 800c2fc:	d130      	bne.n	800c360 <_tx_thread_suspend+0x88>
    {

        /* Initialize status to success.  */
        status =  TX_SUCCESS;
 800c2fe:	2300      	movs	r3, #0
 800c300:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800c302:	f3ef 8305 	mrs	r3, IPSR
 800c306:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
 800c308:	693a      	ldr	r2, [r7, #16]

        /* Determine if we are in a thread context.  */
        if (TX_THREAD_GET_SYSTEM_STATE() == ((ULONG) 0))
 800c30a:	4b29      	ldr	r3, [pc, #164]	; (800c3b0 <_tx_thread_suspend+0xd8>)
 800c30c:	681b      	ldr	r3, [r3, #0]
 800c30e:	4313      	orrs	r3, r2
 800c310:	2b00      	cmp	r3, #0
 800c312:	d109      	bne.n	800c328 <_tx_thread_suspend+0x50>
        {

            /* Yes, we are in a thread context.  */

            /* Determine if the current thread is also the suspending thread.  */
            if (current_thread == thread_ptr)
 800c314:	69fa      	ldr	r2, [r7, #28]
 800c316:	687b      	ldr	r3, [r7, #4]
 800c318:	429a      	cmp	r2, r3
 800c31a:	d105      	bne.n	800c328 <_tx_thread_suspend+0x50>
            {

                /* Now determine if the preempt disable flag is non-zero.  */
                if (_tx_thread_preempt_disable != ((UINT) 0))
 800c31c:	4b25      	ldr	r3, [pc, #148]	; (800c3b4 <_tx_thread_suspend+0xdc>)
 800c31e:	681b      	ldr	r3, [r3, #0]
 800c320:	2b00      	cmp	r3, #0
 800c322:	d001      	beq.n	800c328 <_tx_thread_suspend+0x50>
                {

                    /* Current thread cannot suspend when the preempt disable flag is non-zero,
                       return an error.  */
                    status =  TX_SUSPEND_ERROR;
 800c324:	2314      	movs	r3, #20
 800c326:	627b      	str	r3, [r7, #36]	; 0x24
                }
            }
        }

        /* Determine if the status is still successful.  */
        if (status == TX_SUCCESS)
 800c328:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c32a:	2b00      	cmp	r3, #0
 800c32c:	d132      	bne.n	800c394 <_tx_thread_suspend+0xbc>
        {

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_SUSPENDED;
 800c32e:	687b      	ldr	r3, [r7, #4]
 800c330:	2203      	movs	r2, #3
 800c332:	631a      	str	r2, [r3, #48]	; 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag. */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800c334:	687b      	ldr	r3, [r7, #4]
 800c336:	2201      	movs	r2, #1
 800c338:	639a      	str	r2, [r3, #56]	; 0x38

            /* Setup for no timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 800c33a:	687b      	ldr	r3, [r7, #4]
 800c33c:	2200      	movs	r2, #0
 800c33e:	64da      	str	r2, [r3, #76]	; 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800c340:	4b1c      	ldr	r3, [pc, #112]	; (800c3b4 <_tx_thread_suspend+0xdc>)
 800c342:	681b      	ldr	r3, [r3, #0]
 800c344:	3301      	adds	r3, #1
 800c346:	4a1b      	ldr	r2, [pc, #108]	; (800c3b4 <_tx_thread_suspend+0xdc>)
 800c348:	6013      	str	r3, [r2, #0]
 800c34a:	6a3b      	ldr	r3, [r7, #32]
 800c34c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c34e:	68fb      	ldr	r3, [r7, #12]
 800c350:	f383 8810 	msr	PRIMASK, r3
}
 800c354:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
 800c356:	6878      	ldr	r0, [r7, #4]
 800c358:	f000 f97c 	bl	800c654 <_tx_thread_system_suspend>
            /* Return success.  */
            status =  TX_SUCCESS;
#else

            /* If MISRA is not enabled, return directly.  */
            return(TX_SUCCESS);
 800c35c:	2300      	movs	r3, #0
 800c35e:	e020      	b.n	800c3a2 <_tx_thread_suspend+0xca>
#endif
        }
    }
    else if (thread_ptr -> tx_thread_state == TX_TERMINATED)
 800c360:	687b      	ldr	r3, [r7, #4]
 800c362:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c364:	2b02      	cmp	r3, #2
 800c366:	d102      	bne.n	800c36e <_tx_thread_suspend+0x96>
    {

        /* Thread is terminated.  */
        status =  TX_SUSPEND_ERROR;
 800c368:	2314      	movs	r3, #20
 800c36a:	627b      	str	r3, [r7, #36]	; 0x24
 800c36c:	e012      	b.n	800c394 <_tx_thread_suspend+0xbc>
    }
    else if (thread_ptr -> tx_thread_state == TX_COMPLETED)
 800c36e:	687b      	ldr	r3, [r7, #4]
 800c370:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c372:	2b01      	cmp	r3, #1
 800c374:	d102      	bne.n	800c37c <_tx_thread_suspend+0xa4>
    {

        /* Thread is completed.  */
        status =  TX_SUSPEND_ERROR;
 800c376:	2314      	movs	r3, #20
 800c378:	627b      	str	r3, [r7, #36]	; 0x24
 800c37a:	e00b      	b.n	800c394 <_tx_thread_suspend+0xbc>
    }
    else if (thread_ptr -> tx_thread_state == TX_SUSPENDED)
 800c37c:	687b      	ldr	r3, [r7, #4]
 800c37e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c380:	2b03      	cmp	r3, #3
 800c382:	d102      	bne.n	800c38a <_tx_thread_suspend+0xb2>
    {

        /* Already suspended, just set status to success.  */
        status =  TX_SUCCESS;
 800c384:	2300      	movs	r3, #0
 800c386:	627b      	str	r3, [r7, #36]	; 0x24
 800c388:	e004      	b.n	800c394 <_tx_thread_suspend+0xbc>
    }
    else
    {

        /* Just set the delayed suspension flag.  */
        thread_ptr -> tx_thread_delayed_suspend =  TX_TRUE;
 800c38a:	687b      	ldr	r3, [r7, #4]
 800c38c:	2201      	movs	r2, #1
 800c38e:	635a      	str	r2, [r3, #52]	; 0x34

        /* Set status to success.  */
        status =  TX_SUCCESS;
 800c390:	2300      	movs	r3, #0
 800c392:	627b      	str	r3, [r7, #36]	; 0x24
 800c394:	6a3b      	ldr	r3, [r7, #32]
 800c396:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c398:	68bb      	ldr	r3, [r7, #8]
 800c39a:	f383 8810 	msr	PRIMASK, r3
}
 800c39e:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Always return success, since this function does not perform error
       checking.  */
    return(status);
 800c3a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    TX_RESTORE

    /* Return completion status.  */
    return(status);
#endif
}
 800c3a2:	4618      	mov	r0, r3
 800c3a4:	3728      	adds	r7, #40	; 0x28
 800c3a6:	46bd      	mov	sp, r7
 800c3a8:	bd80      	pop	{r7, pc}
 800c3aa:	bf00      	nop
 800c3ac:	2000efb8 	.word	0x2000efb8
 800c3b0:	2000000c 	.word	0x2000000c
 800c3b4:	2000f054 	.word	0x2000f054

0800c3b8 <_tx_thread_system_preempt_check>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_preempt_check(VOID)
{
 800c3b8:	b480      	push	{r7}
 800c3ba:	b089      	sub	sp, #36	; 0x24
 800c3bc:	af00      	add	r7, sp, #0
TX_THREAD       *current_thread;
TX_THREAD       *thread_ptr;


    /* Combine the system state and preempt disable flags into one for comparison.  */
    TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800c3be:	4b17      	ldr	r3, [pc, #92]	; (800c41c <_tx_thread_system_preempt_check+0x64>)
 800c3c0:	681b      	ldr	r3, [r3, #0]
 800c3c2:	61fb      	str	r3, [r7, #28]

    /* Determine if we are in a system state (ISR or Initialization) or internal preemption is disabled.  */
    if (combined_flags == ((ULONG) 0))
 800c3c4:	69fb      	ldr	r3, [r7, #28]
 800c3c6:	2b00      	cmp	r3, #0
 800c3c8:	d121      	bne.n	800c40e <_tx_thread_system_preempt_check+0x56>
    {

        /* No, at thread execution level so continue checking for preemption.  */

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(current_thread)
 800c3ca:	4b15      	ldr	r3, [pc, #84]	; (800c420 <_tx_thread_system_preempt_check+0x68>)
 800c3cc:	681b      	ldr	r3, [r3, #0]
 800c3ce:	61bb      	str	r3, [r7, #24]

        /* Pickup the next execute pointer.  */
        thread_ptr =  _tx_thread_execute_ptr;
 800c3d0:	4b14      	ldr	r3, [pc, #80]	; (800c424 <_tx_thread_system_preempt_check+0x6c>)
 800c3d2:	681b      	ldr	r3, [r3, #0]
 800c3d4:	617b      	str	r3, [r7, #20]

        /* Determine if preemption should take place.  */
        if (current_thread != thread_ptr)
 800c3d6:	69ba      	ldr	r2, [r7, #24]
 800c3d8:	697b      	ldr	r3, [r7, #20]
 800c3da:	429a      	cmp	r2, r3
 800c3dc:	d017      	beq.n	800c40e <_tx_thread_system_preempt_check+0x56>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800c3de:	4b12      	ldr	r3, [pc, #72]	; (800c428 <_tx_thread_system_preempt_check+0x70>)
 800c3e0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c3e4:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800c3e6:	f3ef 8305 	mrs	r3, IPSR
 800c3ea:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
 800c3ec:	693b      	ldr	r3, [r7, #16]
    if (_tx_ipsr_get() == 0)
 800c3ee:	2b00      	cmp	r3, #0
 800c3f0:	d10c      	bne.n	800c40c <_tx_thread_system_preempt_check+0x54>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c3f2:	f3ef 8310 	mrs	r3, PRIMASK
 800c3f6:	60fb      	str	r3, [r7, #12]
    return(posture);
 800c3f8:	68fb      	ldr	r3, [r7, #12]
        interrupt_save = __get_interrupt_posture();
 800c3fa:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSIE  i": : : "memory");
 800c3fc:	b662      	cpsie	i
}
 800c3fe:	bf00      	nop
 800c400:	68bb      	ldr	r3, [r7, #8]
 800c402:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c404:	687b      	ldr	r3, [r7, #4]
 800c406:	f383 8810 	msr	PRIMASK, r3
}
 800c40a:	bf00      	nop
}
 800c40c:	bf00      	nop

            /* Return to the system so the higher priority thread can be scheduled.  */
            _tx_thread_system_return();
        }
    }
}
 800c40e:	bf00      	nop
 800c410:	3724      	adds	r7, #36	; 0x24
 800c412:	46bd      	mov	sp, r7
 800c414:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c418:	4770      	bx	lr
 800c41a:	bf00      	nop
 800c41c:	2000f054 	.word	0x2000f054
 800c420:	2000efb8 	.word	0x2000efb8
 800c424:	2000efbc 	.word	0x2000efbc
 800c428:	e000ed04 	.word	0xe000ed04

0800c42c <_tx_thread_system_resume>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_resume(TX_THREAD *thread_ptr)
#ifndef TX_NOT_INTERRUPTABLE
{
 800c42c:	b580      	push	{r7, lr}
 800c42e:	b096      	sub	sp, #88	; 0x58
 800c430:	af00      	add	r7, sp, #0
 800c432:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c434:	f3ef 8310 	mrs	r3, PRIMASK
 800c438:	637b      	str	r3, [r7, #52]	; 0x34
    return(posture);
 800c43a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    int_posture = __get_interrupt_posture();
 800c43c:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("CPSID i" : : : "memory");
 800c43e:	b672      	cpsid	i
    return(int_posture);
 800c440:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    /* Check this thread's stack.  */
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif

    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
 800c442:	657b      	str	r3, [r7, #84]	; 0x54

#ifndef TX_NO_TIMER

    /* Deactivate the timeout timer if necessary.  */
    if (thread_ptr -> tx_thread_timer.tx_timer_internal_list_head != TX_NULL)
 800c444:	687b      	ldr	r3, [r7, #4]
 800c446:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800c448:	2b00      	cmp	r3, #0
 800c44a:	d005      	beq.n	800c458 <_tx_thread_system_resume+0x2c>
    {

        /* Deactivate the thread's timeout timer.  */
        _tx_timer_system_deactivate(&(thread_ptr -> tx_thread_timer));
 800c44c:	687b      	ldr	r3, [r7, #4]
 800c44e:	334c      	adds	r3, #76	; 0x4c
 800c450:	4618      	mov	r0, r3
 800c452:	f001 f945 	bl	800d6e0 <_tx_timer_system_deactivate>
 800c456:	e002      	b.n	800c45e <_tx_thread_system_resume+0x32>
    }
    else
    {

        /* Clear the remaining time to ensure timer doesn't get activated.  */
        thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 800c458:	687b      	ldr	r3, [r7, #4]
 800c45a:	2200      	movs	r2, #0
 800c45c:	64da      	str	r2, [r3, #76]	; 0x4c
        time_stamp =  entry_ptr -> tx_trace_buffer_entry_time_stamp;
    }
#endif

    /* Decrease the preempt disabled count.  */
    _tx_thread_preempt_disable--;
 800c45e:	4b75      	ldr	r3, [pc, #468]	; (800c634 <_tx_thread_system_resume+0x208>)
 800c460:	681b      	ldr	r3, [r3, #0]
 800c462:	3b01      	subs	r3, #1
 800c464:	4a73      	ldr	r2, [pc, #460]	; (800c634 <_tx_thread_system_resume+0x208>)
 800c466:	6013      	str	r3, [r2, #0]

    /* Determine if the thread is in the process of suspending.  If so, the thread
       control block is already on the linked list so nothing needs to be done.  */
    if (thread_ptr -> tx_thread_suspending == TX_FALSE)
 800c468:	687b      	ldr	r3, [r7, #4]
 800c46a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800c46c:	2b00      	cmp	r3, #0
 800c46e:	f040 8096 	bne.w	800c59e <_tx_thread_system_resume+0x172>
    {

        /* Thread is not in the process of suspending. Now check to make sure the thread
           has not already been resumed.  */
        if (thread_ptr -> tx_thread_state != TX_READY)
 800c472:	687b      	ldr	r3, [r7, #4]
 800c474:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c476:	2b00      	cmp	r3, #0
 800c478:	f000 80aa 	beq.w	800c5d0 <_tx_thread_system_resume+0x1a4>
        {

            /* No, now check to see if the delayed suspension flag is set.  */
            if (thread_ptr -> tx_thread_delayed_suspend == TX_FALSE)
 800c47c:	687b      	ldr	r3, [r7, #4]
 800c47e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c480:	2b00      	cmp	r3, #0
 800c482:	f040 8085 	bne.w	800c590 <_tx_thread_system_resume+0x164>
                /* Resume the thread!  */

                /* Make this thread ready.  */

                /* Change the state to ready.  */
                thread_ptr -> tx_thread_state =  TX_READY;
 800c486:	687b      	ldr	r3, [r7, #4]
 800c488:	2200      	movs	r2, #0
 800c48a:	631a      	str	r2, [r3, #48]	; 0x30

                /* Pickup priority of thread.  */
                priority =  thread_ptr -> tx_thread_priority;
 800c48c:	687b      	ldr	r3, [r7, #4]
 800c48e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c490:	653b      	str	r3, [r7, #80]	; 0x50
                thread_ptr -> tx_thread_performance_resume_count++;
#endif

                /* Determine if there are other threads at this priority that are
                   ready.  */
                head_ptr =  _tx_thread_priority_list[priority];
 800c492:	4a69      	ldr	r2, [pc, #420]	; (800c638 <_tx_thread_system_resume+0x20c>)
 800c494:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800c496:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800c49a:	64fb      	str	r3, [r7, #76]	; 0x4c
                if (head_ptr == TX_NULL)
 800c49c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c49e:	2b00      	cmp	r3, #0
 800c4a0:	d166      	bne.n	800c570 <_tx_thread_system_resume+0x144>
                {

                    /* First thread at this priority ready.  Add to the front of the list.  */
                    _tx_thread_priority_list[priority] =       thread_ptr;
 800c4a2:	4965      	ldr	r1, [pc, #404]	; (800c638 <_tx_thread_system_resume+0x20c>)
 800c4a4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800c4a6:	687a      	ldr	r2, [r7, #4]
 800c4a8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                    thread_ptr -> tx_thread_ready_next =       thread_ptr;
 800c4ac:	687b      	ldr	r3, [r7, #4]
 800c4ae:	687a      	ldr	r2, [r7, #4]
 800c4b0:	621a      	str	r2, [r3, #32]
                    thread_ptr -> tx_thread_ready_previous =   thread_ptr;
 800c4b2:	687b      	ldr	r3, [r7, #4]
 800c4b4:	687a      	ldr	r2, [r7, #4]
 800c4b6:	625a      	str	r2, [r3, #36]	; 0x24
                    TX_DIV32_BIT_SET(priority, priority_bit)
                    _tx_thread_priority_map_active =  _tx_thread_priority_map_active | priority_bit;
#endif

                    /* Or in the thread's priority bit.  */
                    TX_MOD32_BIT_SET(priority, priority_bit)
 800c4b8:	2201      	movs	r2, #1
 800c4ba:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800c4bc:	fa02 f303 	lsl.w	r3, r2, r3
 800c4c0:	647b      	str	r3, [r7, #68]	; 0x44
                    _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] | priority_bit;
 800c4c2:	4b5e      	ldr	r3, [pc, #376]	; (800c63c <_tx_thread_system_resume+0x210>)
 800c4c4:	681a      	ldr	r2, [r3, #0]
 800c4c6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800c4c8:	4313      	orrs	r3, r2
 800c4ca:	4a5c      	ldr	r2, [pc, #368]	; (800c63c <_tx_thread_system_resume+0x210>)
 800c4cc:	6013      	str	r3, [r2, #0]

                    /* Determine if this newly ready thread is the highest priority.  */
                    if (priority < _tx_thread_highest_priority)
 800c4ce:	4b5c      	ldr	r3, [pc, #368]	; (800c640 <_tx_thread_system_resume+0x214>)
 800c4d0:	681b      	ldr	r3, [r3, #0]
 800c4d2:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800c4d4:	429a      	cmp	r2, r3
 800c4d6:	d27b      	bcs.n	800c5d0 <_tx_thread_system_resume+0x1a4>
                    {

                        /* A new highest priority thread is present. */

                        /* Update the highest priority variable.  */
                        _tx_thread_highest_priority =  priority;
 800c4d8:	4a59      	ldr	r2, [pc, #356]	; (800c640 <_tx_thread_system_resume+0x214>)
 800c4da:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800c4dc:	6013      	str	r3, [r2, #0]

                        /* Pickup the execute pointer. Since it is going to be referenced multiple
                           times, it is placed in a local variable.  */
                        execute_ptr =  _tx_thread_execute_ptr;
 800c4de:	4b59      	ldr	r3, [pc, #356]	; (800c644 <_tx_thread_system_resume+0x218>)
 800c4e0:	681b      	ldr	r3, [r3, #0]
 800c4e2:	643b      	str	r3, [r7, #64]	; 0x40

                        /* Determine if no thread is currently executing.  */
                        if (execute_ptr == TX_NULL)
 800c4e4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c4e6:	2b00      	cmp	r3, #0
 800c4e8:	d103      	bne.n	800c4f2 <_tx_thread_system_resume+0xc6>
                        {

                            /* Simply setup the execute pointer.  */
                            _tx_thread_execute_ptr =  thread_ptr;
 800c4ea:	4a56      	ldr	r2, [pc, #344]	; (800c644 <_tx_thread_system_resume+0x218>)
 800c4ec:	687b      	ldr	r3, [r7, #4]
 800c4ee:	6013      	str	r3, [r2, #0]
 800c4f0:	e06e      	b.n	800c5d0 <_tx_thread_system_resume+0x1a4>
                        {

                            /* Another thread has been scheduled for execution.  */

                            /* Check to see if this is a higher priority thread and determine if preemption is allowed.  */
                            if (priority < execute_ptr -> tx_thread_preempt_threshold)
 800c4f2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c4f4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c4f6:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800c4f8:	429a      	cmp	r2, r3
 800c4fa:	d269      	bcs.n	800c5d0 <_tx_thread_system_resume+0x1a4>
                            {

#ifndef TX_DISABLE_PREEMPTION_THRESHOLD

                                /* Determine if the preempted thread had preemption-threshold set.  */
                                if (execute_ptr -> tx_thread_preempt_threshold != execute_ptr -> tx_thread_priority)
 800c4fc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c4fe:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800c500:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c502:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c504:	429a      	cmp	r2, r3
 800c506:	d00b      	beq.n	800c520 <_tx_thread_system_resume+0xf4>
                                    TX_DIV32_BIT_SET(execute_ptr -> tx_thread_priority, priority_bit)
                                    _tx_thread_preempted_map_active =  _tx_thread_preempted_map_active | priority_bit;
#endif

                                    /* Remember that this thread was preempted by a thread above the thread's threshold.  */
                                    TX_MOD32_BIT_SET(execute_ptr -> tx_thread_priority, priority_bit)
 800c508:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c50a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c50c:	2201      	movs	r2, #1
 800c50e:	fa02 f303 	lsl.w	r3, r2, r3
 800c512:	647b      	str	r3, [r7, #68]	; 0x44
                                    _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] | priority_bit;
 800c514:	4b4c      	ldr	r3, [pc, #304]	; (800c648 <_tx_thread_system_resume+0x21c>)
 800c516:	681a      	ldr	r2, [r3, #0]
 800c518:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800c51a:	4313      	orrs	r3, r2
 800c51c:	4a4a      	ldr	r2, [pc, #296]	; (800c648 <_tx_thread_system_resume+0x21c>)
 800c51e:	6013      	str	r3, [r2, #0]
                                execute_ptr -> tx_thread_performance_last_preempting_thread =  thread_ptr;

#endif

                                /* Yes, modify the execute thread pointer.  */
                                _tx_thread_execute_ptr =  thread_ptr;
 800c520:	4a48      	ldr	r2, [pc, #288]	; (800c644 <_tx_thread_system_resume+0x218>)
 800c522:	687b      	ldr	r3, [r7, #4]
 800c524:	6013      	str	r3, [r2, #0]
 800c526:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800c528:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c52a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c52c:	f383 8810 	msr	PRIMASK, r3
}
 800c530:	bf00      	nop
                                TX_THREAD_STACK_CHECK(thread_ptr)
#endif

                                /* Now determine if preemption should take place. This is only possible if the current thread pointer is
                                   not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
                                TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800c532:	4b40      	ldr	r3, [pc, #256]	; (800c634 <_tx_thread_system_resume+0x208>)
 800c534:	681b      	ldr	r3, [r3, #0]
 800c536:	63fb      	str	r3, [r7, #60]	; 0x3c
                                if (combined_flags == ((ULONG) 0))
 800c538:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c53a:	2b00      	cmp	r3, #0
 800c53c:	d174      	bne.n	800c628 <_tx_thread_system_resume+0x1fc>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800c53e:	4b43      	ldr	r3, [pc, #268]	; (800c64c <_tx_thread_system_resume+0x220>)
 800c540:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c544:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800c546:	f3ef 8305 	mrs	r3, IPSR
 800c54a:	62bb      	str	r3, [r7, #40]	; 0x28
    return(ipsr_value);
 800c54c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    if (_tx_ipsr_get() == 0)
 800c54e:	2b00      	cmp	r3, #0
 800c550:	d10c      	bne.n	800c56c <_tx_thread_system_resume+0x140>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c552:	f3ef 8310 	mrs	r3, PRIMASK
 800c556:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 800c558:	6a7b      	ldr	r3, [r7, #36]	; 0x24
        interrupt_save = __get_interrupt_posture();
 800c55a:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSIE  i": : : "memory");
 800c55c:	b662      	cpsie	i
}
 800c55e:	bf00      	nop
 800c560:	6a3b      	ldr	r3, [r7, #32]
 800c562:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c564:	69fb      	ldr	r3, [r7, #28]
 800c566:	f383 8810 	msr	PRIMASK, r3
}
 800c56a:	bf00      	nop
}
 800c56c:	bf00      	nop
                                    /* Preemption is needed - return to the system!  */
                                    _tx_thread_system_return();
                                }

                                /* Return in-line when MISRA is not enabled.  */
                                return;
 800c56e:	e05b      	b.n	800c628 <_tx_thread_system_resume+0x1fc>
                {

                    /* No, there are other threads at this priority already ready.  */

                    /* Just add this thread to the priority list.  */
                    tail_ptr =                                 head_ptr -> tx_thread_ready_previous;
 800c570:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c572:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c574:	64bb      	str	r3, [r7, #72]	; 0x48
                    tail_ptr -> tx_thread_ready_next =         thread_ptr;
 800c576:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800c578:	687a      	ldr	r2, [r7, #4]
 800c57a:	621a      	str	r2, [r3, #32]
                    head_ptr -> tx_thread_ready_previous =     thread_ptr;
 800c57c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c57e:	687a      	ldr	r2, [r7, #4]
 800c580:	625a      	str	r2, [r3, #36]	; 0x24
                    thread_ptr -> tx_thread_ready_previous =   tail_ptr;
 800c582:	687b      	ldr	r3, [r7, #4]
 800c584:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800c586:	625a      	str	r2, [r3, #36]	; 0x24
                    thread_ptr -> tx_thread_ready_next =       head_ptr;
 800c588:	687b      	ldr	r3, [r7, #4]
 800c58a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800c58c:	621a      	str	r2, [r3, #32]
 800c58e:	e01f      	b.n	800c5d0 <_tx_thread_system_resume+0x1a4>
            /* Else, delayed suspend flag was set.  */
            else
            {

                /* Clear the delayed suspend flag and change the state.  */
                thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
 800c590:	687b      	ldr	r3, [r7, #4]
 800c592:	2200      	movs	r2, #0
 800c594:	635a      	str	r2, [r3, #52]	; 0x34
                thread_ptr -> tx_thread_state =            TX_SUSPENDED;
 800c596:	687b      	ldr	r3, [r7, #4]
 800c598:	2203      	movs	r2, #3
 800c59a:	631a      	str	r2, [r3, #48]	; 0x30
 800c59c:	e018      	b.n	800c5d0 <_tx_thread_system_resume+0x1a4>
        /* A resumption occurred in the middle of a previous thread suspension.  */

        /* Make sure the type of suspension under way is not a terminate or
           thread completion.  In either of these cases, do not void the
           interrupted suspension processing.  */
        if (thread_ptr -> tx_thread_state != TX_COMPLETED)
 800c59e:	687b      	ldr	r3, [r7, #4]
 800c5a0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c5a2:	2b01      	cmp	r3, #1
 800c5a4:	d014      	beq.n	800c5d0 <_tx_thread_system_resume+0x1a4>
        {

            /* Make sure the thread isn't terminated.  */
            if (thread_ptr -> tx_thread_state != TX_TERMINATED)
 800c5a6:	687b      	ldr	r3, [r7, #4]
 800c5a8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c5aa:	2b02      	cmp	r3, #2
 800c5ac:	d010      	beq.n	800c5d0 <_tx_thread_system_resume+0x1a4>
            {

                /* No, now check to see if the delayed suspension flag is set.  */
                if (thread_ptr -> tx_thread_delayed_suspend == TX_FALSE)
 800c5ae:	687b      	ldr	r3, [r7, #4]
 800c5b0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c5b2:	2b00      	cmp	r3, #0
 800c5b4:	d106      	bne.n	800c5c4 <_tx_thread_system_resume+0x198>
                {

                    /* Clear the suspending flag.  */
                    thread_ptr -> tx_thread_suspending =   TX_FALSE;
 800c5b6:	687b      	ldr	r3, [r7, #4]
 800c5b8:	2200      	movs	r2, #0
 800c5ba:	639a      	str	r2, [r3, #56]	; 0x38

                    /* Restore the state to ready.  */
                    thread_ptr -> tx_thread_state =        TX_READY;
 800c5bc:	687b      	ldr	r3, [r7, #4]
 800c5be:	2200      	movs	r2, #0
 800c5c0:	631a      	str	r2, [r3, #48]	; 0x30
 800c5c2:	e005      	b.n	800c5d0 <_tx_thread_system_resume+0x1a4>
                }
                else
                {

                    /* Clear the delayed suspend flag and change the state.  */
                    thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
 800c5c4:	687b      	ldr	r3, [r7, #4]
 800c5c6:	2200      	movs	r2, #0
 800c5c8:	635a      	str	r2, [r3, #52]	; 0x34
                    thread_ptr -> tx_thread_state =            TX_SUSPENDED;
 800c5ca:	687b      	ldr	r3, [r7, #4]
 800c5cc:	2203      	movs	r2, #3
 800c5ce:	631a      	str	r2, [r3, #48]	; 0x30
        }
    }
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
 800c5d0:	4b1f      	ldr	r3, [pc, #124]	; (800c650 <_tx_thread_system_resume+0x224>)
 800c5d2:	681b      	ldr	r3, [r3, #0]
 800c5d4:	63bb      	str	r3, [r7, #56]	; 0x38
 800c5d6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800c5d8:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c5da:	69bb      	ldr	r3, [r7, #24]
 800c5dc:	f383 8810 	msr	PRIMASK, r3
}
 800c5e0:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if a preemption condition is present.  */
    if (current_thread != _tx_thread_execute_ptr)
 800c5e2:	4b18      	ldr	r3, [pc, #96]	; (800c644 <_tx_thread_system_resume+0x218>)
 800c5e4:	681b      	ldr	r3, [r3, #0]
 800c5e6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800c5e8:	429a      	cmp	r2, r3
 800c5ea:	d020      	beq.n	800c62e <_tx_thread_system_resume+0x202>
        TX_THREAD_STACK_CHECK(thread_ptr)
#endif

        /* Now determine if preemption should take place. This is only possible if the current thread pointer is
           not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
        TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800c5ec:	4b11      	ldr	r3, [pc, #68]	; (800c634 <_tx_thread_system_resume+0x208>)
 800c5ee:	681b      	ldr	r3, [r3, #0]
 800c5f0:	63fb      	str	r3, [r7, #60]	; 0x3c
        if (combined_flags == ((ULONG) 0))
 800c5f2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c5f4:	2b00      	cmp	r3, #0
 800c5f6:	d11a      	bne.n	800c62e <_tx_thread_system_resume+0x202>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800c5f8:	4b14      	ldr	r3, [pc, #80]	; (800c64c <_tx_thread_system_resume+0x220>)
 800c5fa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c5fe:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800c600:	f3ef 8305 	mrs	r3, IPSR
 800c604:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800c606:	697b      	ldr	r3, [r7, #20]
    if (_tx_ipsr_get() == 0)
 800c608:	2b00      	cmp	r3, #0
 800c60a:	d10f      	bne.n	800c62c <_tx_thread_system_resume+0x200>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c60c:	f3ef 8310 	mrs	r3, PRIMASK
 800c610:	613b      	str	r3, [r7, #16]
    return(posture);
 800c612:	693b      	ldr	r3, [r7, #16]
        interrupt_save = __get_interrupt_posture();
 800c614:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSIE  i": : : "memory");
 800c616:	b662      	cpsie	i
}
 800c618:	bf00      	nop
 800c61a:	68fb      	ldr	r3, [r7, #12]
 800c61c:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c61e:	68bb      	ldr	r3, [r7, #8]
 800c620:	f383 8810 	msr	PRIMASK, r3
}
 800c624:	bf00      	nop
}
 800c626:	e001      	b.n	800c62c <_tx_thread_system_resume+0x200>
                                return;
 800c628:	bf00      	nop
 800c62a:	e000      	b.n	800c62e <_tx_thread_system_resume+0x202>
 800c62c:	bf00      	nop

            /* Preemption is needed - return to the system!  */
            _tx_thread_system_return();
        }
    }
}
 800c62e:	3758      	adds	r7, #88	; 0x58
 800c630:	46bd      	mov	sp, r7
 800c632:	bd80      	pop	{r7, pc}
 800c634:	2000f054 	.word	0x2000f054
 800c638:	2000efd4 	.word	0x2000efd4
 800c63c:	2000efc8 	.word	0x2000efc8
 800c640:	2000efd0 	.word	0x2000efd0
 800c644:	2000efbc 	.word	0x2000efbc
 800c648:	2000efcc 	.word	0x2000efcc
 800c64c:	e000ed04 	.word	0xe000ed04
 800c650:	2000efb8 	.word	0x2000efb8

0800c654 <_tx_thread_system_suspend>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_suspend(TX_THREAD *thread_ptr)
#ifndef TX_NOT_INTERRUPTABLE
{
 800c654:	b580      	push	{r7, lr}
 800c656:	b0a0      	sub	sp, #128	; 0x80
 800c658:	af00      	add	r7, sp, #0
 800c65a:	6078      	str	r0, [r7, #4]
TX_TRACE_BUFFER_ENTRY       *entry_ptr;
ULONG                       time_stamp =  ((ULONG) 0);
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
 800c65c:	4b5a      	ldr	r3, [pc, #360]	; (800c7c8 <_tx_thread_system_suspend+0x174>)
 800c65e:	681b      	ldr	r3, [r3, #0]
 800c660:	67bb      	str	r3, [r7, #120]	; 0x78
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c662:	f3ef 8310 	mrs	r3, PRIMASK
 800c666:	657b      	str	r3, [r7, #84]	; 0x54
    return(posture);
 800c668:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    int_posture = __get_interrupt_posture();
 800c66a:	653b      	str	r3, [r7, #80]	; 0x50
    __asm__ volatile ("CPSID i" : : : "memory");
 800c66c:	b672      	cpsid	i
    return(int_posture);
 800c66e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    /* Check this thread's stack.  */
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif

    /* Lockout interrupts while the thread is being suspended.  */
    TX_DISABLE
 800c670:	67fb      	str	r3, [r7, #124]	; 0x7c

#ifndef TX_NO_TIMER

    /* Is the current thread suspending?  */
    if (thread_ptr == current_thread)
 800c672:	687a      	ldr	r2, [r7, #4]
 800c674:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800c676:	429a      	cmp	r2, r3
 800c678:	d112      	bne.n	800c6a0 <_tx_thread_system_suspend+0x4c>
    {

        /* Pickup the wait option.  */
        timeout =  thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks;
 800c67a:	687b      	ldr	r3, [r7, #4]
 800c67c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800c67e:	677b      	str	r3, [r7, #116]	; 0x74

        /* Determine if an activation is needed.  */
        if (timeout != TX_NO_WAIT)
 800c680:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800c682:	2b00      	cmp	r3, #0
 800c684:	d008      	beq.n	800c698 <_tx_thread_system_suspend+0x44>
        {

            /* Make sure the suspension is not a wait-forever.  */
            if (timeout != TX_WAIT_FOREVER)
 800c686:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800c688:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800c68c:	d004      	beq.n	800c698 <_tx_thread_system_suspend+0x44>
            {

                /* Activate the thread timer with the timeout value setup in the caller.  */
                _tx_timer_system_activate(&(thread_ptr -> tx_thread_timer));
 800c68e:	687b      	ldr	r3, [r7, #4]
 800c690:	334c      	adds	r3, #76	; 0x4c
 800c692:	4618      	mov	r0, r3
 800c694:	f000 ffc2 	bl	800d61c <_tx_timer_system_activate>
            }
        }

        /* Yes, reset time slice for current thread.  */
        _tx_timer_time_slice =  thread_ptr -> tx_thread_new_time_slice;
 800c698:	687b      	ldr	r3, [r7, #4]
 800c69a:	69db      	ldr	r3, [r3, #28]
 800c69c:	4a4b      	ldr	r2, [pc, #300]	; (800c7cc <_tx_thread_system_suspend+0x178>)
 800c69e:	6013      	str	r3, [r2, #0]
    }
#endif

    /* Decrease the preempt disabled count.  */
    _tx_thread_preempt_disable--;
 800c6a0:	4b4b      	ldr	r3, [pc, #300]	; (800c7d0 <_tx_thread_system_suspend+0x17c>)
 800c6a2:	681b      	ldr	r3, [r3, #0]
 800c6a4:	3b01      	subs	r3, #1
 800c6a6:	4a4a      	ldr	r2, [pc, #296]	; (800c7d0 <_tx_thread_system_suspend+0x17c>)
 800c6a8:	6013      	str	r3, [r2, #0]
    _tx_thread_performance_suspend_count++;
#endif

    /* Check to make sure the thread suspending flag is still set.  If not, it
       has already been resumed.  */
    if (thread_ptr -> tx_thread_suspending == TX_TRUE)
 800c6aa:	687b      	ldr	r3, [r7, #4]
 800c6ac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800c6ae:	2b01      	cmp	r3, #1
 800c6b0:	f040 8122 	bne.w	800c8f8 <_tx_thread_system_suspend+0x2a4>
            time_stamp =  entry_ptr -> tx_trace_buffer_entry_time_stamp;
        }
#endif

        /* Actually suspend this thread.  But first, clear the suspending flag.  */
        thread_ptr -> tx_thread_suspending =  TX_FALSE;
 800c6b4:	687b      	ldr	r3, [r7, #4]
 800c6b6:	2200      	movs	r2, #0
 800c6b8:	639a      	str	r2, [r3, #56]	; 0x38

        /* Pickup priority of thread.  */
        priority =  thread_ptr -> tx_thread_priority;
 800c6ba:	687b      	ldr	r3, [r7, #4]
 800c6bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c6be:	673b      	str	r3, [r7, #112]	; 0x70

        /* Pickup the next ready thread pointer.  */
        ready_next =      thread_ptr -> tx_thread_ready_next;
 800c6c0:	687b      	ldr	r3, [r7, #4]
 800c6c2:	6a1b      	ldr	r3, [r3, #32]
 800c6c4:	66fb      	str	r3, [r7, #108]	; 0x6c

        /* Determine if there are other threads at this priority that are
           ready.  */
        if (ready_next != thread_ptr)
 800c6c6:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 800c6c8:	687b      	ldr	r3, [r7, #4]
 800c6ca:	429a      	cmp	r2, r3
 800c6cc:	d027      	beq.n	800c71e <_tx_thread_system_suspend+0xca>
        {

            /* Yes, there are other threads at this priority ready.  */

            /* Pickup the previous ready thread pointer.  */
            ready_previous =  thread_ptr -> tx_thread_ready_previous;
 800c6ce:	687b      	ldr	r3, [r7, #4]
 800c6d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c6d2:	65bb      	str	r3, [r7, #88]	; 0x58

            /* Just remove this thread from the priority list.  */
            ready_next -> tx_thread_ready_previous =    ready_previous;
 800c6d4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800c6d6:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800c6d8:	625a      	str	r2, [r3, #36]	; 0x24
            ready_previous -> tx_thread_ready_next =    ready_next;
 800c6da:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800c6dc:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 800c6de:	621a      	str	r2, [r3, #32]

            /* Determine if this is the head of the priority list.  */
            if (_tx_thread_priority_list[priority] == thread_ptr)
 800c6e0:	4a3c      	ldr	r2, [pc, #240]	; (800c7d4 <_tx_thread_system_suspend+0x180>)
 800c6e2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c6e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800c6e8:	687a      	ldr	r2, [r7, #4]
 800c6ea:	429a      	cmp	r2, r3
 800c6ec:	f040 808b 	bne.w	800c806 <_tx_thread_system_suspend+0x1b2>
            {

                /* Update the head pointer of this priority list.  */
                _tx_thread_priority_list[priority] =  ready_next;
 800c6f0:	4938      	ldr	r1, [pc, #224]	; (800c7d4 <_tx_thread_system_suspend+0x180>)
 800c6f2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c6f4:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 800c6f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                /* Calculate the index into the bit map array.  */
                map_index =  priority/((UINT) 32);
#endif

                /* Check for a thread preempted that had preemption threshold set.  */
                if (_tx_thread_preempted_maps[MAP_INDEX] != ((ULONG) 0))
 800c6fa:	4b37      	ldr	r3, [pc, #220]	; (800c7d8 <_tx_thread_system_suspend+0x184>)
 800c6fc:	681b      	ldr	r3, [r3, #0]
 800c6fe:	2b00      	cmp	r3, #0
 800c700:	f000 8081 	beq.w	800c806 <_tx_thread_system_suspend+0x1b2>
                {

                    /* Ensure that this thread's priority is clear in the preempt map.  */
                    TX_MOD32_BIT_SET(priority, priority_bit)
 800c704:	2201      	movs	r2, #1
 800c706:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c708:	fa02 f303 	lsl.w	r3, r2, r3
 800c70c:	66bb      	str	r3, [r7, #104]	; 0x68
                    _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] & (~(priority_bit));
 800c70e:	4b32      	ldr	r3, [pc, #200]	; (800c7d8 <_tx_thread_system_suspend+0x184>)
 800c710:	681a      	ldr	r2, [r3, #0]
 800c712:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800c714:	43db      	mvns	r3, r3
 800c716:	4013      	ands	r3, r2
 800c718:	4a2f      	ldr	r2, [pc, #188]	; (800c7d8 <_tx_thread_system_suspend+0x184>)
 800c71a:	6013      	str	r3, [r2, #0]
 800c71c:	e073      	b.n	800c806 <_tx_thread_system_suspend+0x1b2>
        else
        {

            /* This is the only thread at this priority ready to run.  Set the head
               pointer to NULL.  */
            _tx_thread_priority_list[priority] =    TX_NULL;
 800c71e:	4a2d      	ldr	r2, [pc, #180]	; (800c7d4 <_tx_thread_system_suspend+0x180>)
 800c720:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c722:	2100      	movs	r1, #0
 800c724:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            /* Calculate the index into the bit map array.  */
            map_index =  priority/((UINT) 32);
#endif

            /* Clear this priority bit in the ready priority bit map.  */
            TX_MOD32_BIT_SET(priority, priority_bit)
 800c728:	2201      	movs	r2, #1
 800c72a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c72c:	fa02 f303 	lsl.w	r3, r2, r3
 800c730:	66bb      	str	r3, [r7, #104]	; 0x68
            _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] & (~(priority_bit));
 800c732:	4b2a      	ldr	r3, [pc, #168]	; (800c7dc <_tx_thread_system_suspend+0x188>)
 800c734:	681a      	ldr	r2, [r3, #0]
 800c736:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800c738:	43db      	mvns	r3, r3
 800c73a:	4013      	ands	r3, r2
 800c73c:	4a27      	ldr	r2, [pc, #156]	; (800c7dc <_tx_thread_system_suspend+0x188>)
 800c73e:	6013      	str	r3, [r2, #0]
#endif

#ifndef TX_DISABLE_PREEMPTION_THRESHOLD

            /* Check for a thread preempted that had preemption-threshold set.  */
            if (_tx_thread_preempted_maps[MAP_INDEX] != ((ULONG) 0))
 800c740:	4b25      	ldr	r3, [pc, #148]	; (800c7d8 <_tx_thread_system_suspend+0x184>)
 800c742:	681b      	ldr	r3, [r3, #0]
 800c744:	2b00      	cmp	r3, #0
 800c746:	d00b      	beq.n	800c760 <_tx_thread_system_suspend+0x10c>
            {

                /* Ensure that this thread's priority is clear in the preempt map.  */
                TX_MOD32_BIT_SET(priority, priority_bit)
 800c748:	2201      	movs	r2, #1
 800c74a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c74c:	fa02 f303 	lsl.w	r3, r2, r3
 800c750:	66bb      	str	r3, [r7, #104]	; 0x68
                _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] & (~(priority_bit));
 800c752:	4b21      	ldr	r3, [pc, #132]	; (800c7d8 <_tx_thread_system_suspend+0x184>)
 800c754:	681a      	ldr	r2, [r3, #0]
 800c756:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800c758:	43db      	mvns	r3, r3
 800c75a:	4013      	ands	r3, r2
 800c75c:	4a1e      	ldr	r2, [pc, #120]	; (800c7d8 <_tx_thread_system_suspend+0x184>)
 800c75e:	6013      	str	r3, [r2, #0]
            /* Calculate the base priority as well.  */
            base_priority =  map_index * ((UINT) 32);
#else

            /* Setup the base priority to zero.  */
            base_priority =   ((UINT) 0);
 800c760:	2300      	movs	r3, #0
 800c762:	667b      	str	r3, [r7, #100]	; 0x64
#endif

            /* Setup working variable for the priority map.  */
            priority_map =    _tx_thread_priority_maps[MAP_INDEX];
 800c764:	4b1d      	ldr	r3, [pc, #116]	; (800c7dc <_tx_thread_system_suspend+0x188>)
 800c766:	681b      	ldr	r3, [r3, #0]
 800c768:	663b      	str	r3, [r7, #96]	; 0x60

            /* Make a quick check for no other threads ready for execution.  */
            if (priority_map == ((ULONG) 0))
 800c76a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800c76c:	2b00      	cmp	r3, #0
 800c76e:	d13d      	bne.n	800c7ec <_tx_thread_system_suspend+0x198>
            {

                /* Nothing else is ready.  Set highest priority and execute thread
                   accordingly.  */
                _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
 800c770:	4b1b      	ldr	r3, [pc, #108]	; (800c7e0 <_tx_thread_system_suspend+0x18c>)
 800c772:	2220      	movs	r2, #32
 800c774:	601a      	str	r2, [r3, #0]
                _tx_thread_execute_ptr =       TX_NULL;
 800c776:	4b1b      	ldr	r3, [pc, #108]	; (800c7e4 <_tx_thread_system_suspend+0x190>)
 800c778:	2200      	movs	r2, #0
 800c77a:	601a      	str	r2, [r3, #0]
 800c77c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800c77e:	64fb      	str	r3, [r7, #76]	; 0x4c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c780:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c782:	f383 8810 	msr	PRIMASK, r3
}
 800c786:	bf00      	nop
                /* Restore interrupts.  */
                TX_RESTORE

                /* Determine if preemption should take place. This is only possible if the current thread pointer is
                   not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
                TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800c788:	4b11      	ldr	r3, [pc, #68]	; (800c7d0 <_tx_thread_system_suspend+0x17c>)
 800c78a:	681b      	ldr	r3, [r3, #0]
 800c78c:	65fb      	str	r3, [r7, #92]	; 0x5c
                if (combined_flags == ((ULONG) 0))
 800c78e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800c790:	2b00      	cmp	r3, #0
 800c792:	f040 80db 	bne.w	800c94c <_tx_thread_system_suspend+0x2f8>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800c796:	4b14      	ldr	r3, [pc, #80]	; (800c7e8 <_tx_thread_system_suspend+0x194>)
 800c798:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c79c:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800c79e:	f3ef 8305 	mrs	r3, IPSR
 800c7a2:	64bb      	str	r3, [r7, #72]	; 0x48
    return(ipsr_value);
 800c7a4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    if (_tx_ipsr_get() == 0)
 800c7a6:	2b00      	cmp	r3, #0
 800c7a8:	d10c      	bne.n	800c7c4 <_tx_thread_system_suspend+0x170>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c7aa:	f3ef 8310 	mrs	r3, PRIMASK
 800c7ae:	647b      	str	r3, [r7, #68]	; 0x44
    return(posture);
 800c7b0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
        interrupt_save = __get_interrupt_posture();
 800c7b2:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("CPSIE  i": : : "memory");
 800c7b4:	b662      	cpsie	i
}
 800c7b6:	bf00      	nop
 800c7b8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c7ba:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c7bc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c7be:	f383 8810 	msr	PRIMASK, r3
}
 800c7c2:	bf00      	nop
}
 800c7c4:	bf00      	nop
                    /* Preemption is needed - return to the system!  */
                    _tx_thread_system_return();
                }

                /* Return to caller.  */
                return;
 800c7c6:	e0c1      	b.n	800c94c <_tx_thread_system_suspend+0x2f8>
 800c7c8:	2000efb8 	.word	0x2000efb8
 800c7cc:	2000f5fc 	.word	0x2000f5fc
 800c7d0:	2000f054 	.word	0x2000f054
 800c7d4:	2000efd4 	.word	0x2000efd4
 800c7d8:	2000efcc 	.word	0x2000efcc
 800c7dc:	2000efc8 	.word	0x2000efc8
 800c7e0:	2000efd0 	.word	0x2000efd0
 800c7e4:	2000efbc 	.word	0x2000efbc
 800c7e8:	e000ed04 	.word	0xe000ed04
            {

                /* Other threads at different priority levels are ready to run.  */

                /* Calculate the lowest bit set in the priority map. */
                TX_LOWEST_SET_BIT_CALCULATE(priority_map, priority_bit)
 800c7ec:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800c7ee:	fa93 f3a3 	rbit	r3, r3
 800c7f2:	663b      	str	r3, [r7, #96]	; 0x60
 800c7f4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800c7f6:	fab3 f383 	clz	r3, r3
 800c7fa:	66bb      	str	r3, [r7, #104]	; 0x68

                /* Setup the next highest priority variable.  */
                _tx_thread_highest_priority =  base_priority + ((UINT) priority_bit);
 800c7fc:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800c7fe:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800c800:	4413      	add	r3, r2
 800c802:	4a56      	ldr	r2, [pc, #344]	; (800c95c <_tx_thread_system_suspend+0x308>)
 800c804:	6013      	str	r3, [r2, #0]
            }
        }

        /* Determine if the suspending thread is the thread designated to execute.  */
        if (thread_ptr == _tx_thread_execute_ptr)
 800c806:	4b56      	ldr	r3, [pc, #344]	; (800c960 <_tx_thread_system_suspend+0x30c>)
 800c808:	681b      	ldr	r3, [r3, #0]
 800c80a:	687a      	ldr	r2, [r7, #4]
 800c80c:	429a      	cmp	r2, r3
 800c80e:	d173      	bne.n	800c8f8 <_tx_thread_system_suspend+0x2a4>
        {

            /* Pickup the highest priority thread to execute.  */
            _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 800c810:	4b52      	ldr	r3, [pc, #328]	; (800c95c <_tx_thread_system_suspend+0x308>)
 800c812:	681b      	ldr	r3, [r3, #0]
 800c814:	4a53      	ldr	r2, [pc, #332]	; (800c964 <_tx_thread_system_suspend+0x310>)
 800c816:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800c81a:	4a51      	ldr	r2, [pc, #324]	; (800c960 <_tx_thread_system_suspend+0x30c>)
 800c81c:	6013      	str	r3, [r2, #0]

            /* Determine if a previous thread with preemption-threshold was preempted.  */
#if TX_MAX_PRIORITIES > 32
            if (_tx_thread_preempted_map_active != ((ULONG) 0))
#else
            if (_tx_thread_preempted_maps[MAP_INDEX] != ((ULONG) 0))
 800c81e:	4b52      	ldr	r3, [pc, #328]	; (800c968 <_tx_thread_system_suspend+0x314>)
 800c820:	681b      	ldr	r3, [r3, #0]
 800c822:	2b00      	cmp	r3, #0
 800c824:	d043      	beq.n	800c8ae <_tx_thread_system_suspend+0x25a>
            {

                /* Yes, there was a thread preempted when it was using preemption-threshold.  */

                /* Disable preemption.  */
                _tx_thread_preempt_disable++;
 800c826:	4b51      	ldr	r3, [pc, #324]	; (800c96c <_tx_thread_system_suspend+0x318>)
 800c828:	681b      	ldr	r3, [r3, #0]
 800c82a:	3301      	adds	r3, #1
 800c82c:	4a4f      	ldr	r2, [pc, #316]	; (800c96c <_tx_thread_system_suspend+0x318>)
 800c82e:	6013      	str	r3, [r2, #0]
 800c830:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800c832:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c834:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c836:	f383 8810 	msr	PRIMASK, r3
}
 800c83a:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c83c:	f3ef 8310 	mrs	r3, PRIMASK
 800c840:	63bb      	str	r3, [r7, #56]	; 0x38
    return(posture);
 800c842:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    int_posture = __get_interrupt_posture();
 800c844:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile ("CPSID i" : : : "memory");
 800c846:	b672      	cpsid	i
    return(int_posture);
 800c848:	6b7b      	ldr	r3, [r7, #52]	; 0x34

                /* Interrupts are enabled briefly here to keep the interrupt
                   lockout time deterministic.  */

                /* Disable interrupts again.  */
                TX_DISABLE
 800c84a:	67fb      	str	r3, [r7, #124]	; 0x7c

                /* Decrement the preemption disable variable.  */
                _tx_thread_preempt_disable--;
 800c84c:	4b47      	ldr	r3, [pc, #284]	; (800c96c <_tx_thread_system_suspend+0x318>)
 800c84e:	681b      	ldr	r3, [r3, #0]
 800c850:	3b01      	subs	r3, #1
 800c852:	4a46      	ldr	r2, [pc, #280]	; (800c96c <_tx_thread_system_suspend+0x318>)
 800c854:	6013      	str	r3, [r2, #0]
                /* Calculate the base priority as well.  */
                base_priority =  map_index * ((UINT) 32);
#else

                /* Setup the base priority to zero.  */
                base_priority =   ((UINT) 0);
 800c856:	2300      	movs	r3, #0
 800c858:	667b      	str	r3, [r7, #100]	; 0x64
#endif

                /* Setup temporary preempted map.  */
                priority_map =  _tx_thread_preempted_maps[MAP_INDEX];
 800c85a:	4b43      	ldr	r3, [pc, #268]	; (800c968 <_tx_thread_system_suspend+0x314>)
 800c85c:	681b      	ldr	r3, [r3, #0]
 800c85e:	663b      	str	r3, [r7, #96]	; 0x60

                /* Calculate the lowest bit set in the priority map. */
                TX_LOWEST_SET_BIT_CALCULATE(priority_map, priority_bit)
 800c860:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800c862:	fa93 f3a3 	rbit	r3, r3
 800c866:	663b      	str	r3, [r7, #96]	; 0x60
 800c868:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800c86a:	fab3 f383 	clz	r3, r3
 800c86e:	66bb      	str	r3, [r7, #104]	; 0x68

                /* Setup the highest priority preempted thread.  */
                priority =  base_priority + ((UINT) priority_bit);
 800c870:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800c872:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800c874:	4413      	add	r3, r2
 800c876:	673b      	str	r3, [r7, #112]	; 0x70

                /* Determine if the next highest priority thread is above the highest priority threshold value.  */
                if (_tx_thread_highest_priority >= (_tx_thread_priority_list[priority] -> tx_thread_preempt_threshold))
 800c878:	4a3a      	ldr	r2, [pc, #232]	; (800c964 <_tx_thread_system_suspend+0x310>)
 800c87a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c87c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800c880:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800c882:	4b36      	ldr	r3, [pc, #216]	; (800c95c <_tx_thread_system_suspend+0x308>)
 800c884:	681b      	ldr	r3, [r3, #0]
 800c886:	429a      	cmp	r2, r3
 800c888:	d811      	bhi.n	800c8ae <_tx_thread_system_suspend+0x25a>
                {

                    /* Thread not allowed to execute until earlier preempted thread finishes or lowers its
                       preemption-threshold.  */
                    _tx_thread_execute_ptr =  _tx_thread_priority_list[priority];
 800c88a:	4a36      	ldr	r2, [pc, #216]	; (800c964 <_tx_thread_system_suspend+0x310>)
 800c88c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c88e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800c892:	4a33      	ldr	r2, [pc, #204]	; (800c960 <_tx_thread_system_suspend+0x30c>)
 800c894:	6013      	str	r3, [r2, #0]

                    /* Clear the corresponding bit in the preempted map, since the preemption has been restored.  */
                    TX_MOD32_BIT_SET(priority, priority_bit)
 800c896:	2201      	movs	r2, #1
 800c898:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c89a:	fa02 f303 	lsl.w	r3, r2, r3
 800c89e:	66bb      	str	r3, [r7, #104]	; 0x68
                    _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] & (~(priority_bit));
 800c8a0:	4b31      	ldr	r3, [pc, #196]	; (800c968 <_tx_thread_system_suspend+0x314>)
 800c8a2:	681a      	ldr	r2, [r3, #0]
 800c8a4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800c8a6:	43db      	mvns	r3, r3
 800c8a8:	4013      	ands	r3, r2
 800c8aa:	4a2f      	ldr	r2, [pc, #188]	; (800c968 <_tx_thread_system_suspend+0x314>)
 800c8ac:	6013      	str	r3, [r2, #0]
 800c8ae:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800c8b0:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c8b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c8b4:	f383 8810 	msr	PRIMASK, r3
}
 800c8b8:	bf00      	nop
            /* Restore interrupts.  */
            TX_RESTORE

            /* Determine if preemption should take place. This is only possible if the current thread pointer is
               not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
            TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800c8ba:	4b2c      	ldr	r3, [pc, #176]	; (800c96c <_tx_thread_system_suspend+0x318>)
 800c8bc:	681b      	ldr	r3, [r3, #0]
 800c8be:	65fb      	str	r3, [r7, #92]	; 0x5c
            if (combined_flags == ((ULONG) 0))
 800c8c0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800c8c2:	2b00      	cmp	r3, #0
 800c8c4:	d144      	bne.n	800c950 <_tx_thread_system_suspend+0x2fc>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800c8c6:	4b2a      	ldr	r3, [pc, #168]	; (800c970 <_tx_thread_system_suspend+0x31c>)
 800c8c8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c8cc:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800c8ce:	f3ef 8305 	mrs	r3, IPSR
 800c8d2:	62bb      	str	r3, [r7, #40]	; 0x28
    return(ipsr_value);
 800c8d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    if (_tx_ipsr_get() == 0)
 800c8d6:	2b00      	cmp	r3, #0
 800c8d8:	d10c      	bne.n	800c8f4 <_tx_thread_system_suspend+0x2a0>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c8da:	f3ef 8310 	mrs	r3, PRIMASK
 800c8de:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 800c8e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
        interrupt_save = __get_interrupt_posture();
 800c8e2:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSIE  i": : : "memory");
 800c8e4:	b662      	cpsie	i
}
 800c8e6:	bf00      	nop
 800c8e8:	6a3b      	ldr	r3, [r7, #32]
 800c8ea:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c8ec:	69fb      	ldr	r3, [r7, #28]
 800c8ee:	f383 8810 	msr	PRIMASK, r3
}
 800c8f2:	bf00      	nop
}
 800c8f4:	bf00      	nop
                /* Preemption is needed - return to the system!  */
                _tx_thread_system_return();
            }

            /* Return to caller.  */
            return;
 800c8f6:	e02b      	b.n	800c950 <_tx_thread_system_suspend+0x2fc>
 800c8f8:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800c8fa:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c8fc:	69bb      	ldr	r3, [r7, #24]
 800c8fe:	f383 8810 	msr	PRIMASK, r3
}
 800c902:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if a preemption condition is present.  */
    if (current_thread != _tx_thread_execute_ptr)
 800c904:	4b16      	ldr	r3, [pc, #88]	; (800c960 <_tx_thread_system_suspend+0x30c>)
 800c906:	681b      	ldr	r3, [r3, #0]
 800c908:	6fba      	ldr	r2, [r7, #120]	; 0x78
 800c90a:	429a      	cmp	r2, r3
 800c90c:	d022      	beq.n	800c954 <_tx_thread_system_suspend+0x300>
        TX_THREAD_STACK_CHECK(thread_ptr)
#endif

        /* Determine if preemption should take place. This is only possible if the current thread pointer is
           not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
        TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800c90e:	4b17      	ldr	r3, [pc, #92]	; (800c96c <_tx_thread_system_suspend+0x318>)
 800c910:	681b      	ldr	r3, [r3, #0]
 800c912:	65fb      	str	r3, [r7, #92]	; 0x5c
        if (combined_flags == ((ULONG) 0))
 800c914:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800c916:	2b00      	cmp	r3, #0
 800c918:	d11c      	bne.n	800c954 <_tx_thread_system_suspend+0x300>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800c91a:	4b15      	ldr	r3, [pc, #84]	; (800c970 <_tx_thread_system_suspend+0x31c>)
 800c91c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c920:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800c922:	f3ef 8305 	mrs	r3, IPSR
 800c926:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800c928:	697b      	ldr	r3, [r7, #20]
    if (_tx_ipsr_get() == 0)
 800c92a:	2b00      	cmp	r3, #0
 800c92c:	d10c      	bne.n	800c948 <_tx_thread_system_suspend+0x2f4>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c92e:	f3ef 8310 	mrs	r3, PRIMASK
 800c932:	613b      	str	r3, [r7, #16]
    return(posture);
 800c934:	693b      	ldr	r3, [r7, #16]
        interrupt_save = __get_interrupt_posture();
 800c936:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSIE  i": : : "memory");
 800c938:	b662      	cpsie	i
}
 800c93a:	bf00      	nop
 800c93c:	68fb      	ldr	r3, [r7, #12]
 800c93e:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c940:	68bb      	ldr	r3, [r7, #8]
 800c942:	f383 8810 	msr	PRIMASK, r3
}
 800c946:	bf00      	nop
}
 800c948:	bf00      	nop
            _tx_thread_system_return();
        }
    }

    /* Return to caller.  */
    return;
 800c94a:	e003      	b.n	800c954 <_tx_thread_system_suspend+0x300>
                return;
 800c94c:	bf00      	nop
 800c94e:	e002      	b.n	800c956 <_tx_thread_system_suspend+0x302>
            return;
 800c950:	bf00      	nop
 800c952:	e000      	b.n	800c956 <_tx_thread_system_suspend+0x302>
    return;
 800c954:	bf00      	nop
}
 800c956:	3780      	adds	r7, #128	; 0x80
 800c958:	46bd      	mov	sp, r7
 800c95a:	bd80      	pop	{r7, pc}
 800c95c:	2000efd0 	.word	0x2000efd0
 800c960:	2000efbc 	.word	0x2000efbc
 800c964:	2000efd4 	.word	0x2000efd4
 800c968:	2000efcc 	.word	0x2000efcc
 800c96c:	2000f054 	.word	0x2000f054
 800c970:	e000ed04 	.word	0xe000ed04

0800c974 <_tx_thread_terminate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_terminate(TX_THREAD *thread_ptr)
{
 800c974:	b580      	push	{r7, lr}
 800c976:	b0ac      	sub	sp, #176	; 0xb0
 800c978:	af00      	add	r7, sp, #0
 800c97a:	6078      	str	r0, [r7, #4]
UINT        status;
ULONG       suspension_sequence;


    /* Default to successful completion.  */
    status =  TX_SUCCESS;
 800c97c:	2300      	movs	r3, #0
 800c97e:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c982:	f3ef 8310 	mrs	r3, PRIMASK
 800c986:	67bb      	str	r3, [r7, #120]	; 0x78
    return(posture);
 800c988:	6fbb      	ldr	r3, [r7, #120]	; 0x78
    int_posture = __get_interrupt_posture();
 800c98a:	677b      	str	r3, [r7, #116]	; 0x74
    __asm__ volatile ("CPSID i" : : : "memory");
 800c98c:	b672      	cpsid	i
    return(int_posture);
 800c98e:	6f7b      	ldr	r3, [r7, #116]	; 0x74

    /* Lockout interrupts while the thread is being terminated.  */
    TX_DISABLE
 800c990:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac

    /* Deactivate thread timer, if active.  */
    _tx_timer_system_deactivate(&thread_ptr -> tx_thread_timer);
 800c994:	687b      	ldr	r3, [r7, #4]
 800c996:	334c      	adds	r3, #76	; 0x4c
 800c998:	4618      	mov	r0, r3
 800c99a:	f000 fea1 	bl	800d6e0 <_tx_timer_system_deactivate>

    /* Log this kernel call.  */
    TX_EL_THREAD_TERMINATE_INSERT

    /* Is the thread already terminated?  */
    if (thread_ptr -> tx_thread_state == TX_TERMINATED)
 800c99e:	687b      	ldr	r3, [r7, #4]
 800c9a0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c9a2:	2b02      	cmp	r3, #2
 800c9a4:	d10a      	bne.n	800c9bc <_tx_thread_terminate+0x48>
 800c9a6:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800c9aa:	673b      	str	r3, [r7, #112]	; 0x70
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c9ac:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c9ae:	f383 8810 	msr	PRIMASK, r3
}
 800c9b2:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return success since thread is already terminated.  */
        status =  TX_SUCCESS;
 800c9b4:	2300      	movs	r3, #0
 800c9b6:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 800c9ba:	e157      	b.n	800cc6c <_tx_thread_terminate+0x2f8>
    }

    /* Check the specified thread's current status.  */
    else if (thread_ptr -> tx_thread_state != TX_COMPLETED)
 800c9bc:	687b      	ldr	r3, [r7, #4]
 800c9be:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c9c0:	2b01      	cmp	r3, #1
 800c9c2:	f000 814c 	beq.w	800cc5e <_tx_thread_terminate+0x2ea>
    {

        /* Disable preemption.  */
        _tx_thread_preempt_disable++;
 800c9c6:	4bad      	ldr	r3, [pc, #692]	; (800cc7c <_tx_thread_terminate+0x308>)
 800c9c8:	681b      	ldr	r3, [r3, #0]
 800c9ca:	3301      	adds	r3, #1
 800c9cc:	4aab      	ldr	r2, [pc, #684]	; (800cc7c <_tx_thread_terminate+0x308>)
 800c9ce:	6013      	str	r3, [r2, #0]

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Pickup the entry/exit application callback routine.  */
        entry_exit_notify =  thread_ptr -> tx_thread_entry_exit_notify;
 800c9d0:	687b      	ldr	r3, [r7, #4]
 800c9d2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800c9d6:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
#endif

        /* Check to see if the thread is currently ready.  */
        if (thread_ptr -> tx_thread_state == TX_READY)
 800c9da:	687b      	ldr	r3, [r7, #4]
 800c9dc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c9de:	2b00      	cmp	r3, #0
 800c9e0:	d17b      	bne.n	800cada <_tx_thread_terminate+0x166>
        {

            /* Set the state to terminated.  */
            thread_ptr -> tx_thread_state =  TX_TERMINATED;
 800c9e2:	687b      	ldr	r3, [r7, #4]
 800c9e4:	2202      	movs	r2, #2
 800c9e6:	631a      	str	r2, [r3, #48]	; 0x30
            /* Call actual non-interruptable thread suspension routine.  */
            _tx_thread_system_ni_suspend(thread_ptr, ((ULONG) 0));
#else

            /* Set the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800c9e8:	687b      	ldr	r3, [r7, #4]
 800c9ea:	2201      	movs	r2, #1
 800c9ec:	639a      	str	r2, [r3, #56]	; 0x38

            /* Setup for no timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 800c9ee:	687b      	ldr	r3, [r7, #4]
 800c9f0:	2200      	movs	r2, #0
 800c9f2:	64da      	str	r2, [r3, #76]	; 0x4c

            /* Disable preemption.  */
            _tx_thread_preempt_disable++;
 800c9f4:	4ba1      	ldr	r3, [pc, #644]	; (800cc7c <_tx_thread_terminate+0x308>)
 800c9f6:	681b      	ldr	r3, [r3, #0]
 800c9f8:	3301      	adds	r3, #1
 800c9fa:	4aa0      	ldr	r2, [pc, #640]	; (800cc7c <_tx_thread_terminate+0x308>)
 800c9fc:	6013      	str	r3, [r2, #0]
 800c9fe:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800ca02:	66bb      	str	r3, [r7, #104]	; 0x68
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ca04:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ca06:	f383 8810 	msr	PRIMASK, r3
}
 800ca0a:	bf00      	nop
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800ca0c:	f3ef 8305 	mrs	r3, IPSR
 800ca10:	66fb      	str	r3, [r7, #108]	; 0x6c
    return(ipsr_value);
 800ca12:	6efa      	ldr	r2, [r7, #108]	; 0x6c

            /* Restore interrupts.  */
            TX_RESTORE

            /* Perform any additional activities for tool or user purpose.  */
            TX_THREAD_TERMINATED_EXTENSION(thread_ptr)
 800ca14:	4b9a      	ldr	r3, [pc, #616]	; (800cc80 <_tx_thread_terminate+0x30c>)
 800ca16:	681b      	ldr	r3, [r3, #0]
 800ca18:	4313      	orrs	r3, r2
 800ca1a:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 800ca1e:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800ca22:	2b00      	cmp	r3, #0
 800ca24:	d118      	bne.n	800ca58 <_tx_thread_terminate+0xe4>
 800ca26:	4b97      	ldr	r3, [pc, #604]	; (800cc84 <_tx_thread_terminate+0x310>)
 800ca28:	681b      	ldr	r3, [r3, #0]
 800ca2a:	687a      	ldr	r2, [r7, #4]
 800ca2c:	429a      	cmp	r2, r3
 800ca2e:	d113      	bne.n	800ca58 <_tx_thread_terminate+0xe4>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 800ca30:	f3ef 8314 	mrs	r3, CONTROL
 800ca34:	663b      	str	r3, [r7, #96]	; 0x60
    return(control_value);
 800ca36:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800ca38:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 800ca3c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800ca40:	f023 0304 	bic.w	r3, r3, #4
 800ca44:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 800ca48:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800ca4c:	667b      	str	r3, [r7, #100]	; 0x64
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
 800ca4e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800ca50:	f383 8814 	msr	CONTROL, r3
}
 800ca54:	bf00      	nop
 800ca56:	e02a      	b.n	800caae <_tx_thread_terminate+0x13a>
 800ca58:	4b8b      	ldr	r3, [pc, #556]	; (800cc88 <_tx_thread_terminate+0x314>)
 800ca5a:	681b      	ldr	r3, [r3, #0]
 800ca5c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800ca60:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800ca64:	f003 0301 	and.w	r3, r3, #1
 800ca68:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800ca6c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800ca70:	2b01      	cmp	r3, #1
 800ca72:	d11c      	bne.n	800caae <_tx_thread_terminate+0x13a>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 800ca74:	f3ef 8314 	mrs	r3, CONTROL
 800ca78:	65fb      	str	r3, [r7, #92]	; 0x5c
    return(control_value);
 800ca7a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ca7c:	67fb      	str	r3, [r7, #124]	; 0x7c
 800ca7e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800ca80:	f003 0304 	and.w	r3, r3, #4
 800ca84:	67fb      	str	r3, [r7, #124]	; 0x7c
 800ca86:	eeb0 0a40 	vmov.f32	s0, s0
 800ca8a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800ca8c:	2b00      	cmp	r3, #0
 800ca8e:	d10e      	bne.n	800caae <_tx_thread_terminate+0x13a>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 800ca90:	f3ef 8314 	mrs	r3, CONTROL
 800ca94:	657b      	str	r3, [r7, #84]	; 0x54
    return(control_value);
 800ca96:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ca98:	67fb      	str	r3, [r7, #124]	; 0x7c
 800ca9a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800ca9c:	f023 0304 	bic.w	r3, r3, #4
 800caa0:	67fb      	str	r3, [r7, #124]	; 0x7c
 800caa2:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800caa4:	65bb      	str	r3, [r7, #88]	; 0x58
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
 800caa6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800caa8:	f383 8814 	msr	CONTROL, r3
}
 800caac:	bf00      	nop

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Determine if an application callback routine is specified.  */
            if (entry_exit_notify != TX_NULL)
 800caae:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800cab2:	2b00      	cmp	r3, #0
 800cab4:	d004      	beq.n	800cac0 <_tx_thread_terminate+0x14c>
            {

                /* Yes, notify application that this thread has exited!  */
                (entry_exit_notify)(thread_ptr, TX_THREAD_EXIT);
 800cab6:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800caba:	2101      	movs	r1, #1
 800cabc:	6878      	ldr	r0, [r7, #4]
 800cabe:	4798      	blx	r3
            }
#endif

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
 800cac0:	6878      	ldr	r0, [r7, #4]
 800cac2:	f7ff fdc7 	bl	800c654 <_tx_thread_system_suspend>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800cac6:	f3ef 8310 	mrs	r3, PRIMASK
 800caca:	653b      	str	r3, [r7, #80]	; 0x50
    return(posture);
 800cacc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    int_posture = __get_interrupt_posture();
 800cace:	64fb      	str	r3, [r7, #76]	; 0x4c
    __asm__ volatile ("CPSID i" : : : "memory");
 800cad0:	b672      	cpsid	i
    return(int_posture);
 800cad2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c

            /* Disable interrupts.  */
            TX_DISABLE
 800cad4:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 800cad8:	e09d      	b.n	800cc16 <_tx_thread_terminate+0x2a2>
        }
        else
        {

            /* Change the state to terminated.  */
            thread_ptr -> tx_thread_state =    TX_TERMINATED;
 800cada:	687b      	ldr	r3, [r7, #4]
 800cadc:	2202      	movs	r2, #2
 800cade:	631a      	str	r2, [r3, #48]	; 0x30
            /* Thread state change.  */
            TX_THREAD_STATE_CHANGE(thread_ptr, TX_TERMINATED)

            /* Set the suspending flag.  This prevents the thread from being
               resumed before the cleanup routine is executed.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800cae0:	687b      	ldr	r3, [r7, #4]
 800cae2:	2201      	movs	r2, #1
 800cae4:	639a      	str	r2, [r3, #56]	; 0x38

            /* Pickup the cleanup routine address.  */
            suspend_cleanup =  thread_ptr -> tx_thread_suspend_cleanup;
 800cae6:	687b      	ldr	r3, [r7, #4]
 800cae8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800caea:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0

#ifndef TX_NOT_INTERRUPTABLE

            /* Pickup the suspension sequence number that is used later to verify that the
               cleanup is still necessary.  */
            suspension_sequence =  thread_ptr -> tx_thread_suspension_sequence;
 800caee:	687b      	ldr	r3, [r7, #4]
 800caf0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 800caf4:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 800caf8:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800cafc:	64bb      	str	r3, [r7, #72]	; 0x48
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cafe:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800cb00:	f383 8810 	msr	PRIMASK, r3
}
 800cb04:	bf00      	nop
            /* Restore interrupts.  */
            TX_RESTORE
#endif

            /* Call any cleanup routines.  */
            if (suspend_cleanup != TX_NULL)
 800cb06:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800cb0a:	2b00      	cmp	r3, #0
 800cb0c:	d005      	beq.n	800cb1a <_tx_thread_terminate+0x1a6>
            {

                /* Yes, there is a function to call.  */
                (suspend_cleanup)(thread_ptr, suspension_sequence);
 800cb0e:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800cb12:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
 800cb16:	6878      	ldr	r0, [r7, #4]
 800cb18:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800cb1a:	f3ef 8310 	mrs	r3, PRIMASK
 800cb1e:	63fb      	str	r3, [r7, #60]	; 0x3c
    return(posture);
 800cb20:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    int_posture = __get_interrupt_posture();
 800cb22:	63bb      	str	r3, [r7, #56]	; 0x38
    __asm__ volatile ("CPSID i" : : : "memory");
 800cb24:	b672      	cpsid	i
    return(int_posture);
 800cb26:	6bbb      	ldr	r3, [r7, #56]	; 0x38
            }

#ifndef TX_NOT_INTERRUPTABLE

            /* Disable interrupts.  */
            TX_DISABLE
 800cb28:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
#endif

            /* Clear the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_FALSE;
 800cb2c:	687b      	ldr	r3, [r7, #4]
 800cb2e:	2200      	movs	r2, #0
 800cb30:	639a      	str	r2, [r3, #56]	; 0x38
 800cb32:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800cb36:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cb38:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800cb3a:	f383 8810 	msr	PRIMASK, r3
}
 800cb3e:	bf00      	nop
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800cb40:	f3ef 8305 	mrs	r3, IPSR
 800cb44:	647b      	str	r3, [r7, #68]	; 0x44
    return(ipsr_value);
 800cb46:	6c7a      	ldr	r2, [r7, #68]	; 0x44
            /* Restore interrupts.  */
            TX_RESTORE
#endif

            /* Perform any additional activities for tool or user purpose.  */
            TX_THREAD_TERMINATED_EXTENSION(thread_ptr)
 800cb48:	4b4d      	ldr	r3, [pc, #308]	; (800cc80 <_tx_thread_terminate+0x30c>)
 800cb4a:	681b      	ldr	r3, [r3, #0]
 800cb4c:	4313      	orrs	r3, r2
 800cb4e:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 800cb52:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800cb56:	2b00      	cmp	r3, #0
 800cb58:	d118      	bne.n	800cb8c <_tx_thread_terminate+0x218>
 800cb5a:	4b4a      	ldr	r3, [pc, #296]	; (800cc84 <_tx_thread_terminate+0x310>)
 800cb5c:	681b      	ldr	r3, [r3, #0]
 800cb5e:	687a      	ldr	r2, [r7, #4]
 800cb60:	429a      	cmp	r2, r3
 800cb62:	d113      	bne.n	800cb8c <_tx_thread_terminate+0x218>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 800cb64:	f3ef 8314 	mrs	r3, CONTROL
 800cb68:	633b      	str	r3, [r7, #48]	; 0x30
    return(control_value);
 800cb6a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800cb6c:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 800cb70:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800cb74:	f023 0304 	bic.w	r3, r3, #4
 800cb78:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 800cb7c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800cb80:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
 800cb82:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800cb84:	f383 8814 	msr	CONTROL, r3
}
 800cb88:	bf00      	nop
 800cb8a:	e032      	b.n	800cbf2 <_tx_thread_terminate+0x27e>
 800cb8c:	4b3e      	ldr	r3, [pc, #248]	; (800cc88 <_tx_thread_terminate+0x314>)
 800cb8e:	681b      	ldr	r3, [r3, #0]
 800cb90:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 800cb94:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800cb98:	f003 0301 	and.w	r3, r3, #1
 800cb9c:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 800cba0:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800cba4:	2b01      	cmp	r3, #1
 800cba6:	d124      	bne.n	800cbf2 <_tx_thread_terminate+0x27e>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 800cba8:	f3ef 8314 	mrs	r3, CONTROL
 800cbac:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(control_value);
 800cbae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cbb0:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 800cbb4:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800cbb8:	f003 0304 	and.w	r3, r3, #4
 800cbbc:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 800cbc0:	eeb0 0a40 	vmov.f32	s0, s0
 800cbc4:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800cbc8:	2b00      	cmp	r3, #0
 800cbca:	d112      	bne.n	800cbf2 <_tx_thread_terminate+0x27e>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 800cbcc:	f3ef 8314 	mrs	r3, CONTROL
 800cbd0:	627b      	str	r3, [r7, #36]	; 0x24
    return(control_value);
 800cbd2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cbd4:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 800cbd8:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800cbdc:	f023 0304 	bic.w	r3, r3, #4
 800cbe0:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 800cbe4:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800cbe8:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
 800cbea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cbec:	f383 8814 	msr	CONTROL, r3
}
 800cbf0:	bf00      	nop

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Determine if an application callback routine is specified.  */
            if (entry_exit_notify != TX_NULL)
 800cbf2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800cbf6:	2b00      	cmp	r3, #0
 800cbf8:	d004      	beq.n	800cc04 <_tx_thread_terminate+0x290>
            {

                /* Yes, notify application that this thread has exited!  */
                (entry_exit_notify)(thread_ptr, TX_THREAD_EXIT);
 800cbfa:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800cbfe:	2101      	movs	r1, #1
 800cc00:	6878      	ldr	r0, [r7, #4]
 800cc02:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800cc04:	f3ef 8310 	mrs	r3, PRIMASK
 800cc08:	623b      	str	r3, [r7, #32]
    return(posture);
 800cc0a:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 800cc0c:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 800cc0e:	b672      	cpsid	i
    return(int_posture);
 800cc10:	69fb      	ldr	r3, [r7, #28]
#endif

#ifndef TX_NOT_INTERRUPTABLE

            /* Disable interrupts.  */
            TX_DISABLE
 800cc12:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 800cc16:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800cc1a:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cc1c:	69bb      	ldr	r3, [r7, #24]
 800cc1e:	f383 8810 	msr	PRIMASK, r3
}
 800cc22:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE
#endif

        /* Determine if the application is using mutexes.  */
        if (_tx_thread_mutex_release != TX_NULL)
 800cc24:	4b19      	ldr	r3, [pc, #100]	; (800cc8c <_tx_thread_terminate+0x318>)
 800cc26:	681b      	ldr	r3, [r3, #0]
 800cc28:	2b00      	cmp	r3, #0
 800cc2a:	d003      	beq.n	800cc34 <_tx_thread_terminate+0x2c0>
        {

            /* Yes, call the mutex release function via a function pointer that
               is setup during initialization.  */
            (_tx_thread_mutex_release)(thread_ptr);
 800cc2c:	4b17      	ldr	r3, [pc, #92]	; (800cc8c <_tx_thread_terminate+0x318>)
 800cc2e:	681b      	ldr	r3, [r3, #0]
 800cc30:	6878      	ldr	r0, [r7, #4]
 800cc32:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800cc34:	f3ef 8310 	mrs	r3, PRIMASK
 800cc38:	613b      	str	r3, [r7, #16]
    return(posture);
 800cc3a:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 800cc3c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 800cc3e:	b672      	cpsid	i
    return(int_posture);
 800cc40:	68fb      	ldr	r3, [r7, #12]
        }

#ifndef TX_NOT_INTERRUPTABLE

        /* Disable interrupts.  */
        TX_DISABLE
 800cc42:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
#endif

        /* Enable preemption.  */
        _tx_thread_preempt_disable--;
 800cc46:	4b0d      	ldr	r3, [pc, #52]	; (800cc7c <_tx_thread_terminate+0x308>)
 800cc48:	681b      	ldr	r3, [r3, #0]
 800cc4a:	3b01      	subs	r3, #1
 800cc4c:	4a0b      	ldr	r2, [pc, #44]	; (800cc7c <_tx_thread_terminate+0x308>)
 800cc4e:	6013      	str	r3, [r2, #0]
 800cc50:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800cc54:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cc56:	697b      	ldr	r3, [r7, #20]
 800cc58:	f383 8810 	msr	PRIMASK, r3
}
 800cc5c:	e006      	b.n	800cc6c <_tx_thread_terminate+0x2f8>
 800cc5e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800cc62:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cc64:	68bb      	ldr	r3, [r7, #8]
 800cc66:	f383 8810 	msr	PRIMASK, r3
}
 800cc6a:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 800cc6c:	f7ff fba4 	bl	800c3b8 <_tx_thread_system_preempt_check>

    /* Return completion status.  */
    return(status);
 800cc70:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
}
 800cc74:	4618      	mov	r0, r3
 800cc76:	37b0      	adds	r7, #176	; 0xb0
 800cc78:	46bd      	mov	sp, r7
 800cc7a:	bd80      	pop	{r7, pc}
 800cc7c:	2000f054 	.word	0x2000f054
 800cc80:	2000000c 	.word	0x2000000c
 800cc84:	2000efb8 	.word	0x2000efb8
 800cc88:	e000ef34 	.word	0xe000ef34
 800cc8c:	2000f058 	.word	0x2000f058

0800cc90 <_tx_thread_time_slice>:
/*                                            TX_NO_TIMER is defined,     */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_time_slice(VOID)
{
 800cc90:	b480      	push	{r7}
 800cc92:	b087      	sub	sp, #28
 800cc94:	af00      	add	r7, sp, #0
ULONG           system_state;
UINT            preempt_disable;
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800cc96:	4b21      	ldr	r3, [pc, #132]	; (800cd1c <_tx_thread_time_slice+0x8c>)
 800cc98:	681b      	ldr	r3, [r3, #0]
 800cc9a:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800cc9c:	f3ef 8310 	mrs	r3, PRIMASK
 800cca0:	60fb      	str	r3, [r7, #12]
    return(posture);
 800cca2:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 800cca4:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 800cca6:	b672      	cpsid	i
    return(int_posture);
 800cca8:	68bb      	ldr	r3, [r7, #8]
    /* Set the next thread pointer to NULL.  */
    next_thread_ptr =  TX_NULL;
#endif

    /* Lockout interrupts while the time-slice is evaluated.  */
    TX_DISABLE
 800ccaa:	613b      	str	r3, [r7, #16]

    /* Clear the expired time-slice flag.  */
    _tx_timer_expired_time_slice =  TX_FALSE;
 800ccac:	4b1c      	ldr	r3, [pc, #112]	; (800cd20 <_tx_thread_time_slice+0x90>)
 800ccae:	2200      	movs	r2, #0
 800ccb0:	601a      	str	r2, [r3, #0]

    /* Make sure the thread pointer is valid.  */
    if (thread_ptr != TX_NULL)
 800ccb2:	697b      	ldr	r3, [r7, #20]
 800ccb4:	2b00      	cmp	r3, #0
 800ccb6:	d024      	beq.n	800cd02 <_tx_thread_time_slice+0x72>
    {

        /* Make sure the thread is still active, i.e. not suspended.  */
        if (thread_ptr -> tx_thread_state == TX_READY)
 800ccb8:	697b      	ldr	r3, [r7, #20]
 800ccba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ccbc:	2b00      	cmp	r3, #0
 800ccbe:	d120      	bne.n	800cd02 <_tx_thread_time_slice+0x72>
        {

            /* Setup a fresh time-slice for the thread.  */
            thread_ptr -> tx_thread_time_slice =  thread_ptr -> tx_thread_new_time_slice;
 800ccc0:	697b      	ldr	r3, [r7, #20]
 800ccc2:	69da      	ldr	r2, [r3, #28]
 800ccc4:	697b      	ldr	r3, [r7, #20]
 800ccc6:	619a      	str	r2, [r3, #24]

            /* Reset the actual time-slice variable.  */
            _tx_timer_time_slice =  thread_ptr -> tx_thread_time_slice;
 800ccc8:	697b      	ldr	r3, [r7, #20]
 800ccca:	699b      	ldr	r3, [r3, #24]
 800cccc:	4a15      	ldr	r2, [pc, #84]	; (800cd24 <_tx_thread_time_slice+0x94>)
 800ccce:	6013      	str	r3, [r2, #0]

            /* Determine if there is another thread at the same priority and preemption-threshold
               is not set.  Preemption-threshold overrides time-slicing.  */
            if (thread_ptr -> tx_thread_ready_next != thread_ptr)
 800ccd0:	697b      	ldr	r3, [r7, #20]
 800ccd2:	6a1b      	ldr	r3, [r3, #32]
 800ccd4:	697a      	ldr	r2, [r7, #20]
 800ccd6:	429a      	cmp	r2, r3
 800ccd8:	d013      	beq.n	800cd02 <_tx_thread_time_slice+0x72>
            {

                /* Check to see if preemption-threshold is not being used.  */
                if (thread_ptr -> tx_thread_priority == thread_ptr -> tx_thread_preempt_threshold)
 800ccda:	697b      	ldr	r3, [r7, #20]
 800ccdc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ccde:	697b      	ldr	r3, [r7, #20]
 800cce0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800cce2:	429a      	cmp	r2, r3
 800cce4:	d10d      	bne.n	800cd02 <_tx_thread_time_slice+0x72>

                    /* Preemption-threshold is not being used by this thread.  */

                    /* There is another thread at this priority, make it the highest at
                       this priority level.  */
                    _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr -> tx_thread_ready_next;
 800cce6:	697b      	ldr	r3, [r7, #20]
 800cce8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ccea:	697a      	ldr	r2, [r7, #20]
 800ccec:	6a12      	ldr	r2, [r2, #32]
 800ccee:	490e      	ldr	r1, [pc, #56]	; (800cd28 <_tx_thread_time_slice+0x98>)
 800ccf0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

                    /* Designate the highest priority thread as the one to execute.  Don't use this
                       thread's priority as an index just in case a higher priority thread is now
                       ready!  */
                    _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 800ccf4:	4b0d      	ldr	r3, [pc, #52]	; (800cd2c <_tx_thread_time_slice+0x9c>)
 800ccf6:	681b      	ldr	r3, [r3, #0]
 800ccf8:	4a0b      	ldr	r2, [pc, #44]	; (800cd28 <_tx_thread_time_slice+0x98>)
 800ccfa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800ccfe:	4a0c      	ldr	r2, [pc, #48]	; (800cd30 <_tx_thread_time_slice+0xa0>)
 800cd00:	6013      	str	r3, [r2, #0]
 800cd02:	693b      	ldr	r3, [r7, #16]
 800cd04:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cd06:	687b      	ldr	r3, [r7, #4]
 800cd08:	f383 8810 	msr	PRIMASK, r3
}
 800cd0c:	bf00      	nop

        /* Yes, check this thread's stack.  */
        TX_THREAD_STACK_CHECK(next_thread_ptr)
    }
#endif
}
 800cd0e:	bf00      	nop
 800cd10:	371c      	adds	r7, #28
 800cd12:	46bd      	mov	sp, r7
 800cd14:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd18:	4770      	bx	lr
 800cd1a:	bf00      	nop
 800cd1c:	2000efb8 	.word	0x2000efb8
 800cd20:	2000f068 	.word	0x2000f068
 800cd24:	2000f5fc 	.word	0x2000f5fc
 800cd28:	2000efd4 	.word	0x2000efd4
 800cd2c:	2000efd0 	.word	0x2000efd0
 800cd30:	2000efbc 	.word	0x2000efbc

0800cd34 <_tx_thread_time_slice_change>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_time_slice_change(TX_THREAD *thread_ptr, ULONG new_time_slice, ULONG *old_time_slice)
{
 800cd34:	b480      	push	{r7}
 800cd36:	b08b      	sub	sp, #44	; 0x2c
 800cd38:	af00      	add	r7, sp, #0
 800cd3a:	60f8      	str	r0, [r7, #12]
 800cd3c:	60b9      	str	r1, [r7, #8]
 800cd3e:	607a      	str	r2, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800cd40:	f3ef 8310 	mrs	r3, PRIMASK
 800cd44:	61fb      	str	r3, [r7, #28]
    return(posture);
 800cd46:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800cd48:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800cd4a:	b672      	cpsid	i
    return(int_posture);
 800cd4c:	69bb      	ldr	r3, [r7, #24]

TX_THREAD       *current_thread;


    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
 800cd4e:	627b      	str	r3, [r7, #36]	; 0x24

    /* Log this kernel call.  */
    TX_EL_THREAD_TIME_SLICE_CHANGE_INSERT

    /* Return the old time slice.  */
    *old_time_slice =  thread_ptr -> tx_thread_new_time_slice;
 800cd50:	68fb      	ldr	r3, [r7, #12]
 800cd52:	69da      	ldr	r2, [r3, #28]
 800cd54:	687b      	ldr	r3, [r7, #4]
 800cd56:	601a      	str	r2, [r3, #0]

    /* Setup the new time-slice.  */
    thread_ptr -> tx_thread_time_slice =      new_time_slice;
 800cd58:	68fb      	ldr	r3, [r7, #12]
 800cd5a:	68ba      	ldr	r2, [r7, #8]
 800cd5c:	619a      	str	r2, [r3, #24]
    thread_ptr -> tx_thread_new_time_slice =  new_time_slice;
 800cd5e:	68fb      	ldr	r3, [r7, #12]
 800cd60:	68ba      	ldr	r2, [r7, #8]
 800cd62:	61da      	str	r2, [r3, #28]

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
 800cd64:	4b0b      	ldr	r3, [pc, #44]	; (800cd94 <_tx_thread_time_slice_change+0x60>)
 800cd66:	681b      	ldr	r3, [r3, #0]
 800cd68:	623b      	str	r3, [r7, #32]

    /* Determine if this thread is the currently executing thread.  */
    if (thread_ptr == current_thread)
 800cd6a:	68fa      	ldr	r2, [r7, #12]
 800cd6c:	6a3b      	ldr	r3, [r7, #32]
 800cd6e:	429a      	cmp	r2, r3
 800cd70:	d102      	bne.n	800cd78 <_tx_thread_time_slice_change+0x44>
    {

        /* Yes, update the time-slice countdown variable.  */
        _tx_timer_time_slice =  new_time_slice;
 800cd72:	4a09      	ldr	r2, [pc, #36]	; (800cd98 <_tx_thread_time_slice_change+0x64>)
 800cd74:	68bb      	ldr	r3, [r7, #8]
 800cd76:	6013      	str	r3, [r2, #0]
 800cd78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cd7a:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cd7c:	697b      	ldr	r3, [r7, #20]
 800cd7e:	f383 8810 	msr	PRIMASK, r3
}
 800cd82:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(TX_SUCCESS);
 800cd84:	2300      	movs	r3, #0
}
 800cd86:	4618      	mov	r0, r3
 800cd88:	372c      	adds	r7, #44	; 0x2c
 800cd8a:	46bd      	mov	sp, r7
 800cd8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd90:	4770      	bx	lr
 800cd92:	bf00      	nop
 800cd94:	2000efb8 	.word	0x2000efb8
 800cd98:	2000f5fc 	.word	0x2000f5fc

0800cd9c <_tx_thread_timeout>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_timeout(ULONG timeout_input)
{
 800cd9c:	b580      	push	{r7, lr}
 800cd9e:	b08a      	sub	sp, #40	; 0x28
 800cda0:	af00      	add	r7, sp, #0
 800cda2:	6078      	str	r0, [r7, #4]
VOID            (*suspend_cleanup)(struct TX_THREAD_STRUCT *suspend_thread_ptr, ULONG suspension_sequence);
ULONG           suspension_sequence;


    /* Pickup the thread pointer.  */
    TX_THREAD_TIMEOUT_POINTER_SETUP(thread_ptr)
 800cda4:	687b      	ldr	r3, [r7, #4]
 800cda6:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800cda8:	f3ef 8310 	mrs	r3, PRIMASK
 800cdac:	617b      	str	r3, [r7, #20]
    return(posture);
 800cdae:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800cdb0:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800cdb2:	b672      	cpsid	i
    return(int_posture);
 800cdb4:	693b      	ldr	r3, [r7, #16]

    /* Disable interrupts.  */
    TX_DISABLE
 800cdb6:	623b      	str	r3, [r7, #32]

    /* Determine how the thread is currently suspended.  */
    if (thread_ptr -> tx_thread_state == TX_SLEEP)
 800cdb8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cdba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800cdbc:	2b04      	cmp	r3, #4
 800cdbe:	d10e      	bne.n	800cdde <_tx_thread_timeout+0x42>
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Increment the disable preemption flag.  */
        _tx_thread_preempt_disable++;
 800cdc0:	4b13      	ldr	r3, [pc, #76]	; (800ce10 <_tx_thread_timeout+0x74>)
 800cdc2:	681b      	ldr	r3, [r3, #0]
 800cdc4:	3301      	adds	r3, #1
 800cdc6:	4a12      	ldr	r2, [pc, #72]	; (800ce10 <_tx_thread_timeout+0x74>)
 800cdc8:	6013      	str	r3, [r2, #0]
 800cdca:	6a3b      	ldr	r3, [r7, #32]
 800cdcc:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cdce:	68fb      	ldr	r3, [r7, #12]
 800cdd0:	f383 8810 	msr	PRIMASK, r3
}
 800cdd4:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Lift the suspension on the sleeping thread.  */
        _tx_thread_system_resume(thread_ptr);
 800cdd6:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800cdd8:	f7ff fb28 	bl	800c42c <_tx_thread_system_resume>

        /* Restore interrupts.  */
        TX_RESTORE
#endif
    }
}
 800cddc:	e013      	b.n	800ce06 <_tx_thread_timeout+0x6a>
        suspend_cleanup =  thread_ptr -> tx_thread_suspend_cleanup;
 800cdde:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cde0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800cde2:	61fb      	str	r3, [r7, #28]
        suspension_sequence =  thread_ptr -> tx_thread_suspension_sequence;
 800cde4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cde6:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 800cdea:	61bb      	str	r3, [r7, #24]
 800cdec:	6a3b      	ldr	r3, [r7, #32]
 800cdee:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cdf0:	68bb      	ldr	r3, [r7, #8]
 800cdf2:	f383 8810 	msr	PRIMASK, r3
}
 800cdf6:	bf00      	nop
        if (suspend_cleanup != TX_NULL)
 800cdf8:	69fb      	ldr	r3, [r7, #28]
 800cdfa:	2b00      	cmp	r3, #0
 800cdfc:	d003      	beq.n	800ce06 <_tx_thread_timeout+0x6a>
            (suspend_cleanup)(thread_ptr, suspension_sequence);
 800cdfe:	69fb      	ldr	r3, [r7, #28]
 800ce00:	69b9      	ldr	r1, [r7, #24]
 800ce02:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800ce04:	4798      	blx	r3
}
 800ce06:	bf00      	nop
 800ce08:	3728      	adds	r7, #40	; 0x28
 800ce0a:	46bd      	mov	sp, r7
 800ce0c:	bd80      	pop	{r7, pc}
 800ce0e:	bf00      	nop
 800ce10:	2000f054 	.word	0x2000f054

0800ce14 <_tx_thread_wait_abort>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_wait_abort(TX_THREAD  *thread_ptr)
{
 800ce14:	b580      	push	{r7, lr}
 800ce16:	b08e      	sub	sp, #56	; 0x38
 800ce18:	af00      	add	r7, sp, #0
 800ce1a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800ce1c:	f3ef 8310 	mrs	r3, PRIMASK
 800ce20:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 800ce22:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 800ce24:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 800ce26:	b672      	cpsid	i
    return(int_posture);
 800ce28:	6a3b      	ldr	r3, [r7, #32]
UINT            status;
ULONG           suspension_sequence;


    /* Disable interrupts.  */
    TX_DISABLE
 800ce2a:	633b      	str	r3, [r7, #48]	; 0x30

    /* Log this kernel call.  */
    TX_EL_THREAD_WAIT_ABORT_INSERT

    /* Determine if the thread is currently suspended.  */
    if (thread_ptr -> tx_thread_state < TX_SLEEP)
 800ce2c:	687b      	ldr	r3, [r7, #4]
 800ce2e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ce30:	2b03      	cmp	r3, #3
 800ce32:	d808      	bhi.n	800ce46 <_tx_thread_wait_abort+0x32>
 800ce34:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ce36:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ce38:	69fb      	ldr	r3, [r7, #28]
 800ce3a:	f383 8810 	msr	PRIMASK, r3
}
 800ce3e:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE

        /* Just return with an error message to indicate that
           nothing was done.  */
        status =  TX_WAIT_ABORT_ERROR;
 800ce40:	231b      	movs	r3, #27
 800ce42:	637b      	str	r3, [r7, #52]	; 0x34
 800ce44:	e058      	b.n	800cef8 <_tx_thread_wait_abort+0xe4>
    }
    else
    {

        /* Check for a sleep condition.  */
        if (thread_ptr -> tx_thread_state == TX_SLEEP)
 800ce46:	687b      	ldr	r3, [r7, #4]
 800ce48:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ce4a:	2b04      	cmp	r3, #4
 800ce4c:	d114      	bne.n	800ce78 <_tx_thread_wait_abort+0x64>
        {

            /* Set the state to terminated.  */
            thread_ptr -> tx_thread_state =    TX_SUSPENDED;
 800ce4e:	687b      	ldr	r3, [r7, #4]
 800ce50:	2203      	movs	r2, #3
 800ce52:	631a      	str	r2, [r3, #48]	; 0x30

            /* Set the TX_WAIT_ABORTED status in the thread that is
               sleeping.  */
            thread_ptr -> tx_thread_suspend_status =  TX_WAIT_ABORTED;
 800ce54:	687b      	ldr	r3, [r7, #4]
 800ce56:	221a      	movs	r2, #26
 800ce58:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

            /* Make sure there isn't a suspend cleanup routine.  */
            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800ce5c:	687b      	ldr	r3, [r7, #4]
 800ce5e:	2200      	movs	r2, #0
 800ce60:	669a      	str	r2, [r3, #104]	; 0x68

#ifndef TX_NOT_INTERRUPTABLE

            /* Increment the disable preemption flag.  */
            _tx_thread_preempt_disable++;
 800ce62:	4b28      	ldr	r3, [pc, #160]	; (800cf04 <_tx_thread_wait_abort+0xf0>)
 800ce64:	681b      	ldr	r3, [r3, #0]
 800ce66:	3301      	adds	r3, #1
 800ce68:	4a26      	ldr	r2, [pc, #152]	; (800cf04 <_tx_thread_wait_abort+0xf0>)
 800ce6a:	6013      	str	r3, [r2, #0]
 800ce6c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ce6e:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ce70:	69bb      	ldr	r3, [r7, #24]
 800ce72:	f383 8810 	msr	PRIMASK, r3
}
 800ce76:	e01f      	b.n	800ceb8 <_tx_thread_wait_abort+0xa4>
        {

            /* Process all other suspension timeouts.  */

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_SUSPENDED;
 800ce78:	687b      	ldr	r3, [r7, #4]
 800ce7a:	2203      	movs	r2, #3
 800ce7c:	631a      	str	r2, [r3, #48]	; 0x30

            /* Pickup the cleanup routine address.  */
            suspend_cleanup =  thread_ptr -> tx_thread_suspend_cleanup;
 800ce7e:	687b      	ldr	r3, [r7, #4]
 800ce80:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800ce82:	62fb      	str	r3, [r7, #44]	; 0x2c

#ifndef TX_NOT_INTERRUPTABLE

            /* Pickup the suspension sequence number that is used later to verify that the
               cleanup is still necessary.  */
            suspension_sequence =  thread_ptr -> tx_thread_suspension_sequence;
 800ce84:	687b      	ldr	r3, [r7, #4]
 800ce86:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 800ce8a:	62bb      	str	r3, [r7, #40]	; 0x28
            suspension_sequence =  ((ULONG) 0);
#endif

            /* Set the TX_WAIT_ABORTED status in the thread that was
               suspended.  */
            thread_ptr -> tx_thread_suspend_status =  TX_WAIT_ABORTED;
 800ce8c:	687b      	ldr	r3, [r7, #4]
 800ce8e:	221a      	movs	r2, #26
 800ce90:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

#ifndef TX_NOT_INTERRUPTABLE

            /* Increment the disable preemption flag.  */
            _tx_thread_preempt_disable++;
 800ce94:	4b1b      	ldr	r3, [pc, #108]	; (800cf04 <_tx_thread_wait_abort+0xf0>)
 800ce96:	681b      	ldr	r3, [r3, #0]
 800ce98:	3301      	adds	r3, #1
 800ce9a:	4a1a      	ldr	r2, [pc, #104]	; (800cf04 <_tx_thread_wait_abort+0xf0>)
 800ce9c:	6013      	str	r3, [r2, #0]
 800ce9e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800cea0:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cea2:	697b      	ldr	r3, [r7, #20]
 800cea4:	f383 8810 	msr	PRIMASK, r3
}
 800cea8:	bf00      	nop
            /* Restore interrupts.  */
            TX_RESTORE
#endif

            /* Call any cleanup routines.  */
            if (suspend_cleanup != TX_NULL)
 800ceaa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ceac:	2b00      	cmp	r3, #0
 800ceae:	d003      	beq.n	800ceb8 <_tx_thread_wait_abort+0xa4>
            {

                /* Yes, there is a function to call.  */
                (suspend_cleanup)(thread_ptr, suspension_sequence);
 800ceb0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ceb2:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800ceb4:	6878      	ldr	r0, [r7, #4]
 800ceb6:	4798      	blx	r3
            }
        }

        /* If the abort of the thread wait was successful, if so resume the thread.  */
        if (thread_ptr -> tx_thread_suspend_status == TX_WAIT_ABORTED)
 800ceb8:	687b      	ldr	r3, [r7, #4]
 800ceba:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800cebe:	2b1a      	cmp	r3, #26
 800cec0:	d105      	bne.n	800cece <_tx_thread_wait_abort+0xba>
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Lift the suspension on the previously waiting thread.  */
            _tx_thread_system_resume(thread_ptr);
 800cec2:	6878      	ldr	r0, [r7, #4]
 800cec4:	f7ff fab2 	bl	800c42c <_tx_thread_system_resume>
#endif

            /* Return a successful status.  */
            status =  TX_SUCCESS;
 800cec8:	2300      	movs	r3, #0
 800ceca:	637b      	str	r3, [r7, #52]	; 0x34
 800cecc:	e014      	b.n	800cef8 <_tx_thread_wait_abort+0xe4>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800cece:	f3ef 8310 	mrs	r3, PRIMASK
 800ced2:	60fb      	str	r3, [r7, #12]
    return(posture);
 800ced4:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 800ced6:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 800ced8:	b672      	cpsid	i
    return(int_posture);
 800ceda:	68bb      	ldr	r3, [r7, #8]
            TX_RESTORE

#else

            /* Disable interrupts.  */
            TX_DISABLE
 800cedc:	633b      	str	r3, [r7, #48]	; 0x30

            /* Decrement the disable preemption flag.  */
            _tx_thread_preempt_disable--;
 800cede:	4b09      	ldr	r3, [pc, #36]	; (800cf04 <_tx_thread_wait_abort+0xf0>)
 800cee0:	681b      	ldr	r3, [r3, #0]
 800cee2:	3b01      	subs	r3, #1
 800cee4:	4a07      	ldr	r2, [pc, #28]	; (800cf04 <_tx_thread_wait_abort+0xf0>)
 800cee6:	6013      	str	r3, [r2, #0]
 800cee8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ceea:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ceec:	693b      	ldr	r3, [r7, #16]
 800ceee:	f383 8810 	msr	PRIMASK, r3
}
 800cef2:	bf00      	nop
            TX_RESTORE
#endif

            /* Return with an error message to indicate that
               nothing was done.  */
            status =  TX_WAIT_ABORT_ERROR;
 800cef4:	231b      	movs	r3, #27
 800cef6:	637b      	str	r3, [r7, #52]	; 0x34
        }
    }

    /* Return completion status.  */
    return(status);
 800cef8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 800cefa:	4618      	mov	r0, r3
 800cefc:	3738      	adds	r7, #56	; 0x38
 800cefe:	46bd      	mov	sp, r7
 800cf00:	bd80      	pop	{r7, pc}
 800cf02:	bf00      	nop
 800cf04:	2000f054 	.word	0x2000f054

0800cf08 <_tx_time_get>:
/*  12-31-2020     Andres Mlinar            Modified comment(s),          */
/*                                            resulting in version 6.1.3  */
/*                                                                        */
/**************************************************************************/
ULONG  _tx_time_get(VOID)
{
 800cf08:	b480      	push	{r7}
 800cf0a:	b087      	sub	sp, #28
 800cf0c:	af00      	add	r7, sp, #0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800cf0e:	f3ef 8310 	mrs	r3, PRIMASK
 800cf12:	60bb      	str	r3, [r7, #8]
    return(posture);
 800cf14:	68bb      	ldr	r3, [r7, #8]
    int_posture = __get_interrupt_posture();
 800cf16:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("CPSID i" : : : "memory");
 800cf18:	b672      	cpsid	i
    return(int_posture);
 800cf1a:	687b      	ldr	r3, [r7, #4]
#endif
ULONG   temp_time;


    /* Disable interrupts.  */
    TX_DISABLE
 800cf1c:	617b      	str	r3, [r7, #20]

    /* Pickup the system clock time.  */
    temp_time =  _tx_timer_system_clock;
 800cf1e:	4b08      	ldr	r3, [pc, #32]	; (800cf40 <_tx_time_get+0x38>)
 800cf20:	681b      	ldr	r3, [r3, #0]
 800cf22:	613b      	str	r3, [r7, #16]
 800cf24:	697b      	ldr	r3, [r7, #20]
 800cf26:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cf28:	68fb      	ldr	r3, [r7, #12]
 800cf2a:	f383 8810 	msr	PRIMASK, r3
}
 800cf2e:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return the time.  */
    return(temp_time);
 800cf30:	693b      	ldr	r3, [r7, #16]
}
 800cf32:	4618      	mov	r0, r3
 800cf34:	371c      	adds	r7, #28
 800cf36:	46bd      	mov	sp, r7
 800cf38:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf3c:	4770      	bx	lr
 800cf3e:	bf00      	nop
 800cf40:	2000f064 	.word	0x2000f064

0800cf44 <_tx_time_set>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_time_set(ULONG new_time)
{
 800cf44:	b480      	push	{r7}
 800cf46:	b087      	sub	sp, #28
 800cf48:	af00      	add	r7, sp, #0
 800cf4a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800cf4c:	f3ef 8310 	mrs	r3, PRIMASK
 800cf50:	60fb      	str	r3, [r7, #12]
    return(posture);
 800cf52:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 800cf54:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 800cf56:	b672      	cpsid	i
    return(int_posture);
 800cf58:	68bb      	ldr	r3, [r7, #8]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts.  */
    TX_DISABLE
 800cf5a:	617b      	str	r3, [r7, #20]

    /* Log this kernel call.  */
    TX_EL_TIME_SET_INSERT

    /* Set the system clock time.  */
    _tx_timer_system_clock =  new_time;
 800cf5c:	4a07      	ldr	r2, [pc, #28]	; (800cf7c <_tx_time_set+0x38>)
 800cf5e:	687b      	ldr	r3, [r7, #4]
 800cf60:	6013      	str	r3, [r2, #0]
 800cf62:	697b      	ldr	r3, [r7, #20]
 800cf64:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cf66:	693b      	ldr	r3, [r7, #16]
 800cf68:	f383 8810 	msr	PRIMASK, r3
}
 800cf6c:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE
}
 800cf6e:	bf00      	nop
 800cf70:	371c      	adds	r7, #28
 800cf72:	46bd      	mov	sp, r7
 800cf74:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf78:	4770      	bx	lr
 800cf7a:	bf00      	nop
 800cf7c:	2000f064 	.word	0x2000f064

0800cf80 <_tx_timer_activate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_timer_activate(TX_TIMER *timer_ptr)
{
 800cf80:	b580      	push	{r7, lr}
 800cf82:	b088      	sub	sp, #32
 800cf84:	af00      	add	r7, sp, #0
 800cf86:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800cf88:	f3ef 8310 	mrs	r3, PRIMASK
 800cf8c:	617b      	str	r3, [r7, #20]
    return(posture);
 800cf8e:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800cf90:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800cf92:	b672      	cpsid	i
    return(int_posture);
 800cf94:	693b      	ldr	r3, [r7, #16]

UINT        status;


    /* Disable interrupts to put the timer on the created list.  */
    TX_DISABLE
 800cf96:	61bb      	str	r3, [r7, #24]
    /* Log this kernel call.  */
    TX_EL_TIMER_ACTIVATE_INSERT
#endif

    /* Check for an already active timer.  */
    if (timer_ptr -> tx_timer_internal.tx_timer_internal_list_head != TX_NULL)
 800cf98:	687b      	ldr	r3, [r7, #4]
 800cf9a:	6a1b      	ldr	r3, [r3, #32]
 800cf9c:	2b00      	cmp	r3, #0
 800cf9e:	d002      	beq.n	800cfa6 <_tx_timer_activate+0x26>
    {

        /* Timer is already active, return an error.  */
        status =  TX_ACTIVATE_ERROR;
 800cfa0:	2317      	movs	r3, #23
 800cfa2:	61fb      	str	r3, [r7, #28]
 800cfa4:	e00d      	b.n	800cfc2 <_tx_timer_activate+0x42>
    }

    /* Check for a timer with a zero expiration.  */
    else if (timer_ptr -> tx_timer_internal.tx_timer_internal_remaining_ticks == ((ULONG) 0))
 800cfa6:	687b      	ldr	r3, [r7, #4]
 800cfa8:	689b      	ldr	r3, [r3, #8]
 800cfaa:	2b00      	cmp	r3, #0
 800cfac:	d102      	bne.n	800cfb4 <_tx_timer_activate+0x34>
    {

        /* Timer is being activated with a zero expiration.  */
        status =  TX_ACTIVATE_ERROR;
 800cfae:	2317      	movs	r3, #23
 800cfb0:	61fb      	str	r3, [r7, #28]
 800cfb2:	e006      	b.n	800cfc2 <_tx_timer_activate+0x42>
        /* Increment the number of activations on this timer.  */
        timer_ptr -> tx_timer_performance_activate_count++;
#endif

        /* Call actual activation function.  */
        _tx_timer_system_activate(&(timer_ptr -> tx_timer_internal));
 800cfb4:	687b      	ldr	r3, [r7, #4]
 800cfb6:	3308      	adds	r3, #8
 800cfb8:	4618      	mov	r0, r3
 800cfba:	f000 fb2f 	bl	800d61c <_tx_timer_system_activate>

        /* Return a successful status.  */
        status =  TX_SUCCESS;
 800cfbe:	2300      	movs	r3, #0
 800cfc0:	61fb      	str	r3, [r7, #28]
 800cfc2:	69bb      	ldr	r3, [r7, #24]
 800cfc4:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cfc6:	68fb      	ldr	r3, [r7, #12]
 800cfc8:	f383 8810 	msr	PRIMASK, r3
}
 800cfcc:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(status);
 800cfce:	69fb      	ldr	r3, [r7, #28]
}
 800cfd0:	4618      	mov	r0, r3
 800cfd2:	3720      	adds	r7, #32
 800cfd4:	46bd      	mov	sp, r7
 800cfd6:	bd80      	pop	{r7, pc}

0800cfd8 <_tx_timer_change>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_timer_change(TX_TIMER *timer_ptr, ULONG initial_ticks, ULONG reschedule_ticks)
{
 800cfd8:	b480      	push	{r7}
 800cfda:	b089      	sub	sp, #36	; 0x24
 800cfdc:	af00      	add	r7, sp, #0
 800cfde:	60f8      	str	r0, [r7, #12]
 800cfe0:	60b9      	str	r1, [r7, #8]
 800cfe2:	607a      	str	r2, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800cfe4:	f3ef 8310 	mrs	r3, PRIMASK
 800cfe8:	61bb      	str	r3, [r7, #24]
    return(posture);
 800cfea:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800cfec:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800cfee:	b672      	cpsid	i
    return(int_posture);
 800cff0:	697b      	ldr	r3, [r7, #20]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts to put the timer on the created list.  */
    TX_DISABLE
 800cff2:	61fb      	str	r3, [r7, #28]

    /* Log this kernel call.  */
    TX_EL_TIMER_CHANGE_INSERT

    /* Determine if the timer is active.  */
    if (timer_ptr -> tx_timer_internal.tx_timer_internal_list_head == TX_NULL)
 800cff4:	68fb      	ldr	r3, [r7, #12]
 800cff6:	6a1b      	ldr	r3, [r3, #32]
 800cff8:	2b00      	cmp	r3, #0
 800cffa:	d105      	bne.n	800d008 <_tx_timer_change+0x30>
    {

        /* Setup the new expiration fields.  */
        timer_ptr -> tx_timer_internal.tx_timer_internal_remaining_ticks =      initial_ticks;
 800cffc:	68fb      	ldr	r3, [r7, #12]
 800cffe:	68ba      	ldr	r2, [r7, #8]
 800d000:	609a      	str	r2, [r3, #8]
        timer_ptr -> tx_timer_internal.tx_timer_internal_re_initialize_ticks =  reschedule_ticks;
 800d002:	68fb      	ldr	r3, [r7, #12]
 800d004:	687a      	ldr	r2, [r7, #4]
 800d006:	60da      	str	r2, [r3, #12]
 800d008:	69fb      	ldr	r3, [r7, #28]
 800d00a:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d00c:	693b      	ldr	r3, [r7, #16]
 800d00e:	f383 8810 	msr	PRIMASK, r3
}
 800d012:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800d014:	2300      	movs	r3, #0
}
 800d016:	4618      	mov	r0, r3
 800d018:	3724      	adds	r7, #36	; 0x24
 800d01a:	46bd      	mov	sp, r7
 800d01c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d020:	4770      	bx	lr
	...

0800d024 <_tx_timer_create>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_timer_create(TX_TIMER *timer_ptr, CHAR *name_ptr,
            VOID (*expiration_function)(ULONG id), ULONG expiration_input,
            ULONG initial_ticks, ULONG reschedule_ticks, UINT auto_activate)
{
 800d024:	b580      	push	{r7, lr}
 800d026:	b08a      	sub	sp, #40	; 0x28
 800d028:	af00      	add	r7, sp, #0
 800d02a:	60f8      	str	r0, [r7, #12]
 800d02c:	60b9      	str	r1, [r7, #8]
 800d02e:	607a      	str	r2, [r7, #4]
 800d030:	603b      	str	r3, [r7, #0]
TX_TIMER        *next_timer;
TX_TIMER        *previous_timer;


    /* Initialize timer control block to all zeros.  */
    TX_MEMSET(timer_ptr, 0, (sizeof(TX_TIMER)));
 800d032:	2234      	movs	r2, #52	; 0x34
 800d034:	2100      	movs	r1, #0
 800d036:	68f8      	ldr	r0, [r7, #12]
 800d038:	f009 fcd4 	bl	80169e4 <memset>

    /* Setup the basic timer fields.  */
    timer_ptr -> tx_timer_name =                                            name_ptr;
 800d03c:	68fb      	ldr	r3, [r7, #12]
 800d03e:	68ba      	ldr	r2, [r7, #8]
 800d040:	605a      	str	r2, [r3, #4]
    timer_ptr -> tx_timer_internal.tx_timer_internal_remaining_ticks =      initial_ticks;
 800d042:	68fb      	ldr	r3, [r7, #12]
 800d044:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800d046:	609a      	str	r2, [r3, #8]
    timer_ptr -> tx_timer_internal.tx_timer_internal_re_initialize_ticks =  reschedule_ticks;
 800d048:	68fb      	ldr	r3, [r7, #12]
 800d04a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800d04c:	60da      	str	r2, [r3, #12]
    timer_ptr -> tx_timer_internal.tx_timer_internal_timeout_function =     expiration_function;
 800d04e:	68fb      	ldr	r3, [r7, #12]
 800d050:	687a      	ldr	r2, [r7, #4]
 800d052:	611a      	str	r2, [r3, #16]
    timer_ptr -> tx_timer_internal.tx_timer_internal_timeout_param =        expiration_input;
 800d054:	68fb      	ldr	r3, [r7, #12]
 800d056:	683a      	ldr	r2, [r7, #0]
 800d058:	615a      	str	r2, [r3, #20]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d05a:	f3ef 8310 	mrs	r3, PRIMASK
 800d05e:	61bb      	str	r3, [r7, #24]
    return(posture);
 800d060:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800d062:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800d064:	b672      	cpsid	i
    return(int_posture);
 800d066:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to put the timer on the created list.  */
    TX_DISABLE
 800d068:	627b      	str	r3, [r7, #36]	; 0x24

    /* Setup the timer ID to make it valid.  */
    timer_ptr -> tx_timer_id =  TX_TIMER_ID;
 800d06a:	68fb      	ldr	r3, [r7, #12]
 800d06c:	4a1c      	ldr	r2, [pc, #112]	; (800d0e0 <_tx_timer_create+0xbc>)
 800d06e:	601a      	str	r2, [r3, #0]

    /* Place the timer on the list of created application timers.  First,
       check for an empty list.  */
    if (_tx_timer_created_count == TX_EMPTY)
 800d070:	4b1c      	ldr	r3, [pc, #112]	; (800d0e4 <_tx_timer_create+0xc0>)
 800d072:	681b      	ldr	r3, [r3, #0]
 800d074:	2b00      	cmp	r3, #0
 800d076:	d109      	bne.n	800d08c <_tx_timer_create+0x68>
    {

        /* The created timer list is empty.  Add timer to empty list.  */
        _tx_timer_created_ptr =                   timer_ptr;
 800d078:	4a1b      	ldr	r2, [pc, #108]	; (800d0e8 <_tx_timer_create+0xc4>)
 800d07a:	68fb      	ldr	r3, [r7, #12]
 800d07c:	6013      	str	r3, [r2, #0]
        timer_ptr -> tx_timer_created_next =      timer_ptr;
 800d07e:	68fb      	ldr	r3, [r7, #12]
 800d080:	68fa      	ldr	r2, [r7, #12]
 800d082:	625a      	str	r2, [r3, #36]	; 0x24
        timer_ptr -> tx_timer_created_previous =  timer_ptr;
 800d084:	68fb      	ldr	r3, [r7, #12]
 800d086:	68fa      	ldr	r2, [r7, #12]
 800d088:	629a      	str	r2, [r3, #40]	; 0x28
 800d08a:	e011      	b.n	800d0b0 <_tx_timer_create+0x8c>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_timer =  _tx_timer_created_ptr;
 800d08c:	4b16      	ldr	r3, [pc, #88]	; (800d0e8 <_tx_timer_create+0xc4>)
 800d08e:	681b      	ldr	r3, [r3, #0]
 800d090:	623b      	str	r3, [r7, #32]
        previous_timer =  next_timer -> tx_timer_created_previous;
 800d092:	6a3b      	ldr	r3, [r7, #32]
 800d094:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d096:	61fb      	str	r3, [r7, #28]

        /* Place the new timer in the list.  */
        next_timer -> tx_timer_created_previous =  timer_ptr;
 800d098:	6a3b      	ldr	r3, [r7, #32]
 800d09a:	68fa      	ldr	r2, [r7, #12]
 800d09c:	629a      	str	r2, [r3, #40]	; 0x28
        previous_timer -> tx_timer_created_next =    timer_ptr;
 800d09e:	69fb      	ldr	r3, [r7, #28]
 800d0a0:	68fa      	ldr	r2, [r7, #12]
 800d0a2:	625a      	str	r2, [r3, #36]	; 0x24

        /* Setup this timer's created links.  */
        timer_ptr -> tx_timer_created_previous =  previous_timer;
 800d0a4:	68fb      	ldr	r3, [r7, #12]
 800d0a6:	69fa      	ldr	r2, [r7, #28]
 800d0a8:	629a      	str	r2, [r3, #40]	; 0x28
        timer_ptr -> tx_timer_created_next =      next_timer;
 800d0aa:	68fb      	ldr	r3, [r7, #12]
 800d0ac:	6a3a      	ldr	r2, [r7, #32]
 800d0ae:	625a      	str	r2, [r3, #36]	; 0x24
    }

    /* Increment the number of created timers.  */
    _tx_timer_created_count++;
 800d0b0:	4b0c      	ldr	r3, [pc, #48]	; (800d0e4 <_tx_timer_create+0xc0>)
 800d0b2:	681b      	ldr	r3, [r3, #0]
 800d0b4:	3301      	adds	r3, #1
 800d0b6:	4a0b      	ldr	r2, [pc, #44]	; (800d0e4 <_tx_timer_create+0xc0>)
 800d0b8:	6013      	str	r3, [r2, #0]

    /* Log this kernel call.  */
    TX_EL_TIMER_CREATE_INSERT

    /* Determine if this timer needs to be activated.  */
    if (auto_activate == TX_AUTO_ACTIVATE)
 800d0ba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d0bc:	2b01      	cmp	r3, #1
 800d0be:	d104      	bne.n	800d0ca <_tx_timer_create+0xa6>
        /* Increment the number of activations on this timer.  */
        timer_ptr -> tx_timer_performance_activate_count++;
#endif

        /* Call actual activation function.  */
        _tx_timer_system_activate(&(timer_ptr -> tx_timer_internal));
 800d0c0:	68fb      	ldr	r3, [r7, #12]
 800d0c2:	3308      	adds	r3, #8
 800d0c4:	4618      	mov	r0, r3
 800d0c6:	f000 faa9 	bl	800d61c <_tx_timer_system_activate>
 800d0ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d0cc:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d0ce:	693b      	ldr	r3, [r7, #16]
 800d0d0:	f383 8810 	msr	PRIMASK, r3
}
 800d0d4:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800d0d6:	2300      	movs	r3, #0
}
 800d0d8:	4618      	mov	r0, r3
 800d0da:	3728      	adds	r7, #40	; 0x28
 800d0dc:	46bd      	mov	sp, r7
 800d0de:	bd80      	pop	{r7, pc}
 800d0e0:	4154494d 	.word	0x4154494d
 800d0e4:	2000f100 	.word	0x2000f100
 800d0e8:	2000f0fc 	.word	0x2000f0fc

0800d0ec <_tx_timer_deactivate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_timer_deactivate(TX_TIMER *timer_ptr)
{
 800d0ec:	b480      	push	{r7}
 800d0ee:	b08d      	sub	sp, #52	; 0x34
 800d0f0:	af00      	add	r7, sp, #0
 800d0f2:	6078      	str	r0, [r7, #4]
ULONG               ticks_left;
UINT                active_timer_list;


    /* Setup internal timer pointer.  */
    internal_ptr =  &(timer_ptr -> tx_timer_internal);
 800d0f4:	687b      	ldr	r3, [r7, #4]
 800d0f6:	3308      	adds	r3, #8
 800d0f8:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d0fa:	f3ef 8310 	mrs	r3, PRIMASK
 800d0fe:	613b      	str	r3, [r7, #16]
    return(posture);
 800d100:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 800d102:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 800d104:	b672      	cpsid	i
    return(int_posture);
 800d106:	68fb      	ldr	r3, [r7, #12]

    /* Disable interrupts while the remaining time before expiration is
       calculated.  */
    TX_DISABLE
 800d108:	623b      	str	r3, [r7, #32]

    /* Log this kernel call.  */
    TX_EL_TIMER_DEACTIVATE_INSERT

    /* Pickup the list head.  */
    list_head =  internal_ptr -> tx_timer_internal_list_head;
 800d10a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d10c:	699b      	ldr	r3, [r3, #24]
 800d10e:	61fb      	str	r3, [r7, #28]

    /* Is the timer active?  */
    if (list_head != TX_NULL)
 800d110:	69fb      	ldr	r3, [r7, #28]
 800d112:	2b00      	cmp	r3, #0
 800d114:	d07f      	beq.n	800d216 <_tx_timer_deactivate+0x12a>
    {

        /* Default the active timer list flag to false.  */
        active_timer_list =  TX_FALSE;
 800d116:	2300      	movs	r3, #0
 800d118:	62bb      	str	r3, [r7, #40]	; 0x28

        /* Determine if the head pointer is within the timer expiration list.  */
        if (TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(list_head) >= TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(_tx_timer_list_start))
 800d11a:	4b45      	ldr	r3, [pc, #276]	; (800d230 <_tx_timer_deactivate+0x144>)
 800d11c:	681b      	ldr	r3, [r3, #0]
 800d11e:	69fa      	ldr	r2, [r7, #28]
 800d120:	429a      	cmp	r2, r3
 800d122:	d306      	bcc.n	800d132 <_tx_timer_deactivate+0x46>
        {

            /* Now check to make sure the list head is before the end of the list.  */
            if (TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(list_head) < TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(_tx_timer_list_end))
 800d124:	4b43      	ldr	r3, [pc, #268]	; (800d234 <_tx_timer_deactivate+0x148>)
 800d126:	681b      	ldr	r3, [r3, #0]
 800d128:	69fa      	ldr	r2, [r7, #28]
 800d12a:	429a      	cmp	r2, r3
 800d12c:	d201      	bcs.n	800d132 <_tx_timer_deactivate+0x46>
            {

                /* Set the active timer list flag to true.  */
                active_timer_list =  TX_TRUE;
 800d12e:	2301      	movs	r3, #1
 800d130:	62bb      	str	r3, [r7, #40]	; 0x28
            }
        }

        /* Determine if the timer is on active timer list.  */
        if (active_timer_list == TX_TRUE)
 800d132:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d134:	2b01      	cmp	r3, #1
 800d136:	d12e      	bne.n	800d196 <_tx_timer_deactivate+0xaa>

            /* Calculate the amount of time that has elapsed since the timer
               was activated.  */

            /* Is this timer's entry after the current timer pointer?  */
            if (TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(list_head) >= TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(_tx_timer_current_ptr))
 800d138:	4b3f      	ldr	r3, [pc, #252]	; (800d238 <_tx_timer_deactivate+0x14c>)
 800d13a:	681b      	ldr	r3, [r3, #0]
 800d13c:	69fa      	ldr	r2, [r7, #28]
 800d13e:	429a      	cmp	r2, r3
 800d140:	d307      	bcc.n	800d152 <_tx_timer_deactivate+0x66>
            {

                /* Calculate ticks left to expiration - just the difference between this
                   timer's entry and the current timer pointer.  */
                ticks_left =  (ULONG) (TX_TIMER_POINTER_DIF(list_head,_tx_timer_current_ptr)) + ((ULONG) 1);
 800d142:	4b3d      	ldr	r3, [pc, #244]	; (800d238 <_tx_timer_deactivate+0x14c>)
 800d144:	681b      	ldr	r3, [r3, #0]
 800d146:	69fa      	ldr	r2, [r7, #28]
 800d148:	1ad3      	subs	r3, r2, r3
 800d14a:	109b      	asrs	r3, r3, #2
 800d14c:	3301      	adds	r3, #1
 800d14e:	62fb      	str	r3, [r7, #44]	; 0x2c
 800d150:	e010      	b.n	800d174 <_tx_timer_deactivate+0x88>
            }
            else
            {

                /* Calculate the ticks left with a wrapped list condition.  */
                ticks_left =  (ULONG) (TX_TIMER_POINTER_DIF(list_head,_tx_timer_list_start));
 800d152:	4b37      	ldr	r3, [pc, #220]	; (800d230 <_tx_timer_deactivate+0x144>)
 800d154:	681b      	ldr	r3, [r3, #0]
 800d156:	69fa      	ldr	r2, [r7, #28]
 800d158:	1ad3      	subs	r3, r2, r3
 800d15a:	109b      	asrs	r3, r3, #2
 800d15c:	62fb      	str	r3, [r7, #44]	; 0x2c

                ticks_left =  ticks_left + (ULONG) ((TX_TIMER_POINTER_DIF(_tx_timer_list_end, _tx_timer_current_ptr)) + ((ULONG) 1));
 800d15e:	4b35      	ldr	r3, [pc, #212]	; (800d234 <_tx_timer_deactivate+0x148>)
 800d160:	681a      	ldr	r2, [r3, #0]
 800d162:	4b35      	ldr	r3, [pc, #212]	; (800d238 <_tx_timer_deactivate+0x14c>)
 800d164:	681b      	ldr	r3, [r3, #0]
 800d166:	1ad3      	subs	r3, r2, r3
 800d168:	109b      	asrs	r3, r3, #2
 800d16a:	461a      	mov	r2, r3
 800d16c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d16e:	4413      	add	r3, r2
 800d170:	3301      	adds	r3, #1
 800d172:	62fb      	str	r3, [r7, #44]	; 0x2c
            }

            /* Adjust the remaining ticks accordingly.  */
            if (internal_ptr -> tx_timer_internal_remaining_ticks > TX_TIMER_ENTRIES)
 800d174:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d176:	681b      	ldr	r3, [r3, #0]
 800d178:	2b20      	cmp	r3, #32
 800d17a:	d908      	bls.n	800d18e <_tx_timer_deactivate+0xa2>
            {

                /* Subtract off the last full pass through the timer list and add the
                   time left.  */
                internal_ptr -> tx_timer_internal_remaining_ticks =
                        (internal_ptr -> tx_timer_internal_remaining_ticks - TX_TIMER_ENTRIES) + ticks_left;
 800d17c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d17e:	681a      	ldr	r2, [r3, #0]
 800d180:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d182:	4413      	add	r3, r2
 800d184:	f1a3 0220 	sub.w	r2, r3, #32
                internal_ptr -> tx_timer_internal_remaining_ticks =
 800d188:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d18a:	601a      	str	r2, [r3, #0]
 800d18c:	e01c      	b.n	800d1c8 <_tx_timer_deactivate+0xdc>
            }
            else
            {

                /* Just put the ticks left into the timer's remaining ticks.  */
                internal_ptr -> tx_timer_internal_remaining_ticks =  ticks_left;
 800d18e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d190:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d192:	601a      	str	r2, [r3, #0]
 800d194:	e018      	b.n	800d1c8 <_tx_timer_deactivate+0xdc>
        }
        else
        {

            /* Determine if this is timer has just expired.  */
            if (_tx_timer_expired_timer_ptr != internal_ptr)
 800d196:	4b29      	ldr	r3, [pc, #164]	; (800d23c <_tx_timer_deactivate+0x150>)
 800d198:	681b      	ldr	r3, [r3, #0]
 800d19a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d19c:	429a      	cmp	r2, r3
 800d19e:	d00f      	beq.n	800d1c0 <_tx_timer_deactivate+0xd4>
            {

                /* No, it hasn't expired. Now check for remaining time greater than the list
                   size.  */
                if (internal_ptr -> tx_timer_internal_remaining_ticks > TX_TIMER_ENTRIES)
 800d1a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d1a2:	681b      	ldr	r3, [r3, #0]
 800d1a4:	2b20      	cmp	r3, #32
 800d1a6:	d906      	bls.n	800d1b6 <_tx_timer_deactivate+0xca>
                {

                    /* Adjust the remaining ticks.  */
                    internal_ptr -> tx_timer_internal_remaining_ticks =
                                            internal_ptr -> tx_timer_internal_remaining_ticks - TX_TIMER_ENTRIES;
 800d1a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d1aa:	681b      	ldr	r3, [r3, #0]
 800d1ac:	f1a3 0220 	sub.w	r2, r3, #32
                    internal_ptr -> tx_timer_internal_remaining_ticks =
 800d1b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d1b2:	601a      	str	r2, [r3, #0]
 800d1b4:	e008      	b.n	800d1c8 <_tx_timer_deactivate+0xdc>
                }
                else
                {

                    /* Set the remaining time to the reactivation time.  */
                    internal_ptr -> tx_timer_internal_remaining_ticks =  internal_ptr -> tx_timer_internal_re_initialize_ticks;
 800d1b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d1b8:	685a      	ldr	r2, [r3, #4]
 800d1ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d1bc:	601a      	str	r2, [r3, #0]
 800d1be:	e003      	b.n	800d1c8 <_tx_timer_deactivate+0xdc>
            }
            else
            {

                /* Set the remaining time to the reactivation time.  */
                internal_ptr -> tx_timer_internal_remaining_ticks =  internal_ptr -> tx_timer_internal_re_initialize_ticks;
 800d1c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d1c2:	685a      	ldr	r2, [r3, #4]
 800d1c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d1c6:	601a      	str	r2, [r3, #0]
            }
        }

        /* Pickup the next timer.  */
        next_timer =  internal_ptr -> tx_timer_internal_active_next;
 800d1c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d1ca:	691b      	ldr	r3, [r3, #16]
 800d1cc:	61bb      	str	r3, [r7, #24]

        /* See if this is the only timer in the list.  */
        if (internal_ptr == next_timer)
 800d1ce:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d1d0:	69bb      	ldr	r3, [r7, #24]
 800d1d2:	429a      	cmp	r2, r3
 800d1d4:	d108      	bne.n	800d1e8 <_tx_timer_deactivate+0xfc>
        {

            /* Yes, the only timer on the list.  */

            /* Determine if the head pointer needs to be updated.  */
            if (*(list_head) == internal_ptr)
 800d1d6:	69fb      	ldr	r3, [r7, #28]
 800d1d8:	681b      	ldr	r3, [r3, #0]
 800d1da:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d1dc:	429a      	cmp	r2, r3
 800d1de:	d117      	bne.n	800d210 <_tx_timer_deactivate+0x124>
            {

                /* Update the head pointer.  */
                *(list_head) =  TX_NULL;
 800d1e0:	69fb      	ldr	r3, [r7, #28]
 800d1e2:	2200      	movs	r2, #0
 800d1e4:	601a      	str	r2, [r3, #0]
 800d1e6:	e013      	b.n	800d210 <_tx_timer_deactivate+0x124>
        {

            /* At least one more timer is on the same expiration list.  */

            /* Update the links of the adjacent timers.  */
            previous_timer =                                   internal_ptr -> tx_timer_internal_active_previous;
 800d1e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d1ea:	695b      	ldr	r3, [r3, #20]
 800d1ec:	617b      	str	r3, [r7, #20]
            next_timer -> tx_timer_internal_active_previous =  previous_timer;
 800d1ee:	69bb      	ldr	r3, [r7, #24]
 800d1f0:	697a      	ldr	r2, [r7, #20]
 800d1f2:	615a      	str	r2, [r3, #20]
            previous_timer -> tx_timer_internal_active_next =  next_timer;
 800d1f4:	697b      	ldr	r3, [r7, #20]
 800d1f6:	69ba      	ldr	r2, [r7, #24]
 800d1f8:	611a      	str	r2, [r3, #16]

            /* Determine if the head pointer needs to be updated.  */
            if (*(list_head) == internal_ptr)
 800d1fa:	69fb      	ldr	r3, [r7, #28]
 800d1fc:	681b      	ldr	r3, [r3, #0]
 800d1fe:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d200:	429a      	cmp	r2, r3
 800d202:	d105      	bne.n	800d210 <_tx_timer_deactivate+0x124>
            {

                /* Update the next timer in the list with the list head
                   pointer.  */
                next_timer -> tx_timer_internal_list_head =  list_head;
 800d204:	69bb      	ldr	r3, [r7, #24]
 800d206:	69fa      	ldr	r2, [r7, #28]
 800d208:	619a      	str	r2, [r3, #24]

                /* Update the head pointer.  */
                *(list_head) =  next_timer;
 800d20a:	69fb      	ldr	r3, [r7, #28]
 800d20c:	69ba      	ldr	r2, [r7, #24]
 800d20e:	601a      	str	r2, [r3, #0]
            }
        }

        /* Clear the timer's list head pointer.  */
        internal_ptr -> tx_timer_internal_list_head =  TX_NULL;
 800d210:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d212:	2200      	movs	r2, #0
 800d214:	619a      	str	r2, [r3, #24]
 800d216:	6a3b      	ldr	r3, [r7, #32]
 800d218:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d21a:	68bb      	ldr	r3, [r7, #8]
 800d21c:	f383 8810 	msr	PRIMASK, r3
}
 800d220:	bf00      	nop

    /* Restore interrupts to previous posture.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800d222:	2300      	movs	r3, #0
}
 800d224:	4618      	mov	r0, r3
 800d226:	3734      	adds	r7, #52	; 0x34
 800d228:	46bd      	mov	sp, r7
 800d22a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d22e:	4770      	bx	lr
 800d230:	2000f0ec 	.word	0x2000f0ec
 800d234:	2000f0f0 	.word	0x2000f0f0
 800d238:	2000f0f4 	.word	0x2000f0f4
 800d23c:	2000f104 	.word	0x2000f104

0800d240 <_tx_timer_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_timer_delete(TX_TIMER *timer_ptr)
{
 800d240:	b580      	push	{r7, lr}
 800d242:	b088      	sub	sp, #32
 800d244:	af00      	add	r7, sp, #0
 800d246:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d248:	f3ef 8310 	mrs	r3, PRIMASK
 800d24c:	613b      	str	r3, [r7, #16]
    return(posture);
 800d24e:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 800d250:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 800d252:	b672      	cpsid	i
    return(int_posture);
 800d254:	68fb      	ldr	r3, [r7, #12]
TX_TIMER        *next_timer;
TX_TIMER        *previous_timer;


    /* Disable interrupts to remove the timer from the created list.  */
    TX_DISABLE
 800d256:	61fb      	str	r3, [r7, #28]

    /* Determine if the timer needs to be deactivated.  */
    if (timer_ptr -> tx_timer_internal.tx_timer_internal_list_head != TX_NULL)
 800d258:	687b      	ldr	r3, [r7, #4]
 800d25a:	6a1b      	ldr	r3, [r3, #32]
 800d25c:	2b00      	cmp	r3, #0
 800d25e:	d004      	beq.n	800d26a <_tx_timer_delete+0x2a>
    {

        /* Yes, deactivate the timer before it is deleted.  */
        _tx_timer_system_deactivate(&(timer_ptr -> tx_timer_internal));
 800d260:	687b      	ldr	r3, [r7, #4]
 800d262:	3308      	adds	r3, #8
 800d264:	4618      	mov	r0, r3
 800d266:	f000 fa3b 	bl	800d6e0 <_tx_timer_system_deactivate>

    /* Log this kernel call.  */
    TX_EL_TIMER_DELETE_INSERT

    /* Clear the timer ID to make it invalid.  */
    timer_ptr -> tx_timer_id =  TX_CLEAR_ID;
 800d26a:	687b      	ldr	r3, [r7, #4]
 800d26c:	2200      	movs	r2, #0
 800d26e:	601a      	str	r2, [r3, #0]

    /* Decrement the number of created timers.  */
    _tx_timer_created_count--;
 800d270:	4b15      	ldr	r3, [pc, #84]	; (800d2c8 <_tx_timer_delete+0x88>)
 800d272:	681b      	ldr	r3, [r3, #0]
 800d274:	3b01      	subs	r3, #1
 800d276:	4a14      	ldr	r2, [pc, #80]	; (800d2c8 <_tx_timer_delete+0x88>)
 800d278:	6013      	str	r3, [r2, #0]

    /* See if the timer is the only one on the list.  */
    if (_tx_timer_created_count == TX_EMPTY)
 800d27a:	4b13      	ldr	r3, [pc, #76]	; (800d2c8 <_tx_timer_delete+0x88>)
 800d27c:	681b      	ldr	r3, [r3, #0]
 800d27e:	2b00      	cmp	r3, #0
 800d280:	d103      	bne.n	800d28a <_tx_timer_delete+0x4a>
    {

        /* Only created timer, just set the created list to NULL.  */
        _tx_timer_created_ptr =  TX_NULL;
 800d282:	4b12      	ldr	r3, [pc, #72]	; (800d2cc <_tx_timer_delete+0x8c>)
 800d284:	2200      	movs	r2, #0
 800d286:	601a      	str	r2, [r3, #0]
 800d288:	e013      	b.n	800d2b2 <_tx_timer_delete+0x72>
    }
    else
    {

        /* Link-up the neighbors.  */
        next_timer =                               timer_ptr -> tx_timer_created_next;
 800d28a:	687b      	ldr	r3, [r7, #4]
 800d28c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d28e:	61bb      	str	r3, [r7, #24]
        previous_timer =                           timer_ptr -> tx_timer_created_previous;
 800d290:	687b      	ldr	r3, [r7, #4]
 800d292:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d294:	617b      	str	r3, [r7, #20]
        next_timer -> tx_timer_created_previous =  previous_timer;
 800d296:	69bb      	ldr	r3, [r7, #24]
 800d298:	697a      	ldr	r2, [r7, #20]
 800d29a:	629a      	str	r2, [r3, #40]	; 0x28
        previous_timer -> tx_timer_created_next =  next_timer;
 800d29c:	697b      	ldr	r3, [r7, #20]
 800d29e:	69ba      	ldr	r2, [r7, #24]
 800d2a0:	625a      	str	r2, [r3, #36]	; 0x24

        /* See if we have to update the created list head pointer.  */
        if (_tx_timer_created_ptr == timer_ptr)
 800d2a2:	4b0a      	ldr	r3, [pc, #40]	; (800d2cc <_tx_timer_delete+0x8c>)
 800d2a4:	681b      	ldr	r3, [r3, #0]
 800d2a6:	687a      	ldr	r2, [r7, #4]
 800d2a8:	429a      	cmp	r2, r3
 800d2aa:	d102      	bne.n	800d2b2 <_tx_timer_delete+0x72>
        {

            /* Yes, move the head pointer to the next link. */
            _tx_timer_created_ptr =  next_timer;
 800d2ac:	4a07      	ldr	r2, [pc, #28]	; (800d2cc <_tx_timer_delete+0x8c>)
 800d2ae:	69bb      	ldr	r3, [r7, #24]
 800d2b0:	6013      	str	r3, [r2, #0]
 800d2b2:	69fb      	ldr	r3, [r7, #28]
 800d2b4:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d2b6:	68bb      	ldr	r3, [r7, #8]
 800d2b8:	f383 8810 	msr	PRIMASK, r3
}
 800d2bc:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800d2be:	2300      	movs	r3, #0
}
 800d2c0:	4618      	mov	r0, r3
 800d2c2:	3720      	adds	r7, #32
 800d2c4:	46bd      	mov	sp, r7
 800d2c6:	bd80      	pop	{r7, pc}
 800d2c8:	2000f100 	.word	0x2000f100
 800d2cc:	2000f0fc 	.word	0x2000f0fc

0800d2d0 <_tx_timer_expiration_process>:
/*                                            TX_NO_TIMER is defined,     */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_expiration_process(VOID)
{
 800d2d0:	b580      	push	{r7, lr}
 800d2d2:	b084      	sub	sp, #16
 800d2d4:	af00      	add	r7, sp, #0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d2d6:	f3ef 8310 	mrs	r3, PRIMASK
 800d2da:	607b      	str	r3, [r7, #4]
    return(posture);
 800d2dc:	687b      	ldr	r3, [r7, #4]
    int_posture = __get_interrupt_posture();
 800d2de:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("CPSID i" : : : "memory");
 800d2e0:	b672      	cpsid	i
    return(int_posture);
 800d2e2:	683b      	ldr	r3, [r7, #0]

    /* Don't process in the ISR, wakeup the system timer thread to process the
       timer expiration.  */

    /* Disable interrupts.  */
    TX_DISABLE
 800d2e4:	60fb      	str	r3, [r7, #12]
    /* Restore interrupts.  */
    TX_RESTORE
#else

    /* Increment the preempt disable flag.  */
    _tx_thread_preempt_disable++;
 800d2e6:	4b09      	ldr	r3, [pc, #36]	; (800d30c <_tx_timer_expiration_process+0x3c>)
 800d2e8:	681b      	ldr	r3, [r3, #0]
 800d2ea:	3301      	adds	r3, #1
 800d2ec:	4a07      	ldr	r2, [pc, #28]	; (800d30c <_tx_timer_expiration_process+0x3c>)
 800d2ee:	6013      	str	r3, [r2, #0]
 800d2f0:	68fb      	ldr	r3, [r7, #12]
 800d2f2:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d2f4:	68bb      	ldr	r3, [r7, #8]
 800d2f6:	f383 8810 	msr	PRIMASK, r3
}
 800d2fa:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Call the system resume function to activate the timer thread.  */
    _tx_thread_system_resume(&_tx_timer_thread);
 800d2fc:	4804      	ldr	r0, [pc, #16]	; (800d310 <_tx_timer_expiration_process+0x40>)
 800d2fe:	f7ff f895 	bl	800c42c <_tx_thread_system_resume>
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 800d302:	bf00      	nop
 800d304:	3710      	adds	r7, #16
 800d306:	46bd      	mov	sp, r7
 800d308:	bd80      	pop	{r7, pc}
 800d30a:	bf00      	nop
 800d30c:	2000f054 	.word	0x2000f054
 800d310:	2000f108 	.word	0x2000f108

0800d314 <_tx_timer_info_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_timer_info_get(TX_TIMER *timer_ptr, CHAR **name, UINT *active, ULONG *remaining_ticks,
                ULONG *reschedule_ticks, TX_TIMER **next_timer)
{
 800d314:	b480      	push	{r7}
 800d316:	b08f      	sub	sp, #60	; 0x3c
 800d318:	af00      	add	r7, sp, #0
 800d31a:	60f8      	str	r0, [r7, #12]
 800d31c:	60b9      	str	r1, [r7, #8]
 800d31e:	607a      	str	r2, [r7, #4]
 800d320:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d322:	f3ef 8310 	mrs	r3, PRIMASK
 800d326:	61fb      	str	r3, [r7, #28]
    return(posture);
 800d328:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800d32a:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800d32c:	b672      	cpsid	i
    return(int_posture);
 800d32e:	69bb      	ldr	r3, [r7, #24]
UINT                timer_active;
UINT                active_timer_list;


    /* Disable interrupts.  */
    TX_DISABLE
 800d330:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Log this kernel call.  */
    TX_EL_TIMER_INFO_GET_INSERT

    /* Retrieve the name of the timer.  */
    if (name != TX_NULL)
 800d332:	68bb      	ldr	r3, [r7, #8]
 800d334:	2b00      	cmp	r3, #0
 800d336:	d003      	beq.n	800d340 <_tx_timer_info_get+0x2c>
    {

        *name =  timer_ptr -> tx_timer_name;
 800d338:	68fb      	ldr	r3, [r7, #12]
 800d33a:	685a      	ldr	r2, [r3, #4]
 800d33c:	68bb      	ldr	r3, [r7, #8]
 800d33e:	601a      	str	r2, [r3, #0]
    }

    /* Pickup address of internal timer structure.  */
    internal_ptr =  &(timer_ptr -> tx_timer_internal);
 800d340:	68fb      	ldr	r3, [r7, #12]
 800d342:	3308      	adds	r3, #8
 800d344:	627b      	str	r3, [r7, #36]	; 0x24

    /* Retrieve all the pertinent information and return it in the supplied
       destinations.  */

    /* Default active to false.  */
    timer_active =  TX_FALSE;
 800d346:	2300      	movs	r3, #0
 800d348:	633b      	str	r3, [r7, #48]	; 0x30

    /* Default the ticks left to the remaining ticks.  */
    ticks_left =  internal_ptr -> tx_timer_internal_remaining_ticks;
 800d34a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d34c:	681b      	ldr	r3, [r3, #0]
 800d34e:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if the timer is still active.  */
    if (internal_ptr -> tx_timer_internal_list_head != TX_NULL)
 800d350:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d352:	699b      	ldr	r3, [r3, #24]
 800d354:	2b00      	cmp	r3, #0
 800d356:	d053      	beq.n	800d400 <_tx_timer_info_get+0xec>
    {

        /* Indicate this timer is active.  */
        timer_active =  TX_TRUE;
 800d358:	2301      	movs	r3, #1
 800d35a:	633b      	str	r3, [r7, #48]	; 0x30

        /* Default the active timer list flag to false.  */
        active_timer_list =  TX_FALSE;
 800d35c:	2300      	movs	r3, #0
 800d35e:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Determine if the timer is still active.  */
        if (internal_ptr -> tx_timer_internal_list_head >= _tx_timer_list_start)
 800d360:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d362:	699a      	ldr	r2, [r3, #24]
 800d364:	4b3a      	ldr	r3, [pc, #232]	; (800d450 <_tx_timer_info_get+0x13c>)
 800d366:	681b      	ldr	r3, [r3, #0]
 800d368:	429a      	cmp	r2, r3
 800d36a:	d307      	bcc.n	800d37c <_tx_timer_info_get+0x68>
        {

            /* Determine if the list head is before the end of the list.  */
            if (internal_ptr -> tx_timer_internal_list_head < _tx_timer_list_end)
 800d36c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d36e:	699a      	ldr	r2, [r3, #24]
 800d370:	4b38      	ldr	r3, [pc, #224]	; (800d454 <_tx_timer_info_get+0x140>)
 800d372:	681b      	ldr	r3, [r3, #0]
 800d374:	429a      	cmp	r2, r3
 800d376:	d201      	bcs.n	800d37c <_tx_timer_info_get+0x68>
            {

                /* This timer is active and has not yet expired.  */
                active_timer_list =  TX_TRUE;
 800d378:	2301      	movs	r3, #1
 800d37a:	62fb      	str	r3, [r7, #44]	; 0x2c
            }
        }

        /* Determine if the timer is on the active timer list.  */
        if (active_timer_list == TX_TRUE)
 800d37c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d37e:	2b01      	cmp	r3, #1
 800d380:	d12c      	bne.n	800d3dc <_tx_timer_info_get+0xc8>

            /* Calculate the amount of time that has elapsed since the timer
               was activated.  */

            /* Setup the list head pointer.  */
            list_head =  internal_ptr -> tx_timer_internal_list_head;
 800d382:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d384:	699b      	ldr	r3, [r3, #24]
 800d386:	623b      	str	r3, [r7, #32]

            /* Is this timer's entry after the current timer pointer?  */
            if (internal_ptr -> tx_timer_internal_list_head >= _tx_timer_current_ptr)
 800d388:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d38a:	699a      	ldr	r2, [r3, #24]
 800d38c:	4b32      	ldr	r3, [pc, #200]	; (800d458 <_tx_timer_info_get+0x144>)
 800d38e:	681b      	ldr	r3, [r3, #0]
 800d390:	429a      	cmp	r2, r3
 800d392:	d307      	bcc.n	800d3a4 <_tx_timer_info_get+0x90>
            {

                /* Calculate ticks left to expiration - just the difference between this
                   timer's entry and the current timer pointer.  */
                ticks_left =  ((TX_TIMER_POINTER_DIF(list_head, _tx_timer_current_ptr)) + ((ULONG) 1));
 800d394:	4b30      	ldr	r3, [pc, #192]	; (800d458 <_tx_timer_info_get+0x144>)
 800d396:	681b      	ldr	r3, [r3, #0]
 800d398:	6a3a      	ldr	r2, [r7, #32]
 800d39a:	1ad3      	subs	r3, r2, r3
 800d39c:	109b      	asrs	r3, r3, #2
 800d39e:	3301      	adds	r3, #1
 800d3a0:	637b      	str	r3, [r7, #52]	; 0x34
 800d3a2:	e010      	b.n	800d3c6 <_tx_timer_info_get+0xb2>
            }
            else
            {

                /* Calculate the ticks left with a wrapped list condition.  */
                ticks_left =  ((TX_TIMER_POINTER_DIF(list_head, _tx_timer_list_start)));
 800d3a4:	4b2a      	ldr	r3, [pc, #168]	; (800d450 <_tx_timer_info_get+0x13c>)
 800d3a6:	681b      	ldr	r3, [r3, #0]
 800d3a8:	6a3a      	ldr	r2, [r7, #32]
 800d3aa:	1ad3      	subs	r3, r2, r3
 800d3ac:	109b      	asrs	r3, r3, #2
 800d3ae:	637b      	str	r3, [r7, #52]	; 0x34

                ticks_left =  ticks_left + ((TX_TIMER_POINTER_DIF(_tx_timer_list_end, _tx_timer_current_ptr)) + ((ULONG) 1));
 800d3b0:	4b28      	ldr	r3, [pc, #160]	; (800d454 <_tx_timer_info_get+0x140>)
 800d3b2:	681a      	ldr	r2, [r3, #0]
 800d3b4:	4b28      	ldr	r3, [pc, #160]	; (800d458 <_tx_timer_info_get+0x144>)
 800d3b6:	681b      	ldr	r3, [r3, #0]
 800d3b8:	1ad3      	subs	r3, r2, r3
 800d3ba:	109b      	asrs	r3, r3, #2
 800d3bc:	461a      	mov	r2, r3
 800d3be:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d3c0:	4413      	add	r3, r2
 800d3c2:	3301      	adds	r3, #1
 800d3c4:	637b      	str	r3, [r7, #52]	; 0x34
            }

            /* Adjust the remaining ticks accordingly.  */
            if (internal_ptr -> tx_timer_internal_remaining_ticks > TX_TIMER_ENTRIES)
 800d3c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d3c8:	681b      	ldr	r3, [r3, #0]
 800d3ca:	2b20      	cmp	r3, #32
 800d3cc:	d918      	bls.n	800d400 <_tx_timer_info_get+0xec>
            {

                /* Subtract off the last full pass through the timer list and add the
                   time left.  */
                ticks_left =  (internal_ptr -> tx_timer_internal_remaining_ticks - TX_TIMER_ENTRIES) + ticks_left;
 800d3ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d3d0:	681a      	ldr	r2, [r3, #0]
 800d3d2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d3d4:	4413      	add	r3, r2
 800d3d6:	3b20      	subs	r3, #32
 800d3d8:	637b      	str	r3, [r7, #52]	; 0x34
 800d3da:	e011      	b.n	800d400 <_tx_timer_info_get+0xec>

            /* The timer is not on the actual timer list so it must either be being processed
               or on a temporary list to be processed.   */

            /* Check to see if this timer is the timer currently being processed.  */
            if (_tx_timer_expired_timer_ptr == internal_ptr)
 800d3dc:	4b1f      	ldr	r3, [pc, #124]	; (800d45c <_tx_timer_info_get+0x148>)
 800d3de:	681b      	ldr	r3, [r3, #0]
 800d3e0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d3e2:	429a      	cmp	r2, r3
 800d3e4:	d102      	bne.n	800d3ec <_tx_timer_info_get+0xd8>
            {

                /* Timer dispatch routine is executing, waiting to execute, or just finishing. No more remaining ticks for this expiration.  */
                ticks_left =  ((ULONG) 0);
 800d3e6:	2300      	movs	r3, #0
 800d3e8:	637b      	str	r3, [r7, #52]	; 0x34
 800d3ea:	e009      	b.n	800d400 <_tx_timer_info_get+0xec>

                /* Timer is not the one being processed, which means it must be on the temporary expiration list
                   waiting to be processed.  */

                /* Calculate the remaining ticks for a timer in the process of expiring.  */
                if (ticks_left > TX_TIMER_ENTRIES)
 800d3ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d3ee:	2b20      	cmp	r3, #32
 800d3f0:	d904      	bls.n	800d3fc <_tx_timer_info_get+0xe8>
                {

                    /* Calculate the number of ticks remaining.  */
                    ticks_left =  internal_ptr -> tx_timer_internal_remaining_ticks - TX_TIMER_ENTRIES;
 800d3f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d3f4:	681b      	ldr	r3, [r3, #0]
 800d3f6:	3b20      	subs	r3, #32
 800d3f8:	637b      	str	r3, [r7, #52]	; 0x34
 800d3fa:	e001      	b.n	800d400 <_tx_timer_info_get+0xec>
                }
                else
                {

                    /* Timer dispatch routine is waiting to execute, no more remaining ticks for this expiration.  */
                    ticks_left =  ((ULONG) 0);
 800d3fc:	2300      	movs	r3, #0
 800d3fe:	637b      	str	r3, [r7, #52]	; 0x34
            }
        }
    }

    /* Setup return values for an inactive timer.  */
    if (active != TX_NULL)
 800d400:	687b      	ldr	r3, [r7, #4]
 800d402:	2b00      	cmp	r3, #0
 800d404:	d002      	beq.n	800d40c <_tx_timer_info_get+0xf8>
    {

       /* Setup the timer active indication.  */
       *active =  timer_active;
 800d406:	687b      	ldr	r3, [r7, #4]
 800d408:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800d40a:	601a      	str	r2, [r3, #0]
    }
    if (remaining_ticks != TX_NULL)
 800d40c:	683b      	ldr	r3, [r7, #0]
 800d40e:	2b00      	cmp	r3, #0
 800d410:	d002      	beq.n	800d418 <_tx_timer_info_get+0x104>
    {

        /* Setup the default remaining ticks value.  */
        *remaining_ticks =  ticks_left;
 800d412:	683b      	ldr	r3, [r7, #0]
 800d414:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800d416:	601a      	str	r2, [r3, #0]
    }

    /* Pickup the reschedule ticks value.  */
    if (reschedule_ticks != TX_NULL)
 800d418:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d41a:	2b00      	cmp	r3, #0
 800d41c:	d003      	beq.n	800d426 <_tx_timer_info_get+0x112>
    {

        *reschedule_ticks =  internal_ptr -> tx_timer_internal_re_initialize_ticks;
 800d41e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d420:	685a      	ldr	r2, [r3, #4]
 800d422:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d424:	601a      	str	r2, [r3, #0]
    }

    /* Pickup the next created application timer.  */
    if (next_timer != TX_NULL)
 800d426:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800d428:	2b00      	cmp	r3, #0
 800d42a:	d003      	beq.n	800d434 <_tx_timer_info_get+0x120>
    {

        *next_timer =  timer_ptr -> tx_timer_created_next;
 800d42c:	68fb      	ldr	r3, [r7, #12]
 800d42e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800d430:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800d432:	601a      	str	r2, [r3, #0]
 800d434:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d436:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d438:	697b      	ldr	r3, [r7, #20]
 800d43a:	f383 8810 	msr	PRIMASK, r3
}
 800d43e:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(TX_SUCCESS);
 800d440:	2300      	movs	r3, #0
}
 800d442:	4618      	mov	r0, r3
 800d444:	373c      	adds	r7, #60	; 0x3c
 800d446:	46bd      	mov	sp, r7
 800d448:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d44c:	4770      	bx	lr
 800d44e:	bf00      	nop
 800d450:	2000f0ec 	.word	0x2000f0ec
 800d454:	2000f0f0 	.word	0x2000f0f0
 800d458:	2000f0f4 	.word	0x2000f0f4
 800d45c:	2000f104 	.word	0x2000f104

0800d460 <_tx_timer_initialize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_initialize(VOID)
{
 800d460:	b590      	push	{r4, r7, lr}
 800d462:	b089      	sub	sp, #36	; 0x24
 800d464:	af06      	add	r7, sp, #24
#endif

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Initialize the system clock to 0.  */
    _tx_timer_system_clock =  ((ULONG) 0);
 800d466:	4b28      	ldr	r3, [pc, #160]	; (800d508 <_tx_timer_initialize+0xa8>)
 800d468:	2200      	movs	r2, #0
 800d46a:	601a      	str	r2, [r3, #0]

    /* Initialize the time-slice value to 0 to make sure it is disabled.  */
    _tx_timer_time_slice =  ((ULONG) 0);
 800d46c:	4b27      	ldr	r3, [pc, #156]	; (800d50c <_tx_timer_initialize+0xac>)
 800d46e:	2200      	movs	r2, #0
 800d470:	601a      	str	r2, [r3, #0]

    /* Clear the expired flags.  */
    _tx_timer_expired_time_slice =  TX_FALSE;
 800d472:	4b27      	ldr	r3, [pc, #156]	; (800d510 <_tx_timer_initialize+0xb0>)
 800d474:	2200      	movs	r2, #0
 800d476:	601a      	str	r2, [r3, #0]
    _tx_timer_expired =             TX_FALSE;
 800d478:	4b26      	ldr	r3, [pc, #152]	; (800d514 <_tx_timer_initialize+0xb4>)
 800d47a:	2200      	movs	r2, #0
 800d47c:	601a      	str	r2, [r3, #0]

    /* Set the currently expired timer being processed pointer to NULL.  */
    _tx_timer_expired_timer_ptr =  TX_NULL;
 800d47e:	4b26      	ldr	r3, [pc, #152]	; (800d518 <_tx_timer_initialize+0xb8>)
 800d480:	2200      	movs	r2, #0
 800d482:	601a      	str	r2, [r3, #0]

    /* Initialize the thread and application timer management control structures.  */

    /* First, initialize the timer list.  */
    TX_MEMSET(&_tx_timer_list[0], 0, (sizeof(_tx_timer_list)));
 800d484:	2280      	movs	r2, #128	; 0x80
 800d486:	2100      	movs	r1, #0
 800d488:	4824      	ldr	r0, [pc, #144]	; (800d51c <_tx_timer_initialize+0xbc>)
 800d48a:	f009 faab 	bl	80169e4 <memset>
#endif

    /* Initialize all of the list pointers.  */
    _tx_timer_list_start =   &_tx_timer_list[0];
 800d48e:	4b24      	ldr	r3, [pc, #144]	; (800d520 <_tx_timer_initialize+0xc0>)
 800d490:	4a22      	ldr	r2, [pc, #136]	; (800d51c <_tx_timer_initialize+0xbc>)
 800d492:	601a      	str	r2, [r3, #0]
    _tx_timer_current_ptr =  &_tx_timer_list[0];
 800d494:	4b23      	ldr	r3, [pc, #140]	; (800d524 <_tx_timer_initialize+0xc4>)
 800d496:	4a21      	ldr	r2, [pc, #132]	; (800d51c <_tx_timer_initialize+0xbc>)
 800d498:	601a      	str	r2, [r3, #0]

    /* Set the timer list end pointer to one past the actual timer list.  This is done
       to make the timer interrupt handling in assembly language a little easier.  */
    _tx_timer_list_end =     &_tx_timer_list[TX_TIMER_ENTRIES-((ULONG) 1)];
 800d49a:	4b23      	ldr	r3, [pc, #140]	; (800d528 <_tx_timer_initialize+0xc8>)
 800d49c:	4a23      	ldr	r2, [pc, #140]	; (800d52c <_tx_timer_initialize+0xcc>)
 800d49e:	601a      	str	r2, [r3, #0]
    _tx_timer_list_end =     TX_TIMER_POINTER_ADD(_tx_timer_list_end, ((ULONG) 1));
 800d4a0:	4b21      	ldr	r3, [pc, #132]	; (800d528 <_tx_timer_initialize+0xc8>)
 800d4a2:	681b      	ldr	r3, [r3, #0]
 800d4a4:	3304      	adds	r3, #4
 800d4a6:	4a20      	ldr	r2, [pc, #128]	; (800d528 <_tx_timer_initialize+0xc8>)
 800d4a8:	6013      	str	r3, [r2, #0]

#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Setup the variables associated with the system timer thread's stack and
       priority.  */
    _tx_timer_stack_start =  (VOID *) &_tx_timer_thread_stack_area[0];
 800d4aa:	4b21      	ldr	r3, [pc, #132]	; (800d530 <_tx_timer_initialize+0xd0>)
 800d4ac:	4a21      	ldr	r2, [pc, #132]	; (800d534 <_tx_timer_initialize+0xd4>)
 800d4ae:	601a      	str	r2, [r3, #0]
    _tx_timer_stack_size =   ((ULONG) TX_TIMER_THREAD_STACK_SIZE);
 800d4b0:	4b21      	ldr	r3, [pc, #132]	; (800d538 <_tx_timer_initialize+0xd8>)
 800d4b2:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800d4b6:	601a      	str	r2, [r3, #0]
    _tx_timer_priority =     ((UINT) TX_TIMER_THREAD_PRIORITY);
 800d4b8:	4b20      	ldr	r3, [pc, #128]	; (800d53c <_tx_timer_initialize+0xdc>)
 800d4ba:	2200      	movs	r2, #0
 800d4bc:	601a      	str	r2, [r3, #0]
       low-level initialization component.  */
    do
    {

        /* Create the system timer thread.  */
        status =  _tx_thread_create(&_tx_timer_thread,
 800d4be:	4b1c      	ldr	r3, [pc, #112]	; (800d530 <_tx_timer_initialize+0xd0>)
 800d4c0:	681b      	ldr	r3, [r3, #0]
 800d4c2:	4a1d      	ldr	r2, [pc, #116]	; (800d538 <_tx_timer_initialize+0xd8>)
 800d4c4:	6812      	ldr	r2, [r2, #0]
 800d4c6:	491d      	ldr	r1, [pc, #116]	; (800d53c <_tx_timer_initialize+0xdc>)
 800d4c8:	6809      	ldr	r1, [r1, #0]
 800d4ca:	481c      	ldr	r0, [pc, #112]	; (800d53c <_tx_timer_initialize+0xdc>)
 800d4cc:	6800      	ldr	r0, [r0, #0]
 800d4ce:	2400      	movs	r4, #0
 800d4d0:	9405      	str	r4, [sp, #20]
 800d4d2:	2400      	movs	r4, #0
 800d4d4:	9404      	str	r4, [sp, #16]
 800d4d6:	9003      	str	r0, [sp, #12]
 800d4d8:	9102      	str	r1, [sp, #8]
 800d4da:	9201      	str	r2, [sp, #4]
 800d4dc:	9300      	str	r3, [sp, #0]
 800d4de:	4b18      	ldr	r3, [pc, #96]	; (800d540 <_tx_timer_initialize+0xe0>)
 800d4e0:	4a18      	ldr	r2, [pc, #96]	; (800d544 <_tx_timer_initialize+0xe4>)
 800d4e2:	4919      	ldr	r1, [pc, #100]	; (800d548 <_tx_timer_initialize+0xe8>)
 800d4e4:	4819      	ldr	r0, [pc, #100]	; (800d54c <_tx_timer_initialize+0xec>)
 800d4e6:	f7fe f92f 	bl	800b748 <_tx_thread_create>
 800d4ea:	6078      	str	r0, [r7, #4]
#endif

        /* Define timer initialize extension.  */
        TX_TIMER_INITIALIZE_EXTENSION(status)

    } while (status != TX_SUCCESS);
 800d4ec:	687b      	ldr	r3, [r7, #4]
 800d4ee:	2b00      	cmp	r3, #0
 800d4f0:	d1e5      	bne.n	800d4be <_tx_timer_initialize+0x5e>
#endif

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Initialize the head pointer of the created application timer list.  */
    _tx_timer_created_ptr =  TX_NULL;
 800d4f2:	4b17      	ldr	r3, [pc, #92]	; (800d550 <_tx_timer_initialize+0xf0>)
 800d4f4:	2200      	movs	r2, #0
 800d4f6:	601a      	str	r2, [r3, #0]

    /* Set the created count to zero.  */
    _tx_timer_created_count =  TX_EMPTY;
 800d4f8:	4b16      	ldr	r3, [pc, #88]	; (800d554 <_tx_timer_initialize+0xf4>)
 800d4fa:	2200      	movs	r2, #0
 800d4fc:	601a      	str	r2, [r3, #0]
    _tx_timer_performance_expiration_count =         ((ULONG) 0);
    _tx_timer_performance__expiration_adjust_count =  ((ULONG) 0);
#endif
#endif
#endif
}
 800d4fe:	bf00      	nop
 800d500:	370c      	adds	r7, #12
 800d502:	46bd      	mov	sp, r7
 800d504:	bd90      	pop	{r4, r7, pc}
 800d506:	bf00      	nop
 800d508:	2000f064 	.word	0x2000f064
 800d50c:	2000f5fc 	.word	0x2000f5fc
 800d510:	2000f068 	.word	0x2000f068
 800d514:	2000f0f8 	.word	0x2000f0f8
 800d518:	2000f104 	.word	0x2000f104
 800d51c:	2000f06c 	.word	0x2000f06c
 800d520:	2000f0ec 	.word	0x2000f0ec
 800d524:	2000f0f4 	.word	0x2000f0f4
 800d528:	2000f0f0 	.word	0x2000f0f0
 800d52c:	2000f0e8 	.word	0x2000f0e8
 800d530:	2000f1f0 	.word	0x2000f1f0
 800d534:	2000f1fc 	.word	0x2000f1fc
 800d538:	2000f1f4 	.word	0x2000f1f4
 800d53c:	2000f1f8 	.word	0x2000f1f8
 800d540:	4154494d 	.word	0x4154494d
 800d544:	0800d751 	.word	0x0800d751
 800d548:	080179c0 	.word	0x080179c0
 800d54c:	2000f108 	.word	0x2000f108
 800d550:	2000f0fc 	.word	0x2000f0fc
 800d554:	2000f100 	.word	0x2000f100

0800d558 <_tx_timer_performance_info_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_timer_performance_info_get(TX_TIMER *timer_ptr, ULONG *activates, ULONG *reactivates,
                    ULONG *deactivates, ULONG *expirations, ULONG *expiration_adjusts)
{
 800d558:	b480      	push	{r7}
 800d55a:	b087      	sub	sp, #28
 800d55c:	af00      	add	r7, sp, #0
 800d55e:	60f8      	str	r0, [r7, #12]
 800d560:	60b9      	str	r1, [r7, #8]
 800d562:	607a      	str	r2, [r7, #4]
 800d564:	603b      	str	r3, [r7, #0]
#else
UINT                    status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (timer_ptr != TX_NULL)
 800d566:	68fb      	ldr	r3, [r7, #12]
 800d568:	2b00      	cmp	r3, #0
 800d56a:	d002      	beq.n	800d572 <_tx_timer_performance_info_get+0x1a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d56c:	23ff      	movs	r3, #255	; 0xff
 800d56e:	617b      	str	r3, [r7, #20]
 800d570:	e01f      	b.n	800d5b2 <_tx_timer_performance_info_get+0x5a>
    }
    else if (activates != TX_NULL)
 800d572:	68bb      	ldr	r3, [r7, #8]
 800d574:	2b00      	cmp	r3, #0
 800d576:	d002      	beq.n	800d57e <_tx_timer_performance_info_get+0x26>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d578:	23ff      	movs	r3, #255	; 0xff
 800d57a:	617b      	str	r3, [r7, #20]
 800d57c:	e019      	b.n	800d5b2 <_tx_timer_performance_info_get+0x5a>
    }
    else if (reactivates != TX_NULL)
 800d57e:	687b      	ldr	r3, [r7, #4]
 800d580:	2b00      	cmp	r3, #0
 800d582:	d002      	beq.n	800d58a <_tx_timer_performance_info_get+0x32>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d584:	23ff      	movs	r3, #255	; 0xff
 800d586:	617b      	str	r3, [r7, #20]
 800d588:	e013      	b.n	800d5b2 <_tx_timer_performance_info_get+0x5a>
    }
    else if (deactivates != TX_NULL)
 800d58a:	683b      	ldr	r3, [r7, #0]
 800d58c:	2b00      	cmp	r3, #0
 800d58e:	d002      	beq.n	800d596 <_tx_timer_performance_info_get+0x3e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d590:	23ff      	movs	r3, #255	; 0xff
 800d592:	617b      	str	r3, [r7, #20]
 800d594:	e00d      	b.n	800d5b2 <_tx_timer_performance_info_get+0x5a>
    }
    else if (expirations != TX_NULL)
 800d596:	6a3b      	ldr	r3, [r7, #32]
 800d598:	2b00      	cmp	r3, #0
 800d59a:	d002      	beq.n	800d5a2 <_tx_timer_performance_info_get+0x4a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d59c:	23ff      	movs	r3, #255	; 0xff
 800d59e:	617b      	str	r3, [r7, #20]
 800d5a0:	e007      	b.n	800d5b2 <_tx_timer_performance_info_get+0x5a>
    }
    else if (expiration_adjusts != TX_NULL)
 800d5a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d5a4:	2b00      	cmp	r3, #0
 800d5a6:	d002      	beq.n	800d5ae <_tx_timer_performance_info_get+0x56>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d5a8:	23ff      	movs	r3, #255	; 0xff
 800d5aa:	617b      	str	r3, [r7, #20]
 800d5ac:	e001      	b.n	800d5b2 <_tx_timer_performance_info_get+0x5a>
    }
    else
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d5ae:	23ff      	movs	r3, #255	; 0xff
 800d5b0:	617b      	str	r3, [r7, #20]
    }
#endif

    /* Return completion status.  */
    return(status);
 800d5b2:	697b      	ldr	r3, [r7, #20]
}
 800d5b4:	4618      	mov	r0, r3
 800d5b6:	371c      	adds	r7, #28
 800d5b8:	46bd      	mov	sp, r7
 800d5ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d5be:	4770      	bx	lr

0800d5c0 <_tx_timer_performance_system_info_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_timer_performance_system_info_get(ULONG *activates, ULONG *reactivates,
                    ULONG *deactivates, ULONG *expirations, ULONG *expiration_adjusts)
{
 800d5c0:	b480      	push	{r7}
 800d5c2:	b087      	sub	sp, #28
 800d5c4:	af00      	add	r7, sp, #0
 800d5c6:	60f8      	str	r0, [r7, #12]
 800d5c8:	60b9      	str	r1, [r7, #8]
 800d5ca:	607a      	str	r2, [r7, #4]
 800d5cc:	603b      	str	r3, [r7, #0]

UINT        status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (activates != TX_NULL)
 800d5ce:	68fb      	ldr	r3, [r7, #12]
 800d5d0:	2b00      	cmp	r3, #0
 800d5d2:	d002      	beq.n	800d5da <_tx_timer_performance_system_info_get+0x1a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d5d4:	23ff      	movs	r3, #255	; 0xff
 800d5d6:	617b      	str	r3, [r7, #20]
 800d5d8:	e019      	b.n	800d60e <_tx_timer_performance_system_info_get+0x4e>
    }
    else if (reactivates != TX_NULL)
 800d5da:	68bb      	ldr	r3, [r7, #8]
 800d5dc:	2b00      	cmp	r3, #0
 800d5de:	d002      	beq.n	800d5e6 <_tx_timer_performance_system_info_get+0x26>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d5e0:	23ff      	movs	r3, #255	; 0xff
 800d5e2:	617b      	str	r3, [r7, #20]
 800d5e4:	e013      	b.n	800d60e <_tx_timer_performance_system_info_get+0x4e>
    }
    else if (deactivates != TX_NULL)
 800d5e6:	687b      	ldr	r3, [r7, #4]
 800d5e8:	2b00      	cmp	r3, #0
 800d5ea:	d002      	beq.n	800d5f2 <_tx_timer_performance_system_info_get+0x32>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d5ec:	23ff      	movs	r3, #255	; 0xff
 800d5ee:	617b      	str	r3, [r7, #20]
 800d5f0:	e00d      	b.n	800d60e <_tx_timer_performance_system_info_get+0x4e>
    }
    else if (expirations != TX_NULL)
 800d5f2:	683b      	ldr	r3, [r7, #0]
 800d5f4:	2b00      	cmp	r3, #0
 800d5f6:	d002      	beq.n	800d5fe <_tx_timer_performance_system_info_get+0x3e>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d5f8:	23ff      	movs	r3, #255	; 0xff
 800d5fa:	617b      	str	r3, [r7, #20]
 800d5fc:	e007      	b.n	800d60e <_tx_timer_performance_system_info_get+0x4e>
    }
    else if (expiration_adjusts != TX_NULL)
 800d5fe:	6a3b      	ldr	r3, [r7, #32]
 800d600:	2b00      	cmp	r3, #0
 800d602:	d002      	beq.n	800d60a <_tx_timer_performance_system_info_get+0x4a>
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d604:	23ff      	movs	r3, #255	; 0xff
 800d606:	617b      	str	r3, [r7, #20]
 800d608:	e001      	b.n	800d60e <_tx_timer_performance_system_info_get+0x4e>
    }
    else
    {

        /* Not enabled, return error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d60a:	23ff      	movs	r3, #255	; 0xff
 800d60c:	617b      	str	r3, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 800d60e:	697b      	ldr	r3, [r7, #20]
#endif
}
 800d610:	4618      	mov	r0, r3
 800d612:	371c      	adds	r7, #28
 800d614:	46bd      	mov	sp, r7
 800d616:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d61a:	4770      	bx	lr

0800d61c <_tx_timer_system_activate>:
/*                                            TX_NO_TIMER is defined,     */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_system_activate(TX_TIMER_INTERNAL *timer_ptr)
{
 800d61c:	b480      	push	{r7}
 800d61e:	b089      	sub	sp, #36	; 0x24
 800d620:	af00      	add	r7, sp, #0
 800d622:	6078      	str	r0, [r7, #4]
ULONG                       remaining_ticks;
ULONG                       expiration_time;


    /* Pickup the remaining ticks.  */
    remaining_ticks =  timer_ptr -> tx_timer_internal_remaining_ticks;
 800d624:	687b      	ldr	r3, [r7, #4]
 800d626:	681b      	ldr	r3, [r3, #0]
 800d628:	617b      	str	r3, [r7, #20]

    /* Determine if there is a timer to activate.  */
    if (remaining_ticks != ((ULONG) 0))
 800d62a:	697b      	ldr	r3, [r7, #20]
 800d62c:	2b00      	cmp	r3, #0
 800d62e:	d04a      	beq.n	800d6c6 <_tx_timer_system_activate+0xaa>
    {

        /* Determine if the timer is set to wait forever.  */
        if (remaining_ticks != TX_WAIT_FOREVER)
 800d630:	697b      	ldr	r3, [r7, #20]
 800d632:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800d636:	d046      	beq.n	800d6c6 <_tx_timer_system_activate+0xaa>
        {

            /* Valid timer activate request.  */

            /* Determine if the timer still needs activation.  */
            if (timer_ptr -> tx_timer_internal_list_head == TX_NULL)
 800d638:	687b      	ldr	r3, [r7, #4]
 800d63a:	699b      	ldr	r3, [r3, #24]
 800d63c:	2b00      	cmp	r3, #0
 800d63e:	d142      	bne.n	800d6c6 <_tx_timer_system_activate+0xaa>
            {

                /* Activate the timer.  */

                /* Calculate the amount of time remaining for the timer.  */
                if (remaining_ticks > TX_TIMER_ENTRIES)
 800d640:	697b      	ldr	r3, [r7, #20]
 800d642:	2b20      	cmp	r3, #32
 800d644:	d902      	bls.n	800d64c <_tx_timer_system_activate+0x30>
                {

                    /* Set expiration time to the maximum number of entries.  */
                    expiration_time =  TX_TIMER_ENTRIES - ((ULONG) 1);
 800d646:	231f      	movs	r3, #31
 800d648:	61bb      	str	r3, [r7, #24]
 800d64a:	e002      	b.n	800d652 <_tx_timer_system_activate+0x36>
                {

                    /* Timer value fits in the timer entries.  */

                    /* Set the expiration time.  */
                    expiration_time =  (remaining_ticks - ((ULONG) 1));
 800d64c:	697b      	ldr	r3, [r7, #20]
 800d64e:	3b01      	subs	r3, #1
 800d650:	61bb      	str	r3, [r7, #24]

                /* At this point, we are ready to put the timer on one of
                   the timer lists.  */

                /* Calculate the proper place for the timer.  */
                timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, expiration_time);
 800d652:	4b20      	ldr	r3, [pc, #128]	; (800d6d4 <_tx_timer_system_activate+0xb8>)
 800d654:	681a      	ldr	r2, [r3, #0]
 800d656:	69bb      	ldr	r3, [r7, #24]
 800d658:	009b      	lsls	r3, r3, #2
 800d65a:	4413      	add	r3, r2
 800d65c:	61fb      	str	r3, [r7, #28]
                if (TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(timer_list) >= TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(_tx_timer_list_end))
 800d65e:	4b1e      	ldr	r3, [pc, #120]	; (800d6d8 <_tx_timer_system_activate+0xbc>)
 800d660:	681b      	ldr	r3, [r3, #0]
 800d662:	69fa      	ldr	r2, [r7, #28]
 800d664:	429a      	cmp	r2, r3
 800d666:	d30b      	bcc.n	800d680 <_tx_timer_system_activate+0x64>
                {

                    /* Wrap from the beginning of the list.  */
                    delta =  TX_TIMER_POINTER_DIF(timer_list, _tx_timer_list_end);
 800d668:	4b1b      	ldr	r3, [pc, #108]	; (800d6d8 <_tx_timer_system_activate+0xbc>)
 800d66a:	681b      	ldr	r3, [r3, #0]
 800d66c:	69fa      	ldr	r2, [r7, #28]
 800d66e:	1ad3      	subs	r3, r2, r3
 800d670:	109b      	asrs	r3, r3, #2
 800d672:	613b      	str	r3, [r7, #16]
                    timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_list_start, delta);
 800d674:	4b19      	ldr	r3, [pc, #100]	; (800d6dc <_tx_timer_system_activate+0xc0>)
 800d676:	681a      	ldr	r2, [r3, #0]
 800d678:	693b      	ldr	r3, [r7, #16]
 800d67a:	009b      	lsls	r3, r3, #2
 800d67c:	4413      	add	r3, r2
 800d67e:	61fb      	str	r3, [r7, #28]
                }

                /* Now put the timer on this list.  */
                if ((*timer_list) == TX_NULL)
 800d680:	69fb      	ldr	r3, [r7, #28]
 800d682:	681b      	ldr	r3, [r3, #0]
 800d684:	2b00      	cmp	r3, #0
 800d686:	d109      	bne.n	800d69c <_tx_timer_system_activate+0x80>
                {

                    /* This list is NULL, just put the new timer on it.  */

                    /* Setup the links in this timer.  */
                    timer_ptr -> tx_timer_internal_active_next =      timer_ptr;
 800d688:	687b      	ldr	r3, [r7, #4]
 800d68a:	687a      	ldr	r2, [r7, #4]
 800d68c:	611a      	str	r2, [r3, #16]
                    timer_ptr -> tx_timer_internal_active_previous =  timer_ptr;
 800d68e:	687b      	ldr	r3, [r7, #4]
 800d690:	687a      	ldr	r2, [r7, #4]
 800d692:	615a      	str	r2, [r3, #20]

                    /* Setup the list head pointer.  */
                    *timer_list =  timer_ptr;
 800d694:	69fb      	ldr	r3, [r7, #28]
 800d696:	687a      	ldr	r2, [r7, #4]
 800d698:	601a      	str	r2, [r3, #0]
 800d69a:	e011      	b.n	800d6c0 <_tx_timer_system_activate+0xa4>
                }
                else
                {

                    /* This list is not NULL, add current timer to the end. */
                    next_timer =                                        *timer_list;
 800d69c:	69fb      	ldr	r3, [r7, #28]
 800d69e:	681b      	ldr	r3, [r3, #0]
 800d6a0:	60fb      	str	r3, [r7, #12]
                    previous_timer =                                    next_timer -> tx_timer_internal_active_previous;
 800d6a2:	68fb      	ldr	r3, [r7, #12]
 800d6a4:	695b      	ldr	r3, [r3, #20]
 800d6a6:	60bb      	str	r3, [r7, #8]
                    previous_timer -> tx_timer_internal_active_next =   timer_ptr;
 800d6a8:	68bb      	ldr	r3, [r7, #8]
 800d6aa:	687a      	ldr	r2, [r7, #4]
 800d6ac:	611a      	str	r2, [r3, #16]
                    next_timer -> tx_timer_internal_active_previous =   timer_ptr;
 800d6ae:	68fb      	ldr	r3, [r7, #12]
 800d6b0:	687a      	ldr	r2, [r7, #4]
 800d6b2:	615a      	str	r2, [r3, #20]
                    timer_ptr -> tx_timer_internal_active_next =        next_timer;
 800d6b4:	687b      	ldr	r3, [r7, #4]
 800d6b6:	68fa      	ldr	r2, [r7, #12]
 800d6b8:	611a      	str	r2, [r3, #16]
                    timer_ptr -> tx_timer_internal_active_previous =    previous_timer;
 800d6ba:	687b      	ldr	r3, [r7, #4]
 800d6bc:	68ba      	ldr	r2, [r7, #8]
 800d6be:	615a      	str	r2, [r3, #20]
                }

                /* Setup list head pointer.  */
                timer_ptr -> tx_timer_internal_list_head =  timer_list;
 800d6c0:	687b      	ldr	r3, [r7, #4]
 800d6c2:	69fa      	ldr	r2, [r7, #28]
 800d6c4:	619a      	str	r2, [r3, #24]
            }
        }
    }
}
 800d6c6:	bf00      	nop
 800d6c8:	3724      	adds	r7, #36	; 0x24
 800d6ca:	46bd      	mov	sp, r7
 800d6cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d6d0:	4770      	bx	lr
 800d6d2:	bf00      	nop
 800d6d4:	2000f0f4 	.word	0x2000f0f4
 800d6d8:	2000f0f0 	.word	0x2000f0f0
 800d6dc:	2000f0ec 	.word	0x2000f0ec

0800d6e0 <_tx_timer_system_deactivate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_system_deactivate(TX_TIMER_INTERNAL *timer_ptr)
{
 800d6e0:	b480      	push	{r7}
 800d6e2:	b087      	sub	sp, #28
 800d6e4:	af00      	add	r7, sp, #0
 800d6e6:	6078      	str	r0, [r7, #4]
TX_TIMER_INTERNAL   *next_timer;
TX_TIMER_INTERNAL   *previous_timer;


    /* Pickup the list head pointer.  */
    list_head =  timer_ptr -> tx_timer_internal_list_head;
 800d6e8:	687b      	ldr	r3, [r7, #4]
 800d6ea:	699b      	ldr	r3, [r3, #24]
 800d6ec:	617b      	str	r3, [r7, #20]

    /* Determine if the timer still needs deactivation.  */
    if (list_head != TX_NULL)
 800d6ee:	697b      	ldr	r3, [r7, #20]
 800d6f0:	2b00      	cmp	r3, #0
 800d6f2:	d026      	beq.n	800d742 <_tx_timer_system_deactivate+0x62>
    {

        /* Deactivate the timer.  */

        /* Pickup the next active timer.  */
        next_timer =  timer_ptr -> tx_timer_internal_active_next;
 800d6f4:	687b      	ldr	r3, [r7, #4]
 800d6f6:	691b      	ldr	r3, [r3, #16]
 800d6f8:	613b      	str	r3, [r7, #16]

        /* See if this is the only timer in the list.  */
        if (timer_ptr == next_timer)
 800d6fa:	687a      	ldr	r2, [r7, #4]
 800d6fc:	693b      	ldr	r3, [r7, #16]
 800d6fe:	429a      	cmp	r2, r3
 800d700:	d108      	bne.n	800d714 <_tx_timer_system_deactivate+0x34>
        {

            /* Yes, the only timer on the list.  */

            /* Determine if the head pointer needs to be updated.  */
            if (*(list_head) == timer_ptr)
 800d702:	697b      	ldr	r3, [r7, #20]
 800d704:	681b      	ldr	r3, [r3, #0]
 800d706:	687a      	ldr	r2, [r7, #4]
 800d708:	429a      	cmp	r2, r3
 800d70a:	d117      	bne.n	800d73c <_tx_timer_system_deactivate+0x5c>
            {

                /* Update the head pointer.  */
                *(list_head) =  TX_NULL;
 800d70c:	697b      	ldr	r3, [r7, #20]
 800d70e:	2200      	movs	r2, #0
 800d710:	601a      	str	r2, [r3, #0]
 800d712:	e013      	b.n	800d73c <_tx_timer_system_deactivate+0x5c>
        {

            /* At least one more timer is on the same expiration list.  */

            /* Update the links of the adjacent timers.  */
            previous_timer =                                   timer_ptr -> tx_timer_internal_active_previous;
 800d714:	687b      	ldr	r3, [r7, #4]
 800d716:	695b      	ldr	r3, [r3, #20]
 800d718:	60fb      	str	r3, [r7, #12]
            next_timer -> tx_timer_internal_active_previous =  previous_timer;
 800d71a:	693b      	ldr	r3, [r7, #16]
 800d71c:	68fa      	ldr	r2, [r7, #12]
 800d71e:	615a      	str	r2, [r3, #20]
            previous_timer -> tx_timer_internal_active_next =  next_timer;
 800d720:	68fb      	ldr	r3, [r7, #12]
 800d722:	693a      	ldr	r2, [r7, #16]
 800d724:	611a      	str	r2, [r3, #16]

            /* Determine if the head pointer needs to be updated.  */
            if (*(list_head) == timer_ptr)
 800d726:	697b      	ldr	r3, [r7, #20]
 800d728:	681b      	ldr	r3, [r3, #0]
 800d72a:	687a      	ldr	r2, [r7, #4]
 800d72c:	429a      	cmp	r2, r3
 800d72e:	d105      	bne.n	800d73c <_tx_timer_system_deactivate+0x5c>
            {

                /* Update the next timer in the list with the list head pointer.  */
                next_timer -> tx_timer_internal_list_head =  list_head;
 800d730:	693b      	ldr	r3, [r7, #16]
 800d732:	697a      	ldr	r2, [r7, #20]
 800d734:	619a      	str	r2, [r3, #24]

                /* Update the head pointer.  */
                *(list_head) =  next_timer;
 800d736:	697b      	ldr	r3, [r7, #20]
 800d738:	693a      	ldr	r2, [r7, #16]
 800d73a:	601a      	str	r2, [r3, #0]
            }
        }

        /* Clear the timer's list head pointer.  */
        timer_ptr -> tx_timer_internal_list_head =  TX_NULL;
 800d73c:	687b      	ldr	r3, [r7, #4]
 800d73e:	2200      	movs	r2, #0
 800d740:	619a      	str	r2, [r3, #24]
    }
}
 800d742:	bf00      	nop
 800d744:	371c      	adds	r7, #28
 800d746:	46bd      	mov	sp, r7
 800d748:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d74c:	4770      	bx	lr
	...

0800d750 <_tx_timer_thread_entry>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
#ifndef TX_TIMER_PROCESS_IN_ISR
VOID  _tx_timer_thread_entry(ULONG timer_thread_input)
{
 800d750:	b580      	push	{r7, lr}
 800d752:	b098      	sub	sp, #96	; 0x60
 800d754:	af00      	add	r7, sp, #0
 800d756:	6078      	str	r0, [r7, #4]
TX_TIMER_INTERNAL           *reactivate_timer;
TX_TIMER_INTERNAL           *next_timer;
TX_TIMER_INTERNAL           *previous_timer;
TX_TIMER_INTERNAL           *current_timer;
VOID                        (*timeout_function)(ULONG id);
ULONG                       timeout_param =  ((ULONG) 0);
 800d758:	2300      	movs	r3, #0
 800d75a:	657b      	str	r3, [r7, #84]	; 0x54
#endif


    /* Make sure the timer input is correct.  This also gets rid of the
       silly compiler warnings.  */
    if (timer_thread_input == TX_TIMER_ID)
 800d75c:	687b      	ldr	r3, [r7, #4]
 800d75e:	4a73      	ldr	r2, [pc, #460]	; (800d92c <_tx_timer_thread_entry+0x1dc>)
 800d760:	4293      	cmp	r3, r2
 800d762:	f040 80de 	bne.w	800d922 <_tx_timer_thread_entry+0x1d2>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d766:	f3ef 8310 	mrs	r3, PRIMASK
 800d76a:	643b      	str	r3, [r7, #64]	; 0x40
    return(posture);
 800d76c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    int_posture = __get_interrupt_posture();
 800d76e:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("CPSID i" : : : "memory");
 800d770:	b672      	cpsid	i
    return(int_posture);
 800d772:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
        {

            /* First, move the current list pointer and clear the timer
               expired value.  This allows the interrupt handling portion
               to continue looking for timer expirations.  */
            TX_DISABLE
 800d774:	65fb      	str	r3, [r7, #92]	; 0x5c

            /* Save the current timer expiration list pointer.  */
            expired_timers =  *_tx_timer_current_ptr;
 800d776:	4b6e      	ldr	r3, [pc, #440]	; (800d930 <_tx_timer_thread_entry+0x1e0>)
 800d778:	681b      	ldr	r3, [r3, #0]
 800d77a:	681b      	ldr	r3, [r3, #0]
 800d77c:	60fb      	str	r3, [r7, #12]

            /* Modify the head pointer in the first timer in the list, if there
               is one!  */
            if (expired_timers != TX_NULL)
 800d77e:	68fb      	ldr	r3, [r7, #12]
 800d780:	2b00      	cmp	r3, #0
 800d782:	d003      	beq.n	800d78c <_tx_timer_thread_entry+0x3c>
            {

                expired_timers -> tx_timer_internal_list_head =  &expired_timers;
 800d784:	68fb      	ldr	r3, [r7, #12]
 800d786:	f107 020c 	add.w	r2, r7, #12
 800d78a:	619a      	str	r2, [r3, #24]
            }

            /* Set the current list pointer to NULL.  */
            *_tx_timer_current_ptr =  TX_NULL;
 800d78c:	4b68      	ldr	r3, [pc, #416]	; (800d930 <_tx_timer_thread_entry+0x1e0>)
 800d78e:	681b      	ldr	r3, [r3, #0]
 800d790:	2200      	movs	r2, #0
 800d792:	601a      	str	r2, [r3, #0]

            /* Move the current pointer up one timer entry wrap if we get to
               the end of the list.  */
            _tx_timer_current_ptr =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, 1);
 800d794:	4b66      	ldr	r3, [pc, #408]	; (800d930 <_tx_timer_thread_entry+0x1e0>)
 800d796:	681b      	ldr	r3, [r3, #0]
 800d798:	3304      	adds	r3, #4
 800d79a:	4a65      	ldr	r2, [pc, #404]	; (800d930 <_tx_timer_thread_entry+0x1e0>)
 800d79c:	6013      	str	r3, [r2, #0]
            if (_tx_timer_current_ptr == _tx_timer_list_end)
 800d79e:	4b64      	ldr	r3, [pc, #400]	; (800d930 <_tx_timer_thread_entry+0x1e0>)
 800d7a0:	681a      	ldr	r2, [r3, #0]
 800d7a2:	4b64      	ldr	r3, [pc, #400]	; (800d934 <_tx_timer_thread_entry+0x1e4>)
 800d7a4:	681b      	ldr	r3, [r3, #0]
 800d7a6:	429a      	cmp	r2, r3
 800d7a8:	d103      	bne.n	800d7b2 <_tx_timer_thread_entry+0x62>
            {

                _tx_timer_current_ptr =  _tx_timer_list_start;
 800d7aa:	4b63      	ldr	r3, [pc, #396]	; (800d938 <_tx_timer_thread_entry+0x1e8>)
 800d7ac:	681b      	ldr	r3, [r3, #0]
 800d7ae:	4a60      	ldr	r2, [pc, #384]	; (800d930 <_tx_timer_thread_entry+0x1e0>)
 800d7b0:	6013      	str	r3, [r2, #0]
            }

            /* Clear the expired flag.  */
            _tx_timer_expired =  TX_FALSE;
 800d7b2:	4b62      	ldr	r3, [pc, #392]	; (800d93c <_tx_timer_thread_entry+0x1ec>)
 800d7b4:	2200      	movs	r2, #0
 800d7b6:	601a      	str	r2, [r3, #0]
 800d7b8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d7ba:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d7bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d7be:	f383 8810 	msr	PRIMASK, r3
}
 800d7c2:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d7c4:	f3ef 8310 	mrs	r3, PRIMASK
 800d7c8:	63bb      	str	r3, [r7, #56]	; 0x38
    return(posture);
 800d7ca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    int_posture = __get_interrupt_posture();
 800d7cc:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile ("CPSID i" : : : "memory");
 800d7ce:	b672      	cpsid	i
    return(int_posture);
 800d7d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34

            /* Restore interrupts temporarily.  */
            TX_RESTORE

            /* Disable interrupts again.  */
            TX_DISABLE
 800d7d2:	65fb      	str	r3, [r7, #92]	; 0x5c

            /* Next, process the expiration of the associated timers at this
               time slot.  */
            while (expired_timers != TX_NULL)
 800d7d4:	e07f      	b.n	800d8d6 <_tx_timer_thread_entry+0x186>
            {

                /* Something is on the list.  Remove it and process the expiration.  */
                current_timer =  expired_timers;
 800d7d6:	68fb      	ldr	r3, [r7, #12]
 800d7d8:	64fb      	str	r3, [r7, #76]	; 0x4c

                /* Pickup the next timer.  */
                next_timer =  expired_timers -> tx_timer_internal_active_next;
 800d7da:	68fb      	ldr	r3, [r7, #12]
 800d7dc:	691b      	ldr	r3, [r3, #16]
 800d7de:	64bb      	str	r3, [r7, #72]	; 0x48

                /* Set the reactivate_timer to NULL.  */
                reactivate_timer =  TX_NULL;
 800d7e0:	2300      	movs	r3, #0
 800d7e2:	60bb      	str	r3, [r7, #8]

                /* Determine if this is the only timer.  */
                if (current_timer == next_timer)
 800d7e4:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800d7e6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800d7e8:	429a      	cmp	r2, r3
 800d7ea:	d102      	bne.n	800d7f2 <_tx_timer_thread_entry+0xa2>
                {

                    /* Yes, this is the only timer in the list.  */

                    /* Set the head pointer to NULL.  */
                    expired_timers =  TX_NULL;
 800d7ec:	2300      	movs	r3, #0
 800d7ee:	60fb      	str	r3, [r7, #12]
 800d7f0:	e00e      	b.n	800d810 <_tx_timer_thread_entry+0xc0>
                {

                    /* No, not the only expired timer.  */

                    /* Remove this timer from the expired list.  */
                    previous_timer =                                   current_timer -> tx_timer_internal_active_previous;
 800d7f2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d7f4:	695b      	ldr	r3, [r3, #20]
 800d7f6:	647b      	str	r3, [r7, #68]	; 0x44
                    next_timer -> tx_timer_internal_active_previous =  previous_timer;
 800d7f8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800d7fa:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800d7fc:	615a      	str	r2, [r3, #20]
                    previous_timer -> tx_timer_internal_active_next =  next_timer;
 800d7fe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800d800:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800d802:	611a      	str	r2, [r3, #16]

                    /* Modify the next timer's list head to point at the current list head.  */
                    next_timer -> tx_timer_internal_list_head =  &expired_timers;
 800d804:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800d806:	f107 020c 	add.w	r2, r7, #12
 800d80a:	619a      	str	r2, [r3, #24]

                    /* Set the list head pointer.  */
                    expired_timers =  next_timer;
 800d80c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800d80e:	60fb      	str	r3, [r7, #12]

                /* In any case, the timer is now off of the expired list.  */

                /* Determine if the timer has expired or if it is just a really
                   big timer that needs to be placed in the list again.  */
                if (current_timer -> tx_timer_internal_remaining_ticks > TX_TIMER_ENTRIES)
 800d810:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d812:	681b      	ldr	r3, [r3, #0]
 800d814:	2b20      	cmp	r3, #32
 800d816:	d911      	bls.n	800d83c <_tx_timer_thread_entry+0xec>
                    }
#endif

                    /* Decrement the remaining ticks of the timer.  */
                    current_timer -> tx_timer_internal_remaining_ticks =
                            current_timer -> tx_timer_internal_remaining_ticks - TX_TIMER_ENTRIES;
 800d818:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d81a:	681b      	ldr	r3, [r3, #0]
 800d81c:	f1a3 0220 	sub.w	r2, r3, #32
                    current_timer -> tx_timer_internal_remaining_ticks =
 800d820:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d822:	601a      	str	r2, [r3, #0]

                    /* Set the timeout function to NULL in order to bypass the
                       expiration.  */
                    timeout_function =  TX_NULL;
 800d824:	2300      	movs	r3, #0
 800d826:	65bb      	str	r3, [r7, #88]	; 0x58

                    /* Make the timer appear that it is still active while interrupts
                       are enabled.  This will permit proper processing of a timer
                       deactivate from an ISR.  */
                    current_timer -> tx_timer_internal_list_head =    &reactivate_timer;
 800d828:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d82a:	f107 0208 	add.w	r2, r7, #8
 800d82e:	619a      	str	r2, [r3, #24]
                    current_timer -> tx_timer_internal_active_next =  current_timer;
 800d830:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d832:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800d834:	611a      	str	r2, [r3, #16]

                    /* Setup the temporary timer list head pointer.  */
                    reactivate_timer =  current_timer;
 800d836:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d838:	60bb      	str	r3, [r7, #8]
 800d83a:	e01a      	b.n	800d872 <_tx_timer_thread_entry+0x122>
                    }
#endif

                    /* Copy the calling function and ID into local variables before interrupts
                       are re-enabled.  */
                    timeout_function =  current_timer -> tx_timer_internal_timeout_function;
 800d83c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d83e:	689b      	ldr	r3, [r3, #8]
 800d840:	65bb      	str	r3, [r7, #88]	; 0x58
                    timeout_param =     current_timer -> tx_timer_internal_timeout_param;
 800d842:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d844:	68db      	ldr	r3, [r3, #12]
 800d846:	657b      	str	r3, [r7, #84]	; 0x54

                    /* Copy the reinitialize ticks into the remaining ticks.  */
                    current_timer -> tx_timer_internal_remaining_ticks =  current_timer -> tx_timer_internal_re_initialize_ticks;
 800d848:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d84a:	685a      	ldr	r2, [r3, #4]
 800d84c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d84e:	601a      	str	r2, [r3, #0]

                    /* Determine if the timer should be reactivated.  */
                    if (current_timer -> tx_timer_internal_remaining_ticks != ((ULONG) 0))
 800d850:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d852:	681b      	ldr	r3, [r3, #0]
 800d854:	2b00      	cmp	r3, #0
 800d856:	d009      	beq.n	800d86c <_tx_timer_thread_entry+0x11c>

                        /* Make the timer appear that it is still active while processing
                           the expiration routine and with interrupts enabled.  This will
                           permit proper processing of a timer deactivate from both the
                           expiration routine and an ISR.  */
                        current_timer -> tx_timer_internal_list_head =    &reactivate_timer;
 800d858:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d85a:	f107 0208 	add.w	r2, r7, #8
 800d85e:	619a      	str	r2, [r3, #24]
                        current_timer -> tx_timer_internal_active_next =  current_timer;
 800d860:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d862:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800d864:	611a      	str	r2, [r3, #16]

                        /* Setup the temporary timer list head pointer.  */
                        reactivate_timer =  current_timer;
 800d866:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d868:	60bb      	str	r3, [r7, #8]
 800d86a:	e002      	b.n	800d872 <_tx_timer_thread_entry+0x122>
                    else
                    {

                        /* Set the list pointer of this timer to NULL.  This is used to indicate
                           the timer is no longer active.  */
                        current_timer -> tx_timer_internal_list_head =  TX_NULL;
 800d86c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d86e:	2200      	movs	r2, #0
 800d870:	619a      	str	r2, [r3, #24]
                    }
                }

                /* Set pointer to indicate the expired timer that is currently being processed.  */
                _tx_timer_expired_timer_ptr =  current_timer;
 800d872:	4a33      	ldr	r2, [pc, #204]	; (800d940 <_tx_timer_thread_entry+0x1f0>)
 800d874:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d876:	6013      	str	r3, [r2, #0]
 800d878:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d87a:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d87c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d87e:	f383 8810 	msr	PRIMASK, r3
}
 800d882:	bf00      	nop

                /* Restore interrupts for timer expiration call.  */
                TX_RESTORE

                /* Call the timer-expiration function, if non-NULL.  */
                if (timeout_function != TX_NULL)
 800d884:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d886:	2b00      	cmp	r3, #0
 800d888:	d002      	beq.n	800d890 <_tx_timer_thread_entry+0x140>
                {

                    (timeout_function) (timeout_param);
 800d88a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d88c:	6d78      	ldr	r0, [r7, #84]	; 0x54
 800d88e:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d890:	f3ef 8310 	mrs	r3, PRIMASK
 800d894:	62bb      	str	r3, [r7, #40]	; 0x28
    return(posture);
 800d896:	6abb      	ldr	r3, [r7, #40]	; 0x28
    int_posture = __get_interrupt_posture();
 800d898:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
 800d89a:	b672      	cpsid	i
    return(int_posture);
 800d89c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
                }

                /* Lockout interrupts again.  */
                TX_DISABLE
 800d89e:	65fb      	str	r3, [r7, #92]	; 0x5c

                /* Clear expired timer pointer.  */
                _tx_timer_expired_timer_ptr =  TX_NULL;
 800d8a0:	4b27      	ldr	r3, [pc, #156]	; (800d940 <_tx_timer_thread_entry+0x1f0>)
 800d8a2:	2200      	movs	r2, #0
 800d8a4:	601a      	str	r2, [r3, #0]

                /* Determine if the timer needs to be reactivated.  */
                if (reactivate_timer == current_timer)
 800d8a6:	68bb      	ldr	r3, [r7, #8]
 800d8a8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800d8aa:	429a      	cmp	r2, r3
 800d8ac:	d105      	bne.n	800d8ba <_tx_timer_thread_entry+0x16a>
#else

                    /* Reactivate through the timer activate function.  */

                    /* Clear the list head for the timer activate call.  */
                    current_timer -> tx_timer_internal_list_head = TX_NULL;
 800d8ae:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d8b0:	2200      	movs	r2, #0
 800d8b2:	619a      	str	r2, [r3, #24]

                    /* Activate the current timer.  */
                    _tx_timer_system_activate(current_timer);
 800d8b4:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800d8b6:	f7ff feb1 	bl	800d61c <_tx_timer_system_activate>
 800d8ba:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d8bc:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d8be:	69bb      	ldr	r3, [r7, #24]
 800d8c0:	f383 8810 	msr	PRIMASK, r3
}
 800d8c4:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d8c6:	f3ef 8310 	mrs	r3, PRIMASK
 800d8ca:	623b      	str	r3, [r7, #32]
    return(posture);
 800d8cc:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 800d8ce:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 800d8d0:	b672      	cpsid	i
    return(int_posture);
 800d8d2:	69fb      	ldr	r3, [r7, #28]

                /* Restore interrupts.  */
                TX_RESTORE

                /* Lockout interrupts again.  */
                TX_DISABLE
 800d8d4:	65fb      	str	r3, [r7, #92]	; 0x5c
            while (expired_timers != TX_NULL)
 800d8d6:	68fb      	ldr	r3, [r7, #12]
 800d8d8:	2b00      	cmp	r3, #0
 800d8da:	f47f af7c 	bne.w	800d7d6 <_tx_timer_thread_entry+0x86>

            /* Finally, suspend this thread and wait for the next expiration.  */

            /* Determine if another expiration took place while we were in this
               thread.  If so, process another expiration.  */
            if (_tx_timer_expired == TX_FALSE)
 800d8de:	4b17      	ldr	r3, [pc, #92]	; (800d93c <_tx_timer_thread_entry+0x1ec>)
 800d8e0:	681b      	ldr	r3, [r3, #0]
 800d8e2:	2b00      	cmp	r3, #0
 800d8e4:	d116      	bne.n	800d914 <_tx_timer_thread_entry+0x1c4>
            {

                /* Otherwise, no timer expiration, so suspend the thread.  */

                /* Build pointer to the timer thread.  */
                thread_ptr =  &_tx_timer_thread;
 800d8e6:	4b17      	ldr	r3, [pc, #92]	; (800d944 <_tx_timer_thread_entry+0x1f4>)
 800d8e8:	653b      	str	r3, [r7, #80]	; 0x50

                /* Set the status to suspending, in order to indicate the
                   suspension is in progress.  */
                thread_ptr -> tx_thread_state =  TX_SUSPENDED;
 800d8ea:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d8ec:	2203      	movs	r2, #3
 800d8ee:	631a      	str	r2, [r3, #48]	; 0x30
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Set the suspending flag. */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800d8f0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d8f2:	2201      	movs	r2, #1
 800d8f4:	639a      	str	r2, [r3, #56]	; 0x38

                /* Increment the preempt disable count prior to suspending.  */
                _tx_thread_preempt_disable++;
 800d8f6:	4b14      	ldr	r3, [pc, #80]	; (800d948 <_tx_timer_thread_entry+0x1f8>)
 800d8f8:	681b      	ldr	r3, [r3, #0]
 800d8fa:	3301      	adds	r3, #1
 800d8fc:	4a12      	ldr	r2, [pc, #72]	; (800d948 <_tx_timer_thread_entry+0x1f8>)
 800d8fe:	6013      	str	r3, [r2, #0]
 800d900:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d902:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d904:	697b      	ldr	r3, [r7, #20]
 800d906:	f383 8810 	msr	PRIMASK, r3
}
 800d90a:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
 800d90c:	6d38      	ldr	r0, [r7, #80]	; 0x50
 800d90e:	f7fe fea1 	bl	800c654 <_tx_thread_system_suspend>
 800d912:	e728      	b.n	800d766 <_tx_timer_thread_entry+0x16>
 800d914:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d916:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d918:	693b      	ldr	r3, [r7, #16]
 800d91a:	f383 8810 	msr	PRIMASK, r3
}
 800d91e:	bf00      	nop
            TX_DISABLE
 800d920:	e721      	b.n	800d766 <_tx_timer_thread_entry+0x16>

    /* If we ever get here, raise safety critical exception.  */
    TX_SAFETY_CRITICAL_EXCEPTION(__FILE__, __LINE__, 0);
#endif

}
 800d922:	bf00      	nop
 800d924:	3760      	adds	r7, #96	; 0x60
 800d926:	46bd      	mov	sp, r7
 800d928:	bd80      	pop	{r7, pc}
 800d92a:	bf00      	nop
 800d92c:	4154494d 	.word	0x4154494d
 800d930:	2000f0f4 	.word	0x2000f0f4
 800d934:	2000f0f0 	.word	0x2000f0f0
 800d938:	2000f0ec 	.word	0x2000f0ec
 800d93c:	2000f0f8 	.word	0x2000f0f8
 800d940:	2000f104 	.word	0x2000f104
 800d944:	2000f108 	.word	0x2000f108
 800d948:	2000f054 	.word	0x2000f054

0800d94c <_tx_trace_buffer_full_notify>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_trace_buffer_full_notify(VOID (*full_buffer_callback)(VOID *buffer))
{
 800d94c:	b480      	push	{r7}
 800d94e:	b085      	sub	sp, #20
 800d950:	af00      	add	r7, sp, #0
 800d952:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (full_buffer_callback != TX_NULL)
 800d954:	687b      	ldr	r3, [r7, #4]
 800d956:	2b00      	cmp	r3, #0
 800d958:	d002      	beq.n	800d960 <_tx_trace_buffer_full_notify+0x14>
    {

        /* Trace not enabled, return an error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d95a:	23ff      	movs	r3, #255	; 0xff
 800d95c:	60fb      	str	r3, [r7, #12]
 800d95e:	e001      	b.n	800d964 <_tx_trace_buffer_full_notify+0x18>
    }
    else
    {

        /* Trace not enabled, return an error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d960:	23ff      	movs	r3, #255	; 0xff
 800d962:	60fb      	str	r3, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800d964:	68fb      	ldr	r3, [r7, #12]
#endif
}
 800d966:	4618      	mov	r0, r3
 800d968:	3714      	adds	r7, #20
 800d96a:	46bd      	mov	sp, r7
 800d96c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d970:	4770      	bx	lr

0800d972 <_tx_trace_disable>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_trace_disable(VOID)
{
 800d972:	b480      	push	{r7}
 800d974:	af00      	add	r7, sp, #0
    return(status);

#else

    /* Trace not enabled, return an error.  */
    return(TX_FEATURE_NOT_ENABLED);
 800d976:	23ff      	movs	r3, #255	; 0xff
#endif
}
 800d978:	4618      	mov	r0, r3
 800d97a:	46bd      	mov	sp, r7
 800d97c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d980:	4770      	bx	lr

0800d982 <_tx_trace_enable>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_trace_enable(VOID *trace_buffer_start, ULONG trace_buffer_size, ULONG registry_entries)
{
 800d982:	b480      	push	{r7}
 800d984:	b087      	sub	sp, #28
 800d986:	af00      	add	r7, sp, #0
 800d988:	60f8      	str	r0, [r7, #12]
 800d98a:	60b9      	str	r1, [r7, #8]
 800d98c:	607a      	str	r2, [r7, #4]

UINT        status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (trace_buffer_start != TX_NULL)
 800d98e:	68fb      	ldr	r3, [r7, #12]
 800d990:	2b00      	cmp	r3, #0
 800d992:	d002      	beq.n	800d99a <_tx_trace_enable+0x18>
    {

        /* Trace not enabled, return an error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d994:	23ff      	movs	r3, #255	; 0xff
 800d996:	617b      	str	r3, [r7, #20]
 800d998:	e00d      	b.n	800d9b6 <_tx_trace_enable+0x34>
    }
    else if (trace_buffer_size == ((ULONG) 0))
 800d99a:	68bb      	ldr	r3, [r7, #8]
 800d99c:	2b00      	cmp	r3, #0
 800d99e:	d102      	bne.n	800d9a6 <_tx_trace_enable+0x24>
    {

        /* Trace not enabled, return an error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d9a0:	23ff      	movs	r3, #255	; 0xff
 800d9a2:	617b      	str	r3, [r7, #20]
 800d9a4:	e007      	b.n	800d9b6 <_tx_trace_enable+0x34>
    }
    else if (registry_entries == ((ULONG) 0))
 800d9a6:	687b      	ldr	r3, [r7, #4]
 800d9a8:	2b00      	cmp	r3, #0
 800d9aa:	d102      	bne.n	800d9b2 <_tx_trace_enable+0x30>
    {

        /* Trace not enabled, return an error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d9ac:	23ff      	movs	r3, #255	; 0xff
 800d9ae:	617b      	str	r3, [r7, #20]
 800d9b0:	e001      	b.n	800d9b6 <_tx_trace_enable+0x34>
    }
    else
    {

        /* Trace not enabled, return an error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d9b2:	23ff      	movs	r3, #255	; 0xff
 800d9b4:	617b      	str	r3, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 800d9b6:	697b      	ldr	r3, [r7, #20]
#endif
}
 800d9b8:	4618      	mov	r0, r3
 800d9ba:	371c      	adds	r7, #28
 800d9bc:	46bd      	mov	sp, r7
 800d9be:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d9c2:	4770      	bx	lr

0800d9c4 <_tx_trace_event_filter>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_trace_event_filter(ULONG event_filter_bits)
{
 800d9c4:	b480      	push	{r7}
 800d9c6:	b085      	sub	sp, #20
 800d9c8:	af00      	add	r7, sp, #0
 800d9ca:	6078      	str	r0, [r7, #4]

UINT        status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (event_filter_bits != ((ULONG) 0))
 800d9cc:	687b      	ldr	r3, [r7, #4]
 800d9ce:	2b00      	cmp	r3, #0
 800d9d0:	d002      	beq.n	800d9d8 <_tx_trace_event_filter+0x14>
    {

        /* Trace not enabled, return an error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d9d2:	23ff      	movs	r3, #255	; 0xff
 800d9d4:	60fb      	str	r3, [r7, #12]
 800d9d6:	e001      	b.n	800d9dc <_tx_trace_event_filter+0x18>
    }
    else
    {

        /* Trace not enabled, return an error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d9d8:	23ff      	movs	r3, #255	; 0xff
 800d9da:	60fb      	str	r3, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800d9dc:	68fb      	ldr	r3, [r7, #12]
#endif
}
 800d9de:	4618      	mov	r0, r3
 800d9e0:	3714      	adds	r7, #20
 800d9e2:	46bd      	mov	sp, r7
 800d9e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d9e8:	4770      	bx	lr

0800d9ea <_tx_trace_event_unfilter>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_trace_event_unfilter(ULONG event_unfilter_bits)
{
 800d9ea:	b480      	push	{r7}
 800d9ec:	b085      	sub	sp, #20
 800d9ee:	af00      	add	r7, sp, #0
 800d9f0:	6078      	str	r0, [r7, #4]

UINT        status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (event_unfilter_bits != ((ULONG) 0))
 800d9f2:	687b      	ldr	r3, [r7, #4]
 800d9f4:	2b00      	cmp	r3, #0
 800d9f6:	d002      	beq.n	800d9fe <_tx_trace_event_unfilter+0x14>
    {

        /* Trace not enabled, return an error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d9f8:	23ff      	movs	r3, #255	; 0xff
 800d9fa:	60fb      	str	r3, [r7, #12]
 800d9fc:	e001      	b.n	800da02 <_tx_trace_event_unfilter+0x18>
    }
    else
    {

        /* Trace not enabled, return an error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800d9fe:	23ff      	movs	r3, #255	; 0xff
 800da00:	60fb      	str	r3, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800da02:	68fb      	ldr	r3, [r7, #12]
#endif
}
 800da04:	4618      	mov	r0, r3
 800da06:	3714      	adds	r7, #20
 800da08:	46bd      	mov	sp, r7
 800da0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800da0e:	4770      	bx	lr

0800da10 <_tx_trace_interrupt_control>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_trace_interrupt_control(UINT new_posture)
{
 800da10:	b580      	push	{r7, lr}
 800da12:	b084      	sub	sp, #16
 800da14:	af00      	add	r7, sp, #0
 800da16:	6078      	str	r0, [r7, #4]
#else

UINT    saved_posture;

    /* Perform the interrupt service.  */
    saved_posture =  _tx_thread_interrupt_control(new_posture);
 800da18:	6878      	ldr	r0, [r7, #4]
 800da1a:	f7f2 fcc9 	bl	80003b0 <_tx_thread_interrupt_control>
 800da1e:	60f8      	str	r0, [r7, #12]

    /* Return saved posture.  */
    return(saved_posture);
 800da20:	68fb      	ldr	r3, [r7, #12]
#endif
}
 800da22:	4618      	mov	r0, r3
 800da24:	3710      	adds	r7, #16
 800da26:	46bd      	mov	sp, r7
 800da28:	bd80      	pop	{r7, pc}

0800da2a <_tx_trace_isr_enter_insert>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_trace_isr_enter_insert(ULONG isr_id)
{
 800da2a:	b480      	push	{r7}
 800da2c:	b087      	sub	sp, #28
 800da2e:	af00      	add	r7, sp, #0
 800da30:	6078      	str	r0, [r7, #4]
    /* Restore interrupts.  */
    TX_RESTORE
#else

    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (isr_id != ((ULONG) 0))
 800da32:	687b      	ldr	r3, [r7, #4]
 800da34:	2b00      	cmp	r3, #0
 800da36:	d00d      	beq.n	800da54 <_tx_trace_isr_enter_insert+0x2a>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800da38:	f3ef 8310 	mrs	r3, PRIMASK
 800da3c:	60fb      	str	r3, [r7, #12]
    return(posture);
 800da3e:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 800da40:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 800da42:	b672      	cpsid	i
    return(int_posture);
 800da44:	68bb      	ldr	r3, [r7, #8]
    {

        /* NOP code.  */
        TX_DISABLE
 800da46:	617b      	str	r3, [r7, #20]
 800da48:	697b      	ldr	r3, [r7, #20]
 800da4a:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800da4c:	693b      	ldr	r3, [r7, #16]
 800da4e:	f383 8810 	msr	PRIMASK, r3
}
 800da52:	bf00      	nop
        TX_RESTORE
    }
#endif
}
 800da54:	bf00      	nop
 800da56:	371c      	adds	r7, #28
 800da58:	46bd      	mov	sp, r7
 800da5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800da5e:	4770      	bx	lr

0800da60 <_tx_trace_isr_exit_insert>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_trace_isr_exit_insert(ULONG isr_id)
{
 800da60:	b480      	push	{r7}
 800da62:	b087      	sub	sp, #28
 800da64:	af00      	add	r7, sp, #0
 800da66:	6078      	str	r0, [r7, #4]
    /* Restore interrupts.  */
    TX_RESTORE
#else

    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (isr_id != ((ULONG) 0))
 800da68:	687b      	ldr	r3, [r7, #4]
 800da6a:	2b00      	cmp	r3, #0
 800da6c:	d00d      	beq.n	800da8a <_tx_trace_isr_exit_insert+0x2a>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800da6e:	f3ef 8310 	mrs	r3, PRIMASK
 800da72:	60fb      	str	r3, [r7, #12]
    return(posture);
 800da74:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 800da76:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 800da78:	b672      	cpsid	i
    return(int_posture);
 800da7a:	68bb      	ldr	r3, [r7, #8]
    {

        /* NOP code.  */
        TX_DISABLE
 800da7c:	617b      	str	r3, [r7, #20]
 800da7e:	697b      	ldr	r3, [r7, #20]
 800da80:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800da82:	693b      	ldr	r3, [r7, #16]
 800da84:	f383 8810 	msr	PRIMASK, r3
}
 800da88:	bf00      	nop
        TX_RESTORE
    }
#endif
}
 800da8a:	bf00      	nop
 800da8c:	371c      	adds	r7, #28
 800da8e:	46bd      	mov	sp, r7
 800da90:	f85d 7b04 	ldr.w	r7, [sp], #4
 800da94:	4770      	bx	lr

0800da96 <_tx_trace_user_event_insert>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_trace_user_event_insert(ULONG event_id, ULONG info_field_1, ULONG info_field_2, ULONG info_field_3, ULONG info_field_4)
{
 800da96:	b480      	push	{r7}
 800da98:	b087      	sub	sp, #28
 800da9a:	af00      	add	r7, sp, #0
 800da9c:	60f8      	str	r0, [r7, #12]
 800da9e:	60b9      	str	r1, [r7, #8]
 800daa0:	607a      	str	r2, [r7, #4]
 800daa2:	603b      	str	r3, [r7, #0]

UINT        status;


    /* Access input arguments just for the sake of lint, MISRA, etc.  */
    if (event_id != ((ULONG) 0))
 800daa4:	68fb      	ldr	r3, [r7, #12]
 800daa6:	2b00      	cmp	r3, #0
 800daa8:	d002      	beq.n	800dab0 <_tx_trace_user_event_insert+0x1a>
    {

        /* Trace not enabled, return an error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800daaa:	23ff      	movs	r3, #255	; 0xff
 800daac:	617b      	str	r3, [r7, #20]
 800daae:	e019      	b.n	800dae4 <_tx_trace_user_event_insert+0x4e>
    }
    else if (info_field_1 != ((ULONG) 0))
 800dab0:	68bb      	ldr	r3, [r7, #8]
 800dab2:	2b00      	cmp	r3, #0
 800dab4:	d002      	beq.n	800dabc <_tx_trace_user_event_insert+0x26>
    {

        /* Trace not enabled, return an error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800dab6:	23ff      	movs	r3, #255	; 0xff
 800dab8:	617b      	str	r3, [r7, #20]
 800daba:	e013      	b.n	800dae4 <_tx_trace_user_event_insert+0x4e>
    }
    else if (info_field_2 != ((ULONG) 0))
 800dabc:	687b      	ldr	r3, [r7, #4]
 800dabe:	2b00      	cmp	r3, #0
 800dac0:	d002      	beq.n	800dac8 <_tx_trace_user_event_insert+0x32>
    {

        /* Trace not enabled, return an error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800dac2:	23ff      	movs	r3, #255	; 0xff
 800dac4:	617b      	str	r3, [r7, #20]
 800dac6:	e00d      	b.n	800dae4 <_tx_trace_user_event_insert+0x4e>
    }
    else if (info_field_3 != ((ULONG) 0))
 800dac8:	683b      	ldr	r3, [r7, #0]
 800daca:	2b00      	cmp	r3, #0
 800dacc:	d002      	beq.n	800dad4 <_tx_trace_user_event_insert+0x3e>
    {

        /* Trace not enabled, return an error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800dace:	23ff      	movs	r3, #255	; 0xff
 800dad0:	617b      	str	r3, [r7, #20]
 800dad2:	e007      	b.n	800dae4 <_tx_trace_user_event_insert+0x4e>
    }
    else if (info_field_4 != ((ULONG) 0))
 800dad4:	6a3b      	ldr	r3, [r7, #32]
 800dad6:	2b00      	cmp	r3, #0
 800dad8:	d002      	beq.n	800dae0 <_tx_trace_user_event_insert+0x4a>
    {

        /* Trace not enabled, return an error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800dada:	23ff      	movs	r3, #255	; 0xff
 800dadc:	617b      	str	r3, [r7, #20]
 800dade:	e001      	b.n	800dae4 <_tx_trace_user_event_insert+0x4e>
    }
    else
    {

        /* Trace not enabled, return an error.  */
        status =  TX_FEATURE_NOT_ENABLED;
 800dae0:	23ff      	movs	r3, #255	; 0xff
 800dae2:	617b      	str	r3, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 800dae4:	697b      	ldr	r3, [r7, #20]
#endif
}
 800dae6:	4618      	mov	r0, r3
 800dae8:	371c      	adds	r7, #28
 800daea:	46bd      	mov	sp, r7
 800daec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800daf0:	4770      	bx	lr
	...

0800daf4 <_txe_block_allocate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_block_allocate(TX_BLOCK_POOL *pool_ptr, VOID **block_ptr, ULONG wait_option)
{
 800daf4:	b580      	push	{r7, lr}
 800daf6:	b088      	sub	sp, #32
 800daf8:	af00      	add	r7, sp, #0
 800dafa:	60f8      	str	r0, [r7, #12]
 800dafc:	60b9      	str	r1, [r7, #8]
 800dafe:	607a      	str	r2, [r7, #4]

TX_THREAD       *current_thread;
#endif

    /* Default status to success.  */
    status =  TX_SUCCESS;
 800db00:	2300      	movs	r3, #0
 800db02:	61fb      	str	r3, [r7, #28]

    /* Check for an invalid pool pointer.  */
    if (pool_ptr == TX_NULL)
 800db04:	68fb      	ldr	r3, [r7, #12]
 800db06:	2b00      	cmp	r3, #0
 800db08:	d102      	bne.n	800db10 <_txe_block_allocate+0x1c>
    {

        /* Pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800db0a:	2302      	movs	r3, #2
 800db0c:	61fb      	str	r3, [r7, #28]
 800db0e:	e025      	b.n	800db5c <_txe_block_allocate+0x68>
    }

    /* Check for an invalid pool pointer.  */
    else if (pool_ptr -> tx_block_pool_id != TX_BLOCK_POOL_ID)
 800db10:	68fb      	ldr	r3, [r7, #12]
 800db12:	681b      	ldr	r3, [r3, #0]
 800db14:	4a18      	ldr	r2, [pc, #96]	; (800db78 <_txe_block_allocate+0x84>)
 800db16:	4293      	cmp	r3, r2
 800db18:	d002      	beq.n	800db20 <_txe_block_allocate+0x2c>
    {

        /* Pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800db1a:	2302      	movs	r3, #2
 800db1c:	61fb      	str	r3, [r7, #28]
 800db1e:	e01d      	b.n	800db5c <_txe_block_allocate+0x68>
    }

    /* Check for an invalid destination for return pointer.  */
    else if (block_ptr == TX_NULL)
 800db20:	68bb      	ldr	r3, [r7, #8]
 800db22:	2b00      	cmp	r3, #0
 800db24:	d102      	bne.n	800db2c <_txe_block_allocate+0x38>
    {

        /* Null destination pointer, return appropriate error.  */
        status =  TX_PTR_ERROR;
 800db26:	2303      	movs	r3, #3
 800db28:	61fb      	str	r3, [r7, #28]
 800db2a:	e017      	b.n	800db5c <_txe_block_allocate+0x68>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
 800db2c:	687b      	ldr	r3, [r7, #4]
 800db2e:	2b00      	cmp	r3, #0
 800db30:	d014      	beq.n	800db5c <_txe_block_allocate+0x68>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800db32:	f3ef 8305 	mrs	r3, IPSR
 800db36:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800db38:	697a      	ldr	r2, [r7, #20]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800db3a:	4b10      	ldr	r3, [pc, #64]	; (800db7c <_txe_block_allocate+0x88>)
 800db3c:	681b      	ldr	r3, [r3, #0]
 800db3e:	4313      	orrs	r3, r2
 800db40:	2b00      	cmp	r3, #0
 800db42:	d002      	beq.n	800db4a <_txe_block_allocate+0x56>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
 800db44:	2304      	movs	r3, #4
 800db46:	61fb      	str	r3, [r7, #28]
 800db48:	e008      	b.n	800db5c <_txe_block_allocate+0x68>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
 800db4a:	4b0d      	ldr	r3, [pc, #52]	; (800db80 <_txe_block_allocate+0x8c>)
 800db4c:	681b      	ldr	r3, [r3, #0]
 800db4e:	61bb      	str	r3, [r7, #24]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
 800db50:	69bb      	ldr	r3, [r7, #24]
 800db52:	4a0c      	ldr	r2, [pc, #48]	; (800db84 <_txe_block_allocate+0x90>)
 800db54:	4293      	cmp	r3, r2
 800db56:	d101      	bne.n	800db5c <_txe_block_allocate+0x68>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
 800db58:	2304      	movs	r3, #4
 800db5a:	61fb      	str	r3, [r7, #28]
#endif
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800db5c:	69fb      	ldr	r3, [r7, #28]
 800db5e:	2b00      	cmp	r3, #0
 800db60:	d105      	bne.n	800db6e <_txe_block_allocate+0x7a>
    {

        /* Call actual block allocate function.  */
        status =  _tx_block_allocate(pool_ptr, block_ptr, wait_option);
 800db62:	687a      	ldr	r2, [r7, #4]
 800db64:	68b9      	ldr	r1, [r7, #8]
 800db66:	68f8      	ldr	r0, [r7, #12]
 800db68:	f7f9 faac 	bl	80070c4 <_tx_block_allocate>
 800db6c:	61f8      	str	r0, [r7, #28]
    }

    /* Return completion status.  */
    return(status);
 800db6e:	69fb      	ldr	r3, [r7, #28]
}
 800db70:	4618      	mov	r0, r3
 800db72:	3720      	adds	r7, #32
 800db74:	46bd      	mov	sp, r7
 800db76:	bd80      	pop	{r7, pc}
 800db78:	424c4f43 	.word	0x424c4f43
 800db7c:	2000000c 	.word	0x2000000c
 800db80:	2000efb8 	.word	0x2000efb8
 800db84:	2000f108 	.word	0x2000f108

0800db88 <_txe_block_pool_create>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_block_pool_create(TX_BLOCK_POOL *pool_ptr, CHAR *name_ptr, ULONG block_size,
                    VOID *pool_start, ULONG pool_size, UINT pool_control_block_size)
{
 800db88:	b580      	push	{r7, lr}
 800db8a:	b094      	sub	sp, #80	; 0x50
 800db8c:	af02      	add	r7, sp, #8
 800db8e:	60f8      	str	r0, [r7, #12]
 800db90:	60b9      	str	r1, [r7, #8]
 800db92:	607a      	str	r2, [r7, #4]
 800db94:	603b      	str	r3, [r7, #0]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800db96:	2300      	movs	r3, #0
 800db98:	647b      	str	r3, [r7, #68]	; 0x44

    /* Check for an invalid pool pointer.  */
    if (pool_ptr == TX_NULL)
 800db9a:	68fb      	ldr	r3, [r7, #12]
 800db9c:	2b00      	cmp	r3, #0
 800db9e:	d102      	bne.n	800dba6 <_txe_block_pool_create+0x1e>
    {

        /* Pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800dba0:	2302      	movs	r3, #2
 800dba2:	647b      	str	r3, [r7, #68]	; 0x44
 800dba4:	e07b      	b.n	800dc9e <_txe_block_pool_create+0x116>
    }

    /* Check for invalid control block size.  */
    else if (pool_control_block_size != (sizeof(TX_BLOCK_POOL)))
 800dba6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800dba8:	2b30      	cmp	r3, #48	; 0x30
 800dbaa:	d002      	beq.n	800dbb2 <_txe_block_pool_create+0x2a>
    {

        /* Pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800dbac:	2302      	movs	r3, #2
 800dbae:	647b      	str	r3, [r7, #68]	; 0x44
 800dbb0:	e075      	b.n	800dc9e <_txe_block_pool_create+0x116>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800dbb2:	f3ef 8310 	mrs	r3, PRIMASK
 800dbb6:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800dbb8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800dbba:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800dbbc:	b672      	cpsid	i
    return(int_posture);
 800dbbe:	6abb      	ldr	r3, [r7, #40]	; 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
 800dbc0:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
 800dbc2:	4b3f      	ldr	r3, [pc, #252]	; (800dcc0 <_txe_block_pool_create+0x138>)
 800dbc4:	681b      	ldr	r3, [r3, #0]
 800dbc6:	3301      	adds	r3, #1
 800dbc8:	4a3d      	ldr	r2, [pc, #244]	; (800dcc0 <_txe_block_pool_create+0x138>)
 800dbca:	6013      	str	r3, [r2, #0]
 800dbcc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800dbce:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800dbd0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800dbd2:	f383 8810 	msr	PRIMASK, r3
}
 800dbd6:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_pool =   _tx_block_pool_created_ptr;
 800dbd8:	4b3a      	ldr	r3, [pc, #232]	; (800dcc4 <_txe_block_pool_create+0x13c>)
 800dbda:	681b      	ldr	r3, [r3, #0]
 800dbdc:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_block_pool_created_count; i++)
 800dbde:	2300      	movs	r3, #0
 800dbe0:	643b      	str	r3, [r7, #64]	; 0x40
 800dbe2:	e009      	b.n	800dbf8 <_txe_block_pool_create+0x70>
        {

            /* Determine if this block pool matches the pool in the list.  */
            if (pool_ptr == next_pool)
 800dbe4:	68fa      	ldr	r2, [r7, #12]
 800dbe6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800dbe8:	429a      	cmp	r2, r3
 800dbea:	d00b      	beq.n	800dc04 <_txe_block_pool_create+0x7c>
                break;
            }
            else
            {
                /* Move to the next pool.  */
                next_pool =  next_pool -> tx_block_pool_created_next;
 800dbec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800dbee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800dbf0:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_block_pool_created_count; i++)
 800dbf2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800dbf4:	3301      	adds	r3, #1
 800dbf6:	643b      	str	r3, [r7, #64]	; 0x40
 800dbf8:	4b33      	ldr	r3, [pc, #204]	; (800dcc8 <_txe_block_pool_create+0x140>)
 800dbfa:	681b      	ldr	r3, [r3, #0]
 800dbfc:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800dbfe:	429a      	cmp	r2, r3
 800dc00:	d3f0      	bcc.n	800dbe4 <_txe_block_pool_create+0x5c>
 800dc02:	e000      	b.n	800dc06 <_txe_block_pool_create+0x7e>
                break;
 800dc04:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800dc06:	f3ef 8310 	mrs	r3, PRIMASK
 800dc0a:	623b      	str	r3, [r7, #32]
    return(posture);
 800dc0c:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 800dc0e:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 800dc10:	b672      	cpsid	i
    return(int_posture);
 800dc12:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
 800dc14:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
 800dc16:	4b2a      	ldr	r3, [pc, #168]	; (800dcc0 <_txe_block_pool_create+0x138>)
 800dc18:	681b      	ldr	r3, [r3, #0]
 800dc1a:	3b01      	subs	r3, #1
 800dc1c:	4a28      	ldr	r2, [pc, #160]	; (800dcc0 <_txe_block_pool_create+0x138>)
 800dc1e:	6013      	str	r3, [r2, #0]
 800dc20:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800dc22:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800dc24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dc26:	f383 8810 	msr	PRIMASK, r3
}
 800dc2a:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 800dc2c:	f7fe fbc4 	bl	800c3b8 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate pool.  */
        if (pool_ptr == next_pool)
 800dc30:	68fa      	ldr	r2, [r7, #12]
 800dc32:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800dc34:	429a      	cmp	r2, r3
 800dc36:	d102      	bne.n	800dc3e <_txe_block_pool_create+0xb6>
        {

            /* Pool is already created, return appropriate error code.  */
            status =  TX_POOL_ERROR;
 800dc38:	2302      	movs	r3, #2
 800dc3a:	647b      	str	r3, [r7, #68]	; 0x44
 800dc3c:	e02f      	b.n	800dc9e <_txe_block_pool_create+0x116>
        }

        /* Check for an invalid starting address.  */
        else if (pool_start == TX_NULL)
 800dc3e:	683b      	ldr	r3, [r7, #0]
 800dc40:	2b00      	cmp	r3, #0
 800dc42:	d102      	bne.n	800dc4a <_txe_block_pool_create+0xc2>
        {

            /* Null starting address pointer, return appropriate error.  */
            status =  TX_PTR_ERROR;
 800dc44:	2303      	movs	r3, #3
 800dc46:	647b      	str	r3, [r7, #68]	; 0x44
 800dc48:	e029      	b.n	800dc9e <_txe_block_pool_create+0x116>
        }
        else
        {

            /* Check for invalid pool size.  */
            if ((((block_size/(sizeof(void *)))*(sizeof(void *))) + (sizeof(void *))) >
 800dc4a:	687b      	ldr	r3, [r7, #4]
 800dc4c:	f023 0303 	bic.w	r3, r3, #3
 800dc50:	1d1a      	adds	r2, r3, #4
                                            ((pool_size/(sizeof(void *)))*(sizeof(void *))))
 800dc52:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800dc54:	f023 0303 	bic.w	r3, r3, #3
            if ((((block_size/(sizeof(void *)))*(sizeof(void *))) + (sizeof(void *))) >
 800dc58:	429a      	cmp	r2, r3
 800dc5a:	d902      	bls.n	800dc62 <_txe_block_pool_create+0xda>
            {

                /* Not enough memory for one block, return appropriate error.  */
                status =  TX_SIZE_ERROR;
 800dc5c:	2305      	movs	r3, #5
 800dc5e:	647b      	str	r3, [r7, #68]	; 0x44
 800dc60:	e01d      	b.n	800dc9e <_txe_block_pool_create+0x116>
            {

#ifndef TX_TIMER_PROCESS_IN_ISR

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(thread_ptr)
 800dc62:	4b1a      	ldr	r3, [pc, #104]	; (800dccc <_txe_block_pool_create+0x144>)
 800dc64:	681b      	ldr	r3, [r3, #0]
 800dc66:	637b      	str	r3, [r7, #52]	; 0x34

                /* Check for invalid caller of this function.  First check for a calling thread.  */
                if (thread_ptr == &_tx_timer_thread)
 800dc68:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dc6a:	4a19      	ldr	r2, [pc, #100]	; (800dcd0 <_txe_block_pool_create+0x148>)
 800dc6c:	4293      	cmp	r3, r2
 800dc6e:	d101      	bne.n	800dc74 <_txe_block_pool_create+0xec>
                {

                    /* Invalid caller of this function, return appropriate error code.  */
                    status =  TX_CALLER_ERROR;
 800dc70:	2313      	movs	r3, #19
 800dc72:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800dc74:	f3ef 8305 	mrs	r3, IPSR
 800dc78:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 800dc7a:	69ba      	ldr	r2, [r7, #24]
                }
#endif

                /* Check for interrupt call.  */
                if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800dc7c:	4b15      	ldr	r3, [pc, #84]	; (800dcd4 <_txe_block_pool_create+0x14c>)
 800dc7e:	681b      	ldr	r3, [r3, #0]
 800dc80:	4313      	orrs	r3, r2
 800dc82:	2b00      	cmp	r3, #0
 800dc84:	d00b      	beq.n	800dc9e <_txe_block_pool_create+0x116>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800dc86:	f3ef 8305 	mrs	r3, IPSR
 800dc8a:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800dc8c:	697a      	ldr	r2, [r7, #20]
                {

                    /* Now, make sure the call is from an interrupt and not initialization.  */
                    if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800dc8e:	4b11      	ldr	r3, [pc, #68]	; (800dcd4 <_txe_block_pool_create+0x14c>)
 800dc90:	681b      	ldr	r3, [r3, #0]
 800dc92:	4313      	orrs	r3, r2
 800dc94:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800dc98:	d201      	bcs.n	800dc9e <_txe_block_pool_create+0x116>
                    {

                        /* Invalid caller of this function, return appropriate error code.  */
                        status =  TX_CALLER_ERROR;
 800dc9a:	2313      	movs	r3, #19
 800dc9c:	647b      	str	r3, [r7, #68]	; 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800dc9e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800dca0:	2b00      	cmp	r3, #0
 800dca2:	d108      	bne.n	800dcb6 <_txe_block_pool_create+0x12e>
    {

        /* Call actual block pool create function.  */
        status =  _tx_block_pool_create(pool_ptr, name_ptr, block_size, pool_start, pool_size);
 800dca4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800dca6:	9300      	str	r3, [sp, #0]
 800dca8:	683b      	ldr	r3, [r7, #0]
 800dcaa:	687a      	ldr	r2, [r7, #4]
 800dcac:	68b9      	ldr	r1, [r7, #8]
 800dcae:	68f8      	ldr	r0, [r7, #12]
 800dcb0:	f7f9 fb36 	bl	8007320 <_tx_block_pool_create>
 800dcb4:	6478      	str	r0, [r7, #68]	; 0x44
    }

    /* Return completion status.  */
    return(status);
 800dcb6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 800dcb8:	4618      	mov	r0, r3
 800dcba:	3748      	adds	r7, #72	; 0x48
 800dcbc:	46bd      	mov	sp, r7
 800dcbe:	bd80      	pop	{r7, pc}
 800dcc0:	2000f054 	.word	0x2000f054
 800dcc4:	2000efa0 	.word	0x2000efa0
 800dcc8:	2000efa4 	.word	0x2000efa4
 800dccc:	2000efb8 	.word	0x2000efb8
 800dcd0:	2000f108 	.word	0x2000f108
 800dcd4:	2000000c 	.word	0x2000000c

0800dcd8 <_txe_block_pool_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT    _txe_block_pool_delete(TX_BLOCK_POOL *pool_ptr)
{
 800dcd8:	b580      	push	{r7, lr}
 800dcda:	b086      	sub	sp, #24
 800dcdc:	af00      	add	r7, sp, #0
 800dcde:	6078      	str	r0, [r7, #4]


#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Default status to success.  */
    status =  TX_SUCCESS;
 800dce0:	2300      	movs	r3, #0
 800dce2:	617b      	str	r3, [r7, #20]
#endif

    /* Check for an invalid pool pointer.  */
    if (pool_ptr == TX_NULL)
 800dce4:	687b      	ldr	r3, [r7, #4]
 800dce6:	2b00      	cmp	r3, #0
 800dce8:	d102      	bne.n	800dcf0 <_txe_block_pool_delete+0x18>
    {

        /* Pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800dcea:	2302      	movs	r3, #2
 800dcec:	617b      	str	r3, [r7, #20]
 800dcee:	e023      	b.n	800dd38 <_txe_block_pool_delete+0x60>
    }

    /* Now check the pool ID.  */
    else if (pool_ptr -> tx_block_pool_id != TX_BLOCK_POOL_ID)
 800dcf0:	687b      	ldr	r3, [r7, #4]
 800dcf2:	681b      	ldr	r3, [r3, #0]
 800dcf4:	4a13      	ldr	r2, [pc, #76]	; (800dd44 <_txe_block_pool_delete+0x6c>)
 800dcf6:	4293      	cmp	r3, r2
 800dcf8:	d002      	beq.n	800dd00 <_txe_block_pool_delete+0x28>
    {

        /* Pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800dcfa:	2302      	movs	r3, #2
 800dcfc:	617b      	str	r3, [r7, #20]
 800dcfe:	e01b      	b.n	800dd38 <_txe_block_pool_delete+0x60>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800dd00:	f3ef 8305 	mrs	r3, IPSR
 800dd04:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 800dd06:	68fa      	ldr	r2, [r7, #12]
    }

    /* Check for invalid caller of this function.  */

    /* Is the call from an ISR or initialization?  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800dd08:	4b0f      	ldr	r3, [pc, #60]	; (800dd48 <_txe_block_pool_delete+0x70>)
 800dd0a:	681b      	ldr	r3, [r3, #0]
 800dd0c:	4313      	orrs	r3, r2
 800dd0e:	2b00      	cmp	r3, #0
 800dd10:	d002      	beq.n	800dd18 <_txe_block_pool_delete+0x40>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
 800dd12:	2313      	movs	r3, #19
 800dd14:	617b      	str	r3, [r7, #20]
 800dd16:	e00f      	b.n	800dd38 <_txe_block_pool_delete+0x60>
    {

#ifndef TX_TIMER_PROCESS_IN_ISR

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 800dd18:	4b0c      	ldr	r3, [pc, #48]	; (800dd4c <_txe_block_pool_delete+0x74>)
 800dd1a:	681b      	ldr	r3, [r3, #0]
 800dd1c:	613b      	str	r3, [r7, #16]

        /* Is the call from the system timer thread?  */
        if (thread_ptr == &_tx_timer_thread)
 800dd1e:	693b      	ldr	r3, [r7, #16]
 800dd20:	4a0b      	ldr	r2, [pc, #44]	; (800dd50 <_txe_block_pool_delete+0x78>)
 800dd22:	4293      	cmp	r3, r2
 800dd24:	d101      	bne.n	800dd2a <_txe_block_pool_delete+0x52>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 800dd26:	2313      	movs	r3, #19
 800dd28:	617b      	str	r3, [r7, #20]
        }

        /* Determine if everything is okay.  */
        if (status == TX_SUCCESS)
 800dd2a:	697b      	ldr	r3, [r7, #20]
 800dd2c:	2b00      	cmp	r3, #0
 800dd2e:	d103      	bne.n	800dd38 <_txe_block_pool_delete+0x60>
        {
#endif

            /* Call actual block pool delete function.  */
            status =  _tx_block_pool_delete(pool_ptr);
 800dd30:	6878      	ldr	r0, [r7, #4]
 800dd32:	f7f9 fb97 	bl	8007464 <_tx_block_pool_delete>
 800dd36:	6178      	str	r0, [r7, #20]
        }
#endif
    }

    /* Return completion status.  */
    return(status);
 800dd38:	697b      	ldr	r3, [r7, #20]
}
 800dd3a:	4618      	mov	r0, r3
 800dd3c:	3718      	adds	r7, #24
 800dd3e:	46bd      	mov	sp, r7
 800dd40:	bd80      	pop	{r7, pc}
 800dd42:	bf00      	nop
 800dd44:	424c4f43 	.word	0x424c4f43
 800dd48:	2000000c 	.word	0x2000000c
 800dd4c:	2000efb8 	.word	0x2000efb8
 800dd50:	2000f108 	.word	0x2000f108

0800dd54 <_txe_block_pool_info_get>:
/*                                                                        */
/**************************************************************************/
UINT  _txe_block_pool_info_get(TX_BLOCK_POOL *pool_ptr, CHAR **name, ULONG *available_blocks,
                    ULONG *total_blocks, TX_THREAD **first_suspended,
                    ULONG *suspended_count, TX_BLOCK_POOL **next_pool)
{
 800dd54:	b580      	push	{r7, lr}
 800dd56:	b08a      	sub	sp, #40	; 0x28
 800dd58:	af04      	add	r7, sp, #16
 800dd5a:	60f8      	str	r0, [r7, #12]
 800dd5c:	60b9      	str	r1, [r7, #8]
 800dd5e:	607a      	str	r2, [r7, #4]
 800dd60:	603b      	str	r3, [r7, #0]

UINT    status;


    /* Check for an invalid block pool pointer.  */
    if (pool_ptr == TX_NULL)
 800dd62:	68fb      	ldr	r3, [r7, #12]
 800dd64:	2b00      	cmp	r3, #0
 800dd66:	d102      	bne.n	800dd6e <_txe_block_pool_info_get+0x1a>
    {

        /* Block pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800dd68:	2302      	movs	r3, #2
 800dd6a:	617b      	str	r3, [r7, #20]
 800dd6c:	e014      	b.n	800dd98 <_txe_block_pool_info_get+0x44>
    }

    /* Now check the pool ID.  */
    else if (pool_ptr -> tx_block_pool_id != TX_BLOCK_POOL_ID)
 800dd6e:	68fb      	ldr	r3, [r7, #12]
 800dd70:	681b      	ldr	r3, [r3, #0]
 800dd72:	4a0c      	ldr	r2, [pc, #48]	; (800dda4 <_txe_block_pool_info_get+0x50>)
 800dd74:	4293      	cmp	r3, r2
 800dd76:	d002      	beq.n	800dd7e <_txe_block_pool_info_get+0x2a>
    {

        /* Block pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800dd78:	2302      	movs	r3, #2
 800dd7a:	617b      	str	r3, [r7, #20]
 800dd7c:	e00c      	b.n	800dd98 <_txe_block_pool_info_get+0x44>
    }
    else
    {

        /* Otherwise, call the actual block pool information get service.  */
        status =  _tx_block_pool_info_get(pool_ptr, name, available_blocks,
 800dd7e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800dd80:	9302      	str	r3, [sp, #8]
 800dd82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dd84:	9301      	str	r3, [sp, #4]
 800dd86:	6a3b      	ldr	r3, [r7, #32]
 800dd88:	9300      	str	r3, [sp, #0]
 800dd8a:	683b      	ldr	r3, [r7, #0]
 800dd8c:	687a      	ldr	r2, [r7, #4]
 800dd8e:	68b9      	ldr	r1, [r7, #8]
 800dd90:	68f8      	ldr	r0, [r7, #12]
 800dd92:	f7f9 fbf7 	bl	8007584 <_tx_block_pool_info_get>
 800dd96:	6178      	str	r0, [r7, #20]
                        total_blocks, first_suspended, suspended_count, next_pool);
    }

    /* Return completion status.  */
    return(status);
 800dd98:	697b      	ldr	r3, [r7, #20]
}
 800dd9a:	4618      	mov	r0, r3
 800dd9c:	3718      	adds	r7, #24
 800dd9e:	46bd      	mov	sp, r7
 800dda0:	bd80      	pop	{r7, pc}
 800dda2:	bf00      	nop
 800dda4:	424c4f43 	.word	0x424c4f43

0800dda8 <_txe_block_pool_prioritize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_block_pool_prioritize(TX_BLOCK_POOL *pool_ptr)
{
 800dda8:	b580      	push	{r7, lr}
 800ddaa:	b084      	sub	sp, #16
 800ddac:	af00      	add	r7, sp, #0
 800ddae:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Check for an invalid block memory pool pointer.  */
    if (pool_ptr == TX_NULL)
 800ddb0:	687b      	ldr	r3, [r7, #4]
 800ddb2:	2b00      	cmp	r3, #0
 800ddb4:	d102      	bne.n	800ddbc <_txe_block_pool_prioritize+0x14>
    {

        /* Block memory pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800ddb6:	2302      	movs	r3, #2
 800ddb8:	60fb      	str	r3, [r7, #12]
 800ddba:	e00b      	b.n	800ddd4 <_txe_block_pool_prioritize+0x2c>
    }

    /* Now check for invalid pool ID.  */
    else if (pool_ptr -> tx_block_pool_id != TX_BLOCK_POOL_ID)
 800ddbc:	687b      	ldr	r3, [r7, #4]
 800ddbe:	681b      	ldr	r3, [r3, #0]
 800ddc0:	4a07      	ldr	r2, [pc, #28]	; (800dde0 <_txe_block_pool_prioritize+0x38>)
 800ddc2:	4293      	cmp	r3, r2
 800ddc4:	d002      	beq.n	800ddcc <_txe_block_pool_prioritize+0x24>
    {

        /* Block memory pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800ddc6:	2302      	movs	r3, #2
 800ddc8:	60fb      	str	r3, [r7, #12]
 800ddca:	e003      	b.n	800ddd4 <_txe_block_pool_prioritize+0x2c>
    }
    else
    {

        /* Call actual block pool prioritize function.  */
        status =  _tx_block_pool_prioritize(pool_ptr);
 800ddcc:	6878      	ldr	r0, [r7, #4]
 800ddce:	f7f9 fc75 	bl	80076bc <_tx_block_pool_prioritize>
 800ddd2:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800ddd4:	68fb      	ldr	r3, [r7, #12]
}
 800ddd6:	4618      	mov	r0, r3
 800ddd8:	3710      	adds	r7, #16
 800ddda:	46bd      	mov	sp, r7
 800dddc:	bd80      	pop	{r7, pc}
 800ddde:	bf00      	nop
 800dde0:	424c4f43 	.word	0x424c4f43

0800dde4 <_txe_block_release>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_block_release(VOID *block_ptr)
{
 800dde4:	b580      	push	{r7, lr}
 800dde6:	b086      	sub	sp, #24
 800dde8:	af00      	add	r7, sp, #0
 800ddea:	6078      	str	r0, [r7, #4]
UCHAR               **indirect_ptr;
UCHAR               *work_ptr;


    /* First check the supplied pointer.  */
    if (block_ptr == TX_NULL)
 800ddec:	687b      	ldr	r3, [r7, #4]
 800ddee:	2b00      	cmp	r3, #0
 800ddf0:	d102      	bne.n	800ddf8 <_txe_block_release+0x14>
    {

        /* The block pointer is invalid, return appropriate status.  */
        status =  TX_PTR_ERROR;
 800ddf2:	2303      	movs	r3, #3
 800ddf4:	617b      	str	r3, [r7, #20]
 800ddf6:	e01d      	b.n	800de34 <_txe_block_release+0x50>
    else
    {

        /* Pickup the pool pointer which is just previous to the starting
           address of block that the caller sees.  */
        work_ptr =      TX_VOID_TO_UCHAR_POINTER_CONVERT(block_ptr);
 800ddf8:	687b      	ldr	r3, [r7, #4]
 800ddfa:	613b      	str	r3, [r7, #16]
        work_ptr =      TX_UCHAR_POINTER_SUB(work_ptr, (sizeof(UCHAR *)));
 800ddfc:	693b      	ldr	r3, [r7, #16]
 800ddfe:	3b04      	subs	r3, #4
 800de00:	613b      	str	r3, [r7, #16]
        indirect_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
 800de02:	693b      	ldr	r3, [r7, #16]
 800de04:	60fb      	str	r3, [r7, #12]
        work_ptr =      *indirect_ptr;
 800de06:	68fb      	ldr	r3, [r7, #12]
 800de08:	681b      	ldr	r3, [r3, #0]
 800de0a:	613b      	str	r3, [r7, #16]
        pool_ptr =      TX_UCHAR_TO_BLOCK_POOL_POINTER_CONVERT(work_ptr);
 800de0c:	693b      	ldr	r3, [r7, #16]
 800de0e:	60bb      	str	r3, [r7, #8]

        /* Check for an invalid pool pointer.  */
        if (pool_ptr == TX_NULL)
 800de10:	68bb      	ldr	r3, [r7, #8]
 800de12:	2b00      	cmp	r3, #0
 800de14:	d102      	bne.n	800de1c <_txe_block_release+0x38>
        {

            /* Pool pointer is invalid, return appropriate error code.  */
            status =  TX_PTR_ERROR;
 800de16:	2303      	movs	r3, #3
 800de18:	617b      	str	r3, [r7, #20]
 800de1a:	e00b      	b.n	800de34 <_txe_block_release+0x50>
        }

        /* Now check for invalid pool ID.  */
        else if  (pool_ptr -> tx_block_pool_id != TX_BLOCK_POOL_ID)
 800de1c:	68bb      	ldr	r3, [r7, #8]
 800de1e:	681b      	ldr	r3, [r3, #0]
 800de20:	4a07      	ldr	r2, [pc, #28]	; (800de40 <_txe_block_release+0x5c>)
 800de22:	4293      	cmp	r3, r2
 800de24:	d002      	beq.n	800de2c <_txe_block_release+0x48>
        {

            /* Pool pointer is invalid, return appropriate error code.  */
            status =  TX_PTR_ERROR;
 800de26:	2303      	movs	r3, #3
 800de28:	617b      	str	r3, [r7, #20]
 800de2a:	e003      	b.n	800de34 <_txe_block_release+0x50>
        }
        else
        {

            /* Call actual block release function.  */
            status =  _tx_block_release(block_ptr);
 800de2c:	6878      	ldr	r0, [r7, #4]
 800de2e:	f7f9 fcf7 	bl	8007820 <_tx_block_release>
 800de32:	6178      	str	r0, [r7, #20]
        }
    }

    /* Return completion status.  */
    return(status);
 800de34:	697b      	ldr	r3, [r7, #20]
}
 800de36:	4618      	mov	r0, r3
 800de38:	3718      	adds	r7, #24
 800de3a:	46bd      	mov	sp, r7
 800de3c:	bd80      	pop	{r7, pc}
 800de3e:	bf00      	nop
 800de40:	424c4f43 	.word	0x424c4f43

0800de44 <_txe_byte_allocate>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_byte_allocate(TX_BYTE_POOL *pool_ptr, VOID **memory_ptr,
                                    ULONG memory_size,  ULONG wait_option)
{
 800de44:	b580      	push	{r7, lr}
 800de46:	b08a      	sub	sp, #40	; 0x28
 800de48:	af00      	add	r7, sp, #0
 800de4a:	60f8      	str	r0, [r7, #12]
 800de4c:	60b9      	str	r1, [r7, #8]
 800de4e:	607a      	str	r2, [r7, #4]
 800de50:	603b      	str	r3, [r7, #0]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800de52:	2300      	movs	r3, #0
 800de54:	627b      	str	r3, [r7, #36]	; 0x24

    /* Check for an invalid byte pool pointer.  */
    if (pool_ptr == TX_NULL)
 800de56:	68fb      	ldr	r3, [r7, #12]
 800de58:	2b00      	cmp	r3, #0
 800de5a:	d102      	bne.n	800de62 <_txe_byte_allocate+0x1e>
    {

        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800de5c:	2302      	movs	r3, #2
 800de5e:	627b      	str	r3, [r7, #36]	; 0x24
 800de60:	e029      	b.n	800deb6 <_txe_byte_allocate+0x72>
    }

    /* Now check for invalid pool ID.  */
    else if  (pool_ptr -> tx_byte_pool_id != TX_BYTE_POOL_ID)
 800de62:	68fb      	ldr	r3, [r7, #12]
 800de64:	681b      	ldr	r3, [r3, #0]
 800de66:	4a2d      	ldr	r2, [pc, #180]	; (800df1c <_txe_byte_allocate+0xd8>)
 800de68:	4293      	cmp	r3, r2
 800de6a:	d002      	beq.n	800de72 <_txe_byte_allocate+0x2e>
    {

        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800de6c:	2302      	movs	r3, #2
 800de6e:	627b      	str	r3, [r7, #36]	; 0x24
 800de70:	e021      	b.n	800deb6 <_txe_byte_allocate+0x72>
    }

    /* Check for an invalid destination for return pointer.  */
    else if (memory_ptr == TX_NULL)
 800de72:	68bb      	ldr	r3, [r7, #8]
 800de74:	2b00      	cmp	r3, #0
 800de76:	d102      	bne.n	800de7e <_txe_byte_allocate+0x3a>
    {

        /* Null destination pointer, return appropriate error.  */
        status =  TX_PTR_ERROR;
 800de78:	2303      	movs	r3, #3
 800de7a:	627b      	str	r3, [r7, #36]	; 0x24
 800de7c:	e01b      	b.n	800deb6 <_txe_byte_allocate+0x72>
    }

    /* Check for an invalid memory size.  */
    else if (memory_size == ((ULONG) 0))
 800de7e:	687b      	ldr	r3, [r7, #4]
 800de80:	2b00      	cmp	r3, #0
 800de82:	d102      	bne.n	800de8a <_txe_byte_allocate+0x46>
    {

        /* Error in size, return appropriate error.  */
        status =  TX_SIZE_ERROR;
 800de84:	2305      	movs	r3, #5
 800de86:	627b      	str	r3, [r7, #36]	; 0x24
 800de88:	e015      	b.n	800deb6 <_txe_byte_allocate+0x72>
    }

    /* Determine if the size is greater than the pool size.  */
    else if (memory_size > pool_ptr -> tx_byte_pool_size)
 800de8a:	68fb      	ldr	r3, [r7, #12]
 800de8c:	69db      	ldr	r3, [r3, #28]
 800de8e:	687a      	ldr	r2, [r7, #4]
 800de90:	429a      	cmp	r2, r3
 800de92:	d902      	bls.n	800de9a <_txe_byte_allocate+0x56>
    {

        /* Error in size, return appropriate error.  */
        status =  TX_SIZE_ERROR;
 800de94:	2305      	movs	r3, #5
 800de96:	627b      	str	r3, [r7, #36]	; 0x24
 800de98:	e00d      	b.n	800deb6 <_txe_byte_allocate+0x72>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
 800de9a:	683b      	ldr	r3, [r7, #0]
 800de9c:	2b00      	cmp	r3, #0
 800de9e:	d00a      	beq.n	800deb6 <_txe_byte_allocate+0x72>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800dea0:	f3ef 8305 	mrs	r3, IPSR
 800dea4:	61fb      	str	r3, [r7, #28]
    return(ipsr_value);
 800dea6:	69fa      	ldr	r2, [r7, #28]
        {

            /* Is call from ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800dea8:	4b1d      	ldr	r3, [pc, #116]	; (800df20 <_txe_byte_allocate+0xdc>)
 800deaa:	681b      	ldr	r3, [r3, #0]
 800deac:	4313      	orrs	r3, r2
 800deae:	2b00      	cmp	r3, #0
 800deb0:	d001      	beq.n	800deb6 <_txe_byte_allocate+0x72>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
 800deb2:	2304      	movs	r3, #4
 800deb4:	627b      	str	r3, [r7, #36]	; 0x24
        }
    }
#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Check for timer execution.  */
    if (status == TX_SUCCESS)
 800deb6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800deb8:	2b00      	cmp	r3, #0
 800deba:	d108      	bne.n	800dece <_txe_byte_allocate+0x8a>
    {

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 800debc:	4b19      	ldr	r3, [pc, #100]	; (800df24 <_txe_byte_allocate+0xe0>)
 800debe:	681b      	ldr	r3, [r3, #0]
 800dec0:	623b      	str	r3, [r7, #32]

        /* Check for invalid caller of this function.  First check for a calling thread.  */
        if (thread_ptr == &_tx_timer_thread)
 800dec2:	6a3b      	ldr	r3, [r7, #32]
 800dec4:	4a18      	ldr	r2, [pc, #96]	; (800df28 <_txe_byte_allocate+0xe4>)
 800dec6:	4293      	cmp	r3, r2
 800dec8:	d101      	bne.n	800dece <_txe_byte_allocate+0x8a>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 800deca:	2313      	movs	r3, #19
 800decc:	627b      	str	r3, [r7, #36]	; 0x24
        }
    }
#endif

    /* Is everything still okay?  */
    if (status == TX_SUCCESS)
 800dece:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ded0:	2b00      	cmp	r3, #0
 800ded2:	d114      	bne.n	800defe <_txe_byte_allocate+0xba>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800ded4:	f3ef 8305 	mrs	r3, IPSR
 800ded8:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 800deda:	69ba      	ldr	r2, [r7, #24]
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800dedc:	4b10      	ldr	r3, [pc, #64]	; (800df20 <_txe_byte_allocate+0xdc>)
 800dede:	681b      	ldr	r3, [r3, #0]
 800dee0:	4313      	orrs	r3, r2
 800dee2:	2b00      	cmp	r3, #0
 800dee4:	d00b      	beq.n	800defe <_txe_byte_allocate+0xba>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800dee6:	f3ef 8305 	mrs	r3, IPSR
 800deea:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800deec:	697a      	ldr	r2, [r7, #20]
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800deee:	4b0c      	ldr	r3, [pc, #48]	; (800df20 <_txe_byte_allocate+0xdc>)
 800def0:	681b      	ldr	r3, [r3, #0]
 800def2:	4313      	orrs	r3, r2
 800def4:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800def8:	d201      	bcs.n	800defe <_txe_byte_allocate+0xba>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 800defa:	2313      	movs	r3, #19
 800defc:	627b      	str	r3, [r7, #36]	; 0x24
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800defe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800df00:	2b00      	cmp	r3, #0
 800df02:	d106      	bne.n	800df12 <_txe_byte_allocate+0xce>
    {

        /* Call actual byte memory allocate function.  */
        status =  _tx_byte_allocate(pool_ptr, memory_ptr, memory_size,  wait_option);
 800df04:	683b      	ldr	r3, [r7, #0]
 800df06:	687a      	ldr	r2, [r7, #4]
 800df08:	68b9      	ldr	r1, [r7, #8]
 800df0a:	68f8      	ldr	r0, [r7, #12]
 800df0c:	f7f9 fcfa 	bl	8007904 <_tx_byte_allocate>
 800df10:	6278      	str	r0, [r7, #36]	; 0x24
    }

    /* Return completion status.  */
    return(status);
 800df12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 800df14:	4618      	mov	r0, r3
 800df16:	3728      	adds	r7, #40	; 0x28
 800df18:	46bd      	mov	sp, r7
 800df1a:	bd80      	pop	{r7, pc}
 800df1c:	42595445 	.word	0x42595445
 800df20:	2000000c 	.word	0x2000000c
 800df24:	2000efb8 	.word	0x2000efb8
 800df28:	2000f108 	.word	0x2000f108

0800df2c <_txe_byte_pool_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_byte_pool_create(TX_BYTE_POOL *pool_ptr, CHAR *name_ptr, VOID *pool_start, ULONG pool_size, UINT pool_control_block_size)
{
 800df2c:	b580      	push	{r7, lr}
 800df2e:	b092      	sub	sp, #72	; 0x48
 800df30:	af00      	add	r7, sp, #0
 800df32:	60f8      	str	r0, [r7, #12]
 800df34:	60b9      	str	r1, [r7, #8]
 800df36:	607a      	str	r2, [r7, #4]
 800df38:	603b      	str	r3, [r7, #0]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800df3a:	2300      	movs	r3, #0
 800df3c:	647b      	str	r3, [r7, #68]	; 0x44

    /* Check for an invalid byte pool pointer.  */
    if (pool_ptr == TX_NULL)
 800df3e:	68fb      	ldr	r3, [r7, #12]
 800df40:	2b00      	cmp	r3, #0
 800df42:	d102      	bne.n	800df4a <_txe_byte_pool_create+0x1e>
    {

        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800df44:	2302      	movs	r3, #2
 800df46:	647b      	str	r3, [r7, #68]	; 0x44
 800df48:	e075      	b.n	800e036 <_txe_byte_pool_create+0x10a>
    }

    /* Now see if the pool control block size is valid.  */
    else if (pool_control_block_size != (sizeof(TX_BYTE_POOL)))
 800df4a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800df4c:	2b34      	cmp	r3, #52	; 0x34
 800df4e:	d002      	beq.n	800df56 <_txe_byte_pool_create+0x2a>
    {

        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800df50:	2302      	movs	r3, #2
 800df52:	647b      	str	r3, [r7, #68]	; 0x44
 800df54:	e06f      	b.n	800e036 <_txe_byte_pool_create+0x10a>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800df56:	f3ef 8310 	mrs	r3, PRIMASK
 800df5a:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800df5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800df5e:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800df60:	b672      	cpsid	i
    return(int_posture);
 800df62:	6abb      	ldr	r3, [r7, #40]	; 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
 800df64:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
 800df66:	4b3b      	ldr	r3, [pc, #236]	; (800e054 <_txe_byte_pool_create+0x128>)
 800df68:	681b      	ldr	r3, [r3, #0]
 800df6a:	3301      	adds	r3, #1
 800df6c:	4a39      	ldr	r2, [pc, #228]	; (800e054 <_txe_byte_pool_create+0x128>)
 800df6e:	6013      	str	r3, [r2, #0]
 800df70:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800df72:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800df74:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800df76:	f383 8810 	msr	PRIMASK, r3
}
 800df7a:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_pool =   _tx_byte_pool_created_ptr;
 800df7c:	4b36      	ldr	r3, [pc, #216]	; (800e058 <_txe_byte_pool_create+0x12c>)
 800df7e:	681b      	ldr	r3, [r3, #0]
 800df80:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_byte_pool_created_count; i++)
 800df82:	2300      	movs	r3, #0
 800df84:	643b      	str	r3, [r7, #64]	; 0x40
 800df86:	e009      	b.n	800df9c <_txe_byte_pool_create+0x70>
        {

            /* Determine if this byte pool matches the pool in the list.  */
            if (pool_ptr == next_pool)
 800df88:	68fa      	ldr	r2, [r7, #12]
 800df8a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800df8c:	429a      	cmp	r2, r3
 800df8e:	d00b      	beq.n	800dfa8 <_txe_byte_pool_create+0x7c>
            }
            else
            {

                /* Move to the next pool.  */
                next_pool =  next_pool -> tx_byte_pool_created_next;
 800df90:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800df92:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800df94:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_byte_pool_created_count; i++)
 800df96:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800df98:	3301      	adds	r3, #1
 800df9a:	643b      	str	r3, [r7, #64]	; 0x40
 800df9c:	4b2f      	ldr	r3, [pc, #188]	; (800e05c <_txe_byte_pool_create+0x130>)
 800df9e:	681b      	ldr	r3, [r3, #0]
 800dfa0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800dfa2:	429a      	cmp	r2, r3
 800dfa4:	d3f0      	bcc.n	800df88 <_txe_byte_pool_create+0x5c>
 800dfa6:	e000      	b.n	800dfaa <_txe_byte_pool_create+0x7e>
                break;
 800dfa8:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800dfaa:	f3ef 8310 	mrs	r3, PRIMASK
 800dfae:	623b      	str	r3, [r7, #32]
    return(posture);
 800dfb0:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 800dfb2:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 800dfb4:	b672      	cpsid	i
    return(int_posture);
 800dfb6:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
 800dfb8:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
 800dfba:	4b26      	ldr	r3, [pc, #152]	; (800e054 <_txe_byte_pool_create+0x128>)
 800dfbc:	681b      	ldr	r3, [r3, #0]
 800dfbe:	3b01      	subs	r3, #1
 800dfc0:	4a24      	ldr	r2, [pc, #144]	; (800e054 <_txe_byte_pool_create+0x128>)
 800dfc2:	6013      	str	r3, [r2, #0]
 800dfc4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800dfc6:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800dfc8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dfca:	f383 8810 	msr	PRIMASK, r3
}
 800dfce:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 800dfd0:	f7fe f9f2 	bl	800c3b8 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate pool.  */
        if (pool_ptr == next_pool)
 800dfd4:	68fa      	ldr	r2, [r7, #12]
 800dfd6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800dfd8:	429a      	cmp	r2, r3
 800dfda:	d102      	bne.n	800dfe2 <_txe_byte_pool_create+0xb6>
        {

            /* Pool is already created, return appropriate error code.  */
            status =  TX_POOL_ERROR;
 800dfdc:	2302      	movs	r3, #2
 800dfde:	647b      	str	r3, [r7, #68]	; 0x44
 800dfe0:	e029      	b.n	800e036 <_txe_byte_pool_create+0x10a>
        }

        /* Check for an invalid starting address.  */
        else if (pool_start == TX_NULL)
 800dfe2:	687b      	ldr	r3, [r7, #4]
 800dfe4:	2b00      	cmp	r3, #0
 800dfe6:	d102      	bne.n	800dfee <_txe_byte_pool_create+0xc2>
        {

            /* Null starting address pointer, return appropriate error.  */
            status =  TX_PTR_ERROR;
 800dfe8:	2303      	movs	r3, #3
 800dfea:	647b      	str	r3, [r7, #68]	; 0x44
 800dfec:	e023      	b.n	800e036 <_txe_byte_pool_create+0x10a>
        }

        /* Check for invalid pool size.  */
        else if (pool_size < TX_BYTE_POOL_MIN)
 800dfee:	683b      	ldr	r3, [r7, #0]
 800dff0:	2b63      	cmp	r3, #99	; 0x63
 800dff2:	d802      	bhi.n	800dffa <_txe_byte_pool_create+0xce>
        {

            /* Pool not big enough, return appropriate error.  */
            status =  TX_SIZE_ERROR;
 800dff4:	2305      	movs	r3, #5
 800dff6:	647b      	str	r3, [r7, #68]	; 0x44
 800dff8:	e01d      	b.n	800e036 <_txe_byte_pool_create+0x10a>
        {

#ifndef TX_TIMER_PROCESS_IN_ISR

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 800dffa:	4b19      	ldr	r3, [pc, #100]	; (800e060 <_txe_byte_pool_create+0x134>)
 800dffc:	681b      	ldr	r3, [r3, #0]
 800dffe:	637b      	str	r3, [r7, #52]	; 0x34

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (thread_ptr == &_tx_timer_thread)
 800e000:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e002:	4a18      	ldr	r2, [pc, #96]	; (800e064 <_txe_byte_pool_create+0x138>)
 800e004:	4293      	cmp	r3, r2
 800e006:	d101      	bne.n	800e00c <_txe_byte_pool_create+0xe0>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 800e008:	2313      	movs	r3, #19
 800e00a:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e00c:	f3ef 8305 	mrs	r3, IPSR
 800e010:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 800e012:	69ba      	ldr	r2, [r7, #24]
            }
#endif

            /* Check for interrupt call.  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800e014:	4b14      	ldr	r3, [pc, #80]	; (800e068 <_txe_byte_pool_create+0x13c>)
 800e016:	681b      	ldr	r3, [r3, #0]
 800e018:	4313      	orrs	r3, r2
 800e01a:	2b00      	cmp	r3, #0
 800e01c:	d00b      	beq.n	800e036 <_txe_byte_pool_create+0x10a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e01e:	f3ef 8305 	mrs	r3, IPSR
 800e022:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800e024:	697a      	ldr	r2, [r7, #20]
            {

                /* Now, make sure the call is from an interrupt and not initialization.  */
                if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800e026:	4b10      	ldr	r3, [pc, #64]	; (800e068 <_txe_byte_pool_create+0x13c>)
 800e028:	681b      	ldr	r3, [r3, #0]
 800e02a:	4313      	orrs	r3, r2
 800e02c:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800e030:	d201      	bcs.n	800e036 <_txe_byte_pool_create+0x10a>
                {

                    /* Invalid caller of this function, return appropriate error code.  */
                    status =  TX_CALLER_ERROR;
 800e032:	2313      	movs	r3, #19
 800e034:	647b      	str	r3, [r7, #68]	; 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800e036:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e038:	2b00      	cmp	r3, #0
 800e03a:	d106      	bne.n	800e04a <_txe_byte_pool_create+0x11e>
    {

        /* Call actual byte pool create function.  */
        status =  _tx_byte_pool_create(pool_ptr, name_ptr, pool_start, pool_size);
 800e03c:	683b      	ldr	r3, [r7, #0]
 800e03e:	687a      	ldr	r2, [r7, #4]
 800e040:	68b9      	ldr	r1, [r7, #8]
 800e042:	68f8      	ldr	r0, [r7, #12]
 800e044:	f7f9 fda0 	bl	8007b88 <_tx_byte_pool_create>
 800e048:	6478      	str	r0, [r7, #68]	; 0x44
    }

    /* Return completion status.  */
    return(status);
 800e04a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 800e04c:	4618      	mov	r0, r3
 800e04e:	3748      	adds	r7, #72	; 0x48
 800e050:	46bd      	mov	sp, r7
 800e052:	bd80      	pop	{r7, pc}
 800e054:	2000f054 	.word	0x2000f054
 800e058:	2000efa8 	.word	0x2000efa8
 800e05c:	2000efac 	.word	0x2000efac
 800e060:	2000efb8 	.word	0x2000efb8
 800e064:	2000f108 	.word	0x2000f108
 800e068:	2000000c 	.word	0x2000000c

0800e06c <_txe_byte_pool_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_byte_pool_delete(TX_BYTE_POOL *pool_ptr)
{
 800e06c:	b580      	push	{r7, lr}
 800e06e:	b086      	sub	sp, #24
 800e070:	af00      	add	r7, sp, #0
 800e072:	6078      	str	r0, [r7, #4]


#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Default status to success.  */
    status =  TX_SUCCESS;
 800e074:	2300      	movs	r3, #0
 800e076:	617b      	str	r3, [r7, #20]
#endif

    /* Check for an invalid byte pool pointer.  */
    if (pool_ptr == TX_NULL)
 800e078:	687b      	ldr	r3, [r7, #4]
 800e07a:	2b00      	cmp	r3, #0
 800e07c:	d102      	bne.n	800e084 <_txe_byte_pool_delete+0x18>
    {

        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800e07e:	2302      	movs	r3, #2
 800e080:	617b      	str	r3, [r7, #20]
 800e082:	e023      	b.n	800e0cc <_txe_byte_pool_delete+0x60>
    }

    /* Now check the pool ID.  */
    else if (pool_ptr -> tx_byte_pool_id != TX_BYTE_POOL_ID)
 800e084:	687b      	ldr	r3, [r7, #4]
 800e086:	681b      	ldr	r3, [r3, #0]
 800e088:	4a13      	ldr	r2, [pc, #76]	; (800e0d8 <_txe_byte_pool_delete+0x6c>)
 800e08a:	4293      	cmp	r3, r2
 800e08c:	d002      	beq.n	800e094 <_txe_byte_pool_delete+0x28>
    {

        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800e08e:	2302      	movs	r3, #2
 800e090:	617b      	str	r3, [r7, #20]
 800e092:	e01b      	b.n	800e0cc <_txe_byte_pool_delete+0x60>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e094:	f3ef 8305 	mrs	r3, IPSR
 800e098:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 800e09a:	68fa      	ldr	r2, [r7, #12]
    }

    /* Check for interrupt or initialization.  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800e09c:	4b0f      	ldr	r3, [pc, #60]	; (800e0dc <_txe_byte_pool_delete+0x70>)
 800e09e:	681b      	ldr	r3, [r3, #0]
 800e0a0:	4313      	orrs	r3, r2
 800e0a2:	2b00      	cmp	r3, #0
 800e0a4:	d002      	beq.n	800e0ac <_txe_byte_pool_delete+0x40>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
 800e0a6:	2313      	movs	r3, #19
 800e0a8:	617b      	str	r3, [r7, #20]
 800e0aa:	e00f      	b.n	800e0cc <_txe_byte_pool_delete+0x60>
    {

#ifndef TX_TIMER_PROCESS_IN_ISR

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 800e0ac:	4b0c      	ldr	r3, [pc, #48]	; (800e0e0 <_txe_byte_pool_delete+0x74>)
 800e0ae:	681b      	ldr	r3, [r3, #0]
 800e0b0:	613b      	str	r3, [r7, #16]

        /* Check for invalid caller of this function.  First check for a calling thread.  */
        if (thread_ptr == &_tx_timer_thread)
 800e0b2:	693b      	ldr	r3, [r7, #16]
 800e0b4:	4a0b      	ldr	r2, [pc, #44]	; (800e0e4 <_txe_byte_pool_delete+0x78>)
 800e0b6:	4293      	cmp	r3, r2
 800e0b8:	d101      	bne.n	800e0be <_txe_byte_pool_delete+0x52>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 800e0ba:	2313      	movs	r3, #19
 800e0bc:	617b      	str	r3, [r7, #20]
        }

        /* Determine if everything is okay.  */
        if (status == TX_SUCCESS)
 800e0be:	697b      	ldr	r3, [r7, #20]
 800e0c0:	2b00      	cmp	r3, #0
 800e0c2:	d103      	bne.n	800e0cc <_txe_byte_pool_delete+0x60>
        {
#endif

            /* Call actual byte pool delete function.  */
            status =  _tx_byte_pool_delete(pool_ptr);
 800e0c4:	6878      	ldr	r0, [r7, #4]
 800e0c6:	f7f9 fdf5 	bl	8007cb4 <_tx_byte_pool_delete>
 800e0ca:	6178      	str	r0, [r7, #20]
        }
#endif
    }

    /* Return completion status.  */
    return(status);
 800e0cc:	697b      	ldr	r3, [r7, #20]
}
 800e0ce:	4618      	mov	r0, r3
 800e0d0:	3718      	adds	r7, #24
 800e0d2:	46bd      	mov	sp, r7
 800e0d4:	bd80      	pop	{r7, pc}
 800e0d6:	bf00      	nop
 800e0d8:	42595445 	.word	0x42595445
 800e0dc:	2000000c 	.word	0x2000000c
 800e0e0:	2000efb8 	.word	0x2000efb8
 800e0e4:	2000f108 	.word	0x2000f108

0800e0e8 <_txe_byte_pool_info_get>:
/*                                                                        */
/**************************************************************************/
UINT  _txe_byte_pool_info_get(TX_BYTE_POOL *pool_ptr, CHAR **name, ULONG *available_bytes,
                    ULONG *fragments, TX_THREAD **first_suspended,
                    ULONG *suspended_count, TX_BYTE_POOL **next_pool)
{
 800e0e8:	b580      	push	{r7, lr}
 800e0ea:	b08a      	sub	sp, #40	; 0x28
 800e0ec:	af04      	add	r7, sp, #16
 800e0ee:	60f8      	str	r0, [r7, #12]
 800e0f0:	60b9      	str	r1, [r7, #8]
 800e0f2:	607a      	str	r2, [r7, #4]
 800e0f4:	603b      	str	r3, [r7, #0]

UINT    status;


    /* Check for an invalid byte pool pointer.  */
    if (pool_ptr == TX_NULL)
 800e0f6:	68fb      	ldr	r3, [r7, #12]
 800e0f8:	2b00      	cmp	r3, #0
 800e0fa:	d102      	bne.n	800e102 <_txe_byte_pool_info_get+0x1a>
    {

        /* Block pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800e0fc:	2302      	movs	r3, #2
 800e0fe:	617b      	str	r3, [r7, #20]
 800e100:	e014      	b.n	800e12c <_txe_byte_pool_info_get+0x44>
    }

    /* Now check for invalid pool ID.  */
    else if (pool_ptr -> tx_byte_pool_id != TX_BYTE_POOL_ID)
 800e102:	68fb      	ldr	r3, [r7, #12]
 800e104:	681b      	ldr	r3, [r3, #0]
 800e106:	4a0c      	ldr	r2, [pc, #48]	; (800e138 <_txe_byte_pool_info_get+0x50>)
 800e108:	4293      	cmp	r3, r2
 800e10a:	d002      	beq.n	800e112 <_txe_byte_pool_info_get+0x2a>
    {

        /* Block pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800e10c:	2302      	movs	r3, #2
 800e10e:	617b      	str	r3, [r7, #20]
 800e110:	e00c      	b.n	800e12c <_txe_byte_pool_info_get+0x44>
    }
    else
    {

        /* Otherwise, call the actual byte pool information get service.  */
        status =  _tx_byte_pool_info_get(pool_ptr, name, available_bytes,
 800e112:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e114:	9302      	str	r3, [sp, #8]
 800e116:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e118:	9301      	str	r3, [sp, #4]
 800e11a:	6a3b      	ldr	r3, [r7, #32]
 800e11c:	9300      	str	r3, [sp, #0]
 800e11e:	683b      	ldr	r3, [r7, #0]
 800e120:	687a      	ldr	r2, [r7, #4]
 800e122:	68b9      	ldr	r1, [r7, #8]
 800e124:	68f8      	ldr	r0, [r7, #12]
 800e126:	f7f9 fe55 	bl	8007dd4 <_tx_byte_pool_info_get>
 800e12a:	6178      	str	r0, [r7, #20]
                            fragments, first_suspended, suspended_count, next_pool);
    }

    /* Return completion status.  */
    return(status);
 800e12c:	697b      	ldr	r3, [r7, #20]
}
 800e12e:	4618      	mov	r0, r3
 800e130:	3718      	adds	r7, #24
 800e132:	46bd      	mov	sp, r7
 800e134:	bd80      	pop	{r7, pc}
 800e136:	bf00      	nop
 800e138:	42595445 	.word	0x42595445

0800e13c <_txe_byte_pool_prioritize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_byte_pool_prioritize(TX_BYTE_POOL *pool_ptr)
{
 800e13c:	b580      	push	{r7, lr}
 800e13e:	b084      	sub	sp, #16
 800e140:	af00      	add	r7, sp, #0
 800e142:	6078      	str	r0, [r7, #4]

UINT        status;


    /* Check for an invalid byte memory pool pointer.  */
    if (pool_ptr == TX_NULL)
 800e144:	687b      	ldr	r3, [r7, #4]
 800e146:	2b00      	cmp	r3, #0
 800e148:	d102      	bne.n	800e150 <_txe_byte_pool_prioritize+0x14>
    {

        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800e14a:	2302      	movs	r3, #2
 800e14c:	60fb      	str	r3, [r7, #12]
 800e14e:	e00b      	b.n	800e168 <_txe_byte_pool_prioritize+0x2c>
    }

    /* Now check for invalid pool ID.  */
    else if (pool_ptr -> tx_byte_pool_id != TX_BYTE_POOL_ID)
 800e150:	687b      	ldr	r3, [r7, #4]
 800e152:	681b      	ldr	r3, [r3, #0]
 800e154:	4a07      	ldr	r2, [pc, #28]	; (800e174 <_txe_byte_pool_prioritize+0x38>)
 800e156:	4293      	cmp	r3, r2
 800e158:	d002      	beq.n	800e160 <_txe_byte_pool_prioritize+0x24>
    {

        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 800e15a:	2302      	movs	r3, #2
 800e15c:	60fb      	str	r3, [r7, #12]
 800e15e:	e003      	b.n	800e168 <_txe_byte_pool_prioritize+0x2c>
    }
    else
    {

        /* Call actual byte pool prioritize function.  */
        status =  _tx_byte_pool_prioritize(pool_ptr);
 800e160:	6878      	ldr	r0, [r7, #4]
 800e162:	f7f9 fef7 	bl	8007f54 <_tx_byte_pool_prioritize>
 800e166:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800e168:	68fb      	ldr	r3, [r7, #12]
}
 800e16a:	4618      	mov	r0, r3
 800e16c:	3710      	adds	r7, #16
 800e16e:	46bd      	mov	sp, r7
 800e170:	bd80      	pop	{r7, pc}
 800e172:	bf00      	nop
 800e174:	42595445 	.word	0x42595445

0800e178 <_txe_byte_release>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_byte_release(VOID *memory_ptr)
{
 800e178:	b580      	push	{r7, lr}
 800e17a:	b086      	sub	sp, #24
 800e17c:	af00      	add	r7, sp, #0
 800e17e:	6078      	str	r0, [r7, #4]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800e180:	2300      	movs	r3, #0
 800e182:	617b      	str	r3, [r7, #20]

    /* First check the supplied memory pointer.  */
    if (memory_ptr == TX_NULL)
 800e184:	687b      	ldr	r3, [r7, #4]
 800e186:	2b00      	cmp	r3, #0
 800e188:	d102      	bne.n	800e190 <_txe_byte_release+0x18>
    {

        /* The byte memory pointer is invalid, return appropriate status.  */
        status =  TX_PTR_ERROR;
 800e18a:	2303      	movs	r3, #3
 800e18c:	617b      	str	r3, [r7, #20]
 800e18e:	e01d      	b.n	800e1cc <_txe_byte_release+0x54>
    {

#ifndef TX_TIMER_PROCESS_IN_ISR

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 800e190:	4b14      	ldr	r3, [pc, #80]	; (800e1e4 <_txe_byte_release+0x6c>)
 800e192:	681b      	ldr	r3, [r3, #0]
 800e194:	613b      	str	r3, [r7, #16]

        /* Check for invalid caller of this function.  First check for a calling thread.  */
        if (thread_ptr == &_tx_timer_thread)
 800e196:	693b      	ldr	r3, [r7, #16]
 800e198:	4a13      	ldr	r2, [pc, #76]	; (800e1e8 <_txe_byte_release+0x70>)
 800e19a:	4293      	cmp	r3, r2
 800e19c:	d101      	bne.n	800e1a2 <_txe_byte_release+0x2a>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 800e19e:	2313      	movs	r3, #19
 800e1a0:	617b      	str	r3, [r7, #20]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e1a2:	f3ef 8305 	mrs	r3, IPSR
 800e1a6:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 800e1a8:	68fa      	ldr	r2, [r7, #12]
        }
#endif

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800e1aa:	4b10      	ldr	r3, [pc, #64]	; (800e1ec <_txe_byte_release+0x74>)
 800e1ac:	681b      	ldr	r3, [r3, #0]
 800e1ae:	4313      	orrs	r3, r2
 800e1b0:	2b00      	cmp	r3, #0
 800e1b2:	d00b      	beq.n	800e1cc <_txe_byte_release+0x54>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e1b4:	f3ef 8305 	mrs	r3, IPSR
 800e1b8:	60bb      	str	r3, [r7, #8]
    return(ipsr_value);
 800e1ba:	68ba      	ldr	r2, [r7, #8]
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800e1bc:	4b0b      	ldr	r3, [pc, #44]	; (800e1ec <_txe_byte_release+0x74>)
 800e1be:	681b      	ldr	r3, [r3, #0]
 800e1c0:	4313      	orrs	r3, r2
 800e1c2:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800e1c6:	d201      	bcs.n	800e1cc <_txe_byte_release+0x54>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 800e1c8:	2313      	movs	r3, #19
 800e1ca:	617b      	str	r3, [r7, #20]
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800e1cc:	697b      	ldr	r3, [r7, #20]
 800e1ce:	2b00      	cmp	r3, #0
 800e1d0:	d103      	bne.n	800e1da <_txe_byte_release+0x62>
    {

        /* Call actual byte release function.  */
        status =  _tx_byte_release(memory_ptr);
 800e1d2:	6878      	ldr	r0, [r7, #4]
 800e1d4:	f7fa f87e 	bl	80082d4 <_tx_byte_release>
 800e1d8:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 800e1da:	697b      	ldr	r3, [r7, #20]
}
 800e1dc:	4618      	mov	r0, r3
 800e1de:	3718      	adds	r7, #24
 800e1e0:	46bd      	mov	sp, r7
 800e1e2:	bd80      	pop	{r7, pc}
 800e1e4:	2000efb8 	.word	0x2000efb8
 800e1e8:	2000f108 	.word	0x2000f108
 800e1ec:	2000000c 	.word	0x2000000c

0800e1f0 <_txe_event_flags_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_event_flags_create(TX_EVENT_FLAGS_GROUP *group_ptr, CHAR *name_ptr, UINT event_control_block_size)
{
 800e1f0:	b580      	push	{r7, lr}
 800e1f2:	b092      	sub	sp, #72	; 0x48
 800e1f4:	af00      	add	r7, sp, #0
 800e1f6:	60f8      	str	r0, [r7, #12]
 800e1f8:	60b9      	str	r1, [r7, #8]
 800e1fa:	607a      	str	r2, [r7, #4]
TX_THREAD                   *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800e1fc:	2300      	movs	r3, #0
 800e1fe:	647b      	str	r3, [r7, #68]	; 0x44

    /* Check for an invalid event flags group pointer.  */
    if (group_ptr == TX_NULL)
 800e200:	68fb      	ldr	r3, [r7, #12]
 800e202:	2b00      	cmp	r3, #0
 800e204:	d102      	bne.n	800e20c <_txe_event_flags_create+0x1c>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
 800e206:	2306      	movs	r3, #6
 800e208:	647b      	str	r3, [r7, #68]	; 0x44
 800e20a:	e069      	b.n	800e2e0 <_txe_event_flags_create+0xf0>
    }

    /* Now check for proper control block size.  */
    else if (event_control_block_size != (sizeof(TX_EVENT_FLAGS_GROUP)))
 800e20c:	687b      	ldr	r3, [r7, #4]
 800e20e:	2b30      	cmp	r3, #48	; 0x30
 800e210:	d002      	beq.n	800e218 <_txe_event_flags_create+0x28>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
 800e212:	2306      	movs	r3, #6
 800e214:	647b      	str	r3, [r7, #68]	; 0x44
 800e216:	e063      	b.n	800e2e0 <_txe_event_flags_create+0xf0>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e218:	f3ef 8310 	mrs	r3, PRIMASK
 800e21c:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800e21e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800e220:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800e222:	b672      	cpsid	i
    return(int_posture);
 800e224:	6abb      	ldr	r3, [r7, #40]	; 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
 800e226:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
 800e228:	4b34      	ldr	r3, [pc, #208]	; (800e2fc <_txe_event_flags_create+0x10c>)
 800e22a:	681b      	ldr	r3, [r3, #0]
 800e22c:	3301      	adds	r3, #1
 800e22e:	4a33      	ldr	r2, [pc, #204]	; (800e2fc <_txe_event_flags_create+0x10c>)
 800e230:	6013      	str	r3, [r2, #0]
 800e232:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e234:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e236:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e238:	f383 8810 	msr	PRIMASK, r3
}
 800e23c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_group =   _tx_event_flags_created_ptr;
 800e23e:	4b30      	ldr	r3, [pc, #192]	; (800e300 <_txe_event_flags_create+0x110>)
 800e240:	681b      	ldr	r3, [r3, #0]
 800e242:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_event_flags_created_count; i++)
 800e244:	2300      	movs	r3, #0
 800e246:	643b      	str	r3, [r7, #64]	; 0x40
 800e248:	e009      	b.n	800e25e <_txe_event_flags_create+0x6e>
        {

            /* Determine if this group matches the event flags group in the list.  */
            if (group_ptr == next_group)
 800e24a:	68fa      	ldr	r2, [r7, #12]
 800e24c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e24e:	429a      	cmp	r2, r3
 800e250:	d00b      	beq.n	800e26a <_txe_event_flags_create+0x7a>
            }
            else
            {

                /* Move to the next group.  */
                next_group =  next_group -> tx_event_flags_group_created_next;
 800e252:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e254:	699b      	ldr	r3, [r3, #24]
 800e256:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_event_flags_created_count; i++)
 800e258:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800e25a:	3301      	adds	r3, #1
 800e25c:	643b      	str	r3, [r7, #64]	; 0x40
 800e25e:	4b29      	ldr	r3, [pc, #164]	; (800e304 <_txe_event_flags_create+0x114>)
 800e260:	681b      	ldr	r3, [r3, #0]
 800e262:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800e264:	429a      	cmp	r2, r3
 800e266:	d3f0      	bcc.n	800e24a <_txe_event_flags_create+0x5a>
 800e268:	e000      	b.n	800e26c <_txe_event_flags_create+0x7c>
                break;
 800e26a:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e26c:	f3ef 8310 	mrs	r3, PRIMASK
 800e270:	623b      	str	r3, [r7, #32]
    return(posture);
 800e272:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 800e274:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 800e276:	b672      	cpsid	i
    return(int_posture);
 800e278:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
 800e27a:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
 800e27c:	4b1f      	ldr	r3, [pc, #124]	; (800e2fc <_txe_event_flags_create+0x10c>)
 800e27e:	681b      	ldr	r3, [r3, #0]
 800e280:	3b01      	subs	r3, #1
 800e282:	4a1e      	ldr	r2, [pc, #120]	; (800e2fc <_txe_event_flags_create+0x10c>)
 800e284:	6013      	str	r3, [r2, #0]
 800e286:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e288:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e28a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e28c:	f383 8810 	msr	PRIMASK, r3
}
 800e290:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 800e292:	f7fe f891 	bl	800c3b8 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate event flag group.  */
        if (group_ptr == next_group)
 800e296:	68fa      	ldr	r2, [r7, #12]
 800e298:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e29a:	429a      	cmp	r2, r3
 800e29c:	d102      	bne.n	800e2a4 <_txe_event_flags_create+0xb4>
        {

            /* Group is already created, return appropriate error code.  */
            status =  TX_GROUP_ERROR;
 800e29e:	2306      	movs	r3, #6
 800e2a0:	647b      	str	r3, [r7, #68]	; 0x44
 800e2a2:	e01d      	b.n	800e2e0 <_txe_event_flags_create+0xf0>
        {

#ifndef TX_TIMER_PROCESS_IN_ISR

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 800e2a4:	4b18      	ldr	r3, [pc, #96]	; (800e308 <_txe_event_flags_create+0x118>)
 800e2a6:	681b      	ldr	r3, [r3, #0]
 800e2a8:	637b      	str	r3, [r7, #52]	; 0x34

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (thread_ptr == &_tx_timer_thread)
 800e2aa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e2ac:	4a17      	ldr	r2, [pc, #92]	; (800e30c <_txe_event_flags_create+0x11c>)
 800e2ae:	4293      	cmp	r3, r2
 800e2b0:	d101      	bne.n	800e2b6 <_txe_event_flags_create+0xc6>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 800e2b2:	2313      	movs	r3, #19
 800e2b4:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e2b6:	f3ef 8305 	mrs	r3, IPSR
 800e2ba:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 800e2bc:	69ba      	ldr	r2, [r7, #24]
            }
#endif

            /* Check for interrupt call.  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800e2be:	4b14      	ldr	r3, [pc, #80]	; (800e310 <_txe_event_flags_create+0x120>)
 800e2c0:	681b      	ldr	r3, [r3, #0]
 800e2c2:	4313      	orrs	r3, r2
 800e2c4:	2b00      	cmp	r3, #0
 800e2c6:	d00b      	beq.n	800e2e0 <_txe_event_flags_create+0xf0>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e2c8:	f3ef 8305 	mrs	r3, IPSR
 800e2cc:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800e2ce:	697a      	ldr	r2, [r7, #20]
            {

                /* Now, make sure the call is from an interrupt and not initialization.  */
                if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800e2d0:	4b0f      	ldr	r3, [pc, #60]	; (800e310 <_txe_event_flags_create+0x120>)
 800e2d2:	681b      	ldr	r3, [r3, #0]
 800e2d4:	4313      	orrs	r3, r2
 800e2d6:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800e2da:	d201      	bcs.n	800e2e0 <_txe_event_flags_create+0xf0>
                {

                    /* Invalid caller of this function, return appropriate error code.  */
                    status =  TX_CALLER_ERROR;
 800e2dc:	2313      	movs	r3, #19
 800e2de:	647b      	str	r3, [r7, #68]	; 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800e2e0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e2e2:	2b00      	cmp	r3, #0
 800e2e4:	d104      	bne.n	800e2f0 <_txe_event_flags_create+0x100>
    {

        /* Call actual event flags create function.  */
        status =  _tx_event_flags_create(group_ptr, name_ptr);
 800e2e6:	68b9      	ldr	r1, [r7, #8]
 800e2e8:	68f8      	ldr	r0, [r7, #12]
 800e2ea:	f7fa f99d 	bl	8008628 <_tx_event_flags_create>
 800e2ee:	6478      	str	r0, [r7, #68]	; 0x44
    }

    /* Return completion status.  */
    return(status);
 800e2f0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 800e2f2:	4618      	mov	r0, r3
 800e2f4:	3748      	adds	r7, #72	; 0x48
 800e2f6:	46bd      	mov	sp, r7
 800e2f8:	bd80      	pop	{r7, pc}
 800e2fa:	bf00      	nop
 800e2fc:	2000f054 	.word	0x2000f054
 800e300:	2000ef90 	.word	0x2000ef90
 800e304:	2000ef94 	.word	0x2000ef94
 800e308:	2000efb8 	.word	0x2000efb8
 800e30c:	2000f108 	.word	0x2000f108
 800e310:	2000000c 	.word	0x2000000c

0800e314 <_txe_event_flags_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_event_flags_delete(TX_EVENT_FLAGS_GROUP *group_ptr)
{
 800e314:	b580      	push	{r7, lr}
 800e316:	b086      	sub	sp, #24
 800e318:	af00      	add	r7, sp, #0
 800e31a:	6078      	str	r0, [r7, #4]


#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Default status to success.  */
    status =  TX_SUCCESS;
 800e31c:	2300      	movs	r3, #0
 800e31e:	617b      	str	r3, [r7, #20]
#endif

    /* Check for an invalid event flag group pointer.  */
    if (group_ptr == TX_NULL)
 800e320:	687b      	ldr	r3, [r7, #4]
 800e322:	2b00      	cmp	r3, #0
 800e324:	d102      	bne.n	800e32c <_txe_event_flags_delete+0x18>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
 800e326:	2306      	movs	r3, #6
 800e328:	617b      	str	r3, [r7, #20]
 800e32a:	e023      	b.n	800e374 <_txe_event_flags_delete+0x60>
    }

    /* Now check for invalid event flag group ID.  */
    else if (group_ptr -> tx_event_flags_group_id != TX_EVENT_FLAGS_ID)
 800e32c:	687b      	ldr	r3, [r7, #4]
 800e32e:	681b      	ldr	r3, [r3, #0]
 800e330:	4a13      	ldr	r2, [pc, #76]	; (800e380 <_txe_event_flags_delete+0x6c>)
 800e332:	4293      	cmp	r3, r2
 800e334:	d002      	beq.n	800e33c <_txe_event_flags_delete+0x28>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
 800e336:	2306      	movs	r3, #6
 800e338:	617b      	str	r3, [r7, #20]
 800e33a:	e01b      	b.n	800e374 <_txe_event_flags_delete+0x60>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e33c:	f3ef 8305 	mrs	r3, IPSR
 800e340:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 800e342:	68fa      	ldr	r2, [r7, #12]
    }

    /* Check for invalid caller of this function.  */

    /* Is the caller an ISR or Initialization?  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800e344:	4b0f      	ldr	r3, [pc, #60]	; (800e384 <_txe_event_flags_delete+0x70>)
 800e346:	681b      	ldr	r3, [r3, #0]
 800e348:	4313      	orrs	r3, r2
 800e34a:	2b00      	cmp	r3, #0
 800e34c:	d002      	beq.n	800e354 <_txe_event_flags_delete+0x40>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
 800e34e:	2313      	movs	r3, #19
 800e350:	617b      	str	r3, [r7, #20]
 800e352:	e00f      	b.n	800e374 <_txe_event_flags_delete+0x60>
    {

#ifndef TX_TIMER_PROCESS_IN_ISR

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 800e354:	4b0c      	ldr	r3, [pc, #48]	; (800e388 <_txe_event_flags_delete+0x74>)
 800e356:	681b      	ldr	r3, [r3, #0]
 800e358:	613b      	str	r3, [r7, #16]

        /* Is the caller the system timer thread?  */
        if (thread_ptr == &_tx_timer_thread)
 800e35a:	693b      	ldr	r3, [r7, #16]
 800e35c:	4a0b      	ldr	r2, [pc, #44]	; (800e38c <_txe_event_flags_delete+0x78>)
 800e35e:	4293      	cmp	r3, r2
 800e360:	d101      	bne.n	800e366 <_txe_event_flags_delete+0x52>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 800e362:	2313      	movs	r3, #19
 800e364:	617b      	str	r3, [r7, #20]
        }

        /* Determine if everything is okay.  */
        if (status == TX_SUCCESS)
 800e366:	697b      	ldr	r3, [r7, #20]
 800e368:	2b00      	cmp	r3, #0
 800e36a:	d103      	bne.n	800e374 <_txe_event_flags_delete+0x60>
        {
#endif

            /* Call actual event flag group delete function.  */
            status =  _tx_event_flags_delete(group_ptr);
 800e36c:	6878      	ldr	r0, [r7, #4]
 800e36e:	f7fa f9a9 	bl	80086c4 <_tx_event_flags_delete>
 800e372:	6178      	str	r0, [r7, #20]
        }
#endif
    }

    /* Return completion status.  */
    return(status);
 800e374:	697b      	ldr	r3, [r7, #20]
}
 800e376:	4618      	mov	r0, r3
 800e378:	3718      	adds	r7, #24
 800e37a:	46bd      	mov	sp, r7
 800e37c:	bd80      	pop	{r7, pc}
 800e37e:	bf00      	nop
 800e380:	4456444e 	.word	0x4456444e
 800e384:	2000000c 	.word	0x2000000c
 800e388:	2000efb8 	.word	0x2000efb8
 800e38c:	2000f108 	.word	0x2000f108

0800e390 <_txe_event_flags_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_event_flags_get(TX_EVENT_FLAGS_GROUP *group_ptr, ULONG requested_flags,
                    UINT get_option, ULONG *actual_flags_ptr, ULONG wait_option)
{
 800e390:	b580      	push	{r7, lr}
 800e392:	b08a      	sub	sp, #40	; 0x28
 800e394:	af02      	add	r7, sp, #8
 800e396:	60f8      	str	r0, [r7, #12]
 800e398:	60b9      	str	r1, [r7, #8]
 800e39a:	607a      	str	r2, [r7, #4]
 800e39c:	603b      	str	r3, [r7, #0]
TX_THREAD       *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800e39e:	2300      	movs	r3, #0
 800e3a0:	61fb      	str	r3, [r7, #28]

    /* Check for an invalid event flag group pointer.  */
    if (group_ptr == TX_NULL)
 800e3a2:	68fb      	ldr	r3, [r7, #12]
 800e3a4:	2b00      	cmp	r3, #0
 800e3a6:	d102      	bne.n	800e3ae <_txe_event_flags_get+0x1e>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
 800e3a8:	2306      	movs	r3, #6
 800e3aa:	61fb      	str	r3, [r7, #28]
 800e3ac:	e025      	b.n	800e3fa <_txe_event_flags_get+0x6a>
    }

    /* Now check for invalid event group ID.  */
    else if (group_ptr -> tx_event_flags_group_id != TX_EVENT_FLAGS_ID)
 800e3ae:	68fb      	ldr	r3, [r7, #12]
 800e3b0:	681b      	ldr	r3, [r3, #0]
 800e3b2:	4a1e      	ldr	r2, [pc, #120]	; (800e42c <_txe_event_flags_get+0x9c>)
 800e3b4:	4293      	cmp	r3, r2
 800e3b6:	d002      	beq.n	800e3be <_txe_event_flags_get+0x2e>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
 800e3b8:	2306      	movs	r3, #6
 800e3ba:	61fb      	str	r3, [r7, #28]
 800e3bc:	e01d      	b.n	800e3fa <_txe_event_flags_get+0x6a>
    }

    /* Check for an invalid destination for actual flags.  */
    else if (actual_flags_ptr == TX_NULL)
 800e3be:	683b      	ldr	r3, [r7, #0]
 800e3c0:	2b00      	cmp	r3, #0
 800e3c2:	d102      	bne.n	800e3ca <_txe_event_flags_get+0x3a>
    {

        /* Null destination pointer, return appropriate error.  */
        status =  TX_PTR_ERROR;
 800e3c4:	2303      	movs	r3, #3
 800e3c6:	61fb      	str	r3, [r7, #28]
 800e3c8:	e017      	b.n	800e3fa <_txe_event_flags_get+0x6a>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
 800e3ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e3cc:	2b00      	cmp	r3, #0
 800e3ce:	d014      	beq.n	800e3fa <_txe_event_flags_get+0x6a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e3d0:	f3ef 8305 	mrs	r3, IPSR
 800e3d4:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800e3d6:	697a      	ldr	r2, [r7, #20]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800e3d8:	4b15      	ldr	r3, [pc, #84]	; (800e430 <_txe_event_flags_get+0xa0>)
 800e3da:	681b      	ldr	r3, [r3, #0]
 800e3dc:	4313      	orrs	r3, r2
 800e3de:	2b00      	cmp	r3, #0
 800e3e0:	d002      	beq.n	800e3e8 <_txe_event_flags_get+0x58>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
 800e3e2:	2304      	movs	r3, #4
 800e3e4:	61fb      	str	r3, [r7, #28]
 800e3e6:	e008      	b.n	800e3fa <_txe_event_flags_get+0x6a>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
 800e3e8:	4b12      	ldr	r3, [pc, #72]	; (800e434 <_txe_event_flags_get+0xa4>)
 800e3ea:	681b      	ldr	r3, [r3, #0]
 800e3ec:	61bb      	str	r3, [r7, #24]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
 800e3ee:	69bb      	ldr	r3, [r7, #24]
 800e3f0:	4a11      	ldr	r2, [pc, #68]	; (800e438 <_txe_event_flags_get+0xa8>)
 800e3f2:	4293      	cmp	r3, r2
 800e3f4:	d101      	bne.n	800e3fa <_txe_event_flags_get+0x6a>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
 800e3f6:	2304      	movs	r3, #4
 800e3f8:	61fb      	str	r3, [r7, #28]
#endif
        }
    }

    /* Is everything still okay?  */
    if (status == TX_SUCCESS)
 800e3fa:	69fb      	ldr	r3, [r7, #28]
 800e3fc:	2b00      	cmp	r3, #0
 800e3fe:	d104      	bne.n	800e40a <_txe_event_flags_get+0x7a>
    {

        /* Check for invalid get option.  */
        if (get_option > TX_AND_CLEAR)
 800e400:	687b      	ldr	r3, [r7, #4]
 800e402:	2b03      	cmp	r3, #3
 800e404:	d901      	bls.n	800e40a <_txe_event_flags_get+0x7a>
        {

            /* Invalid get events option, return appropriate error.  */
            status =  TX_OPTION_ERROR;
 800e406:	2308      	movs	r3, #8
 800e408:	61fb      	str	r3, [r7, #28]
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800e40a:	69fb      	ldr	r3, [r7, #28]
 800e40c:	2b00      	cmp	r3, #0
 800e40e:	d108      	bne.n	800e422 <_txe_event_flags_get+0x92>
    {

        /* Call actual event flags get function.  */
        status =  _tx_event_flags_get(group_ptr, requested_flags, get_option, actual_flags_ptr, wait_option);
 800e410:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e412:	9300      	str	r3, [sp, #0]
 800e414:	683b      	ldr	r3, [r7, #0]
 800e416:	687a      	ldr	r2, [r7, #4]
 800e418:	68b9      	ldr	r1, [r7, #8]
 800e41a:	68f8      	ldr	r0, [r7, #12]
 800e41c:	f7fa f9e2 	bl	80087e4 <_tx_event_flags_get>
 800e420:	61f8      	str	r0, [r7, #28]
    }

    /* Return completion status.  */
    return(status);
 800e422:	69fb      	ldr	r3, [r7, #28]
}
 800e424:	4618      	mov	r0, r3
 800e426:	3720      	adds	r7, #32
 800e428:	46bd      	mov	sp, r7
 800e42a:	bd80      	pop	{r7, pc}
 800e42c:	4456444e 	.word	0x4456444e
 800e430:	2000000c 	.word	0x2000000c
 800e434:	2000efb8 	.word	0x2000efb8
 800e438:	2000f108 	.word	0x2000f108

0800e43c <_txe_event_flags_info_get>:
/*                                                                        */
/**************************************************************************/
UINT  _txe_event_flags_info_get(TX_EVENT_FLAGS_GROUP *group_ptr, CHAR **name, ULONG *current_flags,
                    TX_THREAD **first_suspended, ULONG *suspended_count,
                    TX_EVENT_FLAGS_GROUP **next_group)
{
 800e43c:	b580      	push	{r7, lr}
 800e43e:	b088      	sub	sp, #32
 800e440:	af02      	add	r7, sp, #8
 800e442:	60f8      	str	r0, [r7, #12]
 800e444:	60b9      	str	r1, [r7, #8]
 800e446:	607a      	str	r2, [r7, #4]
 800e448:	603b      	str	r3, [r7, #0]

UINT        status;


    /* Check for an invalid event flag group pointer.  */
    if (group_ptr == TX_NULL)
 800e44a:	68fb      	ldr	r3, [r7, #12]
 800e44c:	2b00      	cmp	r3, #0
 800e44e:	d102      	bne.n	800e456 <_txe_event_flags_info_get+0x1a>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
 800e450:	2306      	movs	r3, #6
 800e452:	617b      	str	r3, [r7, #20]
 800e454:	e012      	b.n	800e47c <_txe_event_flags_info_get+0x40>
    }

    /* Now check for invalid event flag group ID.  */
    else if (group_ptr -> tx_event_flags_group_id != TX_EVENT_FLAGS_ID)
 800e456:	68fb      	ldr	r3, [r7, #12]
 800e458:	681b      	ldr	r3, [r3, #0]
 800e45a:	4a0b      	ldr	r2, [pc, #44]	; (800e488 <_txe_event_flags_info_get+0x4c>)
 800e45c:	4293      	cmp	r3, r2
 800e45e:	d002      	beq.n	800e466 <_txe_event_flags_info_get+0x2a>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
 800e460:	2306      	movs	r3, #6
 800e462:	617b      	str	r3, [r7, #20]
 800e464:	e00a      	b.n	800e47c <_txe_event_flags_info_get+0x40>
    }
    else
    {

        /* Otherwise, call the actual event flags group information get service.  */
        status =  _tx_event_flags_info_get(group_ptr, name, current_flags, first_suspended,
 800e466:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e468:	9301      	str	r3, [sp, #4]
 800e46a:	6a3b      	ldr	r3, [r7, #32]
 800e46c:	9300      	str	r3, [sp, #0]
 800e46e:	683b      	ldr	r3, [r7, #0]
 800e470:	687a      	ldr	r2, [r7, #4]
 800e472:	68b9      	ldr	r1, [r7, #8]
 800e474:	68f8      	ldr	r0, [r7, #12]
 800e476:	f7fa fa9f 	bl	80089b8 <_tx_event_flags_info_get>
 800e47a:	6178      	str	r0, [r7, #20]
                                                            suspended_count, next_group);
    }

    /* Return completion status.  */
    return(status);
 800e47c:	697b      	ldr	r3, [r7, #20]
}
 800e47e:	4618      	mov	r0, r3
 800e480:	3718      	adds	r7, #24
 800e482:	46bd      	mov	sp, r7
 800e484:	bd80      	pop	{r7, pc}
 800e486:	bf00      	nop
 800e488:	4456444e 	.word	0x4456444e

0800e48c <_txe_event_flags_set>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_event_flags_set(TX_EVENT_FLAGS_GROUP *group_ptr, ULONG flags_to_set, UINT set_option)
{
 800e48c:	b580      	push	{r7, lr}
 800e48e:	b086      	sub	sp, #24
 800e490:	af00      	add	r7, sp, #0
 800e492:	60f8      	str	r0, [r7, #12]
 800e494:	60b9      	str	r1, [r7, #8]
 800e496:	607a      	str	r2, [r7, #4]

UINT        status;


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800e498:	2300      	movs	r3, #0
 800e49a:	617b      	str	r3, [r7, #20]

    /* Check for an invalid event flag group pointer.  */
    if (group_ptr == TX_NULL)
 800e49c:	68fb      	ldr	r3, [r7, #12]
 800e49e:	2b00      	cmp	r3, #0
 800e4a0:	d102      	bne.n	800e4a8 <_txe_event_flags_set+0x1c>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
 800e4a2:	2306      	movs	r3, #6
 800e4a4:	617b      	str	r3, [r7, #20]
 800e4a6:	e00f      	b.n	800e4c8 <_txe_event_flags_set+0x3c>
    }

    /* Now check for invalid event flag group ID.  */
    else if (group_ptr -> tx_event_flags_group_id != TX_EVENT_FLAGS_ID)
 800e4a8:	68fb      	ldr	r3, [r7, #12]
 800e4aa:	681b      	ldr	r3, [r3, #0]
 800e4ac:	4a0d      	ldr	r2, [pc, #52]	; (800e4e4 <_txe_event_flags_set+0x58>)
 800e4ae:	4293      	cmp	r3, r2
 800e4b0:	d002      	beq.n	800e4b8 <_txe_event_flags_set+0x2c>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
 800e4b2:	2306      	movs	r3, #6
 800e4b4:	617b      	str	r3, [r7, #20]
 800e4b6:	e007      	b.n	800e4c8 <_txe_event_flags_set+0x3c>
    }
    else
    {

        /* Check for invalid set option.  */
        if (set_option != TX_AND)
 800e4b8:	687b      	ldr	r3, [r7, #4]
 800e4ba:	2b02      	cmp	r3, #2
 800e4bc:	d004      	beq.n	800e4c8 <_txe_event_flags_set+0x3c>
        {

            if (set_option != TX_OR)
 800e4be:	687b      	ldr	r3, [r7, #4]
 800e4c0:	2b00      	cmp	r3, #0
 800e4c2:	d001      	beq.n	800e4c8 <_txe_event_flags_set+0x3c>
            {

                /* Invalid set events option, return appropriate error.  */
                status =  TX_OPTION_ERROR;
 800e4c4:	2308      	movs	r3, #8
 800e4c6:	617b      	str	r3, [r7, #20]
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800e4c8:	697b      	ldr	r3, [r7, #20]
 800e4ca:	2b00      	cmp	r3, #0
 800e4cc:	d105      	bne.n	800e4da <_txe_event_flags_set+0x4e>
    {

        /* Call actual event flags set function.  */
        status =  _tx_event_flags_set(group_ptr, flags_to_set, set_option);
 800e4ce:	687a      	ldr	r2, [r7, #4]
 800e4d0:	68b9      	ldr	r1, [r7, #8]
 800e4d2:	68f8      	ldr	r0, [r7, #12]
 800e4d4:	f7fa fb0a 	bl	8008aec <_tx_event_flags_set>
 800e4d8:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 800e4da:	697b      	ldr	r3, [r7, #20]
}
 800e4dc:	4618      	mov	r0, r3
 800e4de:	3718      	adds	r7, #24
 800e4e0:	46bd      	mov	sp, r7
 800e4e2:	bd80      	pop	{r7, pc}
 800e4e4:	4456444e 	.word	0x4456444e

0800e4e8 <_txe_event_flags_set_notify>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_event_flags_set_notify(TX_EVENT_FLAGS_GROUP *group_ptr, VOID (*events_set_notify)(TX_EVENT_FLAGS_GROUP *notify_group_ptr))
{
 800e4e8:	b580      	push	{r7, lr}
 800e4ea:	b084      	sub	sp, #16
 800e4ec:	af00      	add	r7, sp, #0
 800e4ee:	6078      	str	r0, [r7, #4]
 800e4f0:	6039      	str	r1, [r7, #0]

UINT    status;


    /* Check for an invalid group pointer.  */
    if (group_ptr == TX_NULL)
 800e4f2:	687b      	ldr	r3, [r7, #4]
 800e4f4:	2b00      	cmp	r3, #0
 800e4f6:	d102      	bne.n	800e4fe <_txe_event_flags_set_notify+0x16>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
 800e4f8:	2306      	movs	r3, #6
 800e4fa:	60fb      	str	r3, [r7, #12]
 800e4fc:	e00c      	b.n	800e518 <_txe_event_flags_set_notify+0x30>
    }

    /* Now check for invalid event group ID.  */
    else if (group_ptr -> tx_event_flags_group_id != TX_EVENT_FLAGS_ID)
 800e4fe:	687b      	ldr	r3, [r7, #4]
 800e500:	681b      	ldr	r3, [r3, #0]
 800e502:	4a08      	ldr	r2, [pc, #32]	; (800e524 <_txe_event_flags_set_notify+0x3c>)
 800e504:	4293      	cmp	r3, r2
 800e506:	d002      	beq.n	800e50e <_txe_event_flags_set_notify+0x26>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
 800e508:	2306      	movs	r3, #6
 800e50a:	60fb      	str	r3, [r7, #12]
 800e50c:	e004      	b.n	800e518 <_txe_event_flags_set_notify+0x30>
    }
    else
    {

        /* Call actual event flags set notify function.  */
        status =  _tx_event_flags_set_notify(group_ptr, events_set_notify);
 800e50e:	6839      	ldr	r1, [r7, #0]
 800e510:	6878      	ldr	r0, [r7, #4]
 800e512:	f7fa fd19 	bl	8008f48 <_tx_event_flags_set_notify>
 800e516:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800e518:	68fb      	ldr	r3, [r7, #12]
}
 800e51a:	4618      	mov	r0, r3
 800e51c:	3710      	adds	r7, #16
 800e51e:	46bd      	mov	sp, r7
 800e520:	bd80      	pop	{r7, pc}
 800e522:	bf00      	nop
 800e524:	4456444e 	.word	0x4456444e

0800e528 <_txe_mutex_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_mutex_create(TX_MUTEX *mutex_ptr, CHAR *name_ptr, UINT inherit, UINT mutex_control_block_size)
{
 800e528:	b580      	push	{r7, lr}
 800e52a:	b092      	sub	sp, #72	; 0x48
 800e52c:	af00      	add	r7, sp, #0
 800e52e:	60f8      	str	r0, [r7, #12]
 800e530:	60b9      	str	r1, [r7, #8]
 800e532:	607a      	str	r2, [r7, #4]
 800e534:	603b      	str	r3, [r7, #0]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800e536:	2300      	movs	r3, #0
 800e538:	647b      	str	r3, [r7, #68]	; 0x44

    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
 800e53a:	68fb      	ldr	r3, [r7, #12]
 800e53c:	2b00      	cmp	r3, #0
 800e53e:	d102      	bne.n	800e546 <_txe_mutex_create+0x1e>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 800e540:	231c      	movs	r3, #28
 800e542:	647b      	str	r3, [r7, #68]	; 0x44
 800e544:	e053      	b.n	800e5ee <_txe_mutex_create+0xc6>
    }

    /* Now check to make sure the control block is the correct size.  */
    else if (mutex_control_block_size != (sizeof(TX_MUTEX)))
 800e546:	683b      	ldr	r3, [r7, #0]
 800e548:	2b34      	cmp	r3, #52	; 0x34
 800e54a:	d002      	beq.n	800e552 <_txe_mutex_create+0x2a>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 800e54c:	231c      	movs	r3, #28
 800e54e:	647b      	str	r3, [r7, #68]	; 0x44
 800e550:	e04d      	b.n	800e5ee <_txe_mutex_create+0xc6>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e552:	f3ef 8310 	mrs	r3, PRIMASK
 800e556:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800e558:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800e55a:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800e55c:	b672      	cpsid	i
    return(int_posture);
 800e55e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
 800e560:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
 800e562:	4b3a      	ldr	r3, [pc, #232]	; (800e64c <_txe_mutex_create+0x124>)
 800e564:	681b      	ldr	r3, [r3, #0]
 800e566:	3301      	adds	r3, #1
 800e568:	4a38      	ldr	r2, [pc, #224]	; (800e64c <_txe_mutex_create+0x124>)
 800e56a:	6013      	str	r3, [r2, #0]
 800e56c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e56e:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e570:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e572:	f383 8810 	msr	PRIMASK, r3
}
 800e576:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_mutex =   _tx_mutex_created_ptr;
 800e578:	4b35      	ldr	r3, [pc, #212]	; (800e650 <_txe_mutex_create+0x128>)
 800e57a:	681b      	ldr	r3, [r3, #0]
 800e57c:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_mutex_created_count; i++)
 800e57e:	2300      	movs	r3, #0
 800e580:	643b      	str	r3, [r7, #64]	; 0x40
 800e582:	e009      	b.n	800e598 <_txe_mutex_create+0x70>
        {

            /* Determine if this mutex matches the mutex in the list.  */
            if (mutex_ptr == next_mutex)
 800e584:	68fa      	ldr	r2, [r7, #12]
 800e586:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e588:	429a      	cmp	r2, r3
 800e58a:	d00b      	beq.n	800e5a4 <_txe_mutex_create+0x7c>
            }
            else
            {

                /* Move to the next mutex.  */
                next_mutex =  next_mutex -> tx_mutex_created_next;
 800e58c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e58e:	6a1b      	ldr	r3, [r3, #32]
 800e590:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_mutex_created_count; i++)
 800e592:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800e594:	3301      	adds	r3, #1
 800e596:	643b      	str	r3, [r7, #64]	; 0x40
 800e598:	4b2e      	ldr	r3, [pc, #184]	; (800e654 <_txe_mutex_create+0x12c>)
 800e59a:	681b      	ldr	r3, [r3, #0]
 800e59c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800e59e:	429a      	cmp	r2, r3
 800e5a0:	d3f0      	bcc.n	800e584 <_txe_mutex_create+0x5c>
 800e5a2:	e000      	b.n	800e5a6 <_txe_mutex_create+0x7e>
                break;
 800e5a4:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e5a6:	f3ef 8310 	mrs	r3, PRIMASK
 800e5aa:	623b      	str	r3, [r7, #32]
    return(posture);
 800e5ac:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 800e5ae:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 800e5b0:	b672      	cpsid	i
    return(int_posture);
 800e5b2:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
 800e5b4:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
 800e5b6:	4b25      	ldr	r3, [pc, #148]	; (800e64c <_txe_mutex_create+0x124>)
 800e5b8:	681b      	ldr	r3, [r3, #0]
 800e5ba:	3b01      	subs	r3, #1
 800e5bc:	4a23      	ldr	r2, [pc, #140]	; (800e64c <_txe_mutex_create+0x124>)
 800e5be:	6013      	str	r3, [r2, #0]
 800e5c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e5c2:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e5c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e5c6:	f383 8810 	msr	PRIMASK, r3
}
 800e5ca:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 800e5cc:	f7fd fef4 	bl	800c3b8 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate mutex.  */
        if (mutex_ptr == next_mutex)
 800e5d0:	68fa      	ldr	r2, [r7, #12]
 800e5d2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e5d4:	429a      	cmp	r2, r3
 800e5d6:	d102      	bne.n	800e5de <_txe_mutex_create+0xb6>
        {

            /* Mutex is already created, return appropriate error code.  */
            status =  TX_MUTEX_ERROR;
 800e5d8:	231c      	movs	r3, #28
 800e5da:	647b      	str	r3, [r7, #68]	; 0x44
 800e5dc:	e007      	b.n	800e5ee <_txe_mutex_create+0xc6>
        }
        else
        {

            /* Check for a valid inherit option.  */
            if (inherit != TX_INHERIT)
 800e5de:	687b      	ldr	r3, [r7, #4]
 800e5e0:	2b01      	cmp	r3, #1
 800e5e2:	d004      	beq.n	800e5ee <_txe_mutex_create+0xc6>
            {

                if (inherit != TX_NO_INHERIT)
 800e5e4:	687b      	ldr	r3, [r7, #4]
 800e5e6:	2b00      	cmp	r3, #0
 800e5e8:	d001      	beq.n	800e5ee <_txe_mutex_create+0xc6>
                {

                    /* Inherit option is illegal.  */
                    status =  TX_INHERIT_ERROR;
 800e5ea:	231f      	movs	r3, #31
 800e5ec:	647b      	str	r3, [r7, #68]	; 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800e5ee:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e5f0:	2b00      	cmp	r3, #0
 800e5f2:	d11d      	bne.n	800e630 <_txe_mutex_create+0x108>
    {

#ifndef TX_TIMER_PROCESS_IN_ISR

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 800e5f4:	4b18      	ldr	r3, [pc, #96]	; (800e658 <_txe_mutex_create+0x130>)
 800e5f6:	681b      	ldr	r3, [r3, #0]
 800e5f8:	637b      	str	r3, [r7, #52]	; 0x34

        /* Check for invalid caller of this function.  First check for a calling thread.  */
        if (thread_ptr == &_tx_timer_thread)
 800e5fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e5fc:	4a17      	ldr	r2, [pc, #92]	; (800e65c <_txe_mutex_create+0x134>)
 800e5fe:	4293      	cmp	r3, r2
 800e600:	d101      	bne.n	800e606 <_txe_mutex_create+0xde>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 800e602:	2313      	movs	r3, #19
 800e604:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e606:	f3ef 8305 	mrs	r3, IPSR
 800e60a:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 800e60c:	69ba      	ldr	r2, [r7, #24]
        }
#endif

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800e60e:	4b14      	ldr	r3, [pc, #80]	; (800e660 <_txe_mutex_create+0x138>)
 800e610:	681b      	ldr	r3, [r3, #0]
 800e612:	4313      	orrs	r3, r2
 800e614:	2b00      	cmp	r3, #0
 800e616:	d00b      	beq.n	800e630 <_txe_mutex_create+0x108>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e618:	f3ef 8305 	mrs	r3, IPSR
 800e61c:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800e61e:	697a      	ldr	r2, [r7, #20]
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800e620:	4b0f      	ldr	r3, [pc, #60]	; (800e660 <_txe_mutex_create+0x138>)
 800e622:	681b      	ldr	r3, [r3, #0]
 800e624:	4313      	orrs	r3, r2
 800e626:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800e62a:	d201      	bcs.n	800e630 <_txe_mutex_create+0x108>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 800e62c:	2313      	movs	r3, #19
 800e62e:	647b      	str	r3, [r7, #68]	; 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800e630:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e632:	2b00      	cmp	r3, #0
 800e634:	d105      	bne.n	800e642 <_txe_mutex_create+0x11a>
    {

        /* Call actual mutex create function.  */
        status =  _tx_mutex_create(mutex_ptr, name_ptr, inherit);
 800e636:	687a      	ldr	r2, [r7, #4]
 800e638:	68b9      	ldr	r1, [r7, #8]
 800e63a:	68f8      	ldr	r0, [r7, #12]
 800e63c:	f7fa fdd0 	bl	80091e0 <_tx_mutex_create>
 800e640:	6478      	str	r0, [r7, #68]	; 0x44
    }

    /* Return completion status.  */
    return(status);
 800e642:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 800e644:	4618      	mov	r0, r3
 800e646:	3748      	adds	r7, #72	; 0x48
 800e648:	46bd      	mov	sp, r7
 800e64a:	bd80      	pop	{r7, pc}
 800e64c:	2000f054 	.word	0x2000f054
 800e650:	2000ef98 	.word	0x2000ef98
 800e654:	2000ef9c 	.word	0x2000ef9c
 800e658:	2000efb8 	.word	0x2000efb8
 800e65c:	2000f108 	.word	0x2000f108
 800e660:	2000000c 	.word	0x2000000c

0800e664 <_txe_mutex_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_mutex_delete(TX_MUTEX *mutex_ptr)
{
 800e664:	b580      	push	{r7, lr}
 800e666:	b086      	sub	sp, #24
 800e668:	af00      	add	r7, sp, #0
 800e66a:	6078      	str	r0, [r7, #4]


#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Default status to success.  */
    status =  TX_SUCCESS;
 800e66c:	2300      	movs	r3, #0
 800e66e:	617b      	str	r3, [r7, #20]
#endif

    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
 800e670:	687b      	ldr	r3, [r7, #4]
 800e672:	2b00      	cmp	r3, #0
 800e674:	d102      	bne.n	800e67c <_txe_mutex_delete+0x18>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 800e676:	231c      	movs	r3, #28
 800e678:	617b      	str	r3, [r7, #20]
 800e67a:	e023      	b.n	800e6c4 <_txe_mutex_delete+0x60>
    }

    /* Now check for a valid mutex ID.  */
    else if (mutex_ptr -> tx_mutex_id != TX_MUTEX_ID)
 800e67c:	687b      	ldr	r3, [r7, #4]
 800e67e:	681b      	ldr	r3, [r3, #0]
 800e680:	4a13      	ldr	r2, [pc, #76]	; (800e6d0 <_txe_mutex_delete+0x6c>)
 800e682:	4293      	cmp	r3, r2
 800e684:	d002      	beq.n	800e68c <_txe_mutex_delete+0x28>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 800e686:	231c      	movs	r3, #28
 800e688:	617b      	str	r3, [r7, #20]
 800e68a:	e01b      	b.n	800e6c4 <_txe_mutex_delete+0x60>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e68c:	f3ef 8305 	mrs	r3, IPSR
 800e690:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 800e692:	68fa      	ldr	r2, [r7, #12]
    }

    /* Check for invalid caller of this function.  */

    /* Is the caller an ISR or Initialization?  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800e694:	4b0f      	ldr	r3, [pc, #60]	; (800e6d4 <_txe_mutex_delete+0x70>)
 800e696:	681b      	ldr	r3, [r3, #0]
 800e698:	4313      	orrs	r3, r2
 800e69a:	2b00      	cmp	r3, #0
 800e69c:	d002      	beq.n	800e6a4 <_txe_mutex_delete+0x40>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
 800e69e:	2313      	movs	r3, #19
 800e6a0:	617b      	str	r3, [r7, #20]
 800e6a2:	e00f      	b.n	800e6c4 <_txe_mutex_delete+0x60>
    {

#ifndef TX_TIMER_PROCESS_IN_ISR

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 800e6a4:	4b0c      	ldr	r3, [pc, #48]	; (800e6d8 <_txe_mutex_delete+0x74>)
 800e6a6:	681b      	ldr	r3, [r3, #0]
 800e6a8:	613b      	str	r3, [r7, #16]

        /* Is the caller the system timer thread?  */
        if (thread_ptr == &_tx_timer_thread)
 800e6aa:	693b      	ldr	r3, [r7, #16]
 800e6ac:	4a0b      	ldr	r2, [pc, #44]	; (800e6dc <_txe_mutex_delete+0x78>)
 800e6ae:	4293      	cmp	r3, r2
 800e6b0:	d101      	bne.n	800e6b6 <_txe_mutex_delete+0x52>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 800e6b2:	2313      	movs	r3, #19
 800e6b4:	617b      	str	r3, [r7, #20]
        }

        /* Determine if everything is okay.  */
        if (status == TX_SUCCESS)
 800e6b6:	697b      	ldr	r3, [r7, #20]
 800e6b8:	2b00      	cmp	r3, #0
 800e6ba:	d103      	bne.n	800e6c4 <_txe_mutex_delete+0x60>
        {
#endif

            /* Call actual mutex delete function.  */
            status =  _tx_mutex_delete(mutex_ptr);
 800e6bc:	6878      	ldr	r0, [r7, #4]
 800e6be:	f7fa fde9 	bl	8009294 <_tx_mutex_delete>
 800e6c2:	6178      	str	r0, [r7, #20]
        }
#endif
    }

    /* Return completion status.  */
    return(status);
 800e6c4:	697b      	ldr	r3, [r7, #20]
}
 800e6c6:	4618      	mov	r0, r3
 800e6c8:	3718      	adds	r7, #24
 800e6ca:	46bd      	mov	sp, r7
 800e6cc:	bd80      	pop	{r7, pc}
 800e6ce:	bf00      	nop
 800e6d0:	4d555445 	.word	0x4d555445
 800e6d4:	2000000c 	.word	0x2000000c
 800e6d8:	2000efb8 	.word	0x2000efb8
 800e6dc:	2000f108 	.word	0x2000f108

0800e6e0 <_txe_mutex_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_mutex_get(TX_MUTEX *mutex_ptr, ULONG wait_option)
{
 800e6e0:	b580      	push	{r7, lr}
 800e6e2:	b088      	sub	sp, #32
 800e6e4:	af00      	add	r7, sp, #0
 800e6e6:	6078      	str	r0, [r7, #4]
 800e6e8:	6039      	str	r1, [r7, #0]
TX_THREAD       *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800e6ea:	2300      	movs	r3, #0
 800e6ec:	61fb      	str	r3, [r7, #28]

    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
 800e6ee:	687b      	ldr	r3, [r7, #4]
 800e6f0:	2b00      	cmp	r3, #0
 800e6f2:	d102      	bne.n	800e6fa <_txe_mutex_get+0x1a>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 800e6f4:	231c      	movs	r3, #28
 800e6f6:	61fb      	str	r3, [r7, #28]
 800e6f8:	e01f      	b.n	800e73a <_txe_mutex_get+0x5a>
    }

    /* Now check for a valid mutex ID.  */
    else if (mutex_ptr -> tx_mutex_id != TX_MUTEX_ID)
 800e6fa:	687b      	ldr	r3, [r7, #4]
 800e6fc:	681b      	ldr	r3, [r3, #0]
 800e6fe:	4a21      	ldr	r2, [pc, #132]	; (800e784 <_txe_mutex_get+0xa4>)
 800e700:	4293      	cmp	r3, r2
 800e702:	d002      	beq.n	800e70a <_txe_mutex_get+0x2a>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 800e704:	231c      	movs	r3, #28
 800e706:	61fb      	str	r3, [r7, #28]
 800e708:	e017      	b.n	800e73a <_txe_mutex_get+0x5a>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
 800e70a:	683b      	ldr	r3, [r7, #0]
 800e70c:	2b00      	cmp	r3, #0
 800e70e:	d014      	beq.n	800e73a <_txe_mutex_get+0x5a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e710:	f3ef 8305 	mrs	r3, IPSR
 800e714:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800e716:	697a      	ldr	r2, [r7, #20]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800e718:	4b1b      	ldr	r3, [pc, #108]	; (800e788 <_txe_mutex_get+0xa8>)
 800e71a:	681b      	ldr	r3, [r3, #0]
 800e71c:	4313      	orrs	r3, r2
 800e71e:	2b00      	cmp	r3, #0
 800e720:	d002      	beq.n	800e728 <_txe_mutex_get+0x48>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
 800e722:	2304      	movs	r3, #4
 800e724:	61fb      	str	r3, [r7, #28]
 800e726:	e008      	b.n	800e73a <_txe_mutex_get+0x5a>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
 800e728:	4b18      	ldr	r3, [pc, #96]	; (800e78c <_txe_mutex_get+0xac>)
 800e72a:	681b      	ldr	r3, [r3, #0]
 800e72c:	61bb      	str	r3, [r7, #24]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
 800e72e:	69bb      	ldr	r3, [r7, #24]
 800e730:	4a17      	ldr	r2, [pc, #92]	; (800e790 <_txe_mutex_get+0xb0>)
 800e732:	4293      	cmp	r3, r2
 800e734:	d101      	bne.n	800e73a <_txe_mutex_get+0x5a>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
 800e736:	2304      	movs	r3, #4
 800e738:	61fb      	str	r3, [r7, #28]
#endif
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800e73a:	69fb      	ldr	r3, [r7, #28]
 800e73c:	2b00      	cmp	r3, #0
 800e73e:	d114      	bne.n	800e76a <_txe_mutex_get+0x8a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e740:	f3ef 8305 	mrs	r3, IPSR
 800e744:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
 800e746:	693a      	ldr	r2, [r7, #16]
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800e748:	4b0f      	ldr	r3, [pc, #60]	; (800e788 <_txe_mutex_get+0xa8>)
 800e74a:	681b      	ldr	r3, [r3, #0]
 800e74c:	4313      	orrs	r3, r2
 800e74e:	2b00      	cmp	r3, #0
 800e750:	d00b      	beq.n	800e76a <_txe_mutex_get+0x8a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e752:	f3ef 8305 	mrs	r3, IPSR
 800e756:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 800e758:	68fa      	ldr	r2, [r7, #12]
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800e75a:	4b0b      	ldr	r3, [pc, #44]	; (800e788 <_txe_mutex_get+0xa8>)
 800e75c:	681b      	ldr	r3, [r3, #0]
 800e75e:	4313      	orrs	r3, r2
 800e760:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800e764:	d201      	bcs.n	800e76a <_txe_mutex_get+0x8a>
            {

                /* Yes, invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 800e766:	2313      	movs	r3, #19
 800e768:	61fb      	str	r3, [r7, #28]
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800e76a:	69fb      	ldr	r3, [r7, #28]
 800e76c:	2b00      	cmp	r3, #0
 800e76e:	d104      	bne.n	800e77a <_txe_mutex_get+0x9a>
    {

        /* Call actual get mutex function.  */
        status =  _tx_mutex_get(mutex_ptr, wait_option);
 800e770:	6839      	ldr	r1, [r7, #0]
 800e772:	6878      	ldr	r0, [r7, #4]
 800e774:	f7fa fe38 	bl	80093e8 <_tx_mutex_get>
 800e778:	61f8      	str	r0, [r7, #28]
    }

    /* Return completion status.  */
    return(status);
 800e77a:	69fb      	ldr	r3, [r7, #28]
}
 800e77c:	4618      	mov	r0, r3
 800e77e:	3720      	adds	r7, #32
 800e780:	46bd      	mov	sp, r7
 800e782:	bd80      	pop	{r7, pc}
 800e784:	4d555445 	.word	0x4d555445
 800e788:	2000000c 	.word	0x2000000c
 800e78c:	2000efb8 	.word	0x2000efb8
 800e790:	2000f108 	.word	0x2000f108

0800e794 <_txe_mutex_info_get>:
/*                                                                        */
/**************************************************************************/
UINT  _txe_mutex_info_get(TX_MUTEX *mutex_ptr, CHAR **name, ULONG *count, TX_THREAD **owner,
                    TX_THREAD **first_suspended, ULONG *suspended_count,
                    TX_MUTEX **next_mutex)
{
 800e794:	b580      	push	{r7, lr}
 800e796:	b08a      	sub	sp, #40	; 0x28
 800e798:	af04      	add	r7, sp, #16
 800e79a:	60f8      	str	r0, [r7, #12]
 800e79c:	60b9      	str	r1, [r7, #8]
 800e79e:	607a      	str	r2, [r7, #4]
 800e7a0:	603b      	str	r3, [r7, #0]

UINT        status;


    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
 800e7a2:	68fb      	ldr	r3, [r7, #12]
 800e7a4:	2b00      	cmp	r3, #0
 800e7a6:	d102      	bne.n	800e7ae <_txe_mutex_info_get+0x1a>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 800e7a8:	231c      	movs	r3, #28
 800e7aa:	617b      	str	r3, [r7, #20]
 800e7ac:	e014      	b.n	800e7d8 <_txe_mutex_info_get+0x44>
    }

    /* Now check for invalid mutex ID.  */
    else if (mutex_ptr -> tx_mutex_id != TX_MUTEX_ID)
 800e7ae:	68fb      	ldr	r3, [r7, #12]
 800e7b0:	681b      	ldr	r3, [r3, #0]
 800e7b2:	4a0c      	ldr	r2, [pc, #48]	; (800e7e4 <_txe_mutex_info_get+0x50>)
 800e7b4:	4293      	cmp	r3, r2
 800e7b6:	d002      	beq.n	800e7be <_txe_mutex_info_get+0x2a>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 800e7b8:	231c      	movs	r3, #28
 800e7ba:	617b      	str	r3, [r7, #20]
 800e7bc:	e00c      	b.n	800e7d8 <_txe_mutex_info_get+0x44>
    }
    else
    {

        /* Otherwise, call the actual mutex information get service.  */
        status =  _tx_mutex_info_get(mutex_ptr, name, count, owner, first_suspended,
 800e7be:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e7c0:	9302      	str	r3, [sp, #8]
 800e7c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e7c4:	9301      	str	r3, [sp, #4]
 800e7c6:	6a3b      	ldr	r3, [r7, #32]
 800e7c8:	9300      	str	r3, [sp, #0]
 800e7ca:	683b      	ldr	r3, [r7, #0]
 800e7cc:	687a      	ldr	r2, [r7, #4]
 800e7ce:	68b9      	ldr	r1, [r7, #8]
 800e7d0:	68f8      	ldr	r0, [r7, #12]
 800e7d2:	f7fa ff11 	bl	80095f8 <_tx_mutex_info_get>
 800e7d6:	6178      	str	r0, [r7, #20]
                                                            suspended_count, next_mutex);
    }

    /* Return completion status.  */
    return(status);
 800e7d8:	697b      	ldr	r3, [r7, #20]
}
 800e7da:	4618      	mov	r0, r3
 800e7dc:	3718      	adds	r7, #24
 800e7de:	46bd      	mov	sp, r7
 800e7e0:	bd80      	pop	{r7, pc}
 800e7e2:	bf00      	nop
 800e7e4:	4d555445 	.word	0x4d555445

0800e7e8 <_txe_mutex_prioritize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_mutex_prioritize(TX_MUTEX *mutex_ptr)
{
 800e7e8:	b580      	push	{r7, lr}
 800e7ea:	b084      	sub	sp, #16
 800e7ec:	af00      	add	r7, sp, #0
 800e7ee:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
 800e7f0:	687b      	ldr	r3, [r7, #4]
 800e7f2:	2b00      	cmp	r3, #0
 800e7f4:	d102      	bne.n	800e7fc <_txe_mutex_prioritize+0x14>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 800e7f6:	231c      	movs	r3, #28
 800e7f8:	60fb      	str	r3, [r7, #12]
 800e7fa:	e00b      	b.n	800e814 <_txe_mutex_prioritize+0x2c>
    }

    /* Now check for invalid mutex ID.  */
    else if (mutex_ptr -> tx_mutex_id != TX_MUTEX_ID)
 800e7fc:	687b      	ldr	r3, [r7, #4]
 800e7fe:	681b      	ldr	r3, [r3, #0]
 800e800:	4a07      	ldr	r2, [pc, #28]	; (800e820 <_txe_mutex_prioritize+0x38>)
 800e802:	4293      	cmp	r3, r2
 800e804:	d002      	beq.n	800e80c <_txe_mutex_prioritize+0x24>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 800e806:	231c      	movs	r3, #28
 800e808:	60fb      	str	r3, [r7, #12]
 800e80a:	e003      	b.n	800e814 <_txe_mutex_prioritize+0x2c>
    }
    else
    {

        /* Call actual mutex prioritize function.  */
        status =  _tx_mutex_prioritize(mutex_ptr);
 800e80c:	6878      	ldr	r0, [r7, #4]
 800e80e:	f7fa ffa7 	bl	8009760 <_tx_mutex_prioritize>
 800e812:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800e814:	68fb      	ldr	r3, [r7, #12]
}
 800e816:	4618      	mov	r0, r3
 800e818:	3710      	adds	r7, #16
 800e81a:	46bd      	mov	sp, r7
 800e81c:	bd80      	pop	{r7, pc}
 800e81e:	bf00      	nop
 800e820:	4d555445 	.word	0x4d555445

0800e824 <_txe_mutex_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_mutex_put(TX_MUTEX *mutex_ptr)
{
 800e824:	b580      	push	{r7, lr}
 800e826:	b086      	sub	sp, #24
 800e828:	af00      	add	r7, sp, #0
 800e82a:	6078      	str	r0, [r7, #4]

UINT            status;


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800e82c:	2300      	movs	r3, #0
 800e82e:	617b      	str	r3, [r7, #20]

    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
 800e830:	687b      	ldr	r3, [r7, #4]
 800e832:	2b00      	cmp	r3, #0
 800e834:	d102      	bne.n	800e83c <_txe_mutex_put+0x18>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 800e836:	231c      	movs	r3, #28
 800e838:	617b      	str	r3, [r7, #20]
 800e83a:	e01c      	b.n	800e876 <_txe_mutex_put+0x52>
    }

    /* Now check for invalid mutex ID.  */
    else if (mutex_ptr -> tx_mutex_id != TX_MUTEX_ID)
 800e83c:	687b      	ldr	r3, [r7, #4]
 800e83e:	681b      	ldr	r3, [r3, #0]
 800e840:	4a13      	ldr	r2, [pc, #76]	; (800e890 <_txe_mutex_put+0x6c>)
 800e842:	4293      	cmp	r3, r2
 800e844:	d002      	beq.n	800e84c <_txe_mutex_put+0x28>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 800e846:	231c      	movs	r3, #28
 800e848:	617b      	str	r3, [r7, #20]
 800e84a:	e014      	b.n	800e876 <_txe_mutex_put+0x52>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e84c:	f3ef 8305 	mrs	r3, IPSR
 800e850:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
 800e852:	693a      	ldr	r2, [r7, #16]
    }
    else
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800e854:	4b0f      	ldr	r3, [pc, #60]	; (800e894 <_txe_mutex_put+0x70>)
 800e856:	681b      	ldr	r3, [r3, #0]
 800e858:	4313      	orrs	r3, r2
 800e85a:	2b00      	cmp	r3, #0
 800e85c:	d00b      	beq.n	800e876 <_txe_mutex_put+0x52>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e85e:	f3ef 8305 	mrs	r3, IPSR
 800e862:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 800e864:	68fa      	ldr	r2, [r7, #12]
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800e866:	4b0b      	ldr	r3, [pc, #44]	; (800e894 <_txe_mutex_put+0x70>)
 800e868:	681b      	ldr	r3, [r3, #0]
 800e86a:	4313      	orrs	r3, r2
 800e86c:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800e870:	d201      	bcs.n	800e876 <_txe_mutex_put+0x52>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 800e872:	2313      	movs	r3, #19
 800e874:	617b      	str	r3, [r7, #20]
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800e876:	697b      	ldr	r3, [r7, #20]
 800e878:	2b00      	cmp	r3, #0
 800e87a:	d103      	bne.n	800e884 <_txe_mutex_put+0x60>
    {

        /* Call actual put mutex function.  */
        status =  _tx_mutex_put(mutex_ptr);
 800e87c:	6878      	ldr	r0, [r7, #4]
 800e87e:	f7fb f8ed 	bl	8009a5c <_tx_mutex_put>
 800e882:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 800e884:	697b      	ldr	r3, [r7, #20]
}
 800e886:	4618      	mov	r0, r3
 800e888:	3718      	adds	r7, #24
 800e88a:	46bd      	mov	sp, r7
 800e88c:	bd80      	pop	{r7, pc}
 800e88e:	bf00      	nop
 800e890:	4d555445 	.word	0x4d555445
 800e894:	2000000c 	.word	0x2000000c

0800e898 <_txe_queue_create>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_queue_create(TX_QUEUE *queue_ptr, CHAR *name_ptr, UINT message_size,
                        VOID *queue_start, ULONG queue_size, UINT queue_control_block_size)
{
 800e898:	b580      	push	{r7, lr}
 800e89a:	b094      	sub	sp, #80	; 0x50
 800e89c:	af02      	add	r7, sp, #8
 800e89e:	60f8      	str	r0, [r7, #12]
 800e8a0:	60b9      	str	r1, [r7, #8]
 800e8a2:	607a      	str	r2, [r7, #4]
 800e8a4:	603b      	str	r3, [r7, #0]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800e8a6:	2300      	movs	r3, #0
 800e8a8:	647b      	str	r3, [r7, #68]	; 0x44

    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
 800e8aa:	68fb      	ldr	r3, [r7, #12]
 800e8ac:	2b00      	cmp	r3, #0
 800e8ae:	d102      	bne.n	800e8b6 <_txe_queue_create+0x1e>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 800e8b0:	2309      	movs	r3, #9
 800e8b2:	647b      	str	r3, [r7, #68]	; 0x44
 800e8b4:	e083      	b.n	800e9be <_txe_queue_create+0x126>
    }

    /* Now check for a valid control block size.  */
    else if (queue_control_block_size != (sizeof(TX_QUEUE)))
 800e8b6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e8b8:	2b44      	cmp	r3, #68	; 0x44
 800e8ba:	d002      	beq.n	800e8c2 <_txe_queue_create+0x2a>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 800e8bc:	2309      	movs	r3, #9
 800e8be:	647b      	str	r3, [r7, #68]	; 0x44
 800e8c0:	e07d      	b.n	800e9be <_txe_queue_create+0x126>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e8c2:	f3ef 8310 	mrs	r3, PRIMASK
 800e8c6:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800e8c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800e8ca:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800e8cc:	b672      	cpsid	i
    return(int_posture);
 800e8ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
 800e8d0:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
 800e8d2:	4b43      	ldr	r3, [pc, #268]	; (800e9e0 <_txe_queue_create+0x148>)
 800e8d4:	681b      	ldr	r3, [r3, #0]
 800e8d6:	3301      	adds	r3, #1
 800e8d8:	4a41      	ldr	r2, [pc, #260]	; (800e9e0 <_txe_queue_create+0x148>)
 800e8da:	6013      	str	r3, [r2, #0]
 800e8dc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e8de:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e8e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e8e2:	f383 8810 	msr	PRIMASK, r3
}
 800e8e6:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_queue =   _tx_queue_created_ptr;
 800e8e8:	4b3e      	ldr	r3, [pc, #248]	; (800e9e4 <_txe_queue_create+0x14c>)
 800e8ea:	681b      	ldr	r3, [r3, #0]
 800e8ec:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_queue_created_count; i++)
 800e8ee:	2300      	movs	r3, #0
 800e8f0:	643b      	str	r3, [r7, #64]	; 0x40
 800e8f2:	e009      	b.n	800e908 <_txe_queue_create+0x70>
        {

            /* Determine if this queue matches the queue in the list.  */
            if (queue_ptr == next_queue)
 800e8f4:	68fa      	ldr	r2, [r7, #12]
 800e8f6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e8f8:	429a      	cmp	r2, r3
 800e8fa:	d00b      	beq.n	800e914 <_txe_queue_create+0x7c>
            }
            else
            {

                /* Move to the next queue.  */
                next_queue =  next_queue -> tx_queue_created_next;
 800e8fc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e8fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e900:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_queue_created_count; i++)
 800e902:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800e904:	3301      	adds	r3, #1
 800e906:	643b      	str	r3, [r7, #64]	; 0x40
 800e908:	4b37      	ldr	r3, [pc, #220]	; (800e9e8 <_txe_queue_create+0x150>)
 800e90a:	681b      	ldr	r3, [r3, #0]
 800e90c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800e90e:	429a      	cmp	r2, r3
 800e910:	d3f0      	bcc.n	800e8f4 <_txe_queue_create+0x5c>
 800e912:	e000      	b.n	800e916 <_txe_queue_create+0x7e>
                break;
 800e914:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e916:	f3ef 8310 	mrs	r3, PRIMASK
 800e91a:	623b      	str	r3, [r7, #32]
    return(posture);
 800e91c:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 800e91e:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 800e920:	b672      	cpsid	i
    return(int_posture);
 800e922:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
 800e924:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
 800e926:	4b2e      	ldr	r3, [pc, #184]	; (800e9e0 <_txe_queue_create+0x148>)
 800e928:	681b      	ldr	r3, [r3, #0]
 800e92a:	3b01      	subs	r3, #1
 800e92c:	4a2c      	ldr	r2, [pc, #176]	; (800e9e0 <_txe_queue_create+0x148>)
 800e92e:	6013      	str	r3, [r2, #0]
 800e930:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e932:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e934:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e936:	f383 8810 	msr	PRIMASK, r3
}
 800e93a:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 800e93c:	f7fd fd3c 	bl	800c3b8 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate queue.  */
        if (queue_ptr == next_queue)
 800e940:	68fa      	ldr	r2, [r7, #12]
 800e942:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e944:	429a      	cmp	r2, r3
 800e946:	d102      	bne.n	800e94e <_txe_queue_create+0xb6>
        {

            /* Queue is already created, return appropriate error code.  */
            status =  TX_QUEUE_ERROR;
 800e948:	2309      	movs	r3, #9
 800e94a:	647b      	str	r3, [r7, #68]	; 0x44
 800e94c:	e037      	b.n	800e9be <_txe_queue_create+0x126>
        }

        /* Check the starting address of the queue.  */
        else if (queue_start == TX_NULL)
 800e94e:	683b      	ldr	r3, [r7, #0]
 800e950:	2b00      	cmp	r3, #0
 800e952:	d102      	bne.n	800e95a <_txe_queue_create+0xc2>
        {

            /* Invalid starting address of queue.  */
            status =  TX_PTR_ERROR;
 800e954:	2303      	movs	r3, #3
 800e956:	647b      	str	r3, [r7, #68]	; 0x44
 800e958:	e031      	b.n	800e9be <_txe_queue_create+0x126>
        }

        /* Check for an invalid message size - less than 1.  */
        else if (message_size < TX_1_ULONG)
 800e95a:	687b      	ldr	r3, [r7, #4]
 800e95c:	2b00      	cmp	r3, #0
 800e95e:	d102      	bne.n	800e966 <_txe_queue_create+0xce>
        {

            /* Invalid message size specified.  */
            status =  TX_SIZE_ERROR;
 800e960:	2305      	movs	r3, #5
 800e962:	647b      	str	r3, [r7, #68]	; 0x44
 800e964:	e02b      	b.n	800e9be <_txe_queue_create+0x126>
        }

        /* Check for an invalid message size - greater than 16.  */
        else if (message_size > TX_16_ULONG)
 800e966:	687b      	ldr	r3, [r7, #4]
 800e968:	2b10      	cmp	r3, #16
 800e96a:	d902      	bls.n	800e972 <_txe_queue_create+0xda>
        {

            /* Invalid message size specified.  */
            status =  TX_SIZE_ERROR;
 800e96c:	2305      	movs	r3, #5
 800e96e:	647b      	str	r3, [r7, #68]	; 0x44
 800e970:	e025      	b.n	800e9be <_txe_queue_create+0x126>
        }

        /* Check on the queue size.  */
        else if ((queue_size/(sizeof(ULONG))) < message_size)
 800e972:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e974:	089b      	lsrs	r3, r3, #2
 800e976:	687a      	ldr	r2, [r7, #4]
 800e978:	429a      	cmp	r2, r3
 800e97a:	d902      	bls.n	800e982 <_txe_queue_create+0xea>
        {

            /* Invalid queue size specified.  */
            status =  TX_SIZE_ERROR;
 800e97c:	2305      	movs	r3, #5
 800e97e:	647b      	str	r3, [r7, #68]	; 0x44
 800e980:	e01d      	b.n	800e9be <_txe_queue_create+0x126>
        {

#ifndef TX_TIMER_PROCESS_IN_ISR

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 800e982:	4b1a      	ldr	r3, [pc, #104]	; (800e9ec <_txe_queue_create+0x154>)
 800e984:	681b      	ldr	r3, [r3, #0]
 800e986:	637b      	str	r3, [r7, #52]	; 0x34

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (thread_ptr == &_tx_timer_thread)
 800e988:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e98a:	4a19      	ldr	r2, [pc, #100]	; (800e9f0 <_txe_queue_create+0x158>)
 800e98c:	4293      	cmp	r3, r2
 800e98e:	d101      	bne.n	800e994 <_txe_queue_create+0xfc>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 800e990:	2313      	movs	r3, #19
 800e992:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e994:	f3ef 8305 	mrs	r3, IPSR
 800e998:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 800e99a:	69ba      	ldr	r2, [r7, #24]
            }
#endif

            /* Check for interrupt call.  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800e99c:	4b15      	ldr	r3, [pc, #84]	; (800e9f4 <_txe_queue_create+0x15c>)
 800e99e:	681b      	ldr	r3, [r3, #0]
 800e9a0:	4313      	orrs	r3, r2
 800e9a2:	2b00      	cmp	r3, #0
 800e9a4:	d00b      	beq.n	800e9be <_txe_queue_create+0x126>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e9a6:	f3ef 8305 	mrs	r3, IPSR
 800e9aa:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800e9ac:	697a      	ldr	r2, [r7, #20]
            {

                /* Now, make sure the call is from an interrupt and not initialization.  */
                if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800e9ae:	4b11      	ldr	r3, [pc, #68]	; (800e9f4 <_txe_queue_create+0x15c>)
 800e9b0:	681b      	ldr	r3, [r3, #0]
 800e9b2:	4313      	orrs	r3, r2
 800e9b4:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800e9b8:	d201      	bcs.n	800e9be <_txe_queue_create+0x126>
                {

                    /* Invalid caller of this function, return appropriate error code.  */
                    status =  TX_CALLER_ERROR;
 800e9ba:	2313      	movs	r3, #19
 800e9bc:	647b      	str	r3, [r7, #68]	; 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800e9be:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e9c0:	2b00      	cmp	r3, #0
 800e9c2:	d108      	bne.n	800e9d6 <_txe_queue_create+0x13e>
    {

        /* Call actual queue create function.  */
        status =  _tx_queue_create(queue_ptr, name_ptr, message_size, queue_start, queue_size);
 800e9c4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e9c6:	9300      	str	r3, [sp, #0]
 800e9c8:	683b      	ldr	r3, [r7, #0]
 800e9ca:	687a      	ldr	r2, [r7, #4]
 800e9cc:	68b9      	ldr	r1, [r7, #8]
 800e9ce:	68f8      	ldr	r0, [r7, #12]
 800e9d0:	f7fb faee 	bl	8009fb0 <_tx_queue_create>
 800e9d4:	6478      	str	r0, [r7, #68]	; 0x44
    }

    /* Return completion status.  */
    return(status);
 800e9d6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 800e9d8:	4618      	mov	r0, r3
 800e9da:	3748      	adds	r7, #72	; 0x48
 800e9dc:	46bd      	mov	sp, r7
 800e9de:	bd80      	pop	{r7, pc}
 800e9e0:	2000f054 	.word	0x2000f054
 800e9e4:	2000ef88 	.word	0x2000ef88
 800e9e8:	2000ef8c 	.word	0x2000ef8c
 800e9ec:	2000efb8 	.word	0x2000efb8
 800e9f0:	2000f108 	.word	0x2000f108
 800e9f4:	2000000c 	.word	0x2000000c

0800e9f8 <_txe_queue_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_queue_delete(TX_QUEUE *queue_ptr)
{
 800e9f8:	b580      	push	{r7, lr}
 800e9fa:	b086      	sub	sp, #24
 800e9fc:	af00      	add	r7, sp, #0
 800e9fe:	6078      	str	r0, [r7, #4]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800ea00:	2300      	movs	r3, #0
 800ea02:	617b      	str	r3, [r7, #20]

    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
 800ea04:	687b      	ldr	r3, [r7, #4]
 800ea06:	2b00      	cmp	r3, #0
 800ea08:	d102      	bne.n	800ea10 <_txe_queue_delete+0x18>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 800ea0a:	2309      	movs	r3, #9
 800ea0c:	617b      	str	r3, [r7, #20]
 800ea0e:	e01c      	b.n	800ea4a <_txe_queue_delete+0x52>
    }

    /* Now check for a valid queue ID.  */
    else if (queue_ptr -> tx_queue_id != TX_QUEUE_ID)
 800ea10:	687b      	ldr	r3, [r7, #4]
 800ea12:	681b      	ldr	r3, [r3, #0]
 800ea14:	4a13      	ldr	r2, [pc, #76]	; (800ea64 <_txe_queue_delete+0x6c>)
 800ea16:	4293      	cmp	r3, r2
 800ea18:	d002      	beq.n	800ea20 <_txe_queue_delete+0x28>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 800ea1a:	2309      	movs	r3, #9
 800ea1c:	617b      	str	r3, [r7, #20]
 800ea1e:	e014      	b.n	800ea4a <_txe_queue_delete+0x52>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800ea20:	f3ef 8305 	mrs	r3, IPSR
 800ea24:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 800ea26:	68fa      	ldr	r2, [r7, #12]
    {

        /* Check for invalid caller of this function.  */

        /* Is the caller an ISR or Initialization?  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800ea28:	4b0f      	ldr	r3, [pc, #60]	; (800ea68 <_txe_queue_delete+0x70>)
 800ea2a:	681b      	ldr	r3, [r3, #0]
 800ea2c:	4313      	orrs	r3, r2
 800ea2e:	2b00      	cmp	r3, #0
 800ea30:	d002      	beq.n	800ea38 <_txe_queue_delete+0x40>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 800ea32:	2313      	movs	r3, #19
 800ea34:	617b      	str	r3, [r7, #20]
 800ea36:	e008      	b.n	800ea4a <_txe_queue_delete+0x52>
#ifndef TX_TIMER_PROCESS_IN_ISR
        else
        {

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 800ea38:	4b0c      	ldr	r3, [pc, #48]	; (800ea6c <_txe_queue_delete+0x74>)
 800ea3a:	681b      	ldr	r3, [r3, #0]
 800ea3c:	613b      	str	r3, [r7, #16]

            /* Is the caller the system timer thread?  */
            if (thread_ptr == &_tx_timer_thread)
 800ea3e:	693b      	ldr	r3, [r7, #16]
 800ea40:	4a0b      	ldr	r2, [pc, #44]	; (800ea70 <_txe_queue_delete+0x78>)
 800ea42:	4293      	cmp	r3, r2
 800ea44:	d101      	bne.n	800ea4a <_txe_queue_delete+0x52>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 800ea46:	2313      	movs	r3, #19
 800ea48:	617b      	str	r3, [r7, #20]
        }
#endif
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800ea4a:	697b      	ldr	r3, [r7, #20]
 800ea4c:	2b00      	cmp	r3, #0
 800ea4e:	d103      	bne.n	800ea58 <_txe_queue_delete+0x60>
    {

        /* Call actual queue delete function.  */
        status =  _tx_queue_delete(queue_ptr);
 800ea50:	6878      	ldr	r0, [r7, #4]
 800ea52:	f7fb fb21 	bl	800a098 <_tx_queue_delete>
 800ea56:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 800ea58:	697b      	ldr	r3, [r7, #20]
}
 800ea5a:	4618      	mov	r0, r3
 800ea5c:	3718      	adds	r7, #24
 800ea5e:	46bd      	mov	sp, r7
 800ea60:	bd80      	pop	{r7, pc}
 800ea62:	bf00      	nop
 800ea64:	51554555 	.word	0x51554555
 800ea68:	2000000c 	.word	0x2000000c
 800ea6c:	2000efb8 	.word	0x2000efb8
 800ea70:	2000f108 	.word	0x2000f108

0800ea74 <_txe_queue_flush>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_queue_flush(TX_QUEUE *queue_ptr)
{
 800ea74:	b580      	push	{r7, lr}
 800ea76:	b084      	sub	sp, #16
 800ea78:	af00      	add	r7, sp, #0
 800ea7a:	6078      	str	r0, [r7, #4]

UINT        status;


    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
 800ea7c:	687b      	ldr	r3, [r7, #4]
 800ea7e:	2b00      	cmp	r3, #0
 800ea80:	d102      	bne.n	800ea88 <_txe_queue_flush+0x14>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 800ea82:	2309      	movs	r3, #9
 800ea84:	60fb      	str	r3, [r7, #12]
 800ea86:	e00b      	b.n	800eaa0 <_txe_queue_flush+0x2c>
    }

    /* Now check for invalid queue ID.  */
    else if (queue_ptr -> tx_queue_id != TX_QUEUE_ID)
 800ea88:	687b      	ldr	r3, [r7, #4]
 800ea8a:	681b      	ldr	r3, [r3, #0]
 800ea8c:	4a07      	ldr	r2, [pc, #28]	; (800eaac <_txe_queue_flush+0x38>)
 800ea8e:	4293      	cmp	r3, r2
 800ea90:	d002      	beq.n	800ea98 <_txe_queue_flush+0x24>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 800ea92:	2309      	movs	r3, #9
 800ea94:	60fb      	str	r3, [r7, #12]
 800ea96:	e003      	b.n	800eaa0 <_txe_queue_flush+0x2c>
    }
    else
    {

        /* Call actual queue flush function.  */
        status =  _tx_queue_flush(queue_ptr);
 800ea98:	6878      	ldr	r0, [r7, #4]
 800ea9a:	f7fb fb8d 	bl	800a1b8 <_tx_queue_flush>
 800ea9e:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800eaa0:	68fb      	ldr	r3, [r7, #12]
}
 800eaa2:	4618      	mov	r0, r3
 800eaa4:	3710      	adds	r7, #16
 800eaa6:	46bd      	mov	sp, r7
 800eaa8:	bd80      	pop	{r7, pc}
 800eaaa:	bf00      	nop
 800eaac:	51554555 	.word	0x51554555

0800eab0 <_txe_queue_front_send>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_queue_front_send(TX_QUEUE *queue_ptr, VOID *source_ptr, ULONG wait_option)
{
 800eab0:	b580      	push	{r7, lr}
 800eab2:	b088      	sub	sp, #32
 800eab4:	af00      	add	r7, sp, #0
 800eab6:	60f8      	str	r0, [r7, #12]
 800eab8:	60b9      	str	r1, [r7, #8]
 800eaba:	607a      	str	r2, [r7, #4]
TX_THREAD   *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800eabc:	2300      	movs	r3, #0
 800eabe:	61fb      	str	r3, [r7, #28]

    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
 800eac0:	68fb      	ldr	r3, [r7, #12]
 800eac2:	2b00      	cmp	r3, #0
 800eac4:	d102      	bne.n	800eacc <_txe_queue_front_send+0x1c>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 800eac6:	2309      	movs	r3, #9
 800eac8:	61fb      	str	r3, [r7, #28]
 800eaca:	e025      	b.n	800eb18 <_txe_queue_front_send+0x68>
    }

    /* Now check for invalid queue ID.  */
    else if (queue_ptr -> tx_queue_id != TX_QUEUE_ID)
 800eacc:	68fb      	ldr	r3, [r7, #12]
 800eace:	681b      	ldr	r3, [r3, #0]
 800ead0:	4a18      	ldr	r2, [pc, #96]	; (800eb34 <_txe_queue_front_send+0x84>)
 800ead2:	4293      	cmp	r3, r2
 800ead4:	d002      	beq.n	800eadc <_txe_queue_front_send+0x2c>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 800ead6:	2309      	movs	r3, #9
 800ead8:	61fb      	str	r3, [r7, #28]
 800eada:	e01d      	b.n	800eb18 <_txe_queue_front_send+0x68>
    }

    /* Check for an invalid source for message.  */
    else if (source_ptr == TX_NULL)
 800eadc:	68bb      	ldr	r3, [r7, #8]
 800eade:	2b00      	cmp	r3, #0
 800eae0:	d102      	bne.n	800eae8 <_txe_queue_front_send+0x38>
    {

        /* Null source pointer, return appropriate error.  */
        status =  TX_PTR_ERROR;
 800eae2:	2303      	movs	r3, #3
 800eae4:	61fb      	str	r3, [r7, #28]
 800eae6:	e017      	b.n	800eb18 <_txe_queue_front_send+0x68>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
 800eae8:	687b      	ldr	r3, [r7, #4]
 800eaea:	2b00      	cmp	r3, #0
 800eaec:	d014      	beq.n	800eb18 <_txe_queue_front_send+0x68>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800eaee:	f3ef 8305 	mrs	r3, IPSR
 800eaf2:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800eaf4:	697a      	ldr	r2, [r7, #20]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800eaf6:	4b10      	ldr	r3, [pc, #64]	; (800eb38 <_txe_queue_front_send+0x88>)
 800eaf8:	681b      	ldr	r3, [r3, #0]
 800eafa:	4313      	orrs	r3, r2
 800eafc:	2b00      	cmp	r3, #0
 800eafe:	d002      	beq.n	800eb06 <_txe_queue_front_send+0x56>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
 800eb00:	2304      	movs	r3, #4
 800eb02:	61fb      	str	r3, [r7, #28]
 800eb04:	e008      	b.n	800eb18 <_txe_queue_front_send+0x68>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
 800eb06:	4b0d      	ldr	r3, [pc, #52]	; (800eb3c <_txe_queue_front_send+0x8c>)
 800eb08:	681b      	ldr	r3, [r3, #0]
 800eb0a:	61bb      	str	r3, [r7, #24]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
 800eb0c:	69bb      	ldr	r3, [r7, #24]
 800eb0e:	4a0c      	ldr	r2, [pc, #48]	; (800eb40 <_txe_queue_front_send+0x90>)
 800eb10:	4293      	cmp	r3, r2
 800eb12:	d101      	bne.n	800eb18 <_txe_queue_front_send+0x68>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
 800eb14:	2304      	movs	r3, #4
 800eb16:	61fb      	str	r3, [r7, #28]
#endif
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800eb18:	69fb      	ldr	r3, [r7, #28]
 800eb1a:	2b00      	cmp	r3, #0
 800eb1c:	d105      	bne.n	800eb2a <_txe_queue_front_send+0x7a>
    {

        /* Call actual queue front send function.  */
        status =  _tx_queue_front_send(queue_ptr, source_ptr, wait_option);
 800eb1e:	687a      	ldr	r2, [r7, #4]
 800eb20:	68b9      	ldr	r1, [r7, #8]
 800eb22:	68f8      	ldr	r0, [r7, #12]
 800eb24:	f7fb fbd6 	bl	800a2d4 <_tx_queue_front_send>
 800eb28:	61f8      	str	r0, [r7, #28]
    }

    /* Return completion status.  */
    return(status);
 800eb2a:	69fb      	ldr	r3, [r7, #28]
}
 800eb2c:	4618      	mov	r0, r3
 800eb2e:	3720      	adds	r7, #32
 800eb30:	46bd      	mov	sp, r7
 800eb32:	bd80      	pop	{r7, pc}
 800eb34:	51554555 	.word	0x51554555
 800eb38:	2000000c 	.word	0x2000000c
 800eb3c:	2000efb8 	.word	0x2000efb8
 800eb40:	2000f108 	.word	0x2000f108

0800eb44 <_txe_queue_info_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_queue_info_get(TX_QUEUE *queue_ptr, CHAR **name, ULONG *enqueued, ULONG *available_storage,
                    TX_THREAD **first_suspended, ULONG *suspended_count, TX_QUEUE **next_queue)
{
 800eb44:	b580      	push	{r7, lr}
 800eb46:	b08a      	sub	sp, #40	; 0x28
 800eb48:	af04      	add	r7, sp, #16
 800eb4a:	60f8      	str	r0, [r7, #12]
 800eb4c:	60b9      	str	r1, [r7, #8]
 800eb4e:	607a      	str	r2, [r7, #4]
 800eb50:	603b      	str	r3, [r7, #0]

UINT    status;


    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
 800eb52:	68fb      	ldr	r3, [r7, #12]
 800eb54:	2b00      	cmp	r3, #0
 800eb56:	d102      	bne.n	800eb5e <_txe_queue_info_get+0x1a>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 800eb58:	2309      	movs	r3, #9
 800eb5a:	617b      	str	r3, [r7, #20]
 800eb5c:	e014      	b.n	800eb88 <_txe_queue_info_get+0x44>
    }

    /* Now check for a valid queue ID.  */
    else if (queue_ptr -> tx_queue_id != TX_QUEUE_ID)
 800eb5e:	68fb      	ldr	r3, [r7, #12]
 800eb60:	681b      	ldr	r3, [r3, #0]
 800eb62:	4a0c      	ldr	r2, [pc, #48]	; (800eb94 <_txe_queue_info_get+0x50>)
 800eb64:	4293      	cmp	r3, r2
 800eb66:	d002      	beq.n	800eb6e <_txe_queue_info_get+0x2a>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 800eb68:	2309      	movs	r3, #9
 800eb6a:	617b      	str	r3, [r7, #20]
 800eb6c:	e00c      	b.n	800eb88 <_txe_queue_info_get+0x44>
    }
    else
    {

        /* Otherwise, call the actual queue information get service.  */
        status =  _tx_queue_info_get(queue_ptr, name, enqueued, available_storage, first_suspended,
 800eb6e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800eb70:	9302      	str	r3, [sp, #8]
 800eb72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800eb74:	9301      	str	r3, [sp, #4]
 800eb76:	6a3b      	ldr	r3, [r7, #32]
 800eb78:	9300      	str	r3, [sp, #0]
 800eb7a:	683b      	ldr	r3, [r7, #0]
 800eb7c:	687a      	ldr	r2, [r7, #4]
 800eb7e:	68b9      	ldr	r1, [r7, #8]
 800eb80:	68f8      	ldr	r0, [r7, #12]
 800eb82:	f7fb fd07 	bl	800a594 <_tx_queue_info_get>
 800eb86:	6178      	str	r0, [r7, #20]
                                                                    suspended_count, next_queue);
    }

    /* Return completion status.  */
    return(status);
 800eb88:	697b      	ldr	r3, [r7, #20]
}
 800eb8a:	4618      	mov	r0, r3
 800eb8c:	3718      	adds	r7, #24
 800eb8e:	46bd      	mov	sp, r7
 800eb90:	bd80      	pop	{r7, pc}
 800eb92:	bf00      	nop
 800eb94:	51554555 	.word	0x51554555

0800eb98 <_txe_queue_prioritize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_queue_prioritize(TX_QUEUE *queue_ptr)
{
 800eb98:	b580      	push	{r7, lr}
 800eb9a:	b084      	sub	sp, #16
 800eb9c:	af00      	add	r7, sp, #0
 800eb9e:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
 800eba0:	687b      	ldr	r3, [r7, #4]
 800eba2:	2b00      	cmp	r3, #0
 800eba4:	d102      	bne.n	800ebac <_txe_queue_prioritize+0x14>
    {
        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 800eba6:	2309      	movs	r3, #9
 800eba8:	60fb      	str	r3, [r7, #12]
 800ebaa:	e00b      	b.n	800ebc4 <_txe_queue_prioritize+0x2c>
    }

    /* Now check for invalid queue ID.  */
    else if (queue_ptr -> tx_queue_id != TX_QUEUE_ID)
 800ebac:	687b      	ldr	r3, [r7, #4]
 800ebae:	681b      	ldr	r3, [r3, #0]
 800ebb0:	4a07      	ldr	r2, [pc, #28]	; (800ebd0 <_txe_queue_prioritize+0x38>)
 800ebb2:	4293      	cmp	r3, r2
 800ebb4:	d002      	beq.n	800ebbc <_txe_queue_prioritize+0x24>
    {
        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 800ebb6:	2309      	movs	r3, #9
 800ebb8:	60fb      	str	r3, [r7, #12]
 800ebba:	e003      	b.n	800ebc4 <_txe_queue_prioritize+0x2c>
    }
    else
    {

        /* Call actual queue prioritize function.  */
        status =  _tx_queue_prioritize(queue_ptr);
 800ebbc:	6878      	ldr	r0, [r7, #4]
 800ebbe:	f7fb fd9d 	bl	800a6fc <_tx_queue_prioritize>
 800ebc2:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800ebc4:	68fb      	ldr	r3, [r7, #12]
}
 800ebc6:	4618      	mov	r0, r3
 800ebc8:	3710      	adds	r7, #16
 800ebca:	46bd      	mov	sp, r7
 800ebcc:	bd80      	pop	{r7, pc}
 800ebce:	bf00      	nop
 800ebd0:	51554555 	.word	0x51554555

0800ebd4 <_txe_queue_receive>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_queue_receive(TX_QUEUE *queue_ptr, VOID *destination_ptr, ULONG wait_option)
{
 800ebd4:	b580      	push	{r7, lr}
 800ebd6:	b088      	sub	sp, #32
 800ebd8:	af00      	add	r7, sp, #0
 800ebda:	60f8      	str	r0, [r7, #12]
 800ebdc:	60b9      	str	r1, [r7, #8]
 800ebde:	607a      	str	r2, [r7, #4]
TX_THREAD   *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800ebe0:	2300      	movs	r3, #0
 800ebe2:	61fb      	str	r3, [r7, #28]

    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
 800ebe4:	68fb      	ldr	r3, [r7, #12]
 800ebe6:	2b00      	cmp	r3, #0
 800ebe8:	d102      	bne.n	800ebf0 <_txe_queue_receive+0x1c>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 800ebea:	2309      	movs	r3, #9
 800ebec:	61fb      	str	r3, [r7, #28]
 800ebee:	e025      	b.n	800ec3c <_txe_queue_receive+0x68>
    }

    /* Now check for invalid queue ID.  */
    else if (queue_ptr -> tx_queue_id != TX_QUEUE_ID)
 800ebf0:	68fb      	ldr	r3, [r7, #12]
 800ebf2:	681b      	ldr	r3, [r3, #0]
 800ebf4:	4a18      	ldr	r2, [pc, #96]	; (800ec58 <_txe_queue_receive+0x84>)
 800ebf6:	4293      	cmp	r3, r2
 800ebf8:	d002      	beq.n	800ec00 <_txe_queue_receive+0x2c>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 800ebfa:	2309      	movs	r3, #9
 800ebfc:	61fb      	str	r3, [r7, #28]
 800ebfe:	e01d      	b.n	800ec3c <_txe_queue_receive+0x68>
    }

    /* Check for an invalid destination for message.  */
    else if (destination_ptr == TX_NULL)
 800ec00:	68bb      	ldr	r3, [r7, #8]
 800ec02:	2b00      	cmp	r3, #0
 800ec04:	d102      	bne.n	800ec0c <_txe_queue_receive+0x38>
    {

        /* Null destination pointer, return appropriate error.  */
        status =  TX_PTR_ERROR;
 800ec06:	2303      	movs	r3, #3
 800ec08:	61fb      	str	r3, [r7, #28]
 800ec0a:	e017      	b.n	800ec3c <_txe_queue_receive+0x68>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
 800ec0c:	687b      	ldr	r3, [r7, #4]
 800ec0e:	2b00      	cmp	r3, #0
 800ec10:	d014      	beq.n	800ec3c <_txe_queue_receive+0x68>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800ec12:	f3ef 8305 	mrs	r3, IPSR
 800ec16:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800ec18:	697a      	ldr	r2, [r7, #20]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800ec1a:	4b10      	ldr	r3, [pc, #64]	; (800ec5c <_txe_queue_receive+0x88>)
 800ec1c:	681b      	ldr	r3, [r3, #0]
 800ec1e:	4313      	orrs	r3, r2
 800ec20:	2b00      	cmp	r3, #0
 800ec22:	d002      	beq.n	800ec2a <_txe_queue_receive+0x56>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
 800ec24:	2304      	movs	r3, #4
 800ec26:	61fb      	str	r3, [r7, #28]
 800ec28:	e008      	b.n	800ec3c <_txe_queue_receive+0x68>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
 800ec2a:	4b0d      	ldr	r3, [pc, #52]	; (800ec60 <_txe_queue_receive+0x8c>)
 800ec2c:	681b      	ldr	r3, [r3, #0]
 800ec2e:	61bb      	str	r3, [r7, #24]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
 800ec30:	69bb      	ldr	r3, [r7, #24]
 800ec32:	4a0c      	ldr	r2, [pc, #48]	; (800ec64 <_txe_queue_receive+0x90>)
 800ec34:	4293      	cmp	r3, r2
 800ec36:	d101      	bne.n	800ec3c <_txe_queue_receive+0x68>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
 800ec38:	2304      	movs	r3, #4
 800ec3a:	61fb      	str	r3, [r7, #28]
#endif
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800ec3c:	69fb      	ldr	r3, [r7, #28]
 800ec3e:	2b00      	cmp	r3, #0
 800ec40:	d105      	bne.n	800ec4e <_txe_queue_receive+0x7a>
    {

        /* Call actual queue receive function.  */
        status =  _tx_queue_receive(queue_ptr, destination_ptr, wait_option);
 800ec42:	687a      	ldr	r2, [r7, #4]
 800ec44:	68b9      	ldr	r1, [r7, #8]
 800ec46:	68f8      	ldr	r0, [r7, #12]
 800ec48:	f7fb fe0a 	bl	800a860 <_tx_queue_receive>
 800ec4c:	61f8      	str	r0, [r7, #28]
    }

    /* Return completion status.  */
    return(status);
 800ec4e:	69fb      	ldr	r3, [r7, #28]
}
 800ec50:	4618      	mov	r0, r3
 800ec52:	3720      	adds	r7, #32
 800ec54:	46bd      	mov	sp, r7
 800ec56:	bd80      	pop	{r7, pc}
 800ec58:	51554555 	.word	0x51554555
 800ec5c:	2000000c 	.word	0x2000000c
 800ec60:	2000efb8 	.word	0x2000efb8
 800ec64:	2000f108 	.word	0x2000f108

0800ec68 <_txe_queue_send>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_queue_send(TX_QUEUE *queue_ptr, VOID *source_ptr, ULONG wait_option)
{
 800ec68:	b580      	push	{r7, lr}
 800ec6a:	b088      	sub	sp, #32
 800ec6c:	af00      	add	r7, sp, #0
 800ec6e:	60f8      	str	r0, [r7, #12]
 800ec70:	60b9      	str	r1, [r7, #8]
 800ec72:	607a      	str	r2, [r7, #4]
TX_THREAD   *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800ec74:	2300      	movs	r3, #0
 800ec76:	61fb      	str	r3, [r7, #28]

    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
 800ec78:	68fb      	ldr	r3, [r7, #12]
 800ec7a:	2b00      	cmp	r3, #0
 800ec7c:	d102      	bne.n	800ec84 <_txe_queue_send+0x1c>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 800ec7e:	2309      	movs	r3, #9
 800ec80:	61fb      	str	r3, [r7, #28]
 800ec82:	e025      	b.n	800ecd0 <_txe_queue_send+0x68>
    }

    /* Now check for invalid queue ID.  */
    else if (queue_ptr -> tx_queue_id != TX_QUEUE_ID)
 800ec84:	68fb      	ldr	r3, [r7, #12]
 800ec86:	681b      	ldr	r3, [r3, #0]
 800ec88:	4a18      	ldr	r2, [pc, #96]	; (800ecec <_txe_queue_send+0x84>)
 800ec8a:	4293      	cmp	r3, r2
 800ec8c:	d002      	beq.n	800ec94 <_txe_queue_send+0x2c>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 800ec8e:	2309      	movs	r3, #9
 800ec90:	61fb      	str	r3, [r7, #28]
 800ec92:	e01d      	b.n	800ecd0 <_txe_queue_send+0x68>
    }

    /* Check for an invalid source for message.  */
    else if (source_ptr == TX_NULL)
 800ec94:	68bb      	ldr	r3, [r7, #8]
 800ec96:	2b00      	cmp	r3, #0
 800ec98:	d102      	bne.n	800eca0 <_txe_queue_send+0x38>
    {

        /* Null source pointer, return appropriate error.  */
        status =  TX_PTR_ERROR;
 800ec9a:	2303      	movs	r3, #3
 800ec9c:	61fb      	str	r3, [r7, #28]
 800ec9e:	e017      	b.n	800ecd0 <_txe_queue_send+0x68>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
 800eca0:	687b      	ldr	r3, [r7, #4]
 800eca2:	2b00      	cmp	r3, #0
 800eca4:	d014      	beq.n	800ecd0 <_txe_queue_send+0x68>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800eca6:	f3ef 8305 	mrs	r3, IPSR
 800ecaa:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800ecac:	697a      	ldr	r2, [r7, #20]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800ecae:	4b10      	ldr	r3, [pc, #64]	; (800ecf0 <_txe_queue_send+0x88>)
 800ecb0:	681b      	ldr	r3, [r3, #0]
 800ecb2:	4313      	orrs	r3, r2
 800ecb4:	2b00      	cmp	r3, #0
 800ecb6:	d002      	beq.n	800ecbe <_txe_queue_send+0x56>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
 800ecb8:	2304      	movs	r3, #4
 800ecba:	61fb      	str	r3, [r7, #28]
 800ecbc:	e008      	b.n	800ecd0 <_txe_queue_send+0x68>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
 800ecbe:	4b0d      	ldr	r3, [pc, #52]	; (800ecf4 <_txe_queue_send+0x8c>)
 800ecc0:	681b      	ldr	r3, [r3, #0]
 800ecc2:	61bb      	str	r3, [r7, #24]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
 800ecc4:	69bb      	ldr	r3, [r7, #24]
 800ecc6:	4a0c      	ldr	r2, [pc, #48]	; (800ecf8 <_txe_queue_send+0x90>)
 800ecc8:	4293      	cmp	r3, r2
 800ecca:	d101      	bne.n	800ecd0 <_txe_queue_send+0x68>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
 800eccc:	2304      	movs	r3, #4
 800ecce:	61fb      	str	r3, [r7, #28]
#endif
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800ecd0:	69fb      	ldr	r3, [r7, #28]
 800ecd2:	2b00      	cmp	r3, #0
 800ecd4:	d105      	bne.n	800ece2 <_txe_queue_send+0x7a>
    {

        /* Call actual queue send function.  */
        status =  _tx_queue_send(queue_ptr, source_ptr, wait_option);
 800ecd6:	687a      	ldr	r2, [r7, #4]
 800ecd8:	68b9      	ldr	r1, [r7, #8]
 800ecda:	68f8      	ldr	r0, [r7, #12]
 800ecdc:	f7fb ff88 	bl	800abf0 <_tx_queue_send>
 800ece0:	61f8      	str	r0, [r7, #28]
    }

    /* Return completion status.  */
    return(status);
 800ece2:	69fb      	ldr	r3, [r7, #28]
}
 800ece4:	4618      	mov	r0, r3
 800ece6:	3720      	adds	r7, #32
 800ece8:	46bd      	mov	sp, r7
 800ecea:	bd80      	pop	{r7, pc}
 800ecec:	51554555 	.word	0x51554555
 800ecf0:	2000000c 	.word	0x2000000c
 800ecf4:	2000efb8 	.word	0x2000efb8
 800ecf8:	2000f108 	.word	0x2000f108

0800ecfc <_txe_queue_send_notify>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_queue_send_notify(TX_QUEUE *queue_ptr, VOID (*queue_send_notify)(TX_QUEUE *notify_queue_ptr))
{
 800ecfc:	b580      	push	{r7, lr}
 800ecfe:	b084      	sub	sp, #16
 800ed00:	af00      	add	r7, sp, #0
 800ed02:	6078      	str	r0, [r7, #4]
 800ed04:	6039      	str	r1, [r7, #0]

UINT    status;


    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
 800ed06:	687b      	ldr	r3, [r7, #4]
 800ed08:	2b00      	cmp	r3, #0
 800ed0a:	d102      	bne.n	800ed12 <_txe_queue_send_notify+0x16>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 800ed0c:	2309      	movs	r3, #9
 800ed0e:	60fb      	str	r3, [r7, #12]
 800ed10:	e00c      	b.n	800ed2c <_txe_queue_send_notify+0x30>
    }

    /* Now check for a valid queue ID.  */
    else if (queue_ptr -> tx_queue_id != TX_QUEUE_ID)
 800ed12:	687b      	ldr	r3, [r7, #4]
 800ed14:	681b      	ldr	r3, [r3, #0]
 800ed16:	4a08      	ldr	r2, [pc, #32]	; (800ed38 <_txe_queue_send_notify+0x3c>)
 800ed18:	4293      	cmp	r3, r2
 800ed1a:	d002      	beq.n	800ed22 <_txe_queue_send_notify+0x26>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 800ed1c:	2309      	movs	r3, #9
 800ed1e:	60fb      	str	r3, [r7, #12]
 800ed20:	e004      	b.n	800ed2c <_txe_queue_send_notify+0x30>
    }
    else
    {

        /* Call actual queue send notify function.  */
        status =  _tx_queue_send_notify(queue_ptr, queue_send_notify);
 800ed22:	6839      	ldr	r1, [r7, #0]
 800ed24:	6878      	ldr	r0, [r7, #4]
 800ed26:	f7fc f8b1 	bl	800ae8c <_tx_queue_send_notify>
 800ed2a:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800ed2c:	68fb      	ldr	r3, [r7, #12]
}
 800ed2e:	4618      	mov	r0, r3
 800ed30:	3710      	adds	r7, #16
 800ed32:	46bd      	mov	sp, r7
 800ed34:	bd80      	pop	{r7, pc}
 800ed36:	bf00      	nop
 800ed38:	51554555 	.word	0x51554555

0800ed3c <_txe_semaphore_ceiling_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_ceiling_put(TX_SEMAPHORE *semaphore_ptr, ULONG ceiling)
{
 800ed3c:	b580      	push	{r7, lr}
 800ed3e:	b084      	sub	sp, #16
 800ed40:	af00      	add	r7, sp, #0
 800ed42:	6078      	str	r0, [r7, #4]
 800ed44:	6039      	str	r1, [r7, #0]

UINT        status;


    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
 800ed46:	687b      	ldr	r3, [r7, #4]
 800ed48:	2b00      	cmp	r3, #0
 800ed4a:	d102      	bne.n	800ed52 <_txe_semaphore_ceiling_put+0x16>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 800ed4c:	230c      	movs	r3, #12
 800ed4e:	60fb      	str	r3, [r7, #12]
 800ed50:	e012      	b.n	800ed78 <_txe_semaphore_ceiling_put+0x3c>
    }

    /* Now check for a valid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
 800ed52:	687b      	ldr	r3, [r7, #4]
 800ed54:	681b      	ldr	r3, [r3, #0]
 800ed56:	4a0b      	ldr	r2, [pc, #44]	; (800ed84 <_txe_semaphore_ceiling_put+0x48>)
 800ed58:	4293      	cmp	r3, r2
 800ed5a:	d002      	beq.n	800ed62 <_txe_semaphore_ceiling_put+0x26>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 800ed5c:	230c      	movs	r3, #12
 800ed5e:	60fb      	str	r3, [r7, #12]
 800ed60:	e00a      	b.n	800ed78 <_txe_semaphore_ceiling_put+0x3c>
    }

    /* Determine if the ceiling is valid - must be greater than 1.  */
    else if (ceiling == ((ULONG) 0))
 800ed62:	683b      	ldr	r3, [r7, #0]
 800ed64:	2b00      	cmp	r3, #0
 800ed66:	d102      	bne.n	800ed6e <_txe_semaphore_ceiling_put+0x32>
    {

        /* Invalid ceiling, return error.  */
        status =  TX_INVALID_CEILING;
 800ed68:	2322      	movs	r3, #34	; 0x22
 800ed6a:	60fb      	str	r3, [r7, #12]
 800ed6c:	e004      	b.n	800ed78 <_txe_semaphore_ceiling_put+0x3c>
    }
    else
    {

        /* Call actual semaphore ceiling put function.  */
        status =  _tx_semaphore_ceiling_put(semaphore_ptr, ceiling);
 800ed6e:	6839      	ldr	r1, [r7, #0]
 800ed70:	6878      	ldr	r0, [r7, #4]
 800ed72:	f7fc f8a9 	bl	800aec8 <_tx_semaphore_ceiling_put>
 800ed76:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800ed78:	68fb      	ldr	r3, [r7, #12]
}
 800ed7a:	4618      	mov	r0, r3
 800ed7c:	3710      	adds	r7, #16
 800ed7e:	46bd      	mov	sp, r7
 800ed80:	bd80      	pop	{r7, pc}
 800ed82:	bf00      	nop
 800ed84:	53454d41 	.word	0x53454d41

0800ed88 <_txe_semaphore_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_create(TX_SEMAPHORE *semaphore_ptr, CHAR *name_ptr, ULONG initial_count, UINT semaphore_control_block_size)
{
 800ed88:	b580      	push	{r7, lr}
 800ed8a:	b092      	sub	sp, #72	; 0x48
 800ed8c:	af00      	add	r7, sp, #0
 800ed8e:	60f8      	str	r0, [r7, #12]
 800ed90:	60b9      	str	r1, [r7, #8]
 800ed92:	607a      	str	r2, [r7, #4]
 800ed94:	603b      	str	r3, [r7, #0]
TX_THREAD           *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800ed96:	2300      	movs	r3, #0
 800ed98:	647b      	str	r3, [r7, #68]	; 0x44

    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
 800ed9a:	68fb      	ldr	r3, [r7, #12]
 800ed9c:	2b00      	cmp	r3, #0
 800ed9e:	d102      	bne.n	800eda6 <_txe_semaphore_create+0x1e>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 800eda0:	230c      	movs	r3, #12
 800eda2:	647b      	str	r3, [r7, #68]	; 0x44
 800eda4:	e054      	b.n	800ee50 <_txe_semaphore_create+0xc8>
    }

    /* Now check for a valid semaphore ID.  */
    else if (semaphore_control_block_size != (sizeof(TX_SEMAPHORE)))
 800eda6:	683b      	ldr	r3, [r7, #0]
 800eda8:	2b28      	cmp	r3, #40	; 0x28
 800edaa:	d002      	beq.n	800edb2 <_txe_semaphore_create+0x2a>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 800edac:	230c      	movs	r3, #12
 800edae:	647b      	str	r3, [r7, #68]	; 0x44
 800edb0:	e04e      	b.n	800ee50 <_txe_semaphore_create+0xc8>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800edb2:	f3ef 8310 	mrs	r3, PRIMASK
 800edb6:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800edb8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800edba:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800edbc:	b672      	cpsid	i
    return(int_posture);
 800edbe:	6abb      	ldr	r3, [r7, #40]	; 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
 800edc0:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
 800edc2:	4b36      	ldr	r3, [pc, #216]	; (800ee9c <_txe_semaphore_create+0x114>)
 800edc4:	681b      	ldr	r3, [r3, #0]
 800edc6:	3301      	adds	r3, #1
 800edc8:	4a34      	ldr	r2, [pc, #208]	; (800ee9c <_txe_semaphore_create+0x114>)
 800edca:	6013      	str	r3, [r2, #0]
 800edcc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800edce:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800edd0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800edd2:	f383 8810 	msr	PRIMASK, r3
}
 800edd6:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_semaphore =  _tx_semaphore_created_ptr;
 800edd8:	4b31      	ldr	r3, [pc, #196]	; (800eea0 <_txe_semaphore_create+0x118>)
 800edda:	681b      	ldr	r3, [r3, #0]
 800eddc:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_semaphore_created_count; i++)
 800edde:	2300      	movs	r3, #0
 800ede0:	643b      	str	r3, [r7, #64]	; 0x40
 800ede2:	e009      	b.n	800edf8 <_txe_semaphore_create+0x70>
        {

            /* Determine if this semaphore matches the current semaphore in the list.  */
            if (semaphore_ptr == next_semaphore)
 800ede4:	68fa      	ldr	r2, [r7, #12]
 800ede6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ede8:	429a      	cmp	r2, r3
 800edea:	d00b      	beq.n	800ee04 <_txe_semaphore_create+0x7c>
            }
            else
            {

                /* Move to next semaphore.  */
                next_semaphore =  next_semaphore -> tx_semaphore_created_next;
 800edec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800edee:	695b      	ldr	r3, [r3, #20]
 800edf0:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_semaphore_created_count; i++)
 800edf2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800edf4:	3301      	adds	r3, #1
 800edf6:	643b      	str	r3, [r7, #64]	; 0x40
 800edf8:	4b2a      	ldr	r3, [pc, #168]	; (800eea4 <_txe_semaphore_create+0x11c>)
 800edfa:	681b      	ldr	r3, [r3, #0]
 800edfc:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800edfe:	429a      	cmp	r2, r3
 800ee00:	d3f0      	bcc.n	800ede4 <_txe_semaphore_create+0x5c>
 800ee02:	e000      	b.n	800ee06 <_txe_semaphore_create+0x7e>
                break;
 800ee04:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800ee06:	f3ef 8310 	mrs	r3, PRIMASK
 800ee0a:	623b      	str	r3, [r7, #32]
    return(posture);
 800ee0c:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 800ee0e:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 800ee10:	b672      	cpsid	i
    return(int_posture);
 800ee12:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
 800ee14:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
 800ee16:	4b21      	ldr	r3, [pc, #132]	; (800ee9c <_txe_semaphore_create+0x114>)
 800ee18:	681b      	ldr	r3, [r3, #0]
 800ee1a:	3b01      	subs	r3, #1
 800ee1c:	4a1f      	ldr	r2, [pc, #124]	; (800ee9c <_txe_semaphore_create+0x114>)
 800ee1e:	6013      	str	r3, [r2, #0]
 800ee20:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ee22:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ee24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ee26:	f383 8810 	msr	PRIMASK, r3
}
 800ee2a:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 800ee2c:	f7fd fac4 	bl	800c3b8 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate semaphore.  */
        if (semaphore_ptr == next_semaphore)
 800ee30:	68fa      	ldr	r2, [r7, #12]
 800ee32:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ee34:	429a      	cmp	r2, r3
 800ee36:	d102      	bne.n	800ee3e <_txe_semaphore_create+0xb6>
        {

            /* Semaphore is already created, return appropriate error code.  */
            status =  TX_SEMAPHORE_ERROR;
 800ee38:	230c      	movs	r3, #12
 800ee3a:	647b      	str	r3, [r7, #68]	; 0x44
 800ee3c:	e008      	b.n	800ee50 <_txe_semaphore_create+0xc8>
#ifndef TX_TIMER_PROCESS_IN_ISR
        else
        {

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 800ee3e:	4b1a      	ldr	r3, [pc, #104]	; (800eea8 <_txe_semaphore_create+0x120>)
 800ee40:	681b      	ldr	r3, [r3, #0]
 800ee42:	637b      	str	r3, [r7, #52]	; 0x34

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (thread_ptr == &_tx_timer_thread)
 800ee44:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ee46:	4a19      	ldr	r2, [pc, #100]	; (800eeac <_txe_semaphore_create+0x124>)
 800ee48:	4293      	cmp	r3, r2
 800ee4a:	d101      	bne.n	800ee50 <_txe_semaphore_create+0xc8>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 800ee4c:	2313      	movs	r3, #19
 800ee4e:	647b      	str	r3, [r7, #68]	; 0x44
        }
#endif
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800ee50:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ee52:	2b00      	cmp	r3, #0
 800ee54:	d114      	bne.n	800ee80 <_txe_semaphore_create+0xf8>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800ee56:	f3ef 8305 	mrs	r3, IPSR
 800ee5a:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 800ee5c:	69ba      	ldr	r2, [r7, #24]
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800ee5e:	4b14      	ldr	r3, [pc, #80]	; (800eeb0 <_txe_semaphore_create+0x128>)
 800ee60:	681b      	ldr	r3, [r3, #0]
 800ee62:	4313      	orrs	r3, r2
 800ee64:	2b00      	cmp	r3, #0
 800ee66:	d00b      	beq.n	800ee80 <_txe_semaphore_create+0xf8>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800ee68:	f3ef 8305 	mrs	r3, IPSR
 800ee6c:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800ee6e:	697a      	ldr	r2, [r7, #20]
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800ee70:	4b0f      	ldr	r3, [pc, #60]	; (800eeb0 <_txe_semaphore_create+0x128>)
 800ee72:	681b      	ldr	r3, [r3, #0]
 800ee74:	4313      	orrs	r3, r2
 800ee76:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800ee7a:	d201      	bcs.n	800ee80 <_txe_semaphore_create+0xf8>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 800ee7c:	2313      	movs	r3, #19
 800ee7e:	647b      	str	r3, [r7, #68]	; 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800ee80:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ee82:	2b00      	cmp	r3, #0
 800ee84:	d105      	bne.n	800ee92 <_txe_semaphore_create+0x10a>
    {

        /* Call actual semaphore create function.  */
        status =  _tx_semaphore_create(semaphore_ptr, name_ptr, initial_count);
 800ee86:	687a      	ldr	r2, [r7, #4]
 800ee88:	68b9      	ldr	r1, [r7, #8]
 800ee8a:	68f8      	ldr	r0, [r7, #12]
 800ee8c:	f7fc f916 	bl	800b0bc <_tx_semaphore_create>
 800ee90:	6478      	str	r0, [r7, #68]	; 0x44
    }

    /* Return completion status.  */
    return(status);
 800ee92:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 800ee94:	4618      	mov	r0, r3
 800ee96:	3748      	adds	r7, #72	; 0x48
 800ee98:	46bd      	mov	sp, r7
 800ee9a:	bd80      	pop	{r7, pc}
 800ee9c:	2000f054 	.word	0x2000f054
 800eea0:	2000ef80 	.word	0x2000ef80
 800eea4:	2000ef84 	.word	0x2000ef84
 800eea8:	2000efb8 	.word	0x2000efb8
 800eeac:	2000f108 	.word	0x2000f108
 800eeb0:	2000000c 	.word	0x2000000c

0800eeb4 <_txe_semaphore_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_delete(TX_SEMAPHORE *semaphore_ptr)
{
 800eeb4:	b580      	push	{r7, lr}
 800eeb6:	b086      	sub	sp, #24
 800eeb8:	af00      	add	r7, sp, #0
 800eeba:	6078      	str	r0, [r7, #4]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800eebc:	2300      	movs	r3, #0
 800eebe:	617b      	str	r3, [r7, #20]

    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
 800eec0:	687b      	ldr	r3, [r7, #4]
 800eec2:	2b00      	cmp	r3, #0
 800eec4:	d102      	bne.n	800eecc <_txe_semaphore_delete+0x18>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 800eec6:	230c      	movs	r3, #12
 800eec8:	617b      	str	r3, [r7, #20]
 800eeca:	e01c      	b.n	800ef06 <_txe_semaphore_delete+0x52>
    }

    /* Now check for invalid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
 800eecc:	687b      	ldr	r3, [r7, #4]
 800eece:	681b      	ldr	r3, [r3, #0]
 800eed0:	4a13      	ldr	r2, [pc, #76]	; (800ef20 <_txe_semaphore_delete+0x6c>)
 800eed2:	4293      	cmp	r3, r2
 800eed4:	d002      	beq.n	800eedc <_txe_semaphore_delete+0x28>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 800eed6:	230c      	movs	r3, #12
 800eed8:	617b      	str	r3, [r7, #20]
 800eeda:	e014      	b.n	800ef06 <_txe_semaphore_delete+0x52>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800eedc:	f3ef 8305 	mrs	r3, IPSR
 800eee0:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 800eee2:	68fa      	ldr	r2, [r7, #12]
    {

        /* Check for invalid caller of this function.  */

        /* Is the caller an ISR or Initialization?  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800eee4:	4b0f      	ldr	r3, [pc, #60]	; (800ef24 <_txe_semaphore_delete+0x70>)
 800eee6:	681b      	ldr	r3, [r3, #0]
 800eee8:	4313      	orrs	r3, r2
 800eeea:	2b00      	cmp	r3, #0
 800eeec:	d002      	beq.n	800eef4 <_txe_semaphore_delete+0x40>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 800eeee:	2313      	movs	r3, #19
 800eef0:	617b      	str	r3, [r7, #20]
 800eef2:	e008      	b.n	800ef06 <_txe_semaphore_delete+0x52>
#ifndef TX_TIMER_PROCESS_IN_ISR
        else
        {

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 800eef4:	4b0c      	ldr	r3, [pc, #48]	; (800ef28 <_txe_semaphore_delete+0x74>)
 800eef6:	681b      	ldr	r3, [r3, #0]
 800eef8:	613b      	str	r3, [r7, #16]

            /* Is the caller the system timer thread?  */
            if (thread_ptr == &_tx_timer_thread)
 800eefa:	693b      	ldr	r3, [r7, #16]
 800eefc:	4a0b      	ldr	r2, [pc, #44]	; (800ef2c <_txe_semaphore_delete+0x78>)
 800eefe:	4293      	cmp	r3, r2
 800ef00:	d101      	bne.n	800ef06 <_txe_semaphore_delete+0x52>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 800ef02:	2313      	movs	r3, #19
 800ef04:	617b      	str	r3, [r7, #20]
        }
#endif
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800ef06:	697b      	ldr	r3, [r7, #20]
 800ef08:	2b00      	cmp	r3, #0
 800ef0a:	d103      	bne.n	800ef14 <_txe_semaphore_delete+0x60>
    {

        /* Call actual semaphore delete function.  */
        status =  _tx_semaphore_delete(semaphore_ptr);
 800ef0c:	6878      	ldr	r0, [r7, #4]
 800ef0e:	f7fc f927 	bl	800b160 <_tx_semaphore_delete>
 800ef12:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 800ef14:	697b      	ldr	r3, [r7, #20]
}
 800ef16:	4618      	mov	r0, r3
 800ef18:	3718      	adds	r7, #24
 800ef1a:	46bd      	mov	sp, r7
 800ef1c:	bd80      	pop	{r7, pc}
 800ef1e:	bf00      	nop
 800ef20:	53454d41 	.word	0x53454d41
 800ef24:	2000000c 	.word	0x2000000c
 800ef28:	2000efb8 	.word	0x2000efb8
 800ef2c:	2000f108 	.word	0x2000f108

0800ef30 <_txe_semaphore_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_get(TX_SEMAPHORE *semaphore_ptr, ULONG wait_option)
{
 800ef30:	b580      	push	{r7, lr}
 800ef32:	b086      	sub	sp, #24
 800ef34:	af00      	add	r7, sp, #0
 800ef36:	6078      	str	r0, [r7, #4]
 800ef38:	6039      	str	r1, [r7, #0]
TX_THREAD   *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800ef3a:	2300      	movs	r3, #0
 800ef3c:	617b      	str	r3, [r7, #20]

    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
 800ef3e:	687b      	ldr	r3, [r7, #4]
 800ef40:	2b00      	cmp	r3, #0
 800ef42:	d102      	bne.n	800ef4a <_txe_semaphore_get+0x1a>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 800ef44:	230c      	movs	r3, #12
 800ef46:	617b      	str	r3, [r7, #20]
 800ef48:	e01f      	b.n	800ef8a <_txe_semaphore_get+0x5a>
    }

    /* Now check for invalid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
 800ef4a:	687b      	ldr	r3, [r7, #4]
 800ef4c:	681b      	ldr	r3, [r3, #0]
 800ef4e:	4a15      	ldr	r2, [pc, #84]	; (800efa4 <_txe_semaphore_get+0x74>)
 800ef50:	4293      	cmp	r3, r2
 800ef52:	d002      	beq.n	800ef5a <_txe_semaphore_get+0x2a>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 800ef54:	230c      	movs	r3, #12
 800ef56:	617b      	str	r3, [r7, #20]
 800ef58:	e017      	b.n	800ef8a <_txe_semaphore_get+0x5a>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
 800ef5a:	683b      	ldr	r3, [r7, #0]
 800ef5c:	2b00      	cmp	r3, #0
 800ef5e:	d014      	beq.n	800ef8a <_txe_semaphore_get+0x5a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800ef60:	f3ef 8305 	mrs	r3, IPSR
 800ef64:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 800ef66:	68fa      	ldr	r2, [r7, #12]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800ef68:	4b0f      	ldr	r3, [pc, #60]	; (800efa8 <_txe_semaphore_get+0x78>)
 800ef6a:	681b      	ldr	r3, [r3, #0]
 800ef6c:	4313      	orrs	r3, r2
 800ef6e:	2b00      	cmp	r3, #0
 800ef70:	d002      	beq.n	800ef78 <_txe_semaphore_get+0x48>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
 800ef72:	2304      	movs	r3, #4
 800ef74:	617b      	str	r3, [r7, #20]
 800ef76:	e008      	b.n	800ef8a <_txe_semaphore_get+0x5a>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
 800ef78:	4b0c      	ldr	r3, [pc, #48]	; (800efac <_txe_semaphore_get+0x7c>)
 800ef7a:	681b      	ldr	r3, [r3, #0]
 800ef7c:	613b      	str	r3, [r7, #16]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
 800ef7e:	693b      	ldr	r3, [r7, #16]
 800ef80:	4a0b      	ldr	r2, [pc, #44]	; (800efb0 <_txe_semaphore_get+0x80>)
 800ef82:	4293      	cmp	r3, r2
 800ef84:	d101      	bne.n	800ef8a <_txe_semaphore_get+0x5a>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
 800ef86:	2304      	movs	r3, #4
 800ef88:	617b      	str	r3, [r7, #20]
#endif
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800ef8a:	697b      	ldr	r3, [r7, #20]
 800ef8c:	2b00      	cmp	r3, #0
 800ef8e:	d104      	bne.n	800ef9a <_txe_semaphore_get+0x6a>
    {

        /* Call actual get semaphore function.  */
        status =  _tx_semaphore_get(semaphore_ptr, wait_option);
 800ef90:	6839      	ldr	r1, [r7, #0]
 800ef92:	6878      	ldr	r0, [r7, #4]
 800ef94:	f7fc f974 	bl	800b280 <_tx_semaphore_get>
 800ef98:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 800ef9a:	697b      	ldr	r3, [r7, #20]
}
 800ef9c:	4618      	mov	r0, r3
 800ef9e:	3718      	adds	r7, #24
 800efa0:	46bd      	mov	sp, r7
 800efa2:	bd80      	pop	{r7, pc}
 800efa4:	53454d41 	.word	0x53454d41
 800efa8:	2000000c 	.word	0x2000000c
 800efac:	2000efb8 	.word	0x2000efb8
 800efb0:	2000f108 	.word	0x2000f108

0800efb4 <_txe_semaphore_info_get>:
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_info_get(TX_SEMAPHORE *semaphore_ptr, CHAR **name, ULONG *current_value,
                    TX_THREAD **first_suspended, ULONG *suspended_count,
                    TX_SEMAPHORE **next_semaphore)
{
 800efb4:	b580      	push	{r7, lr}
 800efb6:	b088      	sub	sp, #32
 800efb8:	af02      	add	r7, sp, #8
 800efba:	60f8      	str	r0, [r7, #12]
 800efbc:	60b9      	str	r1, [r7, #8]
 800efbe:	607a      	str	r2, [r7, #4]
 800efc0:	603b      	str	r3, [r7, #0]

UINT        status;


    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
 800efc2:	68fb      	ldr	r3, [r7, #12]
 800efc4:	2b00      	cmp	r3, #0
 800efc6:	d102      	bne.n	800efce <_txe_semaphore_info_get+0x1a>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 800efc8:	230c      	movs	r3, #12
 800efca:	617b      	str	r3, [r7, #20]
 800efcc:	e012      	b.n	800eff4 <_txe_semaphore_info_get+0x40>
    }

    /* Now check for a valid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
 800efce:	68fb      	ldr	r3, [r7, #12]
 800efd0:	681b      	ldr	r3, [r3, #0]
 800efd2:	4a0b      	ldr	r2, [pc, #44]	; (800f000 <_txe_semaphore_info_get+0x4c>)
 800efd4:	4293      	cmp	r3, r2
 800efd6:	d002      	beq.n	800efde <_txe_semaphore_info_get+0x2a>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 800efd8:	230c      	movs	r3, #12
 800efda:	617b      	str	r3, [r7, #20]
 800efdc:	e00a      	b.n	800eff4 <_txe_semaphore_info_get+0x40>
    }
    else
    {

        /* Otherwise, call the actual semaphore information get service.  */
        status =  _tx_semaphore_info_get(semaphore_ptr, name, current_value, first_suspended,
 800efde:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800efe0:	9301      	str	r3, [sp, #4]
 800efe2:	6a3b      	ldr	r3, [r7, #32]
 800efe4:	9300      	str	r3, [sp, #0]
 800efe6:	683b      	ldr	r3, [r7, #0]
 800efe8:	687a      	ldr	r2, [r7, #4]
 800efea:	68b9      	ldr	r1, [r7, #8]
 800efec:	68f8      	ldr	r0, [r7, #12]
 800efee:	f7fc f9d9 	bl	800b3a4 <_tx_semaphore_info_get>
 800eff2:	6178      	str	r0, [r7, #20]
                                                                suspended_count, next_semaphore);
    }

    /* Return completion status.  */
    return(status);
 800eff4:	697b      	ldr	r3, [r7, #20]
}
 800eff6:	4618      	mov	r0, r3
 800eff8:	3718      	adds	r7, #24
 800effa:	46bd      	mov	sp, r7
 800effc:	bd80      	pop	{r7, pc}
 800effe:	bf00      	nop
 800f000:	53454d41 	.word	0x53454d41

0800f004 <_txe_semaphore_prioritize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_prioritize(TX_SEMAPHORE *semaphore_ptr)
{
 800f004:	b580      	push	{r7, lr}
 800f006:	b084      	sub	sp, #16
 800f008:	af00      	add	r7, sp, #0
 800f00a:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
 800f00c:	687b      	ldr	r3, [r7, #4]
 800f00e:	2b00      	cmp	r3, #0
 800f010:	d102      	bne.n	800f018 <_txe_semaphore_prioritize+0x14>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 800f012:	230c      	movs	r3, #12
 800f014:	60fb      	str	r3, [r7, #12]
 800f016:	e00b      	b.n	800f030 <_txe_semaphore_prioritize+0x2c>
    }

    /* Now check for a valid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
 800f018:	687b      	ldr	r3, [r7, #4]
 800f01a:	681b      	ldr	r3, [r3, #0]
 800f01c:	4a07      	ldr	r2, [pc, #28]	; (800f03c <_txe_semaphore_prioritize+0x38>)
 800f01e:	4293      	cmp	r3, r2
 800f020:	d002      	beq.n	800f028 <_txe_semaphore_prioritize+0x24>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 800f022:	230c      	movs	r3, #12
 800f024:	60fb      	str	r3, [r7, #12]
 800f026:	e003      	b.n	800f030 <_txe_semaphore_prioritize+0x2c>
    }
    else
    {

        /* Call actual semaphore prioritize function.  */
        status =  _tx_semaphore_prioritize(semaphore_ptr);
 800f028:	6878      	ldr	r0, [r7, #4]
 800f02a:	f7fc fa51 	bl	800b4d0 <_tx_semaphore_prioritize>
 800f02e:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800f030:	68fb      	ldr	r3, [r7, #12]
}
 800f032:	4618      	mov	r0, r3
 800f034:	3710      	adds	r7, #16
 800f036:	46bd      	mov	sp, r7
 800f038:	bd80      	pop	{r7, pc}
 800f03a:	bf00      	nop
 800f03c:	53454d41 	.word	0x53454d41

0800f040 <_txe_semaphore_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_put(TX_SEMAPHORE *semaphore_ptr)
{
 800f040:	b580      	push	{r7, lr}
 800f042:	b084      	sub	sp, #16
 800f044:	af00      	add	r7, sp, #0
 800f046:	6078      	str	r0, [r7, #4]

UINT        status;


    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
 800f048:	687b      	ldr	r3, [r7, #4]
 800f04a:	2b00      	cmp	r3, #0
 800f04c:	d102      	bne.n	800f054 <_txe_semaphore_put+0x14>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 800f04e:	230c      	movs	r3, #12
 800f050:	60fb      	str	r3, [r7, #12]
 800f052:	e00b      	b.n	800f06c <_txe_semaphore_put+0x2c>
    }

    /* Now check for invalid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
 800f054:	687b      	ldr	r3, [r7, #4]
 800f056:	681b      	ldr	r3, [r3, #0]
 800f058:	4a07      	ldr	r2, [pc, #28]	; (800f078 <_txe_semaphore_put+0x38>)
 800f05a:	4293      	cmp	r3, r2
 800f05c:	d002      	beq.n	800f064 <_txe_semaphore_put+0x24>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 800f05e:	230c      	movs	r3, #12
 800f060:	60fb      	str	r3, [r7, #12]
 800f062:	e003      	b.n	800f06c <_txe_semaphore_put+0x2c>
    }
    else
    {

        /* Call actual put semaphore function.  */
        status =  _tx_semaphore_put(semaphore_ptr);
 800f064:	6878      	ldr	r0, [r7, #4]
 800f066:	f7fc fae5 	bl	800b634 <_tx_semaphore_put>
 800f06a:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800f06c:	68fb      	ldr	r3, [r7, #12]
}
 800f06e:	4618      	mov	r0, r3
 800f070:	3710      	adds	r7, #16
 800f072:	46bd      	mov	sp, r7
 800f074:	bd80      	pop	{r7, pc}
 800f076:	bf00      	nop
 800f078:	53454d41 	.word	0x53454d41

0800f07c <_txe_semaphore_put_notify>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_put_notify(TX_SEMAPHORE *semaphore_ptr, VOID (*semaphore_put_notify)(TX_SEMAPHORE *notify_semaphore_ptr))
{
 800f07c:	b580      	push	{r7, lr}
 800f07e:	b084      	sub	sp, #16
 800f080:	af00      	add	r7, sp, #0
 800f082:	6078      	str	r0, [r7, #4]
 800f084:	6039      	str	r1, [r7, #0]

UINT    status;


    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
 800f086:	687b      	ldr	r3, [r7, #4]
 800f088:	2b00      	cmp	r3, #0
 800f08a:	d102      	bne.n	800f092 <_txe_semaphore_put_notify+0x16>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 800f08c:	230c      	movs	r3, #12
 800f08e:	60fb      	str	r3, [r7, #12]
 800f090:	e00c      	b.n	800f0ac <_txe_semaphore_put_notify+0x30>
    }

    /* Now check for invalid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
 800f092:	687b      	ldr	r3, [r7, #4]
 800f094:	681b      	ldr	r3, [r3, #0]
 800f096:	4a08      	ldr	r2, [pc, #32]	; (800f0b8 <_txe_semaphore_put_notify+0x3c>)
 800f098:	4293      	cmp	r3, r2
 800f09a:	d002      	beq.n	800f0a2 <_txe_semaphore_put_notify+0x26>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 800f09c:	230c      	movs	r3, #12
 800f09e:	60fb      	str	r3, [r7, #12]
 800f0a0:	e004      	b.n	800f0ac <_txe_semaphore_put_notify+0x30>
    }
    else
    {

        /* Call actual semaphore put notify function.  */
        status =  _tx_semaphore_put_notify(semaphore_ptr, semaphore_put_notify);
 800f0a2:	6839      	ldr	r1, [r7, #0]
 800f0a4:	6878      	ldr	r0, [r7, #4]
 800f0a6:	f7fc fb31 	bl	800b70c <_tx_semaphore_put_notify>
 800f0aa:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800f0ac:	68fb      	ldr	r3, [r7, #12]
}
 800f0ae:	4618      	mov	r0, r3
 800f0b0:	3710      	adds	r7, #16
 800f0b2:	46bd      	mov	sp, r7
 800f0b4:	bd80      	pop	{r7, pc}
 800f0b6:	bf00      	nop
 800f0b8:	53454d41 	.word	0x53454d41

0800f0bc <_txe_thread_create>:
UINT    _txe_thread_create(TX_THREAD *thread_ptr, CHAR *name_ptr,
                VOID (*entry_function)(ULONG id), ULONG entry_input,
                VOID *stack_start, ULONG stack_size,
                UINT priority, UINT preempt_threshold,
                ULONG time_slice, UINT auto_start, UINT thread_control_block_size)
{
 800f0bc:	b580      	push	{r7, lr}
 800f0be:	b09a      	sub	sp, #104	; 0x68
 800f0c0:	af06      	add	r7, sp, #24
 800f0c2:	60f8      	str	r0, [r7, #12]
 800f0c4:	60b9      	str	r1, [r7, #8]
 800f0c6:	607a      	str	r2, [r7, #4]
 800f0c8:	603b      	str	r3, [r7, #0]
TX_THREAD       *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800f0ca:	2300      	movs	r3, #0
 800f0cc:	64fb      	str	r3, [r7, #76]	; 0x4c

    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
 800f0ce:	68fb      	ldr	r3, [r7, #12]
 800f0d0:	2b00      	cmp	r3, #0
 800f0d2:	d102      	bne.n	800f0da <_txe_thread_create+0x1e>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f0d4:	230e      	movs	r3, #14
 800f0d6:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f0d8:	e0bb      	b.n	800f252 <_txe_thread_create+0x196>
    }

    /* Now check for invalid thread control block size.  */
    else if (thread_control_block_size != (sizeof(TX_THREAD)))
 800f0da:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800f0dc:	2be8      	cmp	r3, #232	; 0xe8
 800f0de:	d002      	beq.n	800f0e6 <_txe_thread_create+0x2a>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f0e0:	230e      	movs	r3, #14
 800f0e2:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f0e4:	e0b5      	b.n	800f252 <_txe_thread_create+0x196>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800f0e6:	f3ef 8310 	mrs	r3, PRIMASK
 800f0ea:	62bb      	str	r3, [r7, #40]	; 0x28
    return(posture);
 800f0ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
    int_posture = __get_interrupt_posture();
 800f0ee:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
 800f0f0:	b672      	cpsid	i
    return(int_posture);
 800f0f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
 800f0f4:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
 800f0f6:	4b64      	ldr	r3, [pc, #400]	; (800f288 <_txe_thread_create+0x1cc>)
 800f0f8:	681b      	ldr	r3, [r3, #0]
 800f0fa:	3301      	adds	r3, #1
 800f0fc:	4a62      	ldr	r2, [pc, #392]	; (800f288 <_txe_thread_create+0x1cc>)
 800f0fe:	6013      	str	r3, [r2, #0]
 800f100:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f102:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800f104:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f106:	f383 8810 	msr	PRIMASK, r3
}
 800f10a:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        break_flag =   TX_FALSE;
 800f10c:	2300      	movs	r3, #0
 800f10e:	64bb      	str	r3, [r7, #72]	; 0x48
        next_thread =  _tx_thread_created_ptr;
 800f110:	4b5e      	ldr	r3, [pc, #376]	; (800f28c <_txe_thread_create+0x1d0>)
 800f112:	681b      	ldr	r3, [r3, #0]
 800f114:	643b      	str	r3, [r7, #64]	; 0x40
        work_ptr =     TX_VOID_TO_UCHAR_POINTER_CONVERT(stack_start);
 800f116:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800f118:	63bb      	str	r3, [r7, #56]	; 0x38
        work_ptr =     TX_UCHAR_POINTER_ADD(work_ptr, (stack_size - ((ULONG) 1)));
 800f11a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800f11c:	3b01      	subs	r3, #1
 800f11e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800f120:	4413      	add	r3, r2
 800f122:	63bb      	str	r3, [r7, #56]	; 0x38
        stack_end =    TX_UCHAR_TO_VOID_POINTER_CONVERT(work_ptr);
 800f124:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f126:	637b      	str	r3, [r7, #52]	; 0x34
        for (i = ((ULONG) 0); i < _tx_thread_created_count; i++)
 800f128:	2300      	movs	r3, #0
 800f12a:	647b      	str	r3, [r7, #68]	; 0x44
 800f12c:	e02b      	b.n	800f186 <_txe_thread_create+0xca>
        {

            /* Determine if this thread matches the thread in the list.  */
            if (thread_ptr == next_thread)
 800f12e:	68fa      	ldr	r2, [r7, #12]
 800f130:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f132:	429a      	cmp	r2, r3
 800f134:	d101      	bne.n	800f13a <_txe_thread_create+0x7e>
            {

                /* Set the break flag.  */
                break_flag =  TX_TRUE;
 800f136:	2301      	movs	r3, #1
 800f138:	64bb      	str	r3, [r7, #72]	; 0x48
            }

            /* Determine if we need to break the loop.  */
            if (break_flag == TX_TRUE)
 800f13a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f13c:	2b01      	cmp	r3, #1
 800f13e:	d028      	beq.n	800f192 <_txe_thread_create+0xd6>
                /* Yes, break out of the loop.  */
                break;
            }

            /* Check the stack pointer to see if it overlaps with this thread's stack.  */
            if (stack_start >= next_thread -> tx_thread_stack_start)
 800f140:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f142:	68db      	ldr	r3, [r3, #12]
 800f144:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800f146:	429a      	cmp	r2, r3
 800f148:	d308      	bcc.n	800f15c <_txe_thread_create+0xa0>
            {

                if (stack_start < next_thread -> tx_thread_stack_end)
 800f14a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f14c:	691b      	ldr	r3, [r3, #16]
 800f14e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800f150:	429a      	cmp	r2, r3
 800f152:	d203      	bcs.n	800f15c <_txe_thread_create+0xa0>
                {

                    /* This stack overlaps with an existing thread, clear the stack pointer to
                       force a stack error below.  */
                    stack_start =  TX_NULL;
 800f154:	2300      	movs	r3, #0
 800f156:	65bb      	str	r3, [r7, #88]	; 0x58

                    /* Set the break flag.  */
                    break_flag =  TX_TRUE;
 800f158:	2301      	movs	r3, #1
 800f15a:	64bb      	str	r3, [r7, #72]	; 0x48
                }
            }

            /* Check the end of the stack to see if it is inside this thread's stack area as well.  */
            if (stack_end >= next_thread -> tx_thread_stack_start)
 800f15c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f15e:	68db      	ldr	r3, [r3, #12]
 800f160:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800f162:	429a      	cmp	r2, r3
 800f164:	d308      	bcc.n	800f178 <_txe_thread_create+0xbc>
            {

                if (stack_end < next_thread -> tx_thread_stack_end)
 800f166:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f168:	691b      	ldr	r3, [r3, #16]
 800f16a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800f16c:	429a      	cmp	r2, r3
 800f16e:	d203      	bcs.n	800f178 <_txe_thread_create+0xbc>
                {

                    /* This stack overlaps with an existing thread, clear the stack pointer to
                       force a stack error below.  */
                    stack_start =  TX_NULL;
 800f170:	2300      	movs	r3, #0
 800f172:	65bb      	str	r3, [r7, #88]	; 0x58

                    /* Set the break flag.  */
                    break_flag =  TX_TRUE;
 800f174:	2301      	movs	r3, #1
 800f176:	64bb      	str	r3, [r7, #72]	; 0x48
                }
            }

            /* Move to the next thread.  */
            next_thread =  next_thread -> tx_thread_created_next;
 800f178:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f17a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800f17e:	643b      	str	r3, [r7, #64]	; 0x40
        for (i = ((ULONG) 0); i < _tx_thread_created_count; i++)
 800f180:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f182:	3301      	adds	r3, #1
 800f184:	647b      	str	r3, [r7, #68]	; 0x44
 800f186:	4b42      	ldr	r3, [pc, #264]	; (800f290 <_txe_thread_create+0x1d4>)
 800f188:	681b      	ldr	r3, [r3, #0]
 800f18a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800f18c:	429a      	cmp	r2, r3
 800f18e:	d3ce      	bcc.n	800f12e <_txe_thread_create+0x72>
 800f190:	e000      	b.n	800f194 <_txe_thread_create+0xd8>
                break;
 800f192:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800f194:	f3ef 8310 	mrs	r3, PRIMASK
 800f198:	61fb      	str	r3, [r7, #28]
    return(posture);
 800f19a:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800f19c:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800f19e:	b672      	cpsid	i
    return(int_posture);
 800f1a0:	69bb      	ldr	r3, [r7, #24]
        }

        /* Disable interrupts.  */
        TX_DISABLE
 800f1a2:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
 800f1a4:	4b38      	ldr	r3, [pc, #224]	; (800f288 <_txe_thread_create+0x1cc>)
 800f1a6:	681b      	ldr	r3, [r3, #0]
 800f1a8:	3b01      	subs	r3, #1
 800f1aa:	4a37      	ldr	r2, [pc, #220]	; (800f288 <_txe_thread_create+0x1cc>)
 800f1ac:	6013      	str	r3, [r2, #0]
 800f1ae:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f1b0:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800f1b2:	6a3b      	ldr	r3, [r7, #32]
 800f1b4:	f383 8810 	msr	PRIMASK, r3
}
 800f1b8:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 800f1ba:	f7fd f8fd 	bl	800c3b8 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate thread.  */
        if (thread_ptr == next_thread)
 800f1be:	68fa      	ldr	r2, [r7, #12]
 800f1c0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f1c2:	429a      	cmp	r2, r3
 800f1c4:	d102      	bne.n	800f1cc <_txe_thread_create+0x110>
        {

            /* Thread is already created, return appropriate error code.  */
            status =  TX_THREAD_ERROR;
 800f1c6:	230e      	movs	r3, #14
 800f1c8:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f1ca:	e042      	b.n	800f252 <_txe_thread_create+0x196>
        }

        /* Check for invalid starting address of stack.  */
        else if (stack_start == TX_NULL)
 800f1cc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800f1ce:	2b00      	cmp	r3, #0
 800f1d0:	d102      	bne.n	800f1d8 <_txe_thread_create+0x11c>
        {

            /* Invalid stack or entry point, return appropriate error code.  */
            status =  TX_PTR_ERROR;
 800f1d2:	2303      	movs	r3, #3
 800f1d4:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f1d6:	e03c      	b.n	800f252 <_txe_thread_create+0x196>
        }

        /* Check for invalid thread entry point.  */
        else if (entry_function == TX_NULL)
 800f1d8:	687b      	ldr	r3, [r7, #4]
 800f1da:	2b00      	cmp	r3, #0
 800f1dc:	d102      	bne.n	800f1e4 <_txe_thread_create+0x128>
        {

            /* Invalid stack or entry point, return appropriate error code.  */
            status =  TX_PTR_ERROR;
 800f1de:	2303      	movs	r3, #3
 800f1e0:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f1e2:	e036      	b.n	800f252 <_txe_thread_create+0x196>
        }

        /* Check the stack size.  */
        else if (stack_size < ((ULONG) TX_MINIMUM_STACK))
 800f1e4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800f1e6:	2bc7      	cmp	r3, #199	; 0xc7
 800f1e8:	d802      	bhi.n	800f1f0 <_txe_thread_create+0x134>
        {

            /* Stack is not big enough, return appropriate error code.  */
            status =  TX_SIZE_ERROR;
 800f1ea:	2305      	movs	r3, #5
 800f1ec:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f1ee:	e030      	b.n	800f252 <_txe_thread_create+0x196>
        }

        /* Check the priority specified.  */
        else if (priority >= ((UINT) TX_MAX_PRIORITIES))
 800f1f0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800f1f2:	2b1f      	cmp	r3, #31
 800f1f4:	d902      	bls.n	800f1fc <_txe_thread_create+0x140>
        {

            /* Invalid priority selected, return appropriate error code.  */
            status =  TX_PRIORITY_ERROR;
 800f1f6:	230f      	movs	r3, #15
 800f1f8:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f1fa:	e02a      	b.n	800f252 <_txe_thread_create+0x196>
        }

        /* Check preemption threshold. */
        else if (preempt_threshold > priority)
 800f1fc:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800f1fe:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800f200:	429a      	cmp	r2, r3
 800f202:	d902      	bls.n	800f20a <_txe_thread_create+0x14e>
        {

            /* Invalid preempt threshold, return appropriate error code.  */
            status =  TX_THRESH_ERROR;
 800f204:	2318      	movs	r3, #24
 800f206:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f208:	e023      	b.n	800f252 <_txe_thread_create+0x196>
        }

        /* Check the start selection.  */
        else if (auto_start > TX_AUTO_START)
 800f20a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f20c:	2b01      	cmp	r3, #1
 800f20e:	d902      	bls.n	800f216 <_txe_thread_create+0x15a>
        {

            /* Invalid auto start selection, return appropriate error code.  */
            status =  TX_START_ERROR;
 800f210:	2310      	movs	r3, #16
 800f212:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f214:	e01d      	b.n	800f252 <_txe_thread_create+0x196>
        {

#ifndef TX_TIMER_PROCESS_IN_ISR

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(current_thread)
 800f216:	4b1f      	ldr	r3, [pc, #124]	; (800f294 <_txe_thread_create+0x1d8>)
 800f218:	681b      	ldr	r3, [r3, #0]
 800f21a:	633b      	str	r3, [r7, #48]	; 0x30

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (current_thread == &_tx_timer_thread)
 800f21c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f21e:	4a1e      	ldr	r2, [pc, #120]	; (800f298 <_txe_thread_create+0x1dc>)
 800f220:	4293      	cmp	r3, r2
 800f222:	d101      	bne.n	800f228 <_txe_thread_create+0x16c>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 800f224:	2313      	movs	r3, #19
 800f226:	64fb      	str	r3, [r7, #76]	; 0x4c
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800f228:	f3ef 8305 	mrs	r3, IPSR
 800f22c:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800f22e:	697a      	ldr	r2, [r7, #20]
            }
#endif

            /* Check for interrupt call.  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800f230:	4b1a      	ldr	r3, [pc, #104]	; (800f29c <_txe_thread_create+0x1e0>)
 800f232:	681b      	ldr	r3, [r3, #0]
 800f234:	4313      	orrs	r3, r2
 800f236:	2b00      	cmp	r3, #0
 800f238:	d00b      	beq.n	800f252 <_txe_thread_create+0x196>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800f23a:	f3ef 8305 	mrs	r3, IPSR
 800f23e:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
 800f240:	693a      	ldr	r2, [r7, #16]
            {

                /* Now, make sure the call is from an interrupt and not initialization.  */
                if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800f242:	4b16      	ldr	r3, [pc, #88]	; (800f29c <_txe_thread_create+0x1e0>)
 800f244:	681b      	ldr	r3, [r3, #0]
 800f246:	4313      	orrs	r3, r2
 800f248:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800f24c:	d201      	bcs.n	800f252 <_txe_thread_create+0x196>
                {

                    /* Invalid caller of this function, return appropriate error code.  */
                    status =  TX_CALLER_ERROR;
 800f24e:	2313      	movs	r3, #19
 800f250:	64fb      	str	r3, [r7, #76]	; 0x4c
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800f252:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f254:	2b00      	cmp	r3, #0
 800f256:	d112      	bne.n	800f27e <_txe_thread_create+0x1c2>
    {

        /* Call actual thread create function.  */
        status =  _tx_thread_create(thread_ptr, name_ptr, entry_function, entry_input,
 800f258:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f25a:	9305      	str	r3, [sp, #20]
 800f25c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f25e:	9304      	str	r3, [sp, #16]
 800f260:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800f262:	9303      	str	r3, [sp, #12]
 800f264:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800f266:	9302      	str	r3, [sp, #8]
 800f268:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800f26a:	9301      	str	r3, [sp, #4]
 800f26c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800f26e:	9300      	str	r3, [sp, #0]
 800f270:	683b      	ldr	r3, [r7, #0]
 800f272:	687a      	ldr	r2, [r7, #4]
 800f274:	68b9      	ldr	r1, [r7, #8]
 800f276:	68f8      	ldr	r0, [r7, #12]
 800f278:	f7fc fa66 	bl	800b748 <_tx_thread_create>
 800f27c:	64f8      	str	r0, [r7, #76]	; 0x4c
                        stack_start, stack_size, priority, preempt_threshold,
                        time_slice, auto_start);
    }

    /* Return completion status.  */
    return(status);
 800f27e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
}
 800f280:	4618      	mov	r0, r3
 800f282:	3750      	adds	r7, #80	; 0x50
 800f284:	46bd      	mov	sp, r7
 800f286:	bd80      	pop	{r7, pc}
 800f288:	2000f054 	.word	0x2000f054
 800f28c:	2000efc0 	.word	0x2000efc0
 800f290:	2000efc4 	.word	0x2000efc4
 800f294:	2000efb8 	.word	0x2000efb8
 800f298:	2000f108 	.word	0x2000f108
 800f29c:	2000000c 	.word	0x2000000c

0800f2a0 <_txe_thread_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_thread_delete(TX_THREAD *thread_ptr)
{
 800f2a0:	b580      	push	{r7, lr}
 800f2a2:	b084      	sub	sp, #16
 800f2a4:	af00      	add	r7, sp, #0
 800f2a6:	6078      	str	r0, [r7, #4]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800f2a8:	f3ef 8305 	mrs	r3, IPSR
 800f2ac:	60bb      	str	r3, [r7, #8]
    return(ipsr_value);
 800f2ae:	68ba      	ldr	r2, [r7, #8]

UINT        status;


    /* Check for invalid caller of this function.  */
    if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800f2b0:	4b0f      	ldr	r3, [pc, #60]	; (800f2f0 <_txe_thread_delete+0x50>)
 800f2b2:	681b      	ldr	r3, [r3, #0]
 800f2b4:	4313      	orrs	r3, r2
 800f2b6:	2b00      	cmp	r3, #0
 800f2b8:	d002      	beq.n	800f2c0 <_txe_thread_delete+0x20>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
 800f2ba:	2313      	movs	r3, #19
 800f2bc:	60fb      	str	r3, [r7, #12]
 800f2be:	e011      	b.n	800f2e4 <_txe_thread_delete+0x44>
    }

    /* Check for an invalid thread pointer.  */
    else if (thread_ptr == TX_NULL)
 800f2c0:	687b      	ldr	r3, [r7, #4]
 800f2c2:	2b00      	cmp	r3, #0
 800f2c4:	d102      	bne.n	800f2cc <_txe_thread_delete+0x2c>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f2c6:	230e      	movs	r3, #14
 800f2c8:	60fb      	str	r3, [r7, #12]
 800f2ca:	e00b      	b.n	800f2e4 <_txe_thread_delete+0x44>
    }

    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 800f2cc:	687b      	ldr	r3, [r7, #4]
 800f2ce:	681b      	ldr	r3, [r3, #0]
 800f2d0:	4a08      	ldr	r2, [pc, #32]	; (800f2f4 <_txe_thread_delete+0x54>)
 800f2d2:	4293      	cmp	r3, r2
 800f2d4:	d002      	beq.n	800f2dc <_txe_thread_delete+0x3c>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f2d6:	230e      	movs	r3, #14
 800f2d8:	60fb      	str	r3, [r7, #12]
 800f2da:	e003      	b.n	800f2e4 <_txe_thread_delete+0x44>
    }
    else
    {

        /* Call actual thread delete function.  */
        status =  _tx_thread_delete(thread_ptr);
 800f2dc:	6878      	ldr	r0, [r7, #4]
 800f2de:	f7fc fb1d 	bl	800b91c <_tx_thread_delete>
 800f2e2:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800f2e4:	68fb      	ldr	r3, [r7, #12]
}
 800f2e6:	4618      	mov	r0, r3
 800f2e8:	3710      	adds	r7, #16
 800f2ea:	46bd      	mov	sp, r7
 800f2ec:	bd80      	pop	{r7, pc}
 800f2ee:	bf00      	nop
 800f2f0:	2000000c 	.word	0x2000000c
 800f2f4:	54485244 	.word	0x54485244

0800f2f8 <_txe_thread_entry_exit_notify>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_thread_entry_exit_notify(TX_THREAD *thread_ptr, VOID (*thread_entry_exit_notify)(TX_THREAD *notify_thread_ptr, UINT type))
{
 800f2f8:	b580      	push	{r7, lr}
 800f2fa:	b084      	sub	sp, #16
 800f2fc:	af00      	add	r7, sp, #0
 800f2fe:	6078      	str	r0, [r7, #4]
 800f300:	6039      	str	r1, [r7, #0]

UINT    status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
 800f302:	687b      	ldr	r3, [r7, #4]
 800f304:	2b00      	cmp	r3, #0
 800f306:	d102      	bne.n	800f30e <_txe_thread_entry_exit_notify+0x16>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f308:	230e      	movs	r3, #14
 800f30a:	60fb      	str	r3, [r7, #12]
 800f30c:	e00c      	b.n	800f328 <_txe_thread_entry_exit_notify+0x30>
    }

    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 800f30e:	687b      	ldr	r3, [r7, #4]
 800f310:	681b      	ldr	r3, [r3, #0]
 800f312:	4a08      	ldr	r2, [pc, #32]	; (800f334 <_txe_thread_entry_exit_notify+0x3c>)
 800f314:	4293      	cmp	r3, r2
 800f316:	d002      	beq.n	800f31e <_txe_thread_entry_exit_notify+0x26>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f318:	230e      	movs	r3, #14
 800f31a:	60fb      	str	r3, [r7, #12]
 800f31c:	e004      	b.n	800f328 <_txe_thread_entry_exit_notify+0x30>
    }
    else
    {

        /* Call actual thread entry/exit notify function.  */
        status =  _tx_thread_entry_exit_notify(thread_ptr, thread_entry_exit_notify);
 800f31e:	6839      	ldr	r1, [r7, #0]
 800f320:	6878      	ldr	r0, [r7, #4]
 800f322:	f7fc fb55 	bl	800b9d0 <_tx_thread_entry_exit_notify>
 800f326:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800f328:	68fb      	ldr	r3, [r7, #12]
}
 800f32a:	4618      	mov	r0, r3
 800f32c:	3710      	adds	r7, #16
 800f32e:	46bd      	mov	sp, r7
 800f330:	bd80      	pop	{r7, pc}
 800f332:	bf00      	nop
 800f334:	54485244 	.word	0x54485244

0800f338 <_txe_thread_info_get>:
/*                                                                        */
/**************************************************************************/
UINT  _txe_thread_info_get(TX_THREAD *thread_ptr, CHAR **name, UINT *state, ULONG *run_count,
                UINT *priority, UINT *preemption_threshold, ULONG *time_slice,
                TX_THREAD **next_thread, TX_THREAD **next_suspended_thread)
{
 800f338:	b580      	push	{r7, lr}
 800f33a:	b08c      	sub	sp, #48	; 0x30
 800f33c:	af06      	add	r7, sp, #24
 800f33e:	60f8      	str	r0, [r7, #12]
 800f340:	60b9      	str	r1, [r7, #8]
 800f342:	607a      	str	r2, [r7, #4]
 800f344:	603b      	str	r3, [r7, #0]

UINT    status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
 800f346:	68fb      	ldr	r3, [r7, #12]
 800f348:	2b00      	cmp	r3, #0
 800f34a:	d102      	bne.n	800f352 <_txe_thread_info_get+0x1a>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f34c:	230e      	movs	r3, #14
 800f34e:	617b      	str	r3, [r7, #20]
 800f350:	e018      	b.n	800f384 <_txe_thread_info_get+0x4c>
    }

    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 800f352:	68fb      	ldr	r3, [r7, #12]
 800f354:	681b      	ldr	r3, [r3, #0]
 800f356:	4a0e      	ldr	r2, [pc, #56]	; (800f390 <_txe_thread_info_get+0x58>)
 800f358:	4293      	cmp	r3, r2
 800f35a:	d002      	beq.n	800f362 <_txe_thread_info_get+0x2a>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f35c:	230e      	movs	r3, #14
 800f35e:	617b      	str	r3, [r7, #20]
 800f360:	e010      	b.n	800f384 <_txe_thread_info_get+0x4c>
    }
    else
    {

        /* Call the actual thread information get service.  */
        status =  _tx_thread_info_get(thread_ptr, name, state, run_count, priority, preemption_threshold,
 800f362:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f364:	9304      	str	r3, [sp, #16]
 800f366:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f368:	9303      	str	r3, [sp, #12]
 800f36a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f36c:	9302      	str	r3, [sp, #8]
 800f36e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f370:	9301      	str	r3, [sp, #4]
 800f372:	6a3b      	ldr	r3, [r7, #32]
 800f374:	9300      	str	r3, [sp, #0]
 800f376:	683b      	ldr	r3, [r7, #0]
 800f378:	687a      	ldr	r2, [r7, #4]
 800f37a:	68b9      	ldr	r1, [r7, #8]
 800f37c:	68f8      	ldr	r0, [r7, #12]
 800f37e:	f7fc fb63 	bl	800ba48 <_tx_thread_info_get>
 800f382:	6178      	str	r0, [r7, #20]
                            time_slice, next_thread, next_suspended_thread);
    }

    /* Return completion status.  */
    return(status);
 800f384:	697b      	ldr	r3, [r7, #20]
}
 800f386:	4618      	mov	r0, r3
 800f388:	3718      	adds	r7, #24
 800f38a:	46bd      	mov	sp, r7
 800f38c:	bd80      	pop	{r7, pc}
 800f38e:	bf00      	nop
 800f390:	54485244 	.word	0x54485244

0800f394 <_txe_thread_preemption_change>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_thread_preemption_change(TX_THREAD *thread_ptr, UINT new_threshold, UINT *old_threshold)
{
 800f394:	b580      	push	{r7, lr}
 800f396:	b086      	sub	sp, #24
 800f398:	af00      	add	r7, sp, #0
 800f39a:	60f8      	str	r0, [r7, #12]
 800f39c:	60b9      	str	r1, [r7, #8]
 800f39e:	607a      	str	r2, [r7, #4]

UINT        status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
 800f3a0:	68fb      	ldr	r3, [r7, #12]
 800f3a2:	2b00      	cmp	r3, #0
 800f3a4:	d102      	bne.n	800f3ac <_txe_thread_preemption_change+0x18>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f3a6:	230e      	movs	r3, #14
 800f3a8:	617b      	str	r3, [r7, #20]
 800f3aa:	e028      	b.n	800f3fe <_txe_thread_preemption_change+0x6a>
    }

    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 800f3ac:	68fb      	ldr	r3, [r7, #12]
 800f3ae:	681b      	ldr	r3, [r3, #0]
 800f3b0:	4a15      	ldr	r2, [pc, #84]	; (800f408 <_txe_thread_preemption_change+0x74>)
 800f3b2:	4293      	cmp	r3, r2
 800f3b4:	d002      	beq.n	800f3bc <_txe_thread_preemption_change+0x28>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f3b6:	230e      	movs	r3, #14
 800f3b8:	617b      	str	r3, [r7, #20]
 800f3ba:	e020      	b.n	800f3fe <_txe_thread_preemption_change+0x6a>
    }

    /* Check for a valid old threshold pointer.  */
    else if (old_threshold == TX_NULL)
 800f3bc:	687b      	ldr	r3, [r7, #4]
 800f3be:	2b00      	cmp	r3, #0
 800f3c0:	d102      	bne.n	800f3c8 <_txe_thread_preemption_change+0x34>
    {

        /* Invalid destination pointer, return appropriate error code.  */
        status =  TX_PTR_ERROR;
 800f3c2:	2303      	movs	r3, #3
 800f3c4:	617b      	str	r3, [r7, #20]
 800f3c6:	e01a      	b.n	800f3fe <_txe_thread_preemption_change+0x6a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800f3c8:	f3ef 8305 	mrs	r3, IPSR
 800f3cc:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
 800f3ce:	693a      	ldr	r2, [r7, #16]
    }

    /* Check for invalid caller of this function.  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800f3d0:	4b0e      	ldr	r3, [pc, #56]	; (800f40c <_txe_thread_preemption_change+0x78>)
 800f3d2:	681b      	ldr	r3, [r3, #0]
 800f3d4:	4313      	orrs	r3, r2
 800f3d6:	2b00      	cmp	r3, #0
 800f3d8:	d002      	beq.n	800f3e0 <_txe_thread_preemption_change+0x4c>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
 800f3da:	2313      	movs	r3, #19
 800f3dc:	617b      	str	r3, [r7, #20]
 800f3de:	e00e      	b.n	800f3fe <_txe_thread_preemption_change+0x6a>
    }

    /* Determine if the preemption-threshold is valid.  */
    else if (new_threshold > thread_ptr -> tx_thread_user_priority)
 800f3e0:	68fb      	ldr	r3, [r7, #12]
 800f3e2:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 800f3e6:	68ba      	ldr	r2, [r7, #8]
 800f3e8:	429a      	cmp	r2, r3
 800f3ea:	d902      	bls.n	800f3f2 <_txe_thread_preemption_change+0x5e>
    {

        /* Return an error status.  */
        status =  TX_THRESH_ERROR;
 800f3ec:	2318      	movs	r3, #24
 800f3ee:	617b      	str	r3, [r7, #20]
 800f3f0:	e005      	b.n	800f3fe <_txe_thread_preemption_change+0x6a>
    }
    else
    {

        /* Call actual change thread preemption function.  */
        status =  _tx_thread_preemption_change(thread_ptr, new_threshold, old_threshold);
 800f3f2:	687a      	ldr	r2, [r7, #4]
 800f3f4:	68b9      	ldr	r1, [r7, #8]
 800f3f6:	68f8      	ldr	r0, [r7, #12]
 800f3f8:	f7fc fc62 	bl	800bcc0 <_tx_thread_preemption_change>
 800f3fc:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 800f3fe:	697b      	ldr	r3, [r7, #20]
}
 800f400:	4618      	mov	r0, r3
 800f402:	3718      	adds	r7, #24
 800f404:	46bd      	mov	sp, r7
 800f406:	bd80      	pop	{r7, pc}
 800f408:	54485244 	.word	0x54485244
 800f40c:	2000000c 	.word	0x2000000c

0800f410 <_txe_thread_priority_change>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_thread_priority_change(TX_THREAD *thread_ptr, UINT new_priority, UINT *old_priority)
{
 800f410:	b580      	push	{r7, lr}
 800f412:	b086      	sub	sp, #24
 800f414:	af00      	add	r7, sp, #0
 800f416:	60f8      	str	r0, [r7, #12]
 800f418:	60b9      	str	r1, [r7, #8]
 800f41a:	607a      	str	r2, [r7, #4]

UINT        status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
 800f41c:	68fb      	ldr	r3, [r7, #12]
 800f41e:	2b00      	cmp	r3, #0
 800f420:	d102      	bne.n	800f428 <_txe_thread_priority_change+0x18>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f422:	230e      	movs	r3, #14
 800f424:	617b      	str	r3, [r7, #20]
 800f426:	e025      	b.n	800f474 <_txe_thread_priority_change+0x64>
    }

    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 800f428:	68fb      	ldr	r3, [r7, #12]
 800f42a:	681b      	ldr	r3, [r3, #0]
 800f42c:	4a14      	ldr	r2, [pc, #80]	; (800f480 <_txe_thread_priority_change+0x70>)
 800f42e:	4293      	cmp	r3, r2
 800f430:	d002      	beq.n	800f438 <_txe_thread_priority_change+0x28>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f432:	230e      	movs	r3, #14
 800f434:	617b      	str	r3, [r7, #20]
 800f436:	e01d      	b.n	800f474 <_txe_thread_priority_change+0x64>
    }

    /* Check for a valid old priority pointer.  */
    else if (old_priority == TX_NULL)
 800f438:	687b      	ldr	r3, [r7, #4]
 800f43a:	2b00      	cmp	r3, #0
 800f43c:	d102      	bne.n	800f444 <_txe_thread_priority_change+0x34>
    {

        /* Invalid destination pointer, return appropriate error code.  */
        status =  TX_PTR_ERROR;
 800f43e:	2303      	movs	r3, #3
 800f440:	617b      	str	r3, [r7, #20]
 800f442:	e017      	b.n	800f474 <_txe_thread_priority_change+0x64>
    }

    /* Determine if the priority is legal.  */
    else if (new_priority >= ((UINT) TX_MAX_PRIORITIES))
 800f444:	68bb      	ldr	r3, [r7, #8]
 800f446:	2b1f      	cmp	r3, #31
 800f448:	d902      	bls.n	800f450 <_txe_thread_priority_change+0x40>
    {

        /* Return an error status.  */
        status =  TX_PRIORITY_ERROR;
 800f44a:	230f      	movs	r3, #15
 800f44c:	617b      	str	r3, [r7, #20]
 800f44e:	e011      	b.n	800f474 <_txe_thread_priority_change+0x64>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800f450:	f3ef 8305 	mrs	r3, IPSR
 800f454:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
 800f456:	693a      	ldr	r2, [r7, #16]
    }

    /* Check for invalid caller of this function.  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800f458:	4b0a      	ldr	r3, [pc, #40]	; (800f484 <_txe_thread_priority_change+0x74>)
 800f45a:	681b      	ldr	r3, [r3, #0]
 800f45c:	4313      	orrs	r3, r2
 800f45e:	2b00      	cmp	r3, #0
 800f460:	d002      	beq.n	800f468 <_txe_thread_priority_change+0x58>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
 800f462:	2313      	movs	r3, #19
 800f464:	617b      	str	r3, [r7, #20]
 800f466:	e005      	b.n	800f474 <_txe_thread_priority_change+0x64>
    }
    else
    {

        /* Call actual change thread priority function.  */
        status =  _tx_thread_priority_change(thread_ptr, new_priority, old_priority);
 800f468:	687a      	ldr	r2, [r7, #4]
 800f46a:	68b9      	ldr	r1, [r7, #8]
 800f46c:	68f8      	ldr	r0, [r7, #12]
 800f46e:	f7fc fcbf 	bl	800bdf0 <_tx_thread_priority_change>
 800f472:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 800f474:	697b      	ldr	r3, [r7, #20]
}
 800f476:	4618      	mov	r0, r3
 800f478:	3718      	adds	r7, #24
 800f47a:	46bd      	mov	sp, r7
 800f47c:	bd80      	pop	{r7, pc}
 800f47e:	bf00      	nop
 800f480:	54485244 	.word	0x54485244
 800f484:	2000000c 	.word	0x2000000c

0800f488 <_txe_thread_relinquish>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _txe_thread_relinquish(VOID)
{
 800f488:	b580      	push	{r7, lr}
 800f48a:	b082      	sub	sp, #8
 800f48c:	af00      	add	r7, sp, #0

TX_THREAD   *current_thread;


    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
 800f48e:	4b0a      	ldr	r3, [pc, #40]	; (800f4b8 <_txe_thread_relinquish+0x30>)
 800f490:	681b      	ldr	r3, [r3, #0]
 800f492:	607b      	str	r3, [r7, #4]

    /* Make sure a thread is executing.  */
    if (current_thread != TX_NULL)
 800f494:	687b      	ldr	r3, [r7, #4]
 800f496:	2b00      	cmp	r3, #0
 800f498:	d00a      	beq.n	800f4b0 <_txe_thread_relinquish+0x28>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800f49a:	f3ef 8305 	mrs	r3, IPSR
 800f49e:	603b      	str	r3, [r7, #0]
    return(ipsr_value);
 800f4a0:	683a      	ldr	r2, [r7, #0]
    {

        /* Now make sure the call is not from an ISR or Initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() == ((ULONG) 0))
 800f4a2:	4b06      	ldr	r3, [pc, #24]	; (800f4bc <_txe_thread_relinquish+0x34>)
 800f4a4:	681b      	ldr	r3, [r3, #0]
 800f4a6:	4313      	orrs	r3, r2
 800f4a8:	2b00      	cmp	r3, #0
 800f4aa:	d101      	bne.n	800f4b0 <_txe_thread_relinquish+0x28>
        {

            /* Okay to call the real relinquish function.  */
            _tx_thread_relinquish();
 800f4ac:	f7fc fd5e 	bl	800bf6c <_tx_thread_relinquish>
        }
    }
}
 800f4b0:	bf00      	nop
 800f4b2:	3708      	adds	r7, #8
 800f4b4:	46bd      	mov	sp, r7
 800f4b6:	bd80      	pop	{r7, pc}
 800f4b8:	2000efb8 	.word	0x2000efb8
 800f4bc:	2000000c 	.word	0x2000000c

0800f4c0 <_txe_thread_resume>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_thread_resume(TX_THREAD *thread_ptr)
{
 800f4c0:	b580      	push	{r7, lr}
 800f4c2:	b084      	sub	sp, #16
 800f4c4:	af00      	add	r7, sp, #0
 800f4c6:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
 800f4c8:	687b      	ldr	r3, [r7, #4]
 800f4ca:	2b00      	cmp	r3, #0
 800f4cc:	d102      	bne.n	800f4d4 <_txe_thread_resume+0x14>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f4ce:	230e      	movs	r3, #14
 800f4d0:	60fb      	str	r3, [r7, #12]
 800f4d2:	e00b      	b.n	800f4ec <_txe_thread_resume+0x2c>
    }

    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 800f4d4:	687b      	ldr	r3, [r7, #4]
 800f4d6:	681b      	ldr	r3, [r3, #0]
 800f4d8:	4a07      	ldr	r2, [pc, #28]	; (800f4f8 <_txe_thread_resume+0x38>)
 800f4da:	4293      	cmp	r3, r2
 800f4dc:	d002      	beq.n	800f4e4 <_txe_thread_resume+0x24>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f4de:	230e      	movs	r3, #14
 800f4e0:	60fb      	str	r3, [r7, #12]
 800f4e2:	e003      	b.n	800f4ec <_txe_thread_resume+0x2c>
    }
    else
    {

        /* Call actual thread resume function.  */
        status =  _tx_thread_resume(thread_ptr);
 800f4e4:	6878      	ldr	r0, [r7, #4]
 800f4e6:	f7fc fda7 	bl	800c038 <_tx_thread_resume>
 800f4ea:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800f4ec:	68fb      	ldr	r3, [r7, #12]
}
 800f4ee:	4618      	mov	r0, r3
 800f4f0:	3710      	adds	r7, #16
 800f4f2:	46bd      	mov	sp, r7
 800f4f4:	bd80      	pop	{r7, pc}
 800f4f6:	bf00      	nop
 800f4f8:	54485244 	.word	0x54485244

0800f4fc <_txe_thread_suspend>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_thread_suspend(TX_THREAD *thread_ptr)
{
 800f4fc:	b580      	push	{r7, lr}
 800f4fe:	b084      	sub	sp, #16
 800f500:	af00      	add	r7, sp, #0
 800f502:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
 800f504:	687b      	ldr	r3, [r7, #4]
 800f506:	2b00      	cmp	r3, #0
 800f508:	d102      	bne.n	800f510 <_txe_thread_suspend+0x14>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f50a:	230e      	movs	r3, #14
 800f50c:	60fb      	str	r3, [r7, #12]
 800f50e:	e00b      	b.n	800f528 <_txe_thread_suspend+0x2c>
    }

    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 800f510:	687b      	ldr	r3, [r7, #4]
 800f512:	681b      	ldr	r3, [r3, #0]
 800f514:	4a07      	ldr	r2, [pc, #28]	; (800f534 <_txe_thread_suspend+0x38>)
 800f516:	4293      	cmp	r3, r2
 800f518:	d002      	beq.n	800f520 <_txe_thread_suspend+0x24>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f51a:	230e      	movs	r3, #14
 800f51c:	60fb      	str	r3, [r7, #12]
 800f51e:	e003      	b.n	800f528 <_txe_thread_suspend+0x2c>
    }
    else
    {

        /* Call actual thread suspend function.  */
        status =  _tx_thread_suspend(thread_ptr);
 800f520:	6878      	ldr	r0, [r7, #4]
 800f522:	f7fc fed9 	bl	800c2d8 <_tx_thread_suspend>
 800f526:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800f528:	68fb      	ldr	r3, [r7, #12]
}
 800f52a:	4618      	mov	r0, r3
 800f52c:	3710      	adds	r7, #16
 800f52e:	46bd      	mov	sp, r7
 800f530:	bd80      	pop	{r7, pc}
 800f532:	bf00      	nop
 800f534:	54485244 	.word	0x54485244

0800f538 <_txe_thread_terminate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_thread_terminate(TX_THREAD *thread_ptr)
{
 800f538:	b580      	push	{r7, lr}
 800f53a:	b084      	sub	sp, #16
 800f53c:	af00      	add	r7, sp, #0
 800f53e:	6078      	str	r0, [r7, #4]

UINT        status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
 800f540:	687b      	ldr	r3, [r7, #4]
 800f542:	2b00      	cmp	r3, #0
 800f544:	d102      	bne.n	800f54c <_txe_thread_terminate+0x14>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f546:	230e      	movs	r3, #14
 800f548:	60fb      	str	r3, [r7, #12]
 800f54a:	e017      	b.n	800f57c <_txe_thread_terminate+0x44>
    }

    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 800f54c:	687b      	ldr	r3, [r7, #4]
 800f54e:	681b      	ldr	r3, [r3, #0]
 800f550:	4a0d      	ldr	r2, [pc, #52]	; (800f588 <_txe_thread_terminate+0x50>)
 800f552:	4293      	cmp	r3, r2
 800f554:	d002      	beq.n	800f55c <_txe_thread_terminate+0x24>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f556:	230e      	movs	r3, #14
 800f558:	60fb      	str	r3, [r7, #12]
 800f55a:	e00f      	b.n	800f57c <_txe_thread_terminate+0x44>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800f55c:	f3ef 8305 	mrs	r3, IPSR
 800f560:	60bb      	str	r3, [r7, #8]
    return(ipsr_value);
 800f562:	68ba      	ldr	r2, [r7, #8]
    }

    /* Check for invalid caller of this function.  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800f564:	4b09      	ldr	r3, [pc, #36]	; (800f58c <_txe_thread_terminate+0x54>)
 800f566:	681b      	ldr	r3, [r3, #0]
 800f568:	4313      	orrs	r3, r2
 800f56a:	2b00      	cmp	r3, #0
 800f56c:	d002      	beq.n	800f574 <_txe_thread_terminate+0x3c>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
 800f56e:	2313      	movs	r3, #19
 800f570:	60fb      	str	r3, [r7, #12]
 800f572:	e003      	b.n	800f57c <_txe_thread_terminate+0x44>
    }
    else
    {

        /* Call actual thread terminate function.  */
        status =  _tx_thread_terminate(thread_ptr);
 800f574:	6878      	ldr	r0, [r7, #4]
 800f576:	f7fd f9fd 	bl	800c974 <_tx_thread_terminate>
 800f57a:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800f57c:	68fb      	ldr	r3, [r7, #12]
}
 800f57e:	4618      	mov	r0, r3
 800f580:	3710      	adds	r7, #16
 800f582:	46bd      	mov	sp, r7
 800f584:	bd80      	pop	{r7, pc}
 800f586:	bf00      	nop
 800f588:	54485244 	.word	0x54485244
 800f58c:	2000000c 	.word	0x2000000c

0800f590 <_txe_thread_time_slice_change>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_thread_time_slice_change(TX_THREAD *thread_ptr, ULONG new_time_slice, ULONG *old_time_slice)
{
 800f590:	b580      	push	{r7, lr}
 800f592:	b086      	sub	sp, #24
 800f594:	af00      	add	r7, sp, #0
 800f596:	60f8      	str	r0, [r7, #12]
 800f598:	60b9      	str	r1, [r7, #8]
 800f59a:	607a      	str	r2, [r7, #4]

UINT        status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
 800f59c:	68fb      	ldr	r3, [r7, #12]
 800f59e:	2b00      	cmp	r3, #0
 800f5a0:	d102      	bne.n	800f5a8 <_txe_thread_time_slice_change+0x18>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f5a2:	230e      	movs	r3, #14
 800f5a4:	617b      	str	r3, [r7, #20]
 800f5a6:	e01f      	b.n	800f5e8 <_txe_thread_time_slice_change+0x58>
    }

    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 800f5a8:	68fb      	ldr	r3, [r7, #12]
 800f5aa:	681b      	ldr	r3, [r3, #0]
 800f5ac:	4a11      	ldr	r2, [pc, #68]	; (800f5f4 <_txe_thread_time_slice_change+0x64>)
 800f5ae:	4293      	cmp	r3, r2
 800f5b0:	d002      	beq.n	800f5b8 <_txe_thread_time_slice_change+0x28>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f5b2:	230e      	movs	r3, #14
 800f5b4:	617b      	str	r3, [r7, #20]
 800f5b6:	e017      	b.n	800f5e8 <_txe_thread_time_slice_change+0x58>
    }

    /* Check for a valid old time-slice pointer.  */
    else if (old_time_slice == TX_NULL)
 800f5b8:	687b      	ldr	r3, [r7, #4]
 800f5ba:	2b00      	cmp	r3, #0
 800f5bc:	d102      	bne.n	800f5c4 <_txe_thread_time_slice_change+0x34>
    {

        /* Invalid destination pointer, return appropriate error code.  */
        status =  TX_PTR_ERROR;
 800f5be:	2303      	movs	r3, #3
 800f5c0:	617b      	str	r3, [r7, #20]
 800f5c2:	e011      	b.n	800f5e8 <_txe_thread_time_slice_change+0x58>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800f5c4:	f3ef 8305 	mrs	r3, IPSR
 800f5c8:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
 800f5ca:	693a      	ldr	r2, [r7, #16]
    }

    /* Check for invalid caller of this function.  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800f5cc:	4b0a      	ldr	r3, [pc, #40]	; (800f5f8 <_txe_thread_time_slice_change+0x68>)
 800f5ce:	681b      	ldr	r3, [r3, #0]
 800f5d0:	4313      	orrs	r3, r2
 800f5d2:	2b00      	cmp	r3, #0
 800f5d4:	d002      	beq.n	800f5dc <_txe_thread_time_slice_change+0x4c>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
 800f5d6:	2313      	movs	r3, #19
 800f5d8:	617b      	str	r3, [r7, #20]
 800f5da:	e005      	b.n	800f5e8 <_txe_thread_time_slice_change+0x58>
    }
    else
    {

        /* Call actual change time slice function.  */
        status =  _tx_thread_time_slice_change(thread_ptr, new_time_slice, old_time_slice);
 800f5dc:	687a      	ldr	r2, [r7, #4]
 800f5de:	68b9      	ldr	r1, [r7, #8]
 800f5e0:	68f8      	ldr	r0, [r7, #12]
 800f5e2:	f7fd fba7 	bl	800cd34 <_tx_thread_time_slice_change>
 800f5e6:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 800f5e8:	697b      	ldr	r3, [r7, #20]
}
 800f5ea:	4618      	mov	r0, r3
 800f5ec:	3718      	adds	r7, #24
 800f5ee:	46bd      	mov	sp, r7
 800f5f0:	bd80      	pop	{r7, pc}
 800f5f2:	bf00      	nop
 800f5f4:	54485244 	.word	0x54485244
 800f5f8:	2000000c 	.word	0x2000000c

0800f5fc <_txe_thread_wait_abort>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_thread_wait_abort(TX_THREAD  *thread_ptr)
{
 800f5fc:	b580      	push	{r7, lr}
 800f5fe:	b084      	sub	sp, #16
 800f600:	af00      	add	r7, sp, #0
 800f602:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
 800f604:	687b      	ldr	r3, [r7, #4]
 800f606:	2b00      	cmp	r3, #0
 800f608:	d102      	bne.n	800f610 <_txe_thread_wait_abort+0x14>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f60a:	230e      	movs	r3, #14
 800f60c:	60fb      	str	r3, [r7, #12]
 800f60e:	e00b      	b.n	800f628 <_txe_thread_wait_abort+0x2c>
    }

    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 800f610:	687b      	ldr	r3, [r7, #4]
 800f612:	681b      	ldr	r3, [r3, #0]
 800f614:	4a07      	ldr	r2, [pc, #28]	; (800f634 <_txe_thread_wait_abort+0x38>)
 800f616:	4293      	cmp	r3, r2
 800f618:	d002      	beq.n	800f620 <_txe_thread_wait_abort+0x24>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 800f61a:	230e      	movs	r3, #14
 800f61c:	60fb      	str	r3, [r7, #12]
 800f61e:	e003      	b.n	800f628 <_txe_thread_wait_abort+0x2c>
    }
    else
    {

        /* Call actual thread wait abort function.  */
        status =  _tx_thread_wait_abort(thread_ptr);
 800f620:	6878      	ldr	r0, [r7, #4]
 800f622:	f7fd fbf7 	bl	800ce14 <_tx_thread_wait_abort>
 800f626:	60f8      	str	r0, [r7, #12]
    }

    /* Return status to the caller.  */
    return(status);
 800f628:	68fb      	ldr	r3, [r7, #12]
}
 800f62a:	4618      	mov	r0, r3
 800f62c:	3710      	adds	r7, #16
 800f62e:	46bd      	mov	sp, r7
 800f630:	bd80      	pop	{r7, pc}
 800f632:	bf00      	nop
 800f634:	54485244 	.word	0x54485244

0800f638 <_txe_timer_activate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_timer_activate(TX_TIMER *timer_ptr)
{
 800f638:	b580      	push	{r7, lr}
 800f63a:	b084      	sub	sp, #16
 800f63c:	af00      	add	r7, sp, #0
 800f63e:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Check for an invalid timer pointer.  */
    if (timer_ptr == TX_NULL)
 800f640:	687b      	ldr	r3, [r7, #4]
 800f642:	2b00      	cmp	r3, #0
 800f644:	d102      	bne.n	800f64c <_txe_timer_activate+0x14>
    {
        /* Timer pointer is invalid, return appropriate error code.  */
        status =  TX_TIMER_ERROR;
 800f646:	2315      	movs	r3, #21
 800f648:	60fb      	str	r3, [r7, #12]
 800f64a:	e00b      	b.n	800f664 <_txe_timer_activate+0x2c>
    }

    /* Now check for invalid timer ID.  */
    else if (timer_ptr -> tx_timer_id != TX_TIMER_ID)
 800f64c:	687b      	ldr	r3, [r7, #4]
 800f64e:	681b      	ldr	r3, [r3, #0]
 800f650:	4a07      	ldr	r2, [pc, #28]	; (800f670 <_txe_timer_activate+0x38>)
 800f652:	4293      	cmp	r3, r2
 800f654:	d002      	beq.n	800f65c <_txe_timer_activate+0x24>
    {
        /* Timer pointer is invalid, return appropriate error code.  */
        status =  TX_TIMER_ERROR;
 800f656:	2315      	movs	r3, #21
 800f658:	60fb      	str	r3, [r7, #12]
 800f65a:	e003      	b.n	800f664 <_txe_timer_activate+0x2c>
    }
    else
    {

        /* Call actual application timer activate function.  */
        status =  _tx_timer_activate(timer_ptr);
 800f65c:	6878      	ldr	r0, [r7, #4]
 800f65e:	f7fd fc8f 	bl	800cf80 <_tx_timer_activate>
 800f662:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800f664:	68fb      	ldr	r3, [r7, #12]
}
 800f666:	4618      	mov	r0, r3
 800f668:	3710      	adds	r7, #16
 800f66a:	46bd      	mov	sp, r7
 800f66c:	bd80      	pop	{r7, pc}
 800f66e:	bf00      	nop
 800f670:	4154494d 	.word	0x4154494d

0800f674 <_txe_timer_change>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_timer_change(TX_TIMER *timer_ptr, ULONG initial_ticks, ULONG reschedule_ticks)
{
 800f674:	b580      	push	{r7, lr}
 800f676:	b086      	sub	sp, #24
 800f678:	af00      	add	r7, sp, #0
 800f67a:	60f8      	str	r0, [r7, #12]
 800f67c:	60b9      	str	r1, [r7, #8]
 800f67e:	607a      	str	r2, [r7, #4]

UINT    status;


    /* Check for an invalid timer pointer.  */
    if (timer_ptr == TX_NULL)
 800f680:	68fb      	ldr	r3, [r7, #12]
 800f682:	2b00      	cmp	r3, #0
 800f684:	d102      	bne.n	800f68c <_txe_timer_change+0x18>
    {

        /* Timer pointer is invalid, return appropriate error code.  */
        status =  TX_TIMER_ERROR;
 800f686:	2315      	movs	r3, #21
 800f688:	617b      	str	r3, [r7, #20]
 800f68a:	e020      	b.n	800f6ce <_txe_timer_change+0x5a>
    }

    /* Now check for invalid timer ID.  */
    else if (timer_ptr -> tx_timer_id != TX_TIMER_ID)
 800f68c:	68fb      	ldr	r3, [r7, #12]
 800f68e:	681b      	ldr	r3, [r3, #0]
 800f690:	4a11      	ldr	r2, [pc, #68]	; (800f6d8 <_txe_timer_change+0x64>)
 800f692:	4293      	cmp	r3, r2
 800f694:	d002      	beq.n	800f69c <_txe_timer_change+0x28>
    {

        /* Timer pointer is invalid, return appropriate error code.  */
        status =  TX_TIMER_ERROR;
 800f696:	2315      	movs	r3, #21
 800f698:	617b      	str	r3, [r7, #20]
 800f69a:	e018      	b.n	800f6ce <_txe_timer_change+0x5a>
    }

    /* Check for an illegal initial tick value.  */
    else if (initial_ticks == ((ULONG) 0))
 800f69c:	68bb      	ldr	r3, [r7, #8]
 800f69e:	2b00      	cmp	r3, #0
 800f6a0:	d102      	bne.n	800f6a8 <_txe_timer_change+0x34>
    {

        /* Invalid initial tick value, return appropriate error code.  */
        status =  TX_TICK_ERROR;
 800f6a2:	2316      	movs	r3, #22
 800f6a4:	617b      	str	r3, [r7, #20]
 800f6a6:	e012      	b.n	800f6ce <_txe_timer_change+0x5a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800f6a8:	f3ef 8305 	mrs	r3, IPSR
 800f6ac:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
 800f6ae:	693a      	ldr	r2, [r7, #16]
    }

    /* Check for invalid caller of this function.  */
    else if (TX_THREAD_GET_SYSTEM_STATE() >= TX_INITIALIZE_IN_PROGRESS)
 800f6b0:	4b0a      	ldr	r3, [pc, #40]	; (800f6dc <_txe_timer_change+0x68>)
 800f6b2:	681b      	ldr	r3, [r3, #0]
 800f6b4:	4313      	orrs	r3, r2
 800f6b6:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800f6ba:	d302      	bcc.n	800f6c2 <_txe_timer_change+0x4e>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
 800f6bc:	2313      	movs	r3, #19
 800f6be:	617b      	str	r3, [r7, #20]
 800f6c0:	e005      	b.n	800f6ce <_txe_timer_change+0x5a>
    }
    else
    {

        /* Call actual application timer function.  */
        status =  _tx_timer_change(timer_ptr, initial_ticks, reschedule_ticks);
 800f6c2:	687a      	ldr	r2, [r7, #4]
 800f6c4:	68b9      	ldr	r1, [r7, #8]
 800f6c6:	68f8      	ldr	r0, [r7, #12]
 800f6c8:	f7fd fc86 	bl	800cfd8 <_tx_timer_change>
 800f6cc:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 800f6ce:	697b      	ldr	r3, [r7, #20]
}
 800f6d0:	4618      	mov	r0, r3
 800f6d2:	3718      	adds	r7, #24
 800f6d4:	46bd      	mov	sp, r7
 800f6d6:	bd80      	pop	{r7, pc}
 800f6d8:	4154494d 	.word	0x4154494d
 800f6dc:	2000000c 	.word	0x2000000c

0800f6e0 <_txe_timer_create>:
/*                                                                        */
/**************************************************************************/
UINT  _txe_timer_create(TX_TIMER *timer_ptr, CHAR *name_ptr,
            VOID (*expiration_function)(ULONG id), ULONG expiration_input,
            ULONG initial_ticks, ULONG reschedule_ticks, UINT auto_activate, UINT timer_control_block_size)
{
 800f6e0:	b580      	push	{r7, lr}
 800f6e2:	b096      	sub	sp, #88	; 0x58
 800f6e4:	af04      	add	r7, sp, #16
 800f6e6:	60f8      	str	r0, [r7, #12]
 800f6e8:	60b9      	str	r1, [r7, #8]
 800f6ea:	607a      	str	r2, [r7, #4]
 800f6ec:	603b      	str	r3, [r7, #0]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800f6ee:	2300      	movs	r3, #0
 800f6f0:	647b      	str	r3, [r7, #68]	; 0x44

    /* Check for a NULL timer pointer.  */
    if (timer_ptr == TX_NULL)
 800f6f2:	68fb      	ldr	r3, [r7, #12]
 800f6f4:	2b00      	cmp	r3, #0
 800f6f6:	d102      	bne.n	800f6fe <_txe_timer_create+0x1e>
    {

        /* Timer pointer is invalid, return appropriate error code.  */
        status =  TX_TIMER_ERROR;
 800f6f8:	2315      	movs	r3, #21
 800f6fa:	647b      	str	r3, [r7, #68]	; 0x44
 800f6fc:	e059      	b.n	800f7b2 <_txe_timer_create+0xd2>
    }

    /* Now check for invalid control block size.  */
    else if (timer_control_block_size != (sizeof(TX_TIMER)))
 800f6fe:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800f700:	2b34      	cmp	r3, #52	; 0x34
 800f702:	d002      	beq.n	800f70a <_txe_timer_create+0x2a>
    {

        /* Timer pointer is invalid, return appropriate error code.  */
        status =  TX_TIMER_ERROR;
 800f704:	2315      	movs	r3, #21
 800f706:	647b      	str	r3, [r7, #68]	; 0x44
 800f708:	e053      	b.n	800f7b2 <_txe_timer_create+0xd2>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800f70a:	f3ef 8310 	mrs	r3, PRIMASK
 800f70e:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800f710:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800f712:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800f714:	b672      	cpsid	i
    return(int_posture);
 800f716:	6abb      	ldr	r3, [r7, #40]	; 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
 800f718:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
 800f71a:	4b41      	ldr	r3, [pc, #260]	; (800f820 <_txe_timer_create+0x140>)
 800f71c:	681b      	ldr	r3, [r3, #0]
 800f71e:	3301      	adds	r3, #1
 800f720:	4a3f      	ldr	r2, [pc, #252]	; (800f820 <_txe_timer_create+0x140>)
 800f722:	6013      	str	r3, [r2, #0]
 800f724:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f726:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800f728:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f72a:	f383 8810 	msr	PRIMASK, r3
}
 800f72e:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_timer =  _tx_timer_created_ptr;
 800f730:	4b3c      	ldr	r3, [pc, #240]	; (800f824 <_txe_timer_create+0x144>)
 800f732:	681b      	ldr	r3, [r3, #0]
 800f734:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_timer_created_count; i++)
 800f736:	2300      	movs	r3, #0
 800f738:	643b      	str	r3, [r7, #64]	; 0x40
 800f73a:	e009      	b.n	800f750 <_txe_timer_create+0x70>
        {

            /* Determine if this timer matches the current timer in the list.  */
            if (timer_ptr == next_timer)
 800f73c:	68fa      	ldr	r2, [r7, #12]
 800f73e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f740:	429a      	cmp	r2, r3
 800f742:	d00b      	beq.n	800f75c <_txe_timer_create+0x7c>
            }
            else
            {

                /* Move to next timer.  */
                next_timer =  next_timer -> tx_timer_created_next;
 800f744:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f746:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f748:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_timer_created_count; i++)
 800f74a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f74c:	3301      	adds	r3, #1
 800f74e:	643b      	str	r3, [r7, #64]	; 0x40
 800f750:	4b35      	ldr	r3, [pc, #212]	; (800f828 <_txe_timer_create+0x148>)
 800f752:	681b      	ldr	r3, [r3, #0]
 800f754:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800f756:	429a      	cmp	r2, r3
 800f758:	d3f0      	bcc.n	800f73c <_txe_timer_create+0x5c>
 800f75a:	e000      	b.n	800f75e <_txe_timer_create+0x7e>
                break;
 800f75c:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800f75e:	f3ef 8310 	mrs	r3, PRIMASK
 800f762:	623b      	str	r3, [r7, #32]
    return(posture);
 800f764:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 800f766:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 800f768:	b672      	cpsid	i
    return(int_posture);
 800f76a:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
 800f76c:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
 800f76e:	4b2c      	ldr	r3, [pc, #176]	; (800f820 <_txe_timer_create+0x140>)
 800f770:	681b      	ldr	r3, [r3, #0]
 800f772:	3b01      	subs	r3, #1
 800f774:	4a2a      	ldr	r2, [pc, #168]	; (800f820 <_txe_timer_create+0x140>)
 800f776:	6013      	str	r3, [r2, #0]
 800f778:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f77a:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800f77c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f77e:	f383 8810 	msr	PRIMASK, r3
}
 800f782:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 800f784:	f7fc fe18 	bl	800c3b8 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate timer.  */
        if (timer_ptr == next_timer)
 800f788:	68fa      	ldr	r2, [r7, #12]
 800f78a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f78c:	429a      	cmp	r2, r3
 800f78e:	d102      	bne.n	800f796 <_txe_timer_create+0xb6>
        {

            /* Timer is already created, return appropriate error code.  */
            status =  TX_TIMER_ERROR;
 800f790:	2315      	movs	r3, #21
 800f792:	647b      	str	r3, [r7, #68]	; 0x44
 800f794:	e00d      	b.n	800f7b2 <_txe_timer_create+0xd2>
        }

        /* Check for an illegal initial tick value.  */
        else if (initial_ticks == ((ULONG) 0))
 800f796:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f798:	2b00      	cmp	r3, #0
 800f79a:	d102      	bne.n	800f7a2 <_txe_timer_create+0xc2>
        {

            /* Invalid initial tick value, return appropriate error code.  */
            status =  TX_TICK_ERROR;
 800f79c:	2316      	movs	r3, #22
 800f79e:	647b      	str	r3, [r7, #68]	; 0x44
 800f7a0:	e007      	b.n	800f7b2 <_txe_timer_create+0xd2>
        }
        else
        {

            /* Check for an illegal activation.  */
            if (auto_activate != TX_AUTO_ACTIVATE)
 800f7a2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800f7a4:	2b01      	cmp	r3, #1
 800f7a6:	d004      	beq.n	800f7b2 <_txe_timer_create+0xd2>
            {

                /* And activation is not the other value.  */
                if (auto_activate != TX_NO_ACTIVATE)
 800f7a8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800f7aa:	2b00      	cmp	r3, #0
 800f7ac:	d001      	beq.n	800f7b2 <_txe_timer_create+0xd2>
                {

                    /* Invalid activation selected, return appropriate error code.  */
                    status =  TX_ACTIVATE_ERROR;
 800f7ae:	2317      	movs	r3, #23
 800f7b0:	647b      	str	r3, [r7, #68]	; 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800f7b2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f7b4:	2b00      	cmp	r3, #0
 800f7b6:	d11d      	bne.n	800f7f4 <_txe_timer_create+0x114>
    {

#ifndef TX_TIMER_PROCESS_IN_ISR

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 800f7b8:	4b1c      	ldr	r3, [pc, #112]	; (800f82c <_txe_timer_create+0x14c>)
 800f7ba:	681b      	ldr	r3, [r3, #0]
 800f7bc:	637b      	str	r3, [r7, #52]	; 0x34

        /* Check for invalid caller of this function.  First check for a calling thread.  */
        if (thread_ptr == &_tx_timer_thread)
 800f7be:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f7c0:	4a1b      	ldr	r2, [pc, #108]	; (800f830 <_txe_timer_create+0x150>)
 800f7c2:	4293      	cmp	r3, r2
 800f7c4:	d101      	bne.n	800f7ca <_txe_timer_create+0xea>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 800f7c6:	2313      	movs	r3, #19
 800f7c8:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800f7ca:	f3ef 8305 	mrs	r3, IPSR
 800f7ce:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 800f7d0:	69ba      	ldr	r2, [r7, #24]
        }
#endif

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800f7d2:	4b18      	ldr	r3, [pc, #96]	; (800f834 <_txe_timer_create+0x154>)
 800f7d4:	681b      	ldr	r3, [r3, #0]
 800f7d6:	4313      	orrs	r3, r2
 800f7d8:	2b00      	cmp	r3, #0
 800f7da:	d00b      	beq.n	800f7f4 <_txe_timer_create+0x114>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800f7dc:	f3ef 8305 	mrs	r3, IPSR
 800f7e0:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800f7e2:	697a      	ldr	r2, [r7, #20]
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800f7e4:	4b13      	ldr	r3, [pc, #76]	; (800f834 <_txe_timer_create+0x154>)
 800f7e6:	681b      	ldr	r3, [r3, #0]
 800f7e8:	4313      	orrs	r3, r2
 800f7ea:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800f7ee:	d201      	bcs.n	800f7f4 <_txe_timer_create+0x114>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 800f7f0:	2313      	movs	r3, #19
 800f7f2:	647b      	str	r3, [r7, #68]	; 0x44
        }
    }


    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800f7f4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f7f6:	2b00      	cmp	r3, #0
 800f7f8:	d10c      	bne.n	800f814 <_txe_timer_create+0x134>
    {

        /* Call actual application timer create function.  */
        status =  _tx_timer_create(timer_ptr, name_ptr, expiration_function, expiration_input,
 800f7fa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800f7fc:	9302      	str	r3, [sp, #8]
 800f7fe:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f800:	9301      	str	r3, [sp, #4]
 800f802:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f804:	9300      	str	r3, [sp, #0]
 800f806:	683b      	ldr	r3, [r7, #0]
 800f808:	687a      	ldr	r2, [r7, #4]
 800f80a:	68b9      	ldr	r1, [r7, #8]
 800f80c:	68f8      	ldr	r0, [r7, #12]
 800f80e:	f7fd fc09 	bl	800d024 <_tx_timer_create>
 800f812:	6478      	str	r0, [r7, #68]	; 0x44
                                                    initial_ticks, reschedule_ticks, auto_activate);
    }

    /* Return completion status.  */
    return(status);
 800f814:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 800f816:	4618      	mov	r0, r3
 800f818:	3748      	adds	r7, #72	; 0x48
 800f81a:	46bd      	mov	sp, r7
 800f81c:	bd80      	pop	{r7, pc}
 800f81e:	bf00      	nop
 800f820:	2000f054 	.word	0x2000f054
 800f824:	2000f0fc 	.word	0x2000f0fc
 800f828:	2000f100 	.word	0x2000f100
 800f82c:	2000efb8 	.word	0x2000efb8
 800f830:	2000f108 	.word	0x2000f108
 800f834:	2000000c 	.word	0x2000000c

0800f838 <_txe_timer_deactivate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_timer_deactivate(TX_TIMER *timer_ptr)
{
 800f838:	b580      	push	{r7, lr}
 800f83a:	b084      	sub	sp, #16
 800f83c:	af00      	add	r7, sp, #0
 800f83e:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Check for an invalid timer pointer.  */
    if (timer_ptr == TX_NULL)
 800f840:	687b      	ldr	r3, [r7, #4]
 800f842:	2b00      	cmp	r3, #0
 800f844:	d102      	bne.n	800f84c <_txe_timer_deactivate+0x14>
    {

        /* Timer pointer is invalid, return appropriate error code.  */
        status =  TX_TIMER_ERROR;
 800f846:	2315      	movs	r3, #21
 800f848:	60fb      	str	r3, [r7, #12]
 800f84a:	e00b      	b.n	800f864 <_txe_timer_deactivate+0x2c>
    }

    /* Now check for invalid timer ID.  */
    else if (timer_ptr -> tx_timer_id != TX_TIMER_ID)
 800f84c:	687b      	ldr	r3, [r7, #4]
 800f84e:	681b      	ldr	r3, [r3, #0]
 800f850:	4a07      	ldr	r2, [pc, #28]	; (800f870 <_txe_timer_deactivate+0x38>)
 800f852:	4293      	cmp	r3, r2
 800f854:	d002      	beq.n	800f85c <_txe_timer_deactivate+0x24>
    {

        /* Timer pointer is invalid, return appropriate error code.  */
        status =  TX_TIMER_ERROR;
 800f856:	2315      	movs	r3, #21
 800f858:	60fb      	str	r3, [r7, #12]
 800f85a:	e003      	b.n	800f864 <_txe_timer_deactivate+0x2c>
    }
    else
    {

        /* Call actual application timer deactivate function.  */
        status =  _tx_timer_deactivate(timer_ptr);
 800f85c:	6878      	ldr	r0, [r7, #4]
 800f85e:	f7fd fc45 	bl	800d0ec <_tx_timer_deactivate>
 800f862:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 800f864:	68fb      	ldr	r3, [r7, #12]
}
 800f866:	4618      	mov	r0, r3
 800f868:	3710      	adds	r7, #16
 800f86a:	46bd      	mov	sp, r7
 800f86c:	bd80      	pop	{r7, pc}
 800f86e:	bf00      	nop
 800f870:	4154494d 	.word	0x4154494d

0800f874 <_txe_timer_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_timer_delete(TX_TIMER *timer_ptr)
{
 800f874:	b580      	push	{r7, lr}
 800f876:	b086      	sub	sp, #24
 800f878:	af00      	add	r7, sp, #0
 800f87a:	6078      	str	r0, [r7, #4]


#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Default status to success.  */
    status =  TX_SUCCESS;
 800f87c:	2300      	movs	r3, #0
 800f87e:	617b      	str	r3, [r7, #20]
#endif

    /* Check for an invalid timer pointer.  */
    if (timer_ptr == TX_NULL)
 800f880:	687b      	ldr	r3, [r7, #4]
 800f882:	2b00      	cmp	r3, #0
 800f884:	d102      	bne.n	800f88c <_txe_timer_delete+0x18>
    {
        /* Timer pointer is invalid, return appropriate error code.  */
        status =  TX_TIMER_ERROR;
 800f886:	2315      	movs	r3, #21
 800f888:	617b      	str	r3, [r7, #20]
 800f88a:	e023      	b.n	800f8d4 <_txe_timer_delete+0x60>
    }

    /* Now check for invalid timer ID.  */
    else if (timer_ptr -> tx_timer_id != TX_TIMER_ID)
 800f88c:	687b      	ldr	r3, [r7, #4]
 800f88e:	681b      	ldr	r3, [r3, #0]
 800f890:	4a13      	ldr	r2, [pc, #76]	; (800f8e0 <_txe_timer_delete+0x6c>)
 800f892:	4293      	cmp	r3, r2
 800f894:	d002      	beq.n	800f89c <_txe_timer_delete+0x28>
    {
        /* Timer pointer is invalid, return appropriate error code.  */
        status =  TX_TIMER_ERROR;
 800f896:	2315      	movs	r3, #21
 800f898:	617b      	str	r3, [r7, #20]
 800f89a:	e01b      	b.n	800f8d4 <_txe_timer_delete+0x60>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800f89c:	f3ef 8305 	mrs	r3, IPSR
 800f8a0:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 800f8a2:	68fa      	ldr	r2, [r7, #12]
    }

    /* Check for invalid caller of this function.  */

    /* Is the caller an ISR or Initialization?  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800f8a4:	4b0f      	ldr	r3, [pc, #60]	; (800f8e4 <_txe_timer_delete+0x70>)
 800f8a6:	681b      	ldr	r3, [r3, #0]
 800f8a8:	4313      	orrs	r3, r2
 800f8aa:	2b00      	cmp	r3, #0
 800f8ac:	d002      	beq.n	800f8b4 <_txe_timer_delete+0x40>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
 800f8ae:	2313      	movs	r3, #19
 800f8b0:	617b      	str	r3, [r7, #20]
 800f8b2:	e00f      	b.n	800f8d4 <_txe_timer_delete+0x60>
    {

#ifndef TX_TIMER_PROCESS_IN_ISR

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 800f8b4:	4b0c      	ldr	r3, [pc, #48]	; (800f8e8 <_txe_timer_delete+0x74>)
 800f8b6:	681b      	ldr	r3, [r3, #0]
 800f8b8:	613b      	str	r3, [r7, #16]

        /* Is the caller the system timer thread?  */
        if (thread_ptr == &_tx_timer_thread)
 800f8ba:	693b      	ldr	r3, [r7, #16]
 800f8bc:	4a0b      	ldr	r2, [pc, #44]	; (800f8ec <_txe_timer_delete+0x78>)
 800f8be:	4293      	cmp	r3, r2
 800f8c0:	d101      	bne.n	800f8c6 <_txe_timer_delete+0x52>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 800f8c2:	2313      	movs	r3, #19
 800f8c4:	617b      	str	r3, [r7, #20]
        }

        /* Determine if everything is okay.  */
        if (status == TX_SUCCESS)
 800f8c6:	697b      	ldr	r3, [r7, #20]
 800f8c8:	2b00      	cmp	r3, #0
 800f8ca:	d103      	bne.n	800f8d4 <_txe_timer_delete+0x60>
        {
#endif

            /* Call actual application timer delete function.  */
            status =  _tx_timer_delete(timer_ptr);
 800f8cc:	6878      	ldr	r0, [r7, #4]
 800f8ce:	f7fd fcb7 	bl	800d240 <_tx_timer_delete>
 800f8d2:	6178      	str	r0, [r7, #20]
        }
#endif
    }

    /* Return completion status.  */
    return(status);
 800f8d4:	697b      	ldr	r3, [r7, #20]
}
 800f8d6:	4618      	mov	r0, r3
 800f8d8:	3718      	adds	r7, #24
 800f8da:	46bd      	mov	sp, r7
 800f8dc:	bd80      	pop	{r7, pc}
 800f8de:	bf00      	nop
 800f8e0:	4154494d 	.word	0x4154494d
 800f8e4:	2000000c 	.word	0x2000000c
 800f8e8:	2000efb8 	.word	0x2000efb8
 800f8ec:	2000f108 	.word	0x2000f108

0800f8f0 <_txe_timer_info_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_timer_info_get(TX_TIMER *timer_ptr, CHAR **name, UINT *active, ULONG *remaining_ticks,
                ULONG *reschedule_ticks, TX_TIMER **next_timer)
{
 800f8f0:	b580      	push	{r7, lr}
 800f8f2:	b088      	sub	sp, #32
 800f8f4:	af02      	add	r7, sp, #8
 800f8f6:	60f8      	str	r0, [r7, #12]
 800f8f8:	60b9      	str	r1, [r7, #8]
 800f8fa:	607a      	str	r2, [r7, #4]
 800f8fc:	603b      	str	r3, [r7, #0]

UINT    status;


    /* Check for an invalid timer pointer.  */
    if (timer_ptr == TX_NULL)
 800f8fe:	68fb      	ldr	r3, [r7, #12]
 800f900:	2b00      	cmp	r3, #0
 800f902:	d102      	bne.n	800f90a <_txe_timer_info_get+0x1a>
    {

        /* Timer pointer is invalid, return appropriate error code.  */
        status =  TX_TIMER_ERROR;
 800f904:	2315      	movs	r3, #21
 800f906:	617b      	str	r3, [r7, #20]
 800f908:	e012      	b.n	800f930 <_txe_timer_info_get+0x40>
    }

    /* Now check for invalid timer ID.  */
    else if (timer_ptr -> tx_timer_id != TX_TIMER_ID)
 800f90a:	68fb      	ldr	r3, [r7, #12]
 800f90c:	681b      	ldr	r3, [r3, #0]
 800f90e:	4a0b      	ldr	r2, [pc, #44]	; (800f93c <_txe_timer_info_get+0x4c>)
 800f910:	4293      	cmp	r3, r2
 800f912:	d002      	beq.n	800f91a <_txe_timer_info_get+0x2a>
    {

        /* Timer pointer is invalid, return appropriate error code.  */
        status =  TX_TIMER_ERROR;
 800f914:	2315      	movs	r3, #21
 800f916:	617b      	str	r3, [r7, #20]
 800f918:	e00a      	b.n	800f930 <_txe_timer_info_get+0x40>
    }
    else
    {

        /* Otherwise, call the actual timer information get service.  */
        status =  _tx_timer_info_get(timer_ptr, name, active, remaining_ticks, reschedule_ticks, next_timer);
 800f91a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f91c:	9301      	str	r3, [sp, #4]
 800f91e:	6a3b      	ldr	r3, [r7, #32]
 800f920:	9300      	str	r3, [sp, #0]
 800f922:	683b      	ldr	r3, [r7, #0]
 800f924:	687a      	ldr	r2, [r7, #4]
 800f926:	68b9      	ldr	r1, [r7, #8]
 800f928:	68f8      	ldr	r0, [r7, #12]
 800f92a:	f7fd fcf3 	bl	800d314 <_tx_timer_info_get>
 800f92e:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 800f930:	697b      	ldr	r3, [r7, #20]
}
 800f932:	4618      	mov	r0, r3
 800f934:	3718      	adds	r7, #24
 800f936:	46bd      	mov	sp, r7
 800f938:	bd80      	pop	{r7, pc}
 800f93a:	bf00      	nop
 800f93c:	4154494d 	.word	0x4154494d

0800f940 <_tx_thread_stack_error_notify>:
/*                                            stack check error handling, */
/*                                            resulting in version 6.1.9  */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_stack_error_notify(VOID (*stack_error_handler)(TX_THREAD *thread_ptr))
{
 800f940:	b480      	push	{r7}
 800f942:	b087      	sub	sp, #28
 800f944:	af00      	add	r7, sp, #0
 800f946:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800f948:	f3ef 8310 	mrs	r3, PRIMASK
 800f94c:	60fb      	str	r3, [r7, #12]
    return(posture);
 800f94e:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 800f950:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 800f952:	b672      	cpsid	i
    return(int_posture);
 800f954:	68bb      	ldr	r3, [r7, #8]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts.  */
    TX_DISABLE
 800f956:	617b      	str	r3, [r7, #20]

    /* Make entry in event log.  */
    TX_EL_THREAD_STACK_ERROR_NOTIFY_INSERT

    /* Setup global thread stack error handler.  */
    _tx_thread_application_stack_error_handler =  stack_error_handler;
 800f958:	4a07      	ldr	r2, [pc, #28]	; (800f978 <_tx_thread_stack_error_notify+0x38>)
 800f95a:	687b      	ldr	r3, [r7, #4]
 800f95c:	6013      	str	r3, [r2, #0]
 800f95e:	697b      	ldr	r3, [r7, #20]
 800f960:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800f962:	693b      	ldr	r3, [r7, #16]
 800f964:	f383 8810 	msr	PRIMASK, r3
}
 800f968:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return success to caller.  */
    return(TX_SUCCESS);
 800f96a:	2300      	movs	r3, #0
#endif
}
 800f96c:	4618      	mov	r0, r3
 800f96e:	371c      	adds	r7, #28
 800f970:	46bd      	mov	sp, r7
 800f972:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f976:	4770      	bx	lr
 800f978:	2000f060 	.word	0x2000f060

0800f97c <_txe_thread_secure_stack_allocate>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
UINT    _txe_thread_secure_stack_allocate(TX_THREAD *thread_ptr, ULONG stack_size)
{
 800f97c:	b480      	push	{r7}
 800f97e:	b083      	sub	sp, #12
 800f980:	af00      	add	r7, sp, #0
 800f982:	6078      	str	r0, [r7, #4]
 800f984:	6039      	str	r1, [r7, #0]
#if defined(TX_SINGLE_MODE_SECURE) || defined(TX_SINGLE_MODE_NON_SECURE)
    return(TX_FEATURE_NOT_ENABLED);
 800f986:	23ff      	movs	r3, #255	; 0xff
    }

    /* Return completion status.  */
    return(status);
#endif
}
 800f988:	4618      	mov	r0, r3
 800f98a:	370c      	adds	r7, #12
 800f98c:	46bd      	mov	sp, r7
 800f98e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f992:	4770      	bx	lr

0800f994 <_txe_thread_secure_stack_free>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
UINT    _txe_thread_secure_stack_free(TX_THREAD *thread_ptr)
{
 800f994:	b480      	push	{r7}
 800f996:	b083      	sub	sp, #12
 800f998:	af00      	add	r7, sp, #0
 800f99a:	6078      	str	r0, [r7, #4]
#if defined(TX_SINGLE_MODE_SECURE) || defined(TX_SINGLE_MODE_NON_SECURE)
    return(TX_FEATURE_NOT_ENABLED);
 800f99c:	23ff      	movs	r3, #255	; 0xff
    }

    /* Return completion status.  */
    return(status);
#endif
}
 800f99e:	4618      	mov	r0, r3
 800f9a0:	370c      	adds	r7, #12
 800f9a2:	46bd      	mov	sp, r7
 800f9a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f9a8:	4770      	bx	lr

0800f9aa <_txm_module_manager_alignment_adjust>:
VOID  _txm_module_manager_alignment_adjust(TXM_MODULE_PREAMBLE *module_preamble,
                                           ULONG *code_size,
                                           ULONG *code_alignment,
                                           ULONG *data_size,
                                           ULONG *data_alignment)
{
 800f9aa:	b480      	push	{r7}
 800f9ac:	b085      	sub	sp, #20
 800f9ae:	af00      	add	r7, sp, #0
 800f9b0:	60f8      	str	r0, [r7, #12]
 800f9b2:	60b9      	str	r1, [r7, #8]
 800f9b4:	607a      	str	r2, [r7, #4]
 800f9b6:	603b      	str	r3, [r7, #0]

    /* Round code and data size UP to TXM_MODULE_MPU_ALIGNMENT bytes. */
    *code_size = (*code_size + TXM_MODULE_MPU_ALIGNMENT - 1) & ~(TXM_MODULE_MPU_ALIGNMENT - 1);
 800f9b8:	68bb      	ldr	r3, [r7, #8]
 800f9ba:	681b      	ldr	r3, [r3, #0]
 800f9bc:	331f      	adds	r3, #31
 800f9be:	f023 021f 	bic.w	r2, r3, #31
 800f9c2:	68bb      	ldr	r3, [r7, #8]
 800f9c4:	601a      	str	r2, [r3, #0]
    *data_size = (*data_size + TXM_MODULE_MPU_ALIGNMENT - 1) & ~(TXM_MODULE_MPU_ALIGNMENT - 1);
 800f9c6:	683b      	ldr	r3, [r7, #0]
 800f9c8:	681b      	ldr	r3, [r3, #0]
 800f9ca:	331f      	adds	r3, #31
 800f9cc:	f023 021f 	bic.w	r2, r3, #31
 800f9d0:	683b      	ldr	r3, [r7, #0]
 800f9d2:	601a      	str	r2, [r3, #0]
    
    /* Alignment for code and data is TXM_MODULE_MPU_ALIGNMENT bytes. */
    *code_alignment =   TXM_MODULE_MPU_ALIGNMENT;
 800f9d4:	687b      	ldr	r3, [r7, #4]
 800f9d6:	2220      	movs	r2, #32
 800f9d8:	601a      	str	r2, [r3, #0]
    *data_alignment =   TXM_MODULE_MPU_ALIGNMENT;
 800f9da:	69bb      	ldr	r3, [r7, #24]
 800f9dc:	2220      	movs	r2, #32
 800f9de:	601a      	str	r2, [r3, #0]
}
 800f9e0:	bf00      	nop
 800f9e2:	3714      	adds	r7, #20
 800f9e4:	46bd      	mov	sp, r7
 800f9e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f9ea:	4770      	bx	lr

0800f9ec <_txm_module_manager_application_request>:
/*                                            CALL_NOT_USED option,       */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _txm_module_manager_application_request(ULONG request_id, ALIGN_TYPE param_1, ALIGN_TYPE param_2, ALIGN_TYPE param_3)
{
 800f9ec:	b480      	push	{r7}
 800f9ee:	b085      	sub	sp, #20
 800f9f0:	af00      	add	r7, sp, #0
 800f9f2:	60f8      	str	r0, [r7, #12]
 800f9f4:	60b9      	str	r1, [r7, #8]
 800f9f6:	607a      	str	r2, [r7, #4]
 800f9f8:	603b      	str	r3, [r7, #0]
    /* By default, simply return the status of not available.  */
    return(TX_NOT_AVAILABLE);
 800f9fa:	231d      	movs	r3, #29
}
 800f9fc:	4618      	mov	r0, r3
 800f9fe:	3714      	adds	r7, #20
 800fa00:	46bd      	mov	sp, r7
 800fa02:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fa06:	4770      	bx	lr

0800fa08 <_txm_module_manager_callback_request>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
VOID  _txm_module_manager_callback_request(TX_QUEUE *module_callback_queue, TXM_MODULE_CALLBACK_MESSAGE  *callback_message)
{
 800fa08:	b580      	push	{r7, lr}
 800fa0a:	b08c      	sub	sp, #48	; 0x30
 800fa0c:	af00      	add	r7, sp, #0
 800fa0e:	6078      	str	r0, [r7, #4]
 800fa10:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800fa12:	f3ef 8310 	mrs	r3, PRIMASK
 800fa16:	61bb      	str	r3, [r7, #24]
    return(posture);
 800fa18:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800fa1a:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800fa1c:	b672      	cpsid	i
    return(int_posture);
 800fa1e:	697b      	ldr	r3, [r7, #20]
UINT                            found;
UINT                            status;


    /* Lockout interrupts.  */
    TX_DISABLE
 800fa20:	623b      	str	r3, [r7, #32]

    /* Determine if the queue is valid.  */
    if ((module_callback_queue) && (module_callback_queue -> tx_queue_id == TX_QUEUE_ID))
 800fa22:	687b      	ldr	r3, [r7, #4]
 800fa24:	2b00      	cmp	r3, #0
 800fa26:	f000 8087 	beq.w	800fb38 <_txm_module_manager_callback_request+0x130>
 800fa2a:	687b      	ldr	r3, [r7, #4]
 800fa2c:	681b      	ldr	r3, [r3, #0]
 800fa2e:	4a4a      	ldr	r2, [pc, #296]	; (800fb58 <_txm_module_manager_callback_request+0x150>)
 800fa30:	4293      	cmp	r3, r2
 800fa32:	f040 8081 	bne.w	800fb38 <_txm_module_manager_callback_request+0x130>
    {

        /* Yes, the queue is valid.  */

        /* Pickup the current callback request in the queue.  */
        queued_message =  (TXM_MODULE_CALLBACK_MESSAGE *) module_callback_queue -> tx_queue_read;
 800fa36:	687b      	ldr	r3, [r7, #4]
 800fa38:	6a1b      	ldr	r3, [r3, #32]
 800fa3a:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Pickup the number of items enqueued.  */
        enqueued =  module_callback_queue -> tx_queue_enqueued;
 800fa3c:	687b      	ldr	r3, [r7, #4]
 800fa3e:	691b      	ldr	r3, [r3, #16]
 800fa40:	62bb      	str	r3, [r7, #40]	; 0x28

        /* Set the found flag to false.  */
        found =  TX_FALSE;
 800fa42:	2300      	movs	r3, #0
 800fa44:	627b      	str	r3, [r7, #36]	; 0x24

        /* Loop to look for duplicates in the queue.  */
        while (enqueued != 0)
 800fa46:	e057      	b.n	800faf8 <_txm_module_manager_callback_request+0xf0>
        {

            /* Does this entry match the new callback message?  */
            if ((queued_message -> txm_module_callback_message_application_function == callback_message -> txm_module_callback_message_application_function) &&
 800fa48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fa4a:	689a      	ldr	r2, [r3, #8]
 800fa4c:	683b      	ldr	r3, [r7, #0]
 800fa4e:	689b      	ldr	r3, [r3, #8]
 800fa50:	429a      	cmp	r2, r3
 800fa52:	d143      	bne.n	800fadc <_txm_module_manager_callback_request+0xd4>
                (queued_message -> txm_module_callback_message_param_1 == callback_message -> txm_module_callback_message_param_1) &&
 800fa54:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fa56:	68da      	ldr	r2, [r3, #12]
 800fa58:	683b      	ldr	r3, [r7, #0]
 800fa5a:	68db      	ldr	r3, [r3, #12]
            if ((queued_message -> txm_module_callback_message_application_function == callback_message -> txm_module_callback_message_application_function) &&
 800fa5c:	429a      	cmp	r2, r3
 800fa5e:	d13d      	bne.n	800fadc <_txm_module_manager_callback_request+0xd4>
                (queued_message -> txm_module_callback_message_param_2 == callback_message -> txm_module_callback_message_param_2) &&
 800fa60:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fa62:	691a      	ldr	r2, [r3, #16]
 800fa64:	683b      	ldr	r3, [r7, #0]
 800fa66:	691b      	ldr	r3, [r3, #16]
                (queued_message -> txm_module_callback_message_param_1 == callback_message -> txm_module_callback_message_param_1) &&
 800fa68:	429a      	cmp	r2, r3
 800fa6a:	d137      	bne.n	800fadc <_txm_module_manager_callback_request+0xd4>
                (queued_message -> txm_module_callback_message_param_3 == callback_message -> txm_module_callback_message_param_3) &&
 800fa6c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fa6e:	695a      	ldr	r2, [r3, #20]
 800fa70:	683b      	ldr	r3, [r7, #0]
 800fa72:	695b      	ldr	r3, [r3, #20]
                (queued_message -> txm_module_callback_message_param_2 == callback_message -> txm_module_callback_message_param_2) &&
 800fa74:	429a      	cmp	r2, r3
 800fa76:	d131      	bne.n	800fadc <_txm_module_manager_callback_request+0xd4>
                (queued_message -> txm_module_callback_message_param_4 == callback_message -> txm_module_callback_message_param_4) &&
 800fa78:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fa7a:	699a      	ldr	r2, [r3, #24]
 800fa7c:	683b      	ldr	r3, [r7, #0]
 800fa7e:	699b      	ldr	r3, [r3, #24]
                (queued_message -> txm_module_callback_message_param_3 == callback_message -> txm_module_callback_message_param_3) &&
 800fa80:	429a      	cmp	r2, r3
 800fa82:	d12b      	bne.n	800fadc <_txm_module_manager_callback_request+0xd4>
                (queued_message -> txm_module_callback_message_param_5 == callback_message -> txm_module_callback_message_param_5) &&
 800fa84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fa86:	69da      	ldr	r2, [r3, #28]
 800fa88:	683b      	ldr	r3, [r7, #0]
 800fa8a:	69db      	ldr	r3, [r3, #28]
                (queued_message -> txm_module_callback_message_param_4 == callback_message -> txm_module_callback_message_param_4) &&
 800fa8c:	429a      	cmp	r2, r3
 800fa8e:	d125      	bne.n	800fadc <_txm_module_manager_callback_request+0xd4>
                (queued_message -> txm_module_callback_message_param_6 == callback_message -> txm_module_callback_message_param_6) &&
 800fa90:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fa92:	6a1a      	ldr	r2, [r3, #32]
 800fa94:	683b      	ldr	r3, [r7, #0]
 800fa96:	6a1b      	ldr	r3, [r3, #32]
                (queued_message -> txm_module_callback_message_param_5 == callback_message -> txm_module_callback_message_param_5) &&
 800fa98:	429a      	cmp	r2, r3
 800fa9a:	d11f      	bne.n	800fadc <_txm_module_manager_callback_request+0xd4>
                (queued_message -> txm_module_callback_message_param_7 == callback_message -> txm_module_callback_message_param_7) &&
 800fa9c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fa9e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800faa0:	683b      	ldr	r3, [r7, #0]
 800faa2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                (queued_message -> txm_module_callback_message_param_6 == callback_message -> txm_module_callback_message_param_6) &&
 800faa4:	429a      	cmp	r2, r3
 800faa6:	d119      	bne.n	800fadc <_txm_module_manager_callback_request+0xd4>
                (queued_message -> txm_module_callback_message_param_8 == callback_message -> txm_module_callback_message_param_8) &&
 800faa8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800faaa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800faac:	683b      	ldr	r3, [r7, #0]
 800faae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                (queued_message -> txm_module_callback_message_param_7 == callback_message -> txm_module_callback_message_param_7) &&
 800fab0:	429a      	cmp	r2, r3
 800fab2:	d113      	bne.n	800fadc <_txm_module_manager_callback_request+0xd4>
                (queued_message -> txm_module_callback_message_reserved1 == callback_message -> txm_module_callback_message_reserved1) &&
 800fab4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fab6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800fab8:	683b      	ldr	r3, [r7, #0]
 800faba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
                (queued_message -> txm_module_callback_message_param_8 == callback_message -> txm_module_callback_message_param_8) &&
 800fabc:	429a      	cmp	r2, r3
 800fabe:	d10d      	bne.n	800fadc <_txm_module_manager_callback_request+0xd4>
                (queued_message -> txm_module_callback_message_reserved2 == callback_message -> txm_module_callback_message_reserved2))
 800fac0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fac2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800fac4:	683b      	ldr	r3, [r7, #0]
 800fac6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
                (queued_message -> txm_module_callback_message_reserved1 == callback_message -> txm_module_callback_message_reserved1) &&
 800fac8:	429a      	cmp	r2, r3
 800faca:	d107      	bne.n	800fadc <_txm_module_manager_callback_request+0xd4>
            {

                /* Update the activation count in the queued request.  */
                queued_message -> txm_module_callback_message_activation_count++;
 800facc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800face:	685b      	ldr	r3, [r3, #4]
 800fad0:	1c5a      	adds	r2, r3, #1
 800fad2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fad4:	605a      	str	r2, [r3, #4]

                /* Set the found flag to true.  */
                found =  TX_TRUE;
 800fad6:	2301      	movs	r3, #1
 800fad8:	627b      	str	r3, [r7, #36]	; 0x24

                /* Get out of the loop.  */
                break;
 800fada:	e010      	b.n	800fafe <_txm_module_manager_callback_request+0xf6>
            }

            /* Decrease the number of messages to examine.  */
            enqueued--;
 800fadc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fade:	3b01      	subs	r3, #1
 800fae0:	62bb      	str	r3, [r7, #40]	; 0x28

            /* Move the callback message to the next message.  */
            queued_message++;
 800fae2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fae4:	3334      	adds	r3, #52	; 0x34
 800fae6:	62fb      	str	r3, [r7, #44]	; 0x2c

            /* Check for wrap?  */
            if (((ULONG *) queued_message) >= module_callback_queue -> tx_queue_end)
 800fae8:	687b      	ldr	r3, [r7, #4]
 800faea:	69db      	ldr	r3, [r3, #28]
 800faec:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800faee:	429a      	cmp	r2, r3
 800faf0:	d302      	bcc.n	800faf8 <_txm_module_manager_callback_request+0xf0>
            {

                /* Yes, set the queued message to the beginning of the queue.  */
                queued_message =  (TXM_MODULE_CALLBACK_MESSAGE *) module_callback_queue -> tx_queue_start;
 800faf2:	687b      	ldr	r3, [r7, #4]
 800faf4:	699b      	ldr	r3, [r3, #24]
 800faf6:	62fb      	str	r3, [r7, #44]	; 0x2c
        while (enqueued != 0)
 800faf8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fafa:	2b00      	cmp	r3, #0
 800fafc:	d1a4      	bne.n	800fa48 <_txm_module_manager_callback_request+0x40>
 800fafe:	6a3b      	ldr	r3, [r7, #32]
 800fb00:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800fb02:	693b      	ldr	r3, [r7, #16]
 800fb04:	f383 8810 	msr	PRIMASK, r3
}
 800fb08:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Determine if we need to send the new callback request.  */
        if (found == TX_FALSE)
 800fb0a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fb0c:	2b00      	cmp	r3, #0
 800fb0e:	d10d      	bne.n	800fb2c <_txm_module_manager_callback_request+0x124>
        {

            /* Yes, send the message.  */
            status =  _tx_queue_send(module_callback_queue, (VOID *) callback_message, TX_NO_WAIT);
 800fb10:	2200      	movs	r2, #0
 800fb12:	6839      	ldr	r1, [r7, #0]
 800fb14:	6878      	ldr	r0, [r7, #4]
 800fb16:	f7fb f86b 	bl	800abf0 <_tx_queue_send>
 800fb1a:	61f8      	str	r0, [r7, #28]

            /* Determine if an error was detected.  */
            if (status != TX_SUCCESS)
 800fb1c:	69fb      	ldr	r3, [r7, #28]
 800fb1e:	2b00      	cmp	r3, #0
 800fb20:	d004      	beq.n	800fb2c <_txm_module_manager_callback_request+0x124>
            {

                /* Error, increment the error counter and return.  */
                _txm_module_manager_callback_error_count++;
 800fb22:	4b0e      	ldr	r3, [pc, #56]	; (800fb5c <_txm_module_manager_callback_request+0x154>)
 800fb24:	681b      	ldr	r3, [r3, #0]
 800fb26:	3301      	adds	r3, #1
 800fb28:	4a0c      	ldr	r2, [pc, #48]	; (800fb5c <_txm_module_manager_callback_request+0x154>)
 800fb2a:	6013      	str	r3, [r2, #0]
            }
        }

        /* Increment the total number of callbacks.  */
        _txm_module_manager_callback_total_count++;
 800fb2c:	4b0c      	ldr	r3, [pc, #48]	; (800fb60 <_txm_module_manager_callback_request+0x158>)
 800fb2e:	681b      	ldr	r3, [r3, #0]
 800fb30:	3301      	adds	r3, #1
 800fb32:	4a0b      	ldr	r2, [pc, #44]	; (800fb60 <_txm_module_manager_callback_request+0x158>)
 800fb34:	6013      	str	r3, [r2, #0]
 800fb36:	e00a      	b.n	800fb4e <_txm_module_manager_callback_request+0x146>
    {

        /* Module instance is not valid.  */

        /* Error, increment the error counter and return.  */
        _txm_module_manager_callback_error_count++;
 800fb38:	4b08      	ldr	r3, [pc, #32]	; (800fb5c <_txm_module_manager_callback_request+0x154>)
 800fb3a:	681b      	ldr	r3, [r3, #0]
 800fb3c:	3301      	adds	r3, #1
 800fb3e:	4a07      	ldr	r2, [pc, #28]	; (800fb5c <_txm_module_manager_callback_request+0x154>)
 800fb40:	6013      	str	r3, [r2, #0]
 800fb42:	6a3b      	ldr	r3, [r7, #32]
 800fb44:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800fb46:	68fb      	ldr	r3, [r7, #12]
 800fb48:	f383 8810 	msr	PRIMASK, r3
}
 800fb4c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
    }
}
 800fb4e:	bf00      	nop
 800fb50:	3730      	adds	r7, #48	; 0x30
 800fb52:	46bd      	mov	sp, r7
 800fb54:	bd80      	pop	{r7, pc}
 800fb56:	bf00      	nop
 800fb58:	51554555 	.word	0x51554555
 800fb5c:	2000f6b8 	.word	0x2000f6b8
 800fb60:	2000f6b4 	.word	0x2000f6b4

0800fb64 <_txm_module_manager_event_flags_notify_trampoline>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
VOID  _txm_module_manager_event_flags_notify_trampoline(TX_EVENT_FLAGS_GROUP *group_ptr)
{
 800fb64:	b580      	push	{r7, lr}
 800fb66:	b096      	sub	sp, #88	; 0x58
 800fb68:	af00      	add	r7, sp, #0
 800fb6a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800fb6c:	f3ef 8310 	mrs	r3, PRIMASK
 800fb70:	64bb      	str	r3, [r7, #72]	; 0x48
    return(posture);
 800fb72:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    int_posture = __get_interrupt_posture();
 800fb74:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("CPSID i" : : : "memory");
 800fb76:	b672      	cpsid	i
    return(int_posture);
 800fb78:	6c7b      	ldr	r3, [r7, #68]	; 0x44


    /* We now know the callback is for a module.  */

    /* Disable interrupts.  */
    TX_DISABLE
 800fb7a:	657b      	str	r3, [r7, #84]	; 0x54

    /* Pickup the module instance pointer.  */
    module_instance =  (TXM_MODULE_INSTANCE *) group_ptr -> tx_event_flags_group_module_instance;
 800fb7c:	687b      	ldr	r3, [r7, #4]
 800fb7e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800fb80:	653b      	str	r3, [r7, #80]	; 0x50

    /* Determine if this module is still valid.  */
    if ((module_instance) && (module_instance -> txm_module_instance_id == TXM_MODULE_ID) &&
 800fb82:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800fb84:	2b00      	cmp	r3, #0
 800fb86:	d034      	beq.n	800fbf2 <_txm_module_manager_event_flags_notify_trampoline+0x8e>
 800fb88:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800fb8a:	681b      	ldr	r3, [r3, #0]
 800fb8c:	4a20      	ldr	r2, [pc, #128]	; (800fc10 <_txm_module_manager_event_flags_notify_trampoline+0xac>)
 800fb8e:	4293      	cmp	r3, r2
 800fb90:	d12f      	bne.n	800fbf2 <_txm_module_manager_event_flags_notify_trampoline+0x8e>
        (module_instance -> txm_module_instance_state == TXM_MODULE_STARTED))
 800fb92:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800fb94:	689b      	ldr	r3, [r3, #8]
    if ((module_instance) && (module_instance -> txm_module_instance_id == TXM_MODULE_ID) &&
 800fb96:	2b02      	cmp	r3, #2
 800fb98:	d12b      	bne.n	800fbf2 <_txm_module_manager_event_flags_notify_trampoline+0x8e>
    {

        /* Yes, the module is still valid.  */

        /* Pickup the module's callback message queue.  */
        module_callback_queue =  &(module_instance -> txm_module_instance_callback_request_queue);
 800fb9a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800fb9c:	f503 7328 	add.w	r3, r3, #672	; 0x2a0
 800fba0:	64fb      	str	r3, [r7, #76]	; 0x4c

        /* Build the queue notification message.  */
        callback_message.txm_module_callback_message_type =                  TXM_EVENTS_SET_CALLBACK;
 800fba2:	2301      	movs	r3, #1
 800fba4:	60bb      	str	r3, [r7, #8]
        callback_message.txm_module_callback_message_activation_count =      1;
 800fba6:	2301      	movs	r3, #1
 800fba8:	60fb      	str	r3, [r7, #12]
        callback_message.txm_module_callback_message_application_function =  (VOID (*)(VOID)) group_ptr -> tx_event_flags_group_set_module_notify;
 800fbaa:	687b      	ldr	r3, [r7, #4]
 800fbac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800fbae:	613b      	str	r3, [r7, #16]
        callback_message.txm_module_callback_message_param_1 =               (ALIGN_TYPE) group_ptr;
 800fbb0:	687b      	ldr	r3, [r7, #4]
 800fbb2:	617b      	str	r3, [r7, #20]
        callback_message.txm_module_callback_message_param_2 =               0;
 800fbb4:	2300      	movs	r3, #0
 800fbb6:	61bb      	str	r3, [r7, #24]
        callback_message.txm_module_callback_message_param_3 =               0;
 800fbb8:	2300      	movs	r3, #0
 800fbba:	61fb      	str	r3, [r7, #28]
        callback_message.txm_module_callback_message_param_4 =               0;
 800fbbc:	2300      	movs	r3, #0
 800fbbe:	623b      	str	r3, [r7, #32]
        callback_message.txm_module_callback_message_param_5 =               0;
 800fbc0:	2300      	movs	r3, #0
 800fbc2:	627b      	str	r3, [r7, #36]	; 0x24
        callback_message.txm_module_callback_message_param_6 =               0;
 800fbc4:	2300      	movs	r3, #0
 800fbc6:	62bb      	str	r3, [r7, #40]	; 0x28
        callback_message.txm_module_callback_message_param_7 =               0;
 800fbc8:	2300      	movs	r3, #0
 800fbca:	62fb      	str	r3, [r7, #44]	; 0x2c
        callback_message.txm_module_callback_message_param_8 =               0;
 800fbcc:	2300      	movs	r3, #0
 800fbce:	633b      	str	r3, [r7, #48]	; 0x30
        callback_message.txm_module_callback_message_reserved1 =             0;
 800fbd0:	2300      	movs	r3, #0
 800fbd2:	637b      	str	r3, [r7, #52]	; 0x34
        callback_message.txm_module_callback_message_reserved2 =             0;
 800fbd4:	2300      	movs	r3, #0
 800fbd6:	63bb      	str	r3, [r7, #56]	; 0x38
 800fbd8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fbda:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800fbdc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800fbde:	f383 8810 	msr	PRIMASK, r3
}
 800fbe2:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE

        /* Call the general processing that will place the callback on the
           module's callback request queue.  */
        _txm_module_manager_callback_request(module_callback_queue, &callback_message);
 800fbe4:	f107 0308 	add.w	r3, r7, #8
 800fbe8:	4619      	mov	r1, r3
 800fbea:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800fbec:	f7ff ff0c 	bl	800fa08 <_txm_module_manager_callback_request>
 800fbf0:	e00a      	b.n	800fc08 <_txm_module_manager_event_flags_notify_trampoline+0xa4>
    {

        /* Module no longer valid.  */

        /* Error, increment the error counter and return.  */
        _txm_module_manager_callback_error_count++;
 800fbf2:	4b08      	ldr	r3, [pc, #32]	; (800fc14 <_txm_module_manager_event_flags_notify_trampoline+0xb0>)
 800fbf4:	681b      	ldr	r3, [r3, #0]
 800fbf6:	3301      	adds	r3, #1
 800fbf8:	4a06      	ldr	r2, [pc, #24]	; (800fc14 <_txm_module_manager_event_flags_notify_trampoline+0xb0>)
 800fbfa:	6013      	str	r3, [r2, #0]
 800fbfc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fbfe:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800fc00:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800fc02:	f383 8810 	msr	PRIMASK, r3
}
 800fc06:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
    }
}
 800fc08:	bf00      	nop
 800fc0a:	3758      	adds	r7, #88	; 0x58
 800fc0c:	46bd      	mov	sp, r7
 800fc0e:	bd80      	pop	{r7, pc}
 800fc10:	4d4f4455 	.word	0x4d4f4455
 800fc14:	2000f6b8 	.word	0x2000f6b8

0800fc18 <_txm_module_manager_external_memory_enable>:
/**************************************************************************/
UINT  _txm_module_manager_external_memory_enable(TXM_MODULE_INSTANCE *module_instance,
                                                 VOID *start_address,
                                                 ULONG length,
                                                 UINT attributes)
{
 800fc18:	b580      	push	{r7, lr}
 800fc1a:	b086      	sub	sp, #24
 800fc1c:	af00      	add	r7, sp, #0
 800fc1e:	60f8      	str	r0, [r7, #12]
 800fc20:	60b9      	str	r1, [r7, #8]
 800fc22:	607a      	str	r2, [r7, #4]
 800fc24:	603b      	str	r3, [r7, #0]

ULONG   address;
ULONG   shared_index;

    /* Determine if the module manager has not been initialized yet.  */
    if (_txm_module_manager_ready != TX_TRUE)
 800fc26:	4b3c      	ldr	r3, [pc, #240]	; (800fd18 <_txm_module_manager_external_memory_enable+0x100>)
 800fc28:	681b      	ldr	r3, [r3, #0]
 800fc2a:	2b01      	cmp	r3, #1
 800fc2c:	d001      	beq.n	800fc32 <_txm_module_manager_external_memory_enable+0x1a>
    {
        /* Module manager has not been initialized.  */
        return(TX_NOT_AVAILABLE);
 800fc2e:	231d      	movs	r3, #29
 800fc30:	e06d      	b.n	800fd0e <_txm_module_manager_external_memory_enable+0xf6>
    }

    /* Determine if the module is valid.  */
    if (module_instance == TX_NULL)
 800fc32:	68fb      	ldr	r3, [r7, #12]
 800fc34:	2b00      	cmp	r3, #0
 800fc36:	d101      	bne.n	800fc3c <_txm_module_manager_external_memory_enable+0x24>
    {
        /* Invalid module pointer.  */
        return(TX_PTR_ERROR);
 800fc38:	2303      	movs	r3, #3
 800fc3a:	e068      	b.n	800fd0e <_txm_module_manager_external_memory_enable+0xf6>
    }

    /* Get module manager protection mutex.  */
    _tx_mutex_get(&_txm_module_manager_mutex, TX_WAIT_FOREVER);
 800fc3c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800fc40:	4836      	ldr	r0, [pc, #216]	; (800fd1c <_txm_module_manager_external_memory_enable+0x104>)
 800fc42:	f7f9 fbd1 	bl	80093e8 <_tx_mutex_get>

    /* Determine if the module instance is valid.  */
    if (module_instance -> txm_module_instance_id != TXM_MODULE_ID)
 800fc46:	68fb      	ldr	r3, [r7, #12]
 800fc48:	681b      	ldr	r3, [r3, #0]
 800fc4a:	4a35      	ldr	r2, [pc, #212]	; (800fd20 <_txm_module_manager_external_memory_enable+0x108>)
 800fc4c:	4293      	cmp	r3, r2
 800fc4e:	d004      	beq.n	800fc5a <_txm_module_manager_external_memory_enable+0x42>
    {
        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 800fc50:	4832      	ldr	r0, [pc, #200]	; (800fd1c <_txm_module_manager_external_memory_enable+0x104>)
 800fc52:	f7f9 ff03 	bl	8009a5c <_tx_mutex_put>

        /* Invalid module pointer.  */
        return(TX_PTR_ERROR);
 800fc56:	2303      	movs	r3, #3
 800fc58:	e059      	b.n	800fd0e <_txm_module_manager_external_memory_enable+0xf6>
    }
    
    /* Determine if the module instance is in the loaded state.  */
    if (module_instance -> txm_module_instance_state != TXM_MODULE_LOADED)
 800fc5a:	68fb      	ldr	r3, [r7, #12]
 800fc5c:	689b      	ldr	r3, [r3, #8]
 800fc5e:	2b01      	cmp	r3, #1
 800fc60:	d004      	beq.n	800fc6c <_txm_module_manager_external_memory_enable+0x54>
    {
        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 800fc62:	482e      	ldr	r0, [pc, #184]	; (800fd1c <_txm_module_manager_external_memory_enable+0x104>)
 800fc64:	f7f9 fefa 	bl	8009a5c <_tx_mutex_put>

        /* Return error if the module is not ready.  */
        return(TX_START_ERROR);
 800fc68:	2310      	movs	r3, #16
 800fc6a:	e050      	b.n	800fd0e <_txm_module_manager_external_memory_enable+0xf6>
    }
    
    /* Determine if there are shared memory entries available.  */
    if(module_instance -> txm_module_instance_shared_memory_count >= TXM_MODULE_MPU_SHARED_ENTRIES)
 800fc6c:	68fb      	ldr	r3, [r7, #12]
 800fc6e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 800fc72:	2b04      	cmp	r3, #4
 800fc74:	d904      	bls.n	800fc80 <_txm_module_manager_external_memory_enable+0x68>
    {
        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 800fc76:	4829      	ldr	r0, [pc, #164]	; (800fd1c <_txm_module_manager_external_memory_enable+0x104>)
 800fc78:	f7f9 fef0 	bl	8009a5c <_tx_mutex_put>
        
        /* No more entries available.  */
        return(TX_NO_MEMORY);
 800fc7c:	2310      	movs	r3, #16
 800fc7e:	e046      	b.n	800fd0e <_txm_module_manager_external_memory_enable+0xf6>
    }
    
    /* Start address must adhere to Cortex-M33 MPU alignment.  */
    address = (ULONG) start_address;
 800fc80:	68bb      	ldr	r3, [r7, #8]
 800fc82:	617b      	str	r3, [r7, #20]
    if(address != (address & ~(TXM_MODULE_MPU_ALIGNMENT - 1)))
 800fc84:	697b      	ldr	r3, [r7, #20]
 800fc86:	f023 031f 	bic.w	r3, r3, #31
 800fc8a:	697a      	ldr	r2, [r7, #20]
 800fc8c:	429a      	cmp	r2, r3
 800fc8e:	d004      	beq.n	800fc9a <_txm_module_manager_external_memory_enable+0x82>
    {
        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 800fc90:	4822      	ldr	r0, [pc, #136]	; (800fd1c <_txm_module_manager_external_memory_enable+0x104>)
 800fc92:	f7f9 fee3 	bl	8009a5c <_tx_mutex_put>
        
        /* Return alignment error.  */
        return(TXM_MODULE_ALIGNMENT_ERROR);
 800fc96:	23f0      	movs	r3, #240	; 0xf0
 800fc98:	e039      	b.n	800fd0e <_txm_module_manager_external_memory_enable+0xf6>
    }
    
    /* At this point, we have a valid address. Set up MPU registers.  */
    
    /* Pick up index into shared memory entries.  */
    shared_index = TXM_MODULE_MPU_SHARED_INDEX + module_instance -> txm_module_instance_shared_memory_count;
 800fc9a:	68fb      	ldr	r3, [r7, #12]
 800fc9c:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 800fca0:	3303      	adds	r3, #3
 800fca2:	613b      	str	r3, [r7, #16]
    
    /* Set base address register with start address, sanitized attributes and execute never.  */
    module_instance -> txm_module_instance_mpu_registers[shared_index].txm_module_mpu_region_base_address = address | (attributes & TXM_MODULE_ATTRIBUTE_MASK) | TXM_MODULE_ATTRIBUTE_EXECUTE_NEVER;
 800fca4:	683b      	ldr	r3, [r7, #0]
 800fca6:	f003 021e 	and.w	r2, r3, #30
 800fcaa:	697b      	ldr	r3, [r7, #20]
 800fcac:	4313      	orrs	r3, r2
 800fcae:	f043 0201 	orr.w	r2, r3, #1
 800fcb2:	68f9      	ldr	r1, [r7, #12]
 800fcb4:	693b      	ldr	r3, [r7, #16]
 800fcb6:	330c      	adds	r3, #12
 800fcb8:	00db      	lsls	r3, r3, #3
 800fcba:	440b      	add	r3, r1
 800fcbc:	605a      	str	r2, [r3, #4]
    
    /* Set the limit address (data start + length-1), attribute index, and enable bit.  */
    module_instance -> txm_module_instance_mpu_registers[shared_index].txm_module_mpu_region_limit_address = (address + length-1) | TXM_MODULE_ATTRIBUTE_INDEX | TXM_MODULE_ATTRIBUTE_REGION_ENABLE;
 800fcbe:	697a      	ldr	r2, [r7, #20]
 800fcc0:	687b      	ldr	r3, [r7, #4]
 800fcc2:	4413      	add	r3, r2
 800fcc4:	3b01      	subs	r3, #1
 800fcc6:	f043 0201 	orr.w	r2, r3, #1
 800fcca:	68f9      	ldr	r1, [r7, #12]
 800fccc:	693b      	ldr	r3, [r7, #16]
 800fcce:	330c      	adds	r3, #12
 800fcd0:	00db      	lsls	r3, r3, #3
 800fcd2:	440b      	add	r3, r1
 800fcd4:	609a      	str	r2, [r3, #8]
    
    /* Keep track of shared memory address and length in module instance.  */
    module_instance -> txm_module_instance_shared_memory_address[module_instance -> txm_module_instance_shared_memory_count] = address;
 800fcd6:	68fb      	ldr	r3, [r7, #12]
 800fcd8:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 800fcdc:	68fb      	ldr	r3, [r7, #12]
 800fcde:	322a      	adds	r2, #42	; 0x2a
 800fce0:	6979      	ldr	r1, [r7, #20]
 800fce2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    module_instance -> txm_module_instance_shared_memory_length[module_instance -> txm_module_instance_shared_memory_count] = length;
 800fce6:	68fb      	ldr	r3, [r7, #12]
 800fce8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 800fcec:	68fa      	ldr	r2, [r7, #12]
 800fcee:	332e      	adds	r3, #46	; 0x2e
 800fcf0:	009b      	lsls	r3, r3, #2
 800fcf2:	4413      	add	r3, r2
 800fcf4:	687a      	ldr	r2, [r7, #4]
 800fcf6:	605a      	str	r2, [r3, #4]
    
    /* Increment counter.  */
    module_instance -> txm_module_instance_shared_memory_count++;
 800fcf8:	68fb      	ldr	r3, [r7, #12]
 800fcfa:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 800fcfe:	1c5a      	adds	r2, r3, #1
 800fd00:	68fb      	ldr	r3, [r7, #12]
 800fd02:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
    
    /* Release the protection mutex.  */
    _tx_mutex_put(&_txm_module_manager_mutex);
 800fd06:	4805      	ldr	r0, [pc, #20]	; (800fd1c <_txm_module_manager_external_memory_enable+0x104>)
 800fd08:	f7f9 fea8 	bl	8009a5c <_tx_mutex_put>
    
    /* Return success.  */
    return(TX_SUCCESS);
 800fd0c:	2300      	movs	r3, #0
}
 800fd0e:	4618      	mov	r0, r3
 800fd10:	3718      	adds	r7, #24
 800fd12:	46bd      	mov	sp, r7
 800fd14:	bd80      	pop	{r7, pc}
 800fd16:	bf00      	nop
 800fd18:	2000f6b0 	.word	0x2000f6b0
 800fd1c:	2000f674 	.word	0x2000f674
 800fd20:	4d4f4455 	.word	0x4d4f4455

0800fd24 <_txm_module_manager_in_place_load>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
UINT  _txm_module_manager_in_place_load(TXM_MODULE_INSTANCE *module_instance, CHAR *module_name, VOID *module_location)
{
 800fd24:	b580      	push	{r7, lr}
 800fd26:	b08c      	sub	sp, #48	; 0x30
 800fd28:	af02      	add	r7, sp, #8
 800fd2a:	60f8      	str	r0, [r7, #12]
 800fd2c:	60b9      	str	r1, [r7, #8]
 800fd2e:	607a      	str	r2, [r7, #4]
ULONG                   code_allocation_size_ignored;
UINT                    status;


    /* Pickup the module's information.  */
    module_preamble =  (TXM_MODULE_PREAMBLE *) module_location;
 800fd30:	687b      	ldr	r3, [r7, #4]
 800fd32:	627b      	str	r3, [r7, #36]	; 0x24

    /* Pickup the basic module sizes.  */
    code_size =  module_preamble -> txm_module_preamble_code_size;
 800fd34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fd36:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800fd38:	623b      	str	r3, [r7, #32]

    /* Check for valid sizes.  */
    if (code_size == 0)
 800fd3a:	6a3b      	ldr	r3, [r7, #32]
 800fd3c:	2b00      	cmp	r3, #0
 800fd3e:	d101      	bne.n	800fd44 <_txm_module_manager_in_place_load+0x20>
    {

        /* Invalid module preamble.  */
        return(TXM_MODULE_INVALID);
 800fd40:	23f2      	movs	r3, #242	; 0xf2
 800fd42:	e028      	b.n	800fd96 <_txm_module_manager_in_place_load+0x72>
    }

    /* Get the amount of the bytes we need to allocate for the module's code
       as well as the required alignment. Note that because this is an in-place
       load, we only want the code alignment so we can check it.  */
    status =  _txm_module_manager_util_code_allocation_size_and_alignment_get(module_preamble, &code_alignment, &code_allocation_size_ignored);
 800fd44:	f107 0210 	add.w	r2, r7, #16
 800fd48:	f107 0314 	add.w	r3, r7, #20
 800fd4c:	4619      	mov	r1, r3
 800fd4e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800fd50:	f006 fcec 	bl	801672c <_txm_module_manager_util_code_allocation_size_and_alignment_get>
 800fd54:	61f8      	str	r0, [r7, #28]
    if (status != TX_SUCCESS)
 800fd56:	69fb      	ldr	r3, [r7, #28]
 800fd58:	2b00      	cmp	r3, #0
 800fd5a:	d001      	beq.n	800fd60 <_txm_module_manager_in_place_load+0x3c>
    {

        /* Math overflow error occurred.  */
        return(status);
 800fd5c:	69fb      	ldr	r3, [r7, #28]
 800fd5e:	e01a      	b.n	800fd96 <_txm_module_manager_in_place_load+0x72>
    }

    /* Since this is an in-place load, check the alignment of the module's instruction area (code).  */
    TXM_MODULE_MANAGER_CHECK_CODE_ALIGNMENT(module_location, code_alignment)
 800fd60:	687b      	ldr	r3, [r7, #4]
 800fd62:	61bb      	str	r3, [r7, #24]
 800fd64:	697b      	ldr	r3, [r7, #20]
 800fd66:	3b01      	subs	r3, #1
 800fd68:	69ba      	ldr	r2, [r7, #24]
 800fd6a:	4013      	ands	r3, r2
 800fd6c:	61bb      	str	r3, [r7, #24]
 800fd6e:	69bb      	ldr	r3, [r7, #24]
 800fd70:	2b00      	cmp	r3, #0
 800fd72:	d004      	beq.n	800fd7e <_txm_module_manager_in_place_load+0x5a>
 800fd74:	480a      	ldr	r0, [pc, #40]	; (800fda0 <_txm_module_manager_in_place_load+0x7c>)
 800fd76:	f7f9 fe71 	bl	8009a5c <_tx_mutex_put>
 800fd7a:	23f0      	movs	r3, #240	; 0xf0
 800fd7c:	e00b      	b.n	800fd96 <_txm_module_manager_in_place_load+0x72>

    /* Now load the module in-place.  */
    status =  _txm_module_manager_internal_load(module_instance, module_name, module_location,
 800fd7e:	2300      	movs	r3, #0
 800fd80:	9301      	str	r3, [sp, #4]
 800fd82:	2300      	movs	r3, #0
 800fd84:	9300      	str	r3, [sp, #0]
 800fd86:	6a3b      	ldr	r3, [r7, #32]
 800fd88:	687a      	ldr	r2, [r7, #4]
 800fd8a:	68b9      	ldr	r1, [r7, #8]
 800fd8c:	68f8      	ldr	r0, [r7, #12]
 800fd8e:	f000 f85f 	bl	800fe50 <_txm_module_manager_internal_load>
 800fd92:	61f8      	str	r0, [r7, #28]
                                                code_size, TX_NULL, 0);

    /* Return status.  */
    return(status);
 800fd94:	69fb      	ldr	r3, [r7, #28]
}
 800fd96:	4618      	mov	r0, r3
 800fd98:	3728      	adds	r7, #40	; 0x28
 800fd9a:	46bd      	mov	sp, r7
 800fd9c:	bd80      	pop	{r7, pc}
 800fd9e:	bf00      	nop
 800fda0:	2000f674 	.word	0x2000f674

0800fda4 <_txm_module_manager_initialize>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
UINT  _txm_module_manager_initialize(VOID *module_memory_start, ULONG module_memory_size)
{
 800fda4:	b580      	push	{r7, lr}
 800fda6:	b084      	sub	sp, #16
 800fda8:	af00      	add	r7, sp, #0
 800fdaa:	6078      	str	r0, [r7, #4]
 800fdac:	6039      	str	r1, [r7, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800fdae:	f3ef 8305 	mrs	r3, IPSR
 800fdb2:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 800fdb4:	68fa      	ldr	r2, [r7, #12]

    /* Check for interrupt call.  */
    if (TX_THREAD_GET_SYSTEM_STATE() != 0)
 800fdb6:	4b1b      	ldr	r3, [pc, #108]	; (800fe24 <_txm_module_manager_initialize+0x80>)
 800fdb8:	681b      	ldr	r3, [r3, #0]
 800fdba:	4313      	orrs	r3, r2
 800fdbc:	2b00      	cmp	r3, #0
 800fdbe:	d00b      	beq.n	800fdd8 <_txm_module_manager_initialize+0x34>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800fdc0:	f3ef 8305 	mrs	r3, IPSR
 800fdc4:	60bb      	str	r3, [r7, #8]
    return(ipsr_value);
 800fdc6:	68ba      	ldr	r2, [r7, #8]
    {

        /* Now, make sure the call is from an interrupt and not initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800fdc8:	4b16      	ldr	r3, [pc, #88]	; (800fe24 <_txm_module_manager_initialize+0x80>)
 800fdca:	681b      	ldr	r3, [r3, #0]
 800fdcc:	4313      	orrs	r3, r2
 800fdce:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800fdd2:	d201      	bcs.n	800fdd8 <_txm_module_manager_initialize+0x34>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            return(TX_CALLER_ERROR);
 800fdd4:	2313      	movs	r3, #19
 800fdd6:	e020      	b.n	800fe1a <_txm_module_manager_initialize+0x76>
        }
    }

    /* Setup the module properties supported by this module manager.  */
    _txm_module_manager_properties_supported =  TXM_MODULE_MANAGER_SUPPORTED_OPTIONS;
 800fdd8:	4b13      	ldr	r3, [pc, #76]	; (800fe28 <_txm_module_manager_initialize+0x84>)
 800fdda:	2207      	movs	r2, #7
 800fddc:	601a      	str	r2, [r3, #0]

    /* Setup the module properties required by this module manager.   */
    _txm_module_manager_properties_required =   TXM_MODULE_MANAGER_REQUIRED_OPTIONS;
 800fdde:	4b13      	ldr	r3, [pc, #76]	; (800fe2c <_txm_module_manager_initialize+0x88>)
 800fde0:	2200      	movs	r2, #0
 800fde2:	601a      	str	r2, [r3, #0]

    /* Clear the module manager ready flag.  */
    _txm_module_manager_ready =  TX_FALSE;
 800fde4:	4b12      	ldr	r3, [pc, #72]	; (800fe30 <_txm_module_manager_initialize+0x8c>)
 800fde6:	2200      	movs	r2, #0
 800fde8:	601a      	str	r2, [r3, #0]

    /* Initialize the empty module list.  */
    _txm_module_manager_loaded_list_ptr =  TX_NULL;
 800fdea:	4b12      	ldr	r3, [pc, #72]	; (800fe34 <_txm_module_manager_initialize+0x90>)
 800fdec:	2200      	movs	r2, #0
 800fdee:	601a      	str	r2, [r3, #0]

    /* Clear the number of loaded modules.  */
    _txm_module_manger_loaded_count =  0;
 800fdf0:	4b11      	ldr	r3, [pc, #68]	; (800fe38 <_txm_module_manager_initialize+0x94>)
 800fdf2:	2200      	movs	r2, #0
 800fdf4:	601a      	str	r2, [r3, #0]

    /* Create the module manager protection mutex.  */
    _tx_mutex_create(&_txm_module_manager_mutex, "Module Manager Protection Mutex", TX_NO_INHERIT);
 800fdf6:	2200      	movs	r2, #0
 800fdf8:	4910      	ldr	r1, [pc, #64]	; (800fe3c <_txm_module_manager_initialize+0x98>)
 800fdfa:	4811      	ldr	r0, [pc, #68]	; (800fe40 <_txm_module_manager_initialize+0x9c>)
 800fdfc:	f7f9 f9f0 	bl	80091e0 <_tx_mutex_create>

    /* Create a byte pool for allocating RAM areas for modules.  */
    _tx_byte_pool_create(&_txm_module_manager_byte_pool, "Module Manager Byte Pool", module_memory_start, module_memory_size);
 800fe00:	683b      	ldr	r3, [r7, #0]
 800fe02:	687a      	ldr	r2, [r7, #4]
 800fe04:	490f      	ldr	r1, [pc, #60]	; (800fe44 <_txm_module_manager_initialize+0xa0>)
 800fe06:	4810      	ldr	r0, [pc, #64]	; (800fe48 <_txm_module_manager_initialize+0xa4>)
 800fe08:	f7f7 febe 	bl	8007b88 <_tx_byte_pool_create>

    /* Indicate the module manager object pool has not been created.  */
    _txm_module_manager_object_pool_created =  TX_FALSE;
 800fe0c:	4b0f      	ldr	r3, [pc, #60]	; (800fe4c <_txm_module_manager_initialize+0xa8>)
 800fe0e:	2200      	movs	r2, #0
 800fe10:	601a      	str	r2, [r3, #0]

    /* Mark the module manager as ready!  */
    _txm_module_manager_ready =  TX_TRUE;
 800fe12:	4b07      	ldr	r3, [pc, #28]	; (800fe30 <_txm_module_manager_initialize+0x8c>)
 800fe14:	2201      	movs	r2, #1
 800fe16:	601a      	str	r2, [r3, #0]

    /* Return success.  */
    return(TX_SUCCESS);
 800fe18:	2300      	movs	r3, #0
}
 800fe1a:	4618      	mov	r0, r3
 800fe1c:	3710      	adds	r7, #16
 800fe1e:	46bd      	mov	sp, r7
 800fe20:	bd80      	pop	{r7, pc}
 800fe22:	bf00      	nop
 800fe24:	2000000c 	.word	0x2000000c
 800fe28:	2000f600 	.word	0x2000f600
 800fe2c:	2000f604 	.word	0x2000f604
 800fe30:	2000f6b0 	.word	0x2000f6b0
 800fe34:	2000f6a8 	.word	0x2000f6a8
 800fe38:	2000f6ac 	.word	0x2000f6ac
 800fe3c:	080179d4 	.word	0x080179d4
 800fe40:	2000f674 	.word	0x2000f674
 800fe44:	080179f4 	.word	0x080179f4
 800fe48:	2000f608 	.word	0x2000f608
 800fe4c:	2000f670 	.word	0x2000f670

0800fe50 <_txm_module_manager_internal_load>:
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
UINT  _txm_module_manager_internal_load(TXM_MODULE_INSTANCE *module_instance, CHAR *module_name, VOID *module_location,
                                        ULONG code_size, VOID *code_allocation_ptr, ULONG code_allocation_size)
{
 800fe50:	b580      	push	{r7, lr}
 800fe52:	b09e      	sub	sp, #120	; 0x78
 800fe54:	af02      	add	r7, sp, #8
 800fe56:	60f8      	str	r0, [r7, #12]
 800fe58:	60b9      	str	r1, [r7, #8]
 800fe5a:	607a      	str	r2, [r7, #4]
 800fe5c:	603b      	str	r3, [r7, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800fe5e:	f3ef 8305 	mrs	r3, IPSR
 800fe62:	637b      	str	r3, [r7, #52]	; 0x34
    return(ipsr_value);
 800fe64:	6b7a      	ldr	r2, [r7, #52]	; 0x34
CHAR                    *memory_ptr;
UINT                    status;


    /* Check for interrupt call.  */
    if (TX_THREAD_GET_SYSTEM_STATE() != 0)
 800fe66:	4b7c      	ldr	r3, [pc, #496]	; (8010058 <_txm_module_manager_internal_load+0x208>)
 800fe68:	681b      	ldr	r3, [r3, #0]
 800fe6a:	4313      	orrs	r3, r2
 800fe6c:	2b00      	cmp	r3, #0
 800fe6e:	d00b      	beq.n	800fe88 <_txm_module_manager_internal_load+0x38>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800fe70:	f3ef 8305 	mrs	r3, IPSR
 800fe74:	633b      	str	r3, [r7, #48]	; 0x30
    return(ipsr_value);
 800fe76:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    {

        /* Now, make sure the call is from an interrupt and not initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800fe78:	4b77      	ldr	r3, [pc, #476]	; (8010058 <_txm_module_manager_internal_load+0x208>)
 800fe7a:	681b      	ldr	r3, [r3, #0]
 800fe7c:	4313      	orrs	r3, r2
 800fe7e:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800fe82:	d201      	bcs.n	800fe88 <_txm_module_manager_internal_load+0x38>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            return(TX_CALLER_ERROR);
 800fe84:	2313      	movs	r3, #19
 800fe86:	e216      	b.n	80102b6 <_txm_module_manager_internal_load+0x466>
        }
    }

    /* Determine if the module manager has not been initialized yet.  */
    if (_txm_module_manager_ready != TX_TRUE)
 800fe88:	4b74      	ldr	r3, [pc, #464]	; (801005c <_txm_module_manager_internal_load+0x20c>)
 800fe8a:	681b      	ldr	r3, [r3, #0]
 800fe8c:	2b01      	cmp	r3, #1
 800fe8e:	d001      	beq.n	800fe94 <_txm_module_manager_internal_load+0x44>
    {

        /* Module manager has not been initialized.  */
        return(TX_NOT_AVAILABLE);
 800fe90:	231d      	movs	r3, #29
 800fe92:	e210      	b.n	80102b6 <_txm_module_manager_internal_load+0x466>
    }

    /* Determine if the module is valid.  */
    if (module_instance == TX_NULL)
 800fe94:	68fb      	ldr	r3, [r7, #12]
 800fe96:	2b00      	cmp	r3, #0
 800fe98:	d101      	bne.n	800fe9e <_txm_module_manager_internal_load+0x4e>
    {

        /* Invalid module pointer.  */
        return(TX_PTR_ERROR);
 800fe9a:	2303      	movs	r3, #3
 800fe9c:	e20b      	b.n	80102b6 <_txm_module_manager_internal_load+0x466>
    }

    /* Get module manager protection mutex.  */
    _tx_mutex_get(&_txm_module_manager_mutex, TX_WAIT_FOREVER);
 800fe9e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800fea2:	486f      	ldr	r0, [pc, #444]	; (8010060 <_txm_module_manager_internal_load+0x210>)
 800fea4:	f7f9 faa0 	bl	80093e8 <_tx_mutex_get>

    /* Determine if the module is already valid.  */
    if (module_instance -> txm_module_instance_id == TXM_MODULE_ID)
 800fea8:	68fb      	ldr	r3, [r7, #12]
 800feaa:	681b      	ldr	r3, [r3, #0]
 800feac:	4a6d      	ldr	r2, [pc, #436]	; (8010064 <_txm_module_manager_internal_load+0x214>)
 800feae:	4293      	cmp	r3, r2
 800feb0:	d104      	bne.n	800febc <_txm_module_manager_internal_load+0x6c>
    {

        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 800feb2:	486b      	ldr	r0, [pc, #428]	; (8010060 <_txm_module_manager_internal_load+0x210>)
 800feb4:	f7f9 fdd2 	bl	8009a5c <_tx_mutex_put>

        /* Module already loaded.  */
        return(TXM_MODULE_ALREADY_LOADED);
 800feb8:	23f1      	movs	r3, #241	; 0xf1
 800feba:	e1fc      	b.n	80102b6 <_txm_module_manager_internal_load+0x466>
    }

    /* Pickup the module's information.  */
    module_preamble = (TXM_MODULE_PREAMBLE *) module_location;
 800febc:	687b      	ldr	r3, [r7, #4]
 800febe:	65fb      	str	r3, [r7, #92]	; 0x5c

    /* Check to make sure there is a valid module to load.  */
    if (module_preamble -> txm_module_preamble_id != TXM_MODULE_ID)
 800fec0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800fec2:	681b      	ldr	r3, [r3, #0]
 800fec4:	4a67      	ldr	r2, [pc, #412]	; (8010064 <_txm_module_manager_internal_load+0x214>)
 800fec6:	4293      	cmp	r3, r2
 800fec8:	d004      	beq.n	800fed4 <_txm_module_manager_internal_load+0x84>
    {

        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 800feca:	4865      	ldr	r0, [pc, #404]	; (8010060 <_txm_module_manager_internal_load+0x210>)
 800fecc:	f7f9 fdc6 	bl	8009a5c <_tx_mutex_put>

        /* Invalid module preamble.  */
        return(TXM_MODULE_INVALID);
 800fed0:	23f2      	movs	r3, #242	; 0xf2
 800fed2:	e1f0      	b.n	80102b6 <_txm_module_manager_internal_load+0x466>
    }

    /* Check the properties of this module.  */
    module_properties =  module_preamble -> txm_module_preamble_property_flags & TXM_MODULE_OPTIONS_MASK;
 800fed4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800fed6:	695b      	ldr	r3, [r3, #20]
 800fed8:	b2db      	uxtb	r3, r3
 800feda:	65bb      	str	r3, [r7, #88]	; 0x58
    if (/* Ensure the requested properties are supported.  */
        ((module_properties & _txm_module_manager_properties_supported) != module_properties) ||
 800fedc:	4b62      	ldr	r3, [pc, #392]	; (8010068 <_txm_module_manager_internal_load+0x218>)
 800fede:	681a      	ldr	r2, [r3, #0]
 800fee0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800fee2:	4013      	ands	r3, r2
    if (/* Ensure the requested properties are supported.  */
 800fee4:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800fee6:	429a      	cmp	r2, r3
 800fee8:	d111      	bne.n	800ff0e <_txm_module_manager_internal_load+0xbe>
        /* Ensure the required properties are there.  */
        ((_txm_module_manager_properties_required & module_properties) != _txm_module_manager_properties_required) ||
 800feea:	4b60      	ldr	r3, [pc, #384]	; (801006c <_txm_module_manager_internal_load+0x21c>)
 800feec:	681a      	ldr	r2, [r3, #0]
 800feee:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800fef0:	401a      	ands	r2, r3
 800fef2:	4b5e      	ldr	r3, [pc, #376]	; (801006c <_txm_module_manager_internal_load+0x21c>)
 800fef4:	681b      	ldr	r3, [r3, #0]
        ((module_properties & _txm_module_manager_properties_supported) != module_properties) ||
 800fef6:	429a      	cmp	r2, r3
 800fef8:	d109      	bne.n	800ff0e <_txm_module_manager_internal_load+0xbe>
        /* If memory protection is enabled, then so must user mode.  */
        ((module_properties & TXM_MODULE_MEMORY_PROTECTION) && !(module_properties & TXM_MODULE_USER_MODE))
 800fefa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800fefc:	f003 0302 	and.w	r3, r3, #2
        ((_txm_module_manager_properties_required & module_properties) != _txm_module_manager_properties_required) ||
 800ff00:	2b00      	cmp	r3, #0
 800ff02:	d009      	beq.n	800ff18 <_txm_module_manager_internal_load+0xc8>
        ((module_properties & TXM_MODULE_MEMORY_PROTECTION) && !(module_properties & TXM_MODULE_USER_MODE))
 800ff04:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800ff06:	f003 0301 	and.w	r3, r3, #1
 800ff0a:	2b00      	cmp	r3, #0
 800ff0c:	d104      	bne.n	800ff18 <_txm_module_manager_internal_load+0xc8>
        )
    {

        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 800ff0e:	4854      	ldr	r0, [pc, #336]	; (8010060 <_txm_module_manager_internal_load+0x210>)
 800ff10:	f7f9 fda4 	bl	8009a5c <_tx_mutex_put>

        /* Invalid properties. Return error.  */
        return(TXM_MODULE_INVALID_PROPERTIES);
 800ff14:	23f3      	movs	r3, #243	; 0xf3
 800ff16:	e1ce      	b.n	80102b6 <_txm_module_manager_internal_load+0x466>
    }

    /* Check for valid module entry offsets.  */
    if ((module_preamble -> txm_module_preamble_shell_entry_function == 0) ||
 800ff18:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ff1a:	699b      	ldr	r3, [r3, #24]
 800ff1c:	2b00      	cmp	r3, #0
 800ff1e:	d003      	beq.n	800ff28 <_txm_module_manager_internal_load+0xd8>
        (module_preamble -> txm_module_preamble_start_function == 0))
 800ff20:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ff22:	69db      	ldr	r3, [r3, #28]
    if ((module_preamble -> txm_module_preamble_shell_entry_function == 0) ||
 800ff24:	2b00      	cmp	r3, #0
 800ff26:	d104      	bne.n	800ff32 <_txm_module_manager_internal_load+0xe2>
    {

        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 800ff28:	484d      	ldr	r0, [pc, #308]	; (8010060 <_txm_module_manager_internal_load+0x210>)
 800ff2a:	f7f9 fd97 	bl	8009a5c <_tx_mutex_put>

        /* Invalid module preamble.  */
        return(TXM_MODULE_INVALID);
 800ff2e:	23f2      	movs	r3, #242	; 0xf2
 800ff30:	e1c1      	b.n	80102b6 <_txm_module_manager_internal_load+0x466>
    }

    /* Check for valid sizes.  */
    if ((module_preamble -> txm_module_preamble_code_size == 0) ||
 800ff32:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ff34:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ff36:	2b00      	cmp	r3, #0
 800ff38:	d00b      	beq.n	800ff52 <_txm_module_manager_internal_load+0x102>
        (module_preamble -> txm_module_preamble_data_size == 0) ||
 800ff3a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ff3c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    if ((module_preamble -> txm_module_preamble_code_size == 0) ||
 800ff3e:	2b00      	cmp	r3, #0
 800ff40:	d007      	beq.n	800ff52 <_txm_module_manager_internal_load+0x102>
        (module_preamble -> txm_module_preamble_start_stop_stack_size == 0) ||
 800ff42:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ff44:	6a9b      	ldr	r3, [r3, #40]	; 0x28
        (module_preamble -> txm_module_preamble_data_size == 0) ||
 800ff46:	2b00      	cmp	r3, #0
 800ff48:	d003      	beq.n	800ff52 <_txm_module_manager_internal_load+0x102>
        (module_preamble -> txm_module_preamble_callback_stack_size == 0))
 800ff4a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ff4c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
        (module_preamble -> txm_module_preamble_start_stop_stack_size == 0) ||
 800ff4e:	2b00      	cmp	r3, #0
 800ff50:	d104      	bne.n	800ff5c <_txm_module_manager_internal_load+0x10c>
    {

        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 800ff52:	4843      	ldr	r0, [pc, #268]	; (8010060 <_txm_module_manager_internal_load+0x210>)
 800ff54:	f7f9 fd82 	bl	8009a5c <_tx_mutex_put>

        /* Invalid module preamble.  */
        return(TXM_MODULE_INVALID);
 800ff58:	23f2      	movs	r3, #242	; 0xf2
 800ff5a:	e1ac      	b.n	80102b6 <_txm_module_manager_internal_load+0x466>
    }

    /* Initialize module control block to all zeros.  */
    TX_MEMSET(module_instance, 0, sizeof(TXM_MODULE_INSTANCE));
 800ff5c:	f240 42ac 	movw	r2, #1196	; 0x4ac
 800ff60:	2100      	movs	r1, #0
 800ff62:	68f8      	ldr	r0, [r7, #12]
 800ff64:	f006 fd3e 	bl	80169e4 <memset>

    /* Pickup the basic module sizes.  */
    data_size =              module_preamble -> txm_module_preamble_data_size;
 800ff68:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ff6a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ff6c:	61bb      	str	r3, [r7, #24]
    start_stop_stack_size =  module_preamble -> txm_module_preamble_start_stop_stack_size;
 800ff6e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ff70:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ff72:	657b      	str	r3, [r7, #84]	; 0x54
    callback_stack_size =    module_preamble -> txm_module_preamble_callback_stack_size;
 800ff74:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ff76:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ff78:	653b      	str	r3, [r7, #80]	; 0x50
    /* Adjust the size of the module elements to be aligned to the default alignment. We do this
       so that when we partition the allocated memory, we can simply place these regions right beside
       each other without having to align their pointers. Note this only works when they all have
       the same alignment.  */

    TXM_MODULE_MANAGER_UTIL_MATH_ADD_ULONG(data_size, TXM_MODULE_DATA_ALIGNMENT, data_size);
 800ff7a:	69bb      	ldr	r3, [r7, #24]
 800ff7c:	f113 0f09 	cmn.w	r3, #9
 800ff80:	d901      	bls.n	800ff86 <_txm_module_manager_internal_load+0x136>
 800ff82:	23f8      	movs	r3, #248	; 0xf8
 800ff84:	e197      	b.n	80102b6 <_txm_module_manager_internal_load+0x466>
 800ff86:	69bb      	ldr	r3, [r7, #24]
 800ff88:	3308      	adds	r3, #8
 800ff8a:	61bb      	str	r3, [r7, #24]
    data_size =              ((data_size - 1)/TXM_MODULE_DATA_ALIGNMENT) * TXM_MODULE_DATA_ALIGNMENT;
 800ff8c:	69bb      	ldr	r3, [r7, #24]
 800ff8e:	3b01      	subs	r3, #1
 800ff90:	f023 0307 	bic.w	r3, r3, #7
 800ff94:	61bb      	str	r3, [r7, #24]

    TXM_MODULE_MANAGER_UTIL_MATH_ADD_ULONG(start_stop_stack_size, TXM_MODULE_DATA_ALIGNMENT, start_stop_stack_size);
 800ff96:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ff98:	f113 0f09 	cmn.w	r3, #9
 800ff9c:	d901      	bls.n	800ffa2 <_txm_module_manager_internal_load+0x152>
 800ff9e:	23f8      	movs	r3, #248	; 0xf8
 800ffa0:	e189      	b.n	80102b6 <_txm_module_manager_internal_load+0x466>
 800ffa2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ffa4:	3308      	adds	r3, #8
 800ffa6:	657b      	str	r3, [r7, #84]	; 0x54
    start_stop_stack_size =  ((start_stop_stack_size - 1)/TXM_MODULE_DATA_ALIGNMENT) * TXM_MODULE_DATA_ALIGNMENT;
 800ffa8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ffaa:	3b01      	subs	r3, #1
 800ffac:	f023 0307 	bic.w	r3, r3, #7
 800ffb0:	657b      	str	r3, [r7, #84]	; 0x54

    TXM_MODULE_MANAGER_UTIL_MATH_ADD_ULONG(callback_stack_size, TXM_MODULE_DATA_ALIGNMENT, callback_stack_size);
 800ffb2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ffb4:	f113 0f09 	cmn.w	r3, #9
 800ffb8:	d901      	bls.n	800ffbe <_txm_module_manager_internal_load+0x16e>
 800ffba:	23f8      	movs	r3, #248	; 0xf8
 800ffbc:	e17b      	b.n	80102b6 <_txm_module_manager_internal_load+0x466>
 800ffbe:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ffc0:	3308      	adds	r3, #8
 800ffc2:	653b      	str	r3, [r7, #80]	; 0x50
    callback_stack_size =    ((callback_stack_size - 1)/TXM_MODULE_DATA_ALIGNMENT) * TXM_MODULE_DATA_ALIGNMENT;
 800ffc4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ffc6:	3b01      	subs	r3, #1
 800ffc8:	f023 0307 	bic.w	r3, r3, #7
 800ffcc:	653b      	str	r3, [r7, #80]	; 0x50

    /* Update the data size to account for the default thread stacks.  */
    TXM_MODULE_MANAGER_UTIL_MATH_ADD_ULONG(data_size, start_stop_stack_size, data_size);
 800ffce:	69bb      	ldr	r3, [r7, #24]
 800ffd0:	43db      	mvns	r3, r3
 800ffd2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800ffd4:	429a      	cmp	r2, r3
 800ffd6:	d901      	bls.n	800ffdc <_txm_module_manager_internal_load+0x18c>
 800ffd8:	23f8      	movs	r3, #248	; 0xf8
 800ffda:	e16c      	b.n	80102b6 <_txm_module_manager_internal_load+0x466>
 800ffdc:	69ba      	ldr	r2, [r7, #24]
 800ffde:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ffe0:	4413      	add	r3, r2
 800ffe2:	61bb      	str	r3, [r7, #24]
    TXM_MODULE_MANAGER_UTIL_MATH_ADD_ULONG(data_size, callback_stack_size, data_size);
 800ffe4:	69bb      	ldr	r3, [r7, #24]
 800ffe6:	43db      	mvns	r3, r3
 800ffe8:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800ffea:	429a      	cmp	r2, r3
 800ffec:	d901      	bls.n	800fff2 <_txm_module_manager_internal_load+0x1a2>
 800ffee:	23f8      	movs	r3, #248	; 0xf8
 800fff0:	e161      	b.n	80102b6 <_txm_module_manager_internal_load+0x466>
 800fff2:	69ba      	ldr	r2, [r7, #24]
 800fff4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800fff6:	4413      	add	r3, r2
 800fff8:	61bb      	str	r3, [r7, #24]

    /* Setup the default code and data alignments.  */
    data_alignment =  (ULONG) TXM_MODULE_DATA_ALIGNMENT;
 800fffa:	2308      	movs	r3, #8
 800fffc:	617b      	str	r3, [r7, #20]

    /* Get the port-specific alignment for the data size. Note we only want data
       so we pass values of 1 for code (to avoid any possible div by 0 errors).  */
    code_size_ignored = 1;
 800fffe:	2301      	movs	r3, #1
 8010000:	623b      	str	r3, [r7, #32]
    code_alignment_ignored = 1;
 8010002:	2301      	movs	r3, #1
 8010004:	61fb      	str	r3, [r7, #28]
    TXM_MODULE_MANAGER_ALIGNMENT_ADJUST(module_preamble, code_size_ignored, code_alignment_ignored, data_size, data_alignment)
 8010006:	f107 0018 	add.w	r0, r7, #24
 801000a:	f107 021c 	add.w	r2, r7, #28
 801000e:	f107 0120 	add.w	r1, r7, #32
 8010012:	f107 0314 	add.w	r3, r7, #20
 8010016:	9300      	str	r3, [sp, #0]
 8010018:	4603      	mov	r3, r0
 801001a:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 801001c:	f7ff fcc5 	bl	800f9aa <_txm_module_manager_alignment_adjust>
                            ...
                            End of Module's Data Area
    Highest Address:    */

    /* Add an extra alignment increment so we can align the pointer after allocation.  */
    TXM_MODULE_MANAGER_UTIL_MATH_ADD_ULONG(data_size, data_alignment, data_allocation_size);
 8010020:	69bb      	ldr	r3, [r7, #24]
 8010022:	43da      	mvns	r2, r3
 8010024:	697b      	ldr	r3, [r7, #20]
 8010026:	429a      	cmp	r2, r3
 8010028:	d201      	bcs.n	801002e <_txm_module_manager_internal_load+0x1de>
 801002a:	23f8      	movs	r3, #248	; 0xf8
 801002c:	e143      	b.n	80102b6 <_txm_module_manager_internal_load+0x466>
 801002e:	69ba      	ldr	r2, [r7, #24]
 8010030:	697b      	ldr	r3, [r7, #20]
 8010032:	4413      	add	r3, r2
 8010034:	64fb      	str	r3, [r7, #76]	; 0x4c

    /* Allocate memory for the module.  */
    status =  _tx_byte_allocate(&_txm_module_manager_byte_pool, (VOID **) &memory_ptr, data_allocation_size, TX_NO_WAIT);
 8010036:	f107 0110 	add.w	r1, r7, #16
 801003a:	2300      	movs	r3, #0
 801003c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801003e:	480c      	ldr	r0, [pc, #48]	; (8010070 <_txm_module_manager_internal_load+0x220>)
 8010040:	f7f7 fc60 	bl	8007904 <_tx_byte_allocate>
 8010044:	64b8      	str	r0, [r7, #72]	; 0x48

    /* Determine if the module memory allocation was successful.  */
    if (status)
 8010046:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010048:	2b00      	cmp	r3, #0
 801004a:	d013      	beq.n	8010074 <_txm_module_manager_internal_load+0x224>
    {

        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 801004c:	4804      	ldr	r0, [pc, #16]	; (8010060 <_txm_module_manager_internal_load+0x210>)
 801004e:	f7f9 fd05 	bl	8009a5c <_tx_mutex_put>

        /* No memory, return an error.  */
        return(TX_NO_MEMORY);
 8010052:	2310      	movs	r3, #16
 8010054:	e12f      	b.n	80102b6 <_txm_module_manager_internal_load+0x466>
 8010056:	bf00      	nop
 8010058:	2000000c 	.word	0x2000000c
 801005c:	2000f6b0 	.word	0x2000f6b0
 8010060:	2000f674 	.word	0x2000f674
 8010064:	4d4f4455 	.word	0x4d4f4455
 8010068:	2000f600 	.word	0x2000f600
 801006c:	2000f604 	.word	0x2000f604
 8010070:	2000f608 	.word	0x2000f608
    }

    /* Clear the allocated memory.  */
    TX_MEMSET(memory_ptr, ((UCHAR) 0), data_allocation_size);
 8010074:	693b      	ldr	r3, [r7, #16]
 8010076:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010078:	2100      	movs	r1, #0
 801007a:	4618      	mov	r0, r3
 801007c:	f006 fcb2 	bl	80169e4 <memset>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8010080:	f3ef 8310 	mrs	r3, PRIMASK
 8010084:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 8010086:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 8010088:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 801008a:	b672      	cpsid	i
    return(int_posture);
 801008c:	6abb      	ldr	r3, [r7, #40]	; 0x28

    /* Disable interrupts.  */
    TX_DISABLE
 801008e:	647b      	str	r3, [r7, #68]	; 0x44

    /* Setup the module instance structure.  */
    module_instance -> txm_module_instance_id = TXM_MODULE_ID;
 8010090:	68fb      	ldr	r3, [r7, #12]
 8010092:	4a8b      	ldr	r2, [pc, #556]	; (80102c0 <_txm_module_manager_internal_load+0x470>)
 8010094:	601a      	str	r2, [r3, #0]

    /* Save the module name.  */
    module_instance -> txm_module_instance_name =  module_name;
 8010096:	68fb      	ldr	r3, [r7, #12]
 8010098:	68ba      	ldr	r2, [r7, #8]
 801009a:	605a      	str	r2, [r3, #4]

    /* Save the module properties.  */
    module_instance -> txm_module_instance_property_flags =  module_preamble -> txm_module_preamble_property_flags;
 801009c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801009e:	695a      	ldr	r2, [r3, #20]
 80100a0:	68fb      	ldr	r3, [r7, #12]
 80100a2:	60da      	str	r2, [r3, #12]

    /* Set the module data memory allocation. This is the address released
       when the module is unloaded.  */
    module_instance -> txm_module_instance_data_allocation_ptr =  (VOID *) memory_ptr;
 80100a4:	693a      	ldr	r2, [r7, #16]
 80100a6:	68fb      	ldr	r3, [r7, #12]
 80100a8:	625a      	str	r2, [r3, #36]	; 0x24

    /* Save the data allocation size.  */
    module_instance -> txm_module_instance_data_allocation_size =   data_allocation_size;
 80100aa:	68fb      	ldr	r3, [r7, #12]
 80100ac:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80100ae:	629a      	str	r2, [r3, #40]	; 0x28

    /* Calculate the actual start of the data area. This needs to be adjusted based on the alignment.  */
    data_start =  (ALIGN_TYPE) memory_ptr;
 80100b0:	693b      	ldr	r3, [r7, #16]
 80100b2:	643b      	str	r3, [r7, #64]	; 0x40
    data_start =  (data_start + (((ALIGN_TYPE)data_alignment) - 1)) & ~(((ALIGN_TYPE)data_alignment) - 1);
 80100b4:	697a      	ldr	r2, [r7, #20]
 80100b6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80100b8:	4413      	add	r3, r2
 80100ba:	1e5a      	subs	r2, r3, #1
 80100bc:	697b      	ldr	r3, [r7, #20]
 80100be:	425b      	negs	r3, r3
 80100c0:	4013      	ands	r3, r2
 80100c2:	643b      	str	r3, [r7, #64]	; 0x40
    memory_ptr =  (CHAR *) data_start;
 80100c4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80100c6:	613b      	str	r3, [r7, #16]
    module_instance -> txm_module_instance_data_start =  (VOID *) memory_ptr;
 80100c8:	693a      	ldr	r2, [r7, #16]
 80100ca:	68fb      	ldr	r3, [r7, #12]
 80100cc:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Compute the end of the data memory allocation.  */
    module_instance -> txm_module_instance_data_end =  (VOID *) (memory_ptr + (data_size - 1));
 80100ce:	693a      	ldr	r2, [r7, #16]
 80100d0:	69bb      	ldr	r3, [r7, #24]
 80100d2:	3b01      	subs	r3, #1
 80100d4:	441a      	add	r2, r3
 80100d6:	68fb      	ldr	r3, [r7, #12]
 80100d8:	631a      	str	r2, [r3, #48]	; 0x30

    /* Save the size of the data area.  */
    module_instance -> txm_module_instance_data_size =  data_size;
 80100da:	69ba      	ldr	r2, [r7, #24]
 80100dc:	68fb      	ldr	r3, [r7, #12]
 80100de:	639a      	str	r2, [r3, #56]	; 0x38

    /* Set the module code memory allocation. This is the address released
       when the module is unloaded.  */
    module_instance -> txm_module_instance_code_allocation_ptr =  (VOID *) code_allocation_ptr;
 80100e0:	68fb      	ldr	r3, [r7, #12]
 80100e2:	6fba      	ldr	r2, [r7, #120]	; 0x78
 80100e4:	611a      	str	r2, [r3, #16]

    /* Save the code allocation size.  */
    module_instance -> txm_module_instance_code_allocation_size =   code_allocation_size;
 80100e6:	68fb      	ldr	r3, [r7, #12]
 80100e8:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 80100ea:	615a      	str	r2, [r3, #20]

    /* Setup the code pointers.  Since the code was loaded in-place, this is effectively just the values supplied in the API call.  */
    module_instance -> txm_module_instance_code_start =     (VOID *) module_location;
 80100ec:	68fb      	ldr	r3, [r7, #12]
 80100ee:	687a      	ldr	r2, [r7, #4]
 80100f0:	619a      	str	r2, [r3, #24]
    module_instance -> txm_module_instance_code_end =       (VOID *) (((CHAR *) module_location) + (code_size - 1));
 80100f2:	683b      	ldr	r3, [r7, #0]
 80100f4:	3b01      	subs	r3, #1
 80100f6:	687a      	ldr	r2, [r7, #4]
 80100f8:	441a      	add	r2, r3
 80100fa:	68fb      	ldr	r3, [r7, #12]
 80100fc:	61da      	str	r2, [r3, #28]

    /* Setup the code size.  */
    module_instance -> txm_module_instance_code_size =      code_size;
 80100fe:	68fb      	ldr	r3, [r7, #12]
 8010100:	683a      	ldr	r2, [r7, #0]
 8010102:	621a      	str	r2, [r3, #32]

    /* Save the module's total memory usage.  */
    module_instance -> txm_module_instance_total_ram_usage =  data_allocation_size + code_allocation_size;
 8010104:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010106:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8010108:	441a      	add	r2, r3
 801010a:	68fb      	ldr	r3, [r7, #12]
 801010c:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Set the module state to started.  */
    module_instance -> txm_module_instance_state =  TXM_MODULE_LOADED;
 801010e:	68fb      	ldr	r3, [r7, #12]
 8010110:	2201      	movs	r2, #1
 8010112:	609a      	str	r2, [r3, #8]

    /* Save the preamble pointer.  */
    module_instance -> txm_module_instance_preamble_ptr =  module_preamble;
 8010114:	68fb      	ldr	r3, [r7, #12]
 8010116:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010118:	651a      	str	r2, [r3, #80]	; 0x50

    /* Save the module application ID in the module instance.  */
    module_instance -> txm_module_instance_application_module_id =  module_preamble -> txm_module_preamble_application_module_id;
 801011a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801011c:	691a      	ldr	r2, [r3, #16]
 801011e:	68fb      	ldr	r3, [r7, #12]
 8010120:	f8c3 2494 	str.w	r2, [r3, #1172]	; 0x494

    /* Setup the module's start/stop thread stack area.  */
    module_instance -> txm_module_instance_start_stop_stack_start_address =  (VOID *) (memory_ptr);
 8010124:	693a      	ldr	r2, [r7, #16]
 8010126:	68fb      	ldr	r3, [r7, #12]
 8010128:	641a      	str	r2, [r3, #64]	; 0x40
    module_instance -> txm_module_instance_start_stop_stack_size =           start_stop_stack_size;
 801012a:	68fb      	ldr	r3, [r7, #12]
 801012c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801012e:	f8c3 2484 	str.w	r2, [r3, #1156]	; 0x484
    module_instance -> txm_module_instance_start_stop_stack_end_address =    (VOID *) (memory_ptr + (start_stop_stack_size - 1));
 8010132:	693a      	ldr	r2, [r7, #16]
 8010134:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010136:	3b01      	subs	r3, #1
 8010138:	441a      	add	r2, r3
 801013a:	68fb      	ldr	r3, [r7, #12]
 801013c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Move the memory pointer forward.  */
    memory_ptr =  memory_ptr + start_stop_stack_size;
 801013e:	693a      	ldr	r2, [r7, #16]
 8010140:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010142:	4413      	add	r3, r2
 8010144:	613b      	str	r3, [r7, #16]

    /* Save the start/stop thread priority.  */
    module_instance -> txm_module_instance_start_stop_priority =     module_preamble -> txm_module_preamble_start_stop_priority;
 8010146:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010148:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801014a:	68fb      	ldr	r3, [r7, #12]
 801014c:	f8c3 2488 	str.w	r2, [r3, #1160]	; 0x488

    /* Setup the module's callback thread stack area.  */
    module_instance -> txm_module_instance_callback_stack_start_address =  (VOID *) (memory_ptr);
 8010150:	693a      	ldr	r2, [r7, #16]
 8010152:	68fb      	ldr	r3, [r7, #12]
 8010154:	649a      	str	r2, [r3, #72]	; 0x48
    module_instance -> txm_module_instance_callback_stack_size =           callback_stack_size;
 8010156:	68fb      	ldr	r3, [r7, #12]
 8010158:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 801015a:	f8c3 248c 	str.w	r2, [r3, #1164]	; 0x48c
    module_instance -> txm_module_instance_callback_stack_end_address =    (VOID *) (memory_ptr + (callback_stack_size - 1));
 801015e:	693a      	ldr	r2, [r7, #16]
 8010160:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010162:	3b01      	subs	r3, #1
 8010164:	441a      	add	r2, r3
 8010166:	68fb      	ldr	r3, [r7, #12]
 8010168:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Move the memory pointer forward.  */
    memory_ptr =  memory_ptr + callback_stack_size;
 801016a:	693a      	ldr	r2, [r7, #16]
 801016c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801016e:	4413      	add	r3, r2
 8010170:	613b      	str	r3, [r7, #16]

    /* Save the callback thread priority.  */
    module_instance -> txm_module_instance_callback_priority =  module_preamble -> txm_module_preamble_callback_priority;
 8010172:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010174:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8010176:	68fb      	ldr	r3, [r7, #12]
 8010178:	f8c3 2490 	str.w	r2, [r3, #1168]	; 0x490

    /* Setup the start of the module data section.  */
    module_instance -> txm_module_instance_module_data_base_address =  (VOID *) (memory_ptr);
 801017c:	693a      	ldr	r2, [r7, #16]
 801017e:	68fb      	ldr	r3, [r7, #12]
 8010180:	635a      	str	r2, [r3, #52]	; 0x34

    /* Calculate the function adjustments based on the specific implementation of the module manager/module.  */
    TXM_MODULE_MANAGER_CALCULATE_ADJUSTMENTS(module_preamble -> txm_module_preamble_property_flags, shell_function_adjust, start_function_adjust, stop_function_adjust, callback_function_adjust)
 8010182:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010184:	695b      	ldr	r3, [r3, #20]
 8010186:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 801018a:	2b00      	cmp	r3, #0
 801018c:	d108      	bne.n	80101a0 <_txm_module_manager_internal_load+0x350>
 801018e:	2318      	movs	r3, #24
 8010190:	66fb      	str	r3, [r7, #108]	; 0x6c
 8010192:	231c      	movs	r3, #28
 8010194:	66bb      	str	r3, [r7, #104]	; 0x68
 8010196:	2320      	movs	r3, #32
 8010198:	667b      	str	r3, [r7, #100]	; 0x64
 801019a:	232c      	movs	r3, #44	; 0x2c
 801019c:	663b      	str	r3, [r7, #96]	; 0x60
 801019e:	e017      	b.n	80101d0 <_txm_module_manager_internal_load+0x380>
 80101a0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80101a2:	695b      	ldr	r3, [r3, #20]
 80101a4:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 80101a8:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80101ac:	d108      	bne.n	80101c0 <_txm_module_manager_internal_load+0x370>
 80101ae:	2300      	movs	r3, #0
 80101b0:	66fb      	str	r3, [r7, #108]	; 0x6c
 80101b2:	2300      	movs	r3, #0
 80101b4:	66bb      	str	r3, [r7, #104]	; 0x68
 80101b6:	2300      	movs	r3, #0
 80101b8:	667b      	str	r3, [r7, #100]	; 0x64
 80101ba:	2300      	movs	r3, #0
 80101bc:	663b      	str	r3, [r7, #96]	; 0x60
 80101be:	e007      	b.n	80101d0 <_txm_module_manager_internal_load+0x380>
 80101c0:	2318      	movs	r3, #24
 80101c2:	66fb      	str	r3, [r7, #108]	; 0x6c
 80101c4:	231c      	movs	r3, #28
 80101c6:	66bb      	str	r3, [r7, #104]	; 0x68
 80101c8:	2320      	movs	r3, #32
 80101ca:	667b      	str	r3, [r7, #100]	; 0x64
 80101cc:	232c      	movs	r3, #44	; 0x2c
 80101ce:	663b      	str	r3, [r7, #96]	; 0x60

    /* Build actual addresses based on load...  Setup all the function pointers. Any adjustments needed to shell entry, start function, and callback function are defined in the
       module preamble. */
    module_instance -> txm_module_instance_shell_entry_function  =          (VOID (*)(TX_THREAD *, TXM_MODULE_INSTANCE *)) (((CHAR *) module_instance -> txm_module_instance_code_start) +
 80101d0:	68fb      	ldr	r3, [r7, #12]
 80101d2:	699b      	ldr	r3, [r3, #24]
 80101d4:	4619      	mov	r1, r3
                                                                                                                                      (module_preamble -> txm_module_preamble_shell_entry_function) +
 80101d6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80101d8:	699a      	ldr	r2, [r3, #24]
 80101da:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80101dc:	4413      	add	r3, r2
    module_instance -> txm_module_instance_shell_entry_function  =          (VOID (*)(TX_THREAD *, TXM_MODULE_INSTANCE *)) (((CHAR *) module_instance -> txm_module_instance_code_start) +
 80101de:	18ca      	adds	r2, r1, r3
 80101e0:	68fb      	ldr	r3, [r7, #12]
 80101e2:	655a      	str	r2, [r3, #84]	; 0x54
                                                                                                                                      (shell_function_adjust));
    module_instance -> txm_module_instance_start_thread_entry =             (VOID (*)(ULONG)) (((CHAR *) module_instance -> txm_module_instance_code_start) +
 80101e4:	68fb      	ldr	r3, [r7, #12]
 80101e6:	699b      	ldr	r3, [r3, #24]
                                                                                                                                      (module_preamble -> txm_module_preamble_start_function) +
 80101e8:	4619      	mov	r1, r3
 80101ea:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80101ec:	69da      	ldr	r2, [r3, #28]
 80101ee:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80101f0:	4413      	add	r3, r2
    module_instance -> txm_module_instance_start_thread_entry =             (VOID (*)(ULONG)) (((CHAR *) module_instance -> txm_module_instance_code_start) +
 80101f2:	18ca      	adds	r2, r1, r3
 80101f4:	68fb      	ldr	r3, [r7, #12]
 80101f6:	659a      	str	r2, [r3, #88]	; 0x58
                                                                                                                                      (start_function_adjust));
    module_instance -> txm_module_instance_callback_request_thread_entry =  (VOID (*)(ULONG)) (((CHAR *) module_instance -> txm_module_instance_code_start) +
 80101f8:	68fb      	ldr	r3, [r7, #12]
 80101fa:	699b      	ldr	r3, [r3, #24]
                                                                                                                                      (module_preamble -> txm_module_preamble_callback_function) +
 80101fc:	4619      	mov	r1, r3
 80101fe:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010200:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8010202:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8010204:	4413      	add	r3, r2
    module_instance -> txm_module_instance_callback_request_thread_entry =  (VOID (*)(ULONG)) (((CHAR *) module_instance -> txm_module_instance_code_start) +
 8010206:	18ca      	adds	r2, r1, r3
 8010208:	68fb      	ldr	r3, [r7, #12]
 801020a:	661a      	str	r2, [r3, #96]	; 0x60
                                                                                                                                      (callback_function_adjust));
    /* Determine if there is a stop function for this module.  */
    if (module_preamble -> txm_module_preamble_stop_function)
 801020c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801020e:	6a1b      	ldr	r3, [r3, #32]
 8010210:	2b00      	cmp	r3, #0
 8010212:	d00a      	beq.n	801022a <_txm_module_manager_internal_load+0x3da>
    {

        /* Yes, there is a stop function, build the address.  */
        module_instance -> txm_module_instance_stop_thread_entry =  (VOID (*)(ULONG)) (((CHAR *) module_instance -> txm_module_instance_code_start) +
 8010214:	68fb      	ldr	r3, [r7, #12]
 8010216:	699b      	ldr	r3, [r3, #24]
                                                                                                                                      (module_preamble -> txm_module_preamble_stop_function) +
 8010218:	4619      	mov	r1, r3
 801021a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801021c:	6a1a      	ldr	r2, [r3, #32]
 801021e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010220:	4413      	add	r3, r2
        module_instance -> txm_module_instance_stop_thread_entry =  (VOID (*)(ULONG)) (((CHAR *) module_instance -> txm_module_instance_code_start) +
 8010222:	18ca      	adds	r2, r1, r3
 8010224:	68fb      	ldr	r3, [r7, #12]
 8010226:	65da      	str	r2, [r3, #92]	; 0x5c
 8010228:	e002      	b.n	8010230 <_txm_module_manager_internal_load+0x3e0>
    }
    else
    {

        /* No, there is no stop function. Just set the pointer to NULL.  */
        module_instance -> txm_module_instance_stop_thread_entry =  TX_NULL;
 801022a:	68fb      	ldr	r3, [r7, #12]
 801022c:	2200      	movs	r2, #0
 801022e:	65da      	str	r2, [r3, #92]	; 0x5c
    }

    /* Load the module control block with port-specific information. */
    TXM_MODULE_MANAGER_MODULE_SETUP(module_instance);
 8010230:	68fb      	ldr	r3, [r7, #12]
 8010232:	68db      	ldr	r3, [r3, #12]
 8010234:	f003 0301 	and.w	r3, r3, #1
 8010238:	2b00      	cmp	r3, #0
 801023a:	d008      	beq.n	801024e <_txm_module_manager_internal_load+0x3fe>
 801023c:	68fb      	ldr	r3, [r7, #12]
 801023e:	68db      	ldr	r3, [r3, #12]
 8010240:	f003 0302 	and.w	r3, r3, #2
 8010244:	2b00      	cmp	r3, #0
 8010246:	d002      	beq.n	801024e <_txm_module_manager_internal_load+0x3fe>
 8010248:	68f8      	ldr	r0, [r7, #12]
 801024a:	f004 fd97 	bl	8014d7c <_txm_module_manager_mm_register_setup>

    /* Now add the module to the linked list of created modules.  */
    if (_txm_module_manger_loaded_count++ == 0)
 801024e:	4b1d      	ldr	r3, [pc, #116]	; (80102c4 <_txm_module_manager_internal_load+0x474>)
 8010250:	681b      	ldr	r3, [r3, #0]
 8010252:	1c5a      	adds	r2, r3, #1
 8010254:	491b      	ldr	r1, [pc, #108]	; (80102c4 <_txm_module_manager_internal_load+0x474>)
 8010256:	600a      	str	r2, [r1, #0]
 8010258:	2b00      	cmp	r3, #0
 801025a:	d10b      	bne.n	8010274 <_txm_module_manager_internal_load+0x424>
    {

        /* The loaded module list is empty.  Add module to empty list.  */
        _txm_module_manager_loaded_list_ptr =                     module_instance;
 801025c:	4a1a      	ldr	r2, [pc, #104]	; (80102c8 <_txm_module_manager_internal_load+0x478>)
 801025e:	68fb      	ldr	r3, [r7, #12]
 8010260:	6013      	str	r3, [r2, #0]
        module_instance -> txm_module_instance_loaded_next =      module_instance;
 8010262:	68fb      	ldr	r3, [r7, #12]
 8010264:	68fa      	ldr	r2, [r7, #12]
 8010266:	f8c3 24a4 	str.w	r2, [r3, #1188]	; 0x4a4
        module_instance -> txm_module_instance_loaded_previous =  module_instance;
 801026a:	68fb      	ldr	r3, [r7, #12]
 801026c:	68fa      	ldr	r2, [r7, #12]
 801026e:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
 8010272:	e016      	b.n	80102a2 <_txm_module_manager_internal_load+0x452>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_module =      _txm_module_manager_loaded_list_ptr;
 8010274:	4b14      	ldr	r3, [pc, #80]	; (80102c8 <_txm_module_manager_internal_load+0x478>)
 8010276:	681b      	ldr	r3, [r3, #0]
 8010278:	63fb      	str	r3, [r7, #60]	; 0x3c
        previous_module =  next_module -> txm_module_instance_loaded_previous;
 801027a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801027c:	f8d3 34a8 	ldr.w	r3, [r3, #1192]	; 0x4a8
 8010280:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Place the new module in the list.  */
        next_module -> txm_module_instance_loaded_previous =  module_instance;
 8010282:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010284:	68fa      	ldr	r2, [r7, #12]
 8010286:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
        previous_module -> txm_module_instance_loaded_next =  module_instance;
 801028a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801028c:	68fa      	ldr	r2, [r7, #12]
 801028e:	f8c3 24a4 	str.w	r2, [r3, #1188]	; 0x4a4

        /* Setup this module's created links.  */
        module_instance -> txm_module_instance_loaded_previous =  previous_module;
 8010292:	68fb      	ldr	r3, [r7, #12]
 8010294:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8010296:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
        module_instance -> txm_module_instance_loaded_next =      next_module;
 801029a:	68fb      	ldr	r3, [r7, #12]
 801029c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801029e:	f8c3 24a4 	str.w	r2, [r3, #1188]	; 0x4a4
 80102a2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80102a4:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80102a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80102a8:	f383 8810 	msr	PRIMASK, r3
}
 80102ac:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Release the protection mutex.  */
    _tx_mutex_put(&_txm_module_manager_mutex);
 80102ae:	4807      	ldr	r0, [pc, #28]	; (80102cc <_txm_module_manager_internal_load+0x47c>)
 80102b0:	f7f9 fbd4 	bl	8009a5c <_tx_mutex_put>

    /* Return success.  */
    return(TX_SUCCESS);
 80102b4:	2300      	movs	r3, #0
}
 80102b6:	4618      	mov	r0, r3
 80102b8:	3770      	adds	r7, #112	; 0x70
 80102ba:	46bd      	mov	sp, r7
 80102bc:	bd80      	pop	{r7, pc}
 80102be:	bf00      	nop
 80102c0:	4d4f4455 	.word	0x4d4f4455
 80102c4:	2000f6ac 	.word	0x2000f6ac
 80102c8:	2000f6a8 	.word	0x2000f6a8
 80102cc:	2000f674 	.word	0x2000f674

080102d0 <_txm_module_manager_tx_block_allocate_dispatch>:
    TX_BLOCK_POOL *pool_ptr, -> param_0
    VOID **block_ptr, -> param_1
    ULONG wait_option -> param_2
   ); */
static ALIGN_TYPE _txm_module_manager_tx_block_allocate_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE param_2)
{
 80102d0:	b580      	push	{r7, lr}
 80102d2:	b086      	sub	sp, #24
 80102d4:	af00      	add	r7, sp, #0
 80102d6:	60f8      	str	r0, [r7, #12]
 80102d8:	60b9      	str	r1, [r7, #8]
 80102da:	607a      	str	r2, [r7, #4]
 80102dc:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 80102de:	68fb      	ldr	r3, [r7, #12]
 80102e0:	68db      	ldr	r3, [r3, #12]
 80102e2:	f003 0302 	and.w	r3, r3, #2
 80102e6:	2b00      	cmp	r3, #0
 80102e8:	d02b      	beq.n	8010342 <_txm_module_manager_tx_block_allocate_dispatch+0x72>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_BLOCK_POOL)))
 80102ea:	2230      	movs	r2, #48	; 0x30
 80102ec:	68b9      	ldr	r1, [r7, #8]
 80102ee:	68f8      	ldr	r0, [r7, #12]
 80102f0:	f004 fdaa 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80102f4:	4603      	mov	r3, r0
 80102f6:	2b00      	cmp	r3, #0
 80102f8:	d111      	bne.n	801031e <_txm_module_manager_tx_block_allocate_dispatch+0x4e>
 80102fa:	68bb      	ldr	r3, [r7, #8]
 80102fc:	f113 0f31 	cmn.w	r3, #49	; 0x31
 8010300:	d812      	bhi.n	8010328 <_txm_module_manager_tx_block_allocate_dispatch+0x58>
 8010302:	68fb      	ldr	r3, [r7, #12]
 8010304:	699b      	ldr	r3, [r3, #24]
 8010306:	461a      	mov	r2, r3
 8010308:	68bb      	ldr	r3, [r7, #8]
 801030a:	4293      	cmp	r3, r2
 801030c:	d30c      	bcc.n	8010328 <_txm_module_manager_tx_block_allocate_dispatch+0x58>
 801030e:	68bb      	ldr	r3, [r7, #8]
 8010310:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8010314:	68fb      	ldr	r3, [r7, #12]
 8010316:	69db      	ldr	r3, [r3, #28]
 8010318:	3301      	adds	r3, #1
 801031a:	429a      	cmp	r2, r3
 801031c:	d804      	bhi.n	8010328 <_txm_module_manager_tx_block_allocate_dispatch+0x58>
 801031e:	68bb      	ldr	r3, [r7, #8]
 8010320:	2b00      	cmp	r3, #0
 8010322:	d001      	beq.n	8010328 <_txm_module_manager_tx_block_allocate_dispatch+0x58>
            return(TXM_MODULE_INVALID_MEMORY);
 8010324:	23f4      	movs	r3, #244	; 0xf4
 8010326:	e014      	b.n	8010352 <_txm_module_manager_tx_block_allocate_dispatch+0x82>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(VOID *)))
 8010328:	2204      	movs	r2, #4
 801032a:	6879      	ldr	r1, [r7, #4]
 801032c:	68f8      	ldr	r0, [r7, #12]
 801032e:	f004 fd8b 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010332:	4603      	mov	r3, r0
 8010334:	2b00      	cmp	r3, #0
 8010336:	d104      	bne.n	8010342 <_txm_module_manager_tx_block_allocate_dispatch+0x72>
 8010338:	687b      	ldr	r3, [r7, #4]
 801033a:	2b00      	cmp	r3, #0
 801033c:	d001      	beq.n	8010342 <_txm_module_manager_tx_block_allocate_dispatch+0x72>
            return(TXM_MODULE_INVALID_MEMORY);
 801033e:	23f4      	movs	r3, #244	; 0xf4
 8010340:	e007      	b.n	8010352 <_txm_module_manager_tx_block_allocate_dispatch+0x82>
    }

    return_value = (ALIGN_TYPE) _txe_block_allocate(
 8010342:	68bb      	ldr	r3, [r7, #8]
 8010344:	6879      	ldr	r1, [r7, #4]
 8010346:	683a      	ldr	r2, [r7, #0]
 8010348:	4618      	mov	r0, r3
 801034a:	f7fd fbd3 	bl	800daf4 <_txe_block_allocate>
 801034e:	6178      	str	r0, [r7, #20]
        (TX_BLOCK_POOL *) param_0,
        (VOID **) param_1,
        (ULONG) param_2
    );
    return(return_value);
 8010350:	697b      	ldr	r3, [r7, #20]
}
 8010352:	4618      	mov	r0, r3
 8010354:	3718      	adds	r7, #24
 8010356:	46bd      	mov	sp, r7
 8010358:	bd80      	pop	{r7, pc}
	...

0801035c <_txm_module_manager_tx_block_pool_create_dispatch>:
    VOID *pool_start, -> extra_parameters[1]
    ULONG pool_size, -> extra_parameters[2]
    UINT pool_control_block_size -> extra_parameters[3]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_block_pool_create_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 801035c:	b5b0      	push	{r4, r5, r7, lr}
 801035e:	b088      	sub	sp, #32
 8010360:	af02      	add	r7, sp, #8
 8010362:	60f8      	str	r0, [r7, #12]
 8010364:	60b9      	str	r1, [r7, #8]
 8010366:	607a      	str	r2, [r7, #4]
 8010368:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 801036a:	68fb      	ldr	r3, [r7, #12]
 801036c:	68db      	ldr	r3, [r3, #12]
 801036e:	f003 0302 	and.w	r3, r3, #2
 8010372:	2b00      	cmp	r3, #0
 8010374:	d05f      	beq.n	8010436 <_txm_module_manager_tx_block_pool_create_dispatch+0xda>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_CREATION(module_instance, param_0, sizeof(TX_BLOCK_POOL)))
 8010376:	4b3d      	ldr	r3, [pc, #244]	; (801046c <_txm_module_manager_tx_block_pool_create_dispatch+0x110>)
 8010378:	681b      	ldr	r3, [r3, #0]
 801037a:	2b01      	cmp	r3, #1
 801037c:	d119      	bne.n	80103b2 <_txm_module_manager_tx_block_pool_create_dispatch+0x56>
 801037e:	68bb      	ldr	r3, [r7, #8]
 8010380:	f113 0f31 	cmn.w	r3, #49	; 0x31
 8010384:	d815      	bhi.n	80103b2 <_txm_module_manager_tx_block_pool_create_dispatch+0x56>
 8010386:	4b3a      	ldr	r3, [pc, #232]	; (8010470 <_txm_module_manager_tx_block_pool_create_dispatch+0x114>)
 8010388:	699b      	ldr	r3, [r3, #24]
 801038a:	3310      	adds	r3, #16
 801038c:	68ba      	ldr	r2, [r7, #8]
 801038e:	429a      	cmp	r2, r3
 8010390:	d30f      	bcc.n	80103b2 <_txm_module_manager_tx_block_pool_create_dispatch+0x56>
 8010392:	68bb      	ldr	r3, [r7, #8]
 8010394:	3330      	adds	r3, #48	; 0x30
 8010396:	4a36      	ldr	r2, [pc, #216]	; (8010470 <_txm_module_manager_tx_block_pool_create_dispatch+0x114>)
 8010398:	6991      	ldr	r1, [r2, #24]
 801039a:	4a35      	ldr	r2, [pc, #212]	; (8010470 <_txm_module_manager_tx_block_pool_create_dispatch+0x114>)
 801039c:	69d2      	ldr	r2, [r2, #28]
 801039e:	440a      	add	r2, r1
 80103a0:	4293      	cmp	r3, r2
 80103a2:	d806      	bhi.n	80103b2 <_txm_module_manager_tx_block_pool_create_dispatch+0x56>
 80103a4:	2130      	movs	r1, #48	; 0x30
 80103a6:	68b8      	ldr	r0, [r7, #8]
 80103a8:	f006 f976 	bl	8016698 <_txm_module_manager_object_size_check>
 80103ac:	4603      	mov	r3, r0
 80103ae:	2b00      	cmp	r3, #0
 80103b0:	d004      	beq.n	80103bc <_txm_module_manager_tx_block_pool_create_dispatch+0x60>
 80103b2:	68bb      	ldr	r3, [r7, #8]
 80103b4:	2b00      	cmp	r3, #0
 80103b6:	d001      	beq.n	80103bc <_txm_module_manager_tx_block_pool_create_dispatch+0x60>
            return(TXM_MODULE_INVALID_MEMORY);
 80103b8:	23f4      	movs	r3, #244	; 0xf4
 80103ba:	e052      	b.n	8010462 <_txm_module_manager_tx_block_pool_create_dispatch+0x106>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_DEREFERENCE_STRING(module_instance, param_1))
 80103bc:	2201      	movs	r2, #1
 80103be:	6879      	ldr	r1, [r7, #4]
 80103c0:	68f8      	ldr	r0, [r7, #12]
 80103c2:	f004 fd41 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80103c6:	4603      	mov	r3, r0
 80103c8:	2b00      	cmp	r3, #0
 80103ca:	d115      	bne.n	80103f8 <_txm_module_manager_tx_block_pool_create_dispatch+0x9c>
 80103cc:	687b      	ldr	r3, [r7, #4]
 80103ce:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80103d2:	d00c      	beq.n	80103ee <_txm_module_manager_tx_block_pool_create_dispatch+0x92>
 80103d4:	68fb      	ldr	r3, [r7, #12]
 80103d6:	699b      	ldr	r3, [r3, #24]
 80103d8:	461a      	mov	r2, r3
 80103da:	687b      	ldr	r3, [r7, #4]
 80103dc:	4293      	cmp	r3, r2
 80103de:	d306      	bcc.n	80103ee <_txm_module_manager_tx_block_pool_create_dispatch+0x92>
 80103e0:	687b      	ldr	r3, [r7, #4]
 80103e2:	1c5a      	adds	r2, r3, #1
 80103e4:	68fb      	ldr	r3, [r7, #12]
 80103e6:	69db      	ldr	r3, [r3, #28]
 80103e8:	3301      	adds	r3, #1
 80103ea:	429a      	cmp	r2, r3
 80103ec:	d904      	bls.n	80103f8 <_txm_module_manager_tx_block_pool_create_dispatch+0x9c>
 80103ee:	687b      	ldr	r3, [r7, #4]
 80103f0:	2b00      	cmp	r3, #0
 80103f2:	d001      	beq.n	80103f8 <_txm_module_manager_tx_block_pool_create_dispatch+0x9c>
            return(TXM_MODULE_INVALID_MEMORY);
 80103f4:	23f4      	movs	r3, #244	; 0xf4
 80103f6:	e034      	b.n	8010462 <_txm_module_manager_tx_block_pool_create_dispatch+0x106>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[2])))
 80103f8:	683b      	ldr	r3, [r7, #0]
 80103fa:	2208      	movs	r2, #8
 80103fc:	4619      	mov	r1, r3
 80103fe:	68f8      	ldr	r0, [r7, #12]
 8010400:	f004 fd22 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010404:	4603      	mov	r3, r0
 8010406:	2b00      	cmp	r3, #0
 8010408:	d101      	bne.n	801040e <_txm_module_manager_tx_block_pool_create_dispatch+0xb2>
            return(TXM_MODULE_INVALID_MEMORY);
 801040a:	23f4      	movs	r3, #244	; 0xf4
 801040c:	e029      	b.n	8010462 <_txm_module_manager_tx_block_pool_create_dispatch+0x106>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], extra_parameters[2]))
 801040e:	683b      	ldr	r3, [r7, #0]
 8010410:	3304      	adds	r3, #4
 8010412:	6819      	ldr	r1, [r3, #0]
 8010414:	683b      	ldr	r3, [r7, #0]
 8010416:	3308      	adds	r3, #8
 8010418:	681b      	ldr	r3, [r3, #0]
 801041a:	461a      	mov	r2, r3
 801041c:	68f8      	ldr	r0, [r7, #12]
 801041e:	f004 fd13 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010422:	4603      	mov	r3, r0
 8010424:	2b00      	cmp	r3, #0
 8010426:	d106      	bne.n	8010436 <_txm_module_manager_tx_block_pool_create_dispatch+0xda>
 8010428:	683b      	ldr	r3, [r7, #0]
 801042a:	3304      	adds	r3, #4
 801042c:	681b      	ldr	r3, [r3, #0]
 801042e:	2b00      	cmp	r3, #0
 8010430:	d001      	beq.n	8010436 <_txm_module_manager_tx_block_pool_create_dispatch+0xda>
            return(TXM_MODULE_INVALID_MEMORY);
 8010432:	23f4      	movs	r3, #244	; 0xf4
 8010434:	e015      	b.n	8010462 <_txm_module_manager_tx_block_pool_create_dispatch+0x106>
    }

    return_value = (ALIGN_TYPE) _txe_block_pool_create(
 8010436:	68b8      	ldr	r0, [r7, #8]
 8010438:	6879      	ldr	r1, [r7, #4]
 801043a:	683b      	ldr	r3, [r7, #0]
 801043c:	681c      	ldr	r4, [r3, #0]
        (TX_BLOCK_POOL *) param_0,
        (CHAR *) param_1,
        (ULONG) extra_parameters[0],
        (VOID *) extra_parameters[1],
 801043e:	683b      	ldr	r3, [r7, #0]
 8010440:	3304      	adds	r3, #4
 8010442:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_block_pool_create(
 8010444:	461d      	mov	r5, r3
        (ULONG) extra_parameters[2],
 8010446:	683b      	ldr	r3, [r7, #0]
 8010448:	3308      	adds	r3, #8
    return_value = (ALIGN_TYPE) _txe_block_pool_create(
 801044a:	681b      	ldr	r3, [r3, #0]
        (UINT) extra_parameters[3]
 801044c:	683a      	ldr	r2, [r7, #0]
 801044e:	320c      	adds	r2, #12
    return_value = (ALIGN_TYPE) _txe_block_pool_create(
 8010450:	6812      	ldr	r2, [r2, #0]
 8010452:	9201      	str	r2, [sp, #4]
 8010454:	9300      	str	r3, [sp, #0]
 8010456:	462b      	mov	r3, r5
 8010458:	4622      	mov	r2, r4
 801045a:	f7fd fb95 	bl	800db88 <_txe_block_pool_create>
 801045e:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 8010460:	697b      	ldr	r3, [r7, #20]
}
 8010462:	4618      	mov	r0, r3
 8010464:	3718      	adds	r7, #24
 8010466:	46bd      	mov	sp, r7
 8010468:	bdb0      	pop	{r4, r5, r7, pc}
 801046a:	bf00      	nop
 801046c:	2000f670 	.word	0x2000f670
 8010470:	2000f63c 	.word	0x2000f63c

08010474 <_txm_module_manager_tx_block_pool_delete_dispatch>:
#ifndef TXM_BLOCK_POOL_DELETE_CALL_NOT_USED
/* UINT _txe_block_pool_delete(
    TX_BLOCK_POOL *pool_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_block_pool_delete_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8010474:	b580      	push	{r7, lr}
 8010476:	b084      	sub	sp, #16
 8010478:	af00      	add	r7, sp, #0
 801047a:	6078      	str	r0, [r7, #4]
 801047c:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 801047e:	687b      	ldr	r3, [r7, #4]
 8010480:	68db      	ldr	r3, [r3, #12]
 8010482:	f003 0302 	and.w	r3, r3, #2
 8010486:	2b00      	cmp	r3, #0
 8010488:	d01e      	beq.n	80104c8 <_txm_module_manager_tx_block_pool_delete_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_BLOCK_POOL)))
 801048a:	2230      	movs	r2, #48	; 0x30
 801048c:	6839      	ldr	r1, [r7, #0]
 801048e:	6878      	ldr	r0, [r7, #4]
 8010490:	f004 fcda 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010494:	4603      	mov	r3, r0
 8010496:	2b00      	cmp	r3, #0
 8010498:	d111      	bne.n	80104be <_txm_module_manager_tx_block_pool_delete_dispatch+0x4a>
 801049a:	683b      	ldr	r3, [r7, #0]
 801049c:	f113 0f31 	cmn.w	r3, #49	; 0x31
 80104a0:	d812      	bhi.n	80104c8 <_txm_module_manager_tx_block_pool_delete_dispatch+0x54>
 80104a2:	687b      	ldr	r3, [r7, #4]
 80104a4:	699b      	ldr	r3, [r3, #24]
 80104a6:	461a      	mov	r2, r3
 80104a8:	683b      	ldr	r3, [r7, #0]
 80104aa:	4293      	cmp	r3, r2
 80104ac:	d30c      	bcc.n	80104c8 <_txm_module_manager_tx_block_pool_delete_dispatch+0x54>
 80104ae:	683b      	ldr	r3, [r7, #0]
 80104b0:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80104b4:	687b      	ldr	r3, [r7, #4]
 80104b6:	69db      	ldr	r3, [r3, #28]
 80104b8:	3301      	adds	r3, #1
 80104ba:	429a      	cmp	r2, r3
 80104bc:	d804      	bhi.n	80104c8 <_txm_module_manager_tx_block_pool_delete_dispatch+0x54>
 80104be:	683b      	ldr	r3, [r7, #0]
 80104c0:	2b00      	cmp	r3, #0
 80104c2:	d001      	beq.n	80104c8 <_txm_module_manager_tx_block_pool_delete_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 80104c4:	23f4      	movs	r3, #244	; 0xf4
 80104c6:	e00d      	b.n	80104e4 <_txm_module_manager_tx_block_pool_delete_dispatch+0x70>
    }

    return_value = (ALIGN_TYPE) _txe_block_pool_delete(
 80104c8:	683b      	ldr	r3, [r7, #0]
 80104ca:	4618      	mov	r0, r3
 80104cc:	f7fd fc04 	bl	800dcd8 <_txe_block_pool_delete>
 80104d0:	60f8      	str	r0, [r7, #12]
        (TX_BLOCK_POOL *) param_0
    );

    /* Deallocate object memory.  */
    if (return_value == TX_SUCCESS)
 80104d2:	68fb      	ldr	r3, [r7, #12]
 80104d4:	2b00      	cmp	r3, #0
 80104d6:	d104      	bne.n	80104e2 <_txm_module_manager_tx_block_pool_delete_dispatch+0x6e>
    {
        return_value = _txm_module_manager_object_deallocate((VOID *) param_0);
 80104d8:	683b      	ldr	r3, [r7, #0]
 80104da:	4618      	mov	r0, r3
 80104dc:	f004 fd6a 	bl	8014fb4 <_txm_module_manager_object_deallocate>
 80104e0:	60f8      	str	r0, [r7, #12]
    }
    return(return_value);
 80104e2:	68fb      	ldr	r3, [r7, #12]
}
 80104e4:	4618      	mov	r0, r3
 80104e6:	3710      	adds	r7, #16
 80104e8:	46bd      	mov	sp, r7
 80104ea:	bd80      	pop	{r7, pc}

080104ec <_txm_module_manager_tx_block_pool_info_get_dispatch>:
    TX_THREAD **first_suspended, -> extra_parameters[2]
    ULONG *suspended_count, -> extra_parameters[3]
    TX_BLOCK_POOL **next_pool -> extra_parameters[4]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_block_pool_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 80104ec:	b5f0      	push	{r4, r5, r6, r7, lr}
 80104ee:	b08b      	sub	sp, #44	; 0x2c
 80104f0:	af04      	add	r7, sp, #16
 80104f2:	60f8      	str	r0, [r7, #12]
 80104f4:	60b9      	str	r1, [r7, #8]
 80104f6:	607a      	str	r2, [r7, #4]
 80104f8:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 80104fa:	68fb      	ldr	r3, [r7, #12]
 80104fc:	68db      	ldr	r3, [r3, #12]
 80104fe:	f003 0302 	and.w	r3, r3, #2
 8010502:	2b00      	cmp	r3, #0
 8010504:	f000 808f 	beq.w	8010626 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x13a>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_BLOCK_POOL)))
 8010508:	2230      	movs	r2, #48	; 0x30
 801050a:	68b9      	ldr	r1, [r7, #8]
 801050c:	68f8      	ldr	r0, [r7, #12]
 801050e:	f004 fc9b 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010512:	4603      	mov	r3, r0
 8010514:	2b00      	cmp	r3, #0
 8010516:	d111      	bne.n	801053c <_txm_module_manager_tx_block_pool_info_get_dispatch+0x50>
 8010518:	68bb      	ldr	r3, [r7, #8]
 801051a:	f113 0f31 	cmn.w	r3, #49	; 0x31
 801051e:	d812      	bhi.n	8010546 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x5a>
 8010520:	68fb      	ldr	r3, [r7, #12]
 8010522:	699b      	ldr	r3, [r3, #24]
 8010524:	461a      	mov	r2, r3
 8010526:	68bb      	ldr	r3, [r7, #8]
 8010528:	4293      	cmp	r3, r2
 801052a:	d30c      	bcc.n	8010546 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x5a>
 801052c:	68bb      	ldr	r3, [r7, #8]
 801052e:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8010532:	68fb      	ldr	r3, [r7, #12]
 8010534:	69db      	ldr	r3, [r3, #28]
 8010536:	3301      	adds	r3, #1
 8010538:	429a      	cmp	r2, r3
 801053a:	d804      	bhi.n	8010546 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x5a>
 801053c:	68bb      	ldr	r3, [r7, #8]
 801053e:	2b00      	cmp	r3, #0
 8010540:	d001      	beq.n	8010546 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x5a>
            return(TXM_MODULE_INVALID_MEMORY);
 8010542:	23f4      	movs	r3, #244	; 0xf4
 8010544:	e08c      	b.n	8010660 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(CHAR *)))
 8010546:	2204      	movs	r2, #4
 8010548:	6879      	ldr	r1, [r7, #4]
 801054a:	68f8      	ldr	r0, [r7, #12]
 801054c:	f004 fc7c 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010550:	4603      	mov	r3, r0
 8010552:	2b00      	cmp	r3, #0
 8010554:	d104      	bne.n	8010560 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x74>
 8010556:	687b      	ldr	r3, [r7, #4]
 8010558:	2b00      	cmp	r3, #0
 801055a:	d001      	beq.n	8010560 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x74>
            return(TXM_MODULE_INVALID_MEMORY);
 801055c:	23f4      	movs	r3, #244	; 0xf4
 801055e:	e07f      	b.n	8010660 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[5])))
 8010560:	683b      	ldr	r3, [r7, #0]
 8010562:	2214      	movs	r2, #20
 8010564:	4619      	mov	r1, r3
 8010566:	68f8      	ldr	r0, [r7, #12]
 8010568:	f004 fc6e 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801056c:	4603      	mov	r3, r0
 801056e:	2b00      	cmp	r3, #0
 8010570:	d101      	bne.n	8010576 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x8a>
            return(TXM_MODULE_INVALID_MEMORY);
 8010572:	23f4      	movs	r3, #244	; 0xf4
 8010574:	e074      	b.n	8010660 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 8010576:	683b      	ldr	r3, [r7, #0]
 8010578:	681b      	ldr	r3, [r3, #0]
 801057a:	2204      	movs	r2, #4
 801057c:	4619      	mov	r1, r3
 801057e:	68f8      	ldr	r0, [r7, #12]
 8010580:	f004 fc62 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010584:	4603      	mov	r3, r0
 8010586:	2b00      	cmp	r3, #0
 8010588:	d105      	bne.n	8010596 <_txm_module_manager_tx_block_pool_info_get_dispatch+0xaa>
 801058a:	683b      	ldr	r3, [r7, #0]
 801058c:	681b      	ldr	r3, [r3, #0]
 801058e:	2b00      	cmp	r3, #0
 8010590:	d001      	beq.n	8010596 <_txm_module_manager_tx_block_pool_info_get_dispatch+0xaa>
            return(TXM_MODULE_INVALID_MEMORY);
 8010592:	23f4      	movs	r3, #244	; 0xf4
 8010594:	e064      	b.n	8010660 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 8010596:	683b      	ldr	r3, [r7, #0]
 8010598:	3304      	adds	r3, #4
 801059a:	681b      	ldr	r3, [r3, #0]
 801059c:	2204      	movs	r2, #4
 801059e:	4619      	mov	r1, r3
 80105a0:	68f8      	ldr	r0, [r7, #12]
 80105a2:	f004 fc51 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80105a6:	4603      	mov	r3, r0
 80105a8:	2b00      	cmp	r3, #0
 80105aa:	d106      	bne.n	80105ba <_txm_module_manager_tx_block_pool_info_get_dispatch+0xce>
 80105ac:	683b      	ldr	r3, [r7, #0]
 80105ae:	3304      	adds	r3, #4
 80105b0:	681b      	ldr	r3, [r3, #0]
 80105b2:	2b00      	cmp	r3, #0
 80105b4:	d001      	beq.n	80105ba <_txm_module_manager_tx_block_pool_info_get_dispatch+0xce>
            return(TXM_MODULE_INVALID_MEMORY);
 80105b6:	23f4      	movs	r3, #244	; 0xf4
 80105b8:	e052      	b.n	8010660 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(TX_THREAD *)))
 80105ba:	683b      	ldr	r3, [r7, #0]
 80105bc:	3308      	adds	r3, #8
 80105be:	681b      	ldr	r3, [r3, #0]
 80105c0:	2204      	movs	r2, #4
 80105c2:	4619      	mov	r1, r3
 80105c4:	68f8      	ldr	r0, [r7, #12]
 80105c6:	f004 fc3f 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80105ca:	4603      	mov	r3, r0
 80105cc:	2b00      	cmp	r3, #0
 80105ce:	d106      	bne.n	80105de <_txm_module_manager_tx_block_pool_info_get_dispatch+0xf2>
 80105d0:	683b      	ldr	r3, [r7, #0]
 80105d2:	3308      	adds	r3, #8
 80105d4:	681b      	ldr	r3, [r3, #0]
 80105d6:	2b00      	cmp	r3, #0
 80105d8:	d001      	beq.n	80105de <_txm_module_manager_tx_block_pool_info_get_dispatch+0xf2>
            return(TXM_MODULE_INVALID_MEMORY);
 80105da:	23f4      	movs	r3, #244	; 0xf4
 80105dc:	e040      	b.n	8010660 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[3], sizeof(ULONG)))
 80105de:	683b      	ldr	r3, [r7, #0]
 80105e0:	330c      	adds	r3, #12
 80105e2:	681b      	ldr	r3, [r3, #0]
 80105e4:	2204      	movs	r2, #4
 80105e6:	4619      	mov	r1, r3
 80105e8:	68f8      	ldr	r0, [r7, #12]
 80105ea:	f004 fc2d 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80105ee:	4603      	mov	r3, r0
 80105f0:	2b00      	cmp	r3, #0
 80105f2:	d106      	bne.n	8010602 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x116>
 80105f4:	683b      	ldr	r3, [r7, #0]
 80105f6:	330c      	adds	r3, #12
 80105f8:	681b      	ldr	r3, [r3, #0]
 80105fa:	2b00      	cmp	r3, #0
 80105fc:	d001      	beq.n	8010602 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x116>
            return(TXM_MODULE_INVALID_MEMORY);
 80105fe:	23f4      	movs	r3, #244	; 0xf4
 8010600:	e02e      	b.n	8010660 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[4], sizeof(TX_BLOCK_POOL *)))
 8010602:	683b      	ldr	r3, [r7, #0]
 8010604:	3310      	adds	r3, #16
 8010606:	681b      	ldr	r3, [r3, #0]
 8010608:	2204      	movs	r2, #4
 801060a:	4619      	mov	r1, r3
 801060c:	68f8      	ldr	r0, [r7, #12]
 801060e:	f004 fc1b 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010612:	4603      	mov	r3, r0
 8010614:	2b00      	cmp	r3, #0
 8010616:	d106      	bne.n	8010626 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x13a>
 8010618:	683b      	ldr	r3, [r7, #0]
 801061a:	3310      	adds	r3, #16
 801061c:	681b      	ldr	r3, [r3, #0]
 801061e:	2b00      	cmp	r3, #0
 8010620:	d001      	beq.n	8010626 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x13a>
            return(TXM_MODULE_INVALID_MEMORY);
 8010622:	23f4      	movs	r3, #244	; 0xf4
 8010624:	e01c      	b.n	8010660 <_txm_module_manager_tx_block_pool_info_get_dispatch+0x174>
    }

    return_value = (ALIGN_TYPE) _txe_block_pool_info_get(
 8010626:	68b8      	ldr	r0, [r7, #8]
 8010628:	6879      	ldr	r1, [r7, #4]
        (TX_BLOCK_POOL *) param_0,
        (CHAR **) param_1,
        (ULONG *) extra_parameters[0],
 801062a:	683b      	ldr	r3, [r7, #0]
 801062c:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_block_pool_info_get(
 801062e:	461d      	mov	r5, r3
        (ULONG *) extra_parameters[1],
 8010630:	683b      	ldr	r3, [r7, #0]
 8010632:	3304      	adds	r3, #4
 8010634:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_block_pool_info_get(
 8010636:	461e      	mov	r6, r3
        (TX_THREAD **) extra_parameters[2],
 8010638:	683b      	ldr	r3, [r7, #0]
 801063a:	3308      	adds	r3, #8
 801063c:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_block_pool_info_get(
 801063e:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[3],
 8010640:	683b      	ldr	r3, [r7, #0]
 8010642:	330c      	adds	r3, #12
 8010644:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_block_pool_info_get(
 8010646:	461c      	mov	r4, r3
        (TX_BLOCK_POOL **) extra_parameters[4]
 8010648:	683b      	ldr	r3, [r7, #0]
 801064a:	3310      	adds	r3, #16
 801064c:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_block_pool_info_get(
 801064e:	9302      	str	r3, [sp, #8]
 8010650:	9401      	str	r4, [sp, #4]
 8010652:	9200      	str	r2, [sp, #0]
 8010654:	4633      	mov	r3, r6
 8010656:	462a      	mov	r2, r5
 8010658:	f7fd fb7c 	bl	800dd54 <_txe_block_pool_info_get>
 801065c:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 801065e:	697b      	ldr	r3, [r7, #20]
}
 8010660:	4618      	mov	r0, r3
 8010662:	371c      	adds	r7, #28
 8010664:	46bd      	mov	sp, r7
 8010666:	bdf0      	pop	{r4, r5, r6, r7, pc}

08010668 <_txm_module_manager_tx_block_pool_performance_info_get_dispatch>:
    ULONG *releases, -> extra_parameters[0]
    ULONG *suspensions, -> extra_parameters[1]
    ULONG *timeouts -> extra_parameters[2]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_block_pool_performance_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8010668:	b590      	push	{r4, r7, lr}
 801066a:	b089      	sub	sp, #36	; 0x24
 801066c:	af02      	add	r7, sp, #8
 801066e:	60f8      	str	r0, [r7, #12]
 8010670:	60b9      	str	r1, [r7, #8]
 8010672:	607a      	str	r2, [r7, #4]
 8010674:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8010676:	68fb      	ldr	r3, [r7, #12]
 8010678:	68db      	ldr	r3, [r3, #12]
 801067a:	f003 0302 	and.w	r3, r3, #2
 801067e:	2b00      	cmp	r3, #0
 8010680:	d06a      	beq.n	8010758 <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0xf0>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_BLOCK_POOL)))
 8010682:	2230      	movs	r2, #48	; 0x30
 8010684:	68b9      	ldr	r1, [r7, #8]
 8010686:	68f8      	ldr	r0, [r7, #12]
 8010688:	f004 fbde 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801068c:	4603      	mov	r3, r0
 801068e:	2b00      	cmp	r3, #0
 8010690:	d111      	bne.n	80106b6 <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0x4e>
 8010692:	68bb      	ldr	r3, [r7, #8]
 8010694:	f113 0f31 	cmn.w	r3, #49	; 0x31
 8010698:	d812      	bhi.n	80106c0 <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0x58>
 801069a:	68fb      	ldr	r3, [r7, #12]
 801069c:	699b      	ldr	r3, [r3, #24]
 801069e:	461a      	mov	r2, r3
 80106a0:	68bb      	ldr	r3, [r7, #8]
 80106a2:	4293      	cmp	r3, r2
 80106a4:	d30c      	bcc.n	80106c0 <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0x58>
 80106a6:	68bb      	ldr	r3, [r7, #8]
 80106a8:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80106ac:	68fb      	ldr	r3, [r7, #12]
 80106ae:	69db      	ldr	r3, [r3, #28]
 80106b0:	3301      	adds	r3, #1
 80106b2:	429a      	cmp	r2, r3
 80106b4:	d804      	bhi.n	80106c0 <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0x58>
 80106b6:	68bb      	ldr	r3, [r7, #8]
 80106b8:	2b00      	cmp	r3, #0
 80106ba:	d001      	beq.n	80106c0 <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0x58>
            return(TXM_MODULE_INVALID_MEMORY);
 80106bc:	23f4      	movs	r3, #244	; 0xf4
 80106be:	e05d      	b.n	801077c <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0x114>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(ULONG)))
 80106c0:	2204      	movs	r2, #4
 80106c2:	6879      	ldr	r1, [r7, #4]
 80106c4:	68f8      	ldr	r0, [r7, #12]
 80106c6:	f004 fbbf 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80106ca:	4603      	mov	r3, r0
 80106cc:	2b00      	cmp	r3, #0
 80106ce:	d104      	bne.n	80106da <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0x72>
 80106d0:	687b      	ldr	r3, [r7, #4]
 80106d2:	2b00      	cmp	r3, #0
 80106d4:	d001      	beq.n	80106da <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0x72>
            return(TXM_MODULE_INVALID_MEMORY);
 80106d6:	23f4      	movs	r3, #244	; 0xf4
 80106d8:	e050      	b.n	801077c <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0x114>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[3])))
 80106da:	683b      	ldr	r3, [r7, #0]
 80106dc:	220c      	movs	r2, #12
 80106de:	4619      	mov	r1, r3
 80106e0:	68f8      	ldr	r0, [r7, #12]
 80106e2:	f004 fbb1 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80106e6:	4603      	mov	r3, r0
 80106e8:	2b00      	cmp	r3, #0
 80106ea:	d101      	bne.n	80106f0 <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0x88>
            return(TXM_MODULE_INVALID_MEMORY);
 80106ec:	23f4      	movs	r3, #244	; 0xf4
 80106ee:	e045      	b.n	801077c <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0x114>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 80106f0:	683b      	ldr	r3, [r7, #0]
 80106f2:	681b      	ldr	r3, [r3, #0]
 80106f4:	2204      	movs	r2, #4
 80106f6:	4619      	mov	r1, r3
 80106f8:	68f8      	ldr	r0, [r7, #12]
 80106fa:	f004 fba5 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80106fe:	4603      	mov	r3, r0
 8010700:	2b00      	cmp	r3, #0
 8010702:	d105      	bne.n	8010710 <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0xa8>
 8010704:	683b      	ldr	r3, [r7, #0]
 8010706:	681b      	ldr	r3, [r3, #0]
 8010708:	2b00      	cmp	r3, #0
 801070a:	d001      	beq.n	8010710 <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0xa8>
            return(TXM_MODULE_INVALID_MEMORY);
 801070c:	23f4      	movs	r3, #244	; 0xf4
 801070e:	e035      	b.n	801077c <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0x114>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 8010710:	683b      	ldr	r3, [r7, #0]
 8010712:	3304      	adds	r3, #4
 8010714:	681b      	ldr	r3, [r3, #0]
 8010716:	2204      	movs	r2, #4
 8010718:	4619      	mov	r1, r3
 801071a:	68f8      	ldr	r0, [r7, #12]
 801071c:	f004 fb94 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010720:	4603      	mov	r3, r0
 8010722:	2b00      	cmp	r3, #0
 8010724:	d106      	bne.n	8010734 <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0xcc>
 8010726:	683b      	ldr	r3, [r7, #0]
 8010728:	3304      	adds	r3, #4
 801072a:	681b      	ldr	r3, [r3, #0]
 801072c:	2b00      	cmp	r3, #0
 801072e:	d001      	beq.n	8010734 <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0xcc>
            return(TXM_MODULE_INVALID_MEMORY);
 8010730:	23f4      	movs	r3, #244	; 0xf4
 8010732:	e023      	b.n	801077c <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0x114>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(ULONG)))
 8010734:	683b      	ldr	r3, [r7, #0]
 8010736:	3308      	adds	r3, #8
 8010738:	681b      	ldr	r3, [r3, #0]
 801073a:	2204      	movs	r2, #4
 801073c:	4619      	mov	r1, r3
 801073e:	68f8      	ldr	r0, [r7, #12]
 8010740:	f004 fb82 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010744:	4603      	mov	r3, r0
 8010746:	2b00      	cmp	r3, #0
 8010748:	d106      	bne.n	8010758 <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0xf0>
 801074a:	683b      	ldr	r3, [r7, #0]
 801074c:	3308      	adds	r3, #8
 801074e:	681b      	ldr	r3, [r3, #0]
 8010750:	2b00      	cmp	r3, #0
 8010752:	d001      	beq.n	8010758 <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0xf0>
            return(TXM_MODULE_INVALID_MEMORY);
 8010754:	23f4      	movs	r3, #244	; 0xf4
 8010756:	e011      	b.n	801077c <_txm_module_manager_tx_block_pool_performance_info_get_dispatch+0x114>
    }

    return_value = (ALIGN_TYPE) _tx_block_pool_performance_info_get(
 8010758:	68b8      	ldr	r0, [r7, #8]
 801075a:	6879      	ldr	r1, [r7, #4]
        (TX_BLOCK_POOL *) param_0,
        (ULONG *) param_1,
        (ULONG *) extra_parameters[0],
 801075c:	683b      	ldr	r3, [r7, #0]
 801075e:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_block_pool_performance_info_get(
 8010760:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[1],
 8010762:	683b      	ldr	r3, [r7, #0]
 8010764:	3304      	adds	r3, #4
 8010766:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_block_pool_performance_info_get(
 8010768:	461c      	mov	r4, r3
        (ULONG *) extra_parameters[2]
 801076a:	683b      	ldr	r3, [r7, #0]
 801076c:	3308      	adds	r3, #8
 801076e:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_block_pool_performance_info_get(
 8010770:	9300      	str	r3, [sp, #0]
 8010772:	4623      	mov	r3, r4
 8010774:	f7f6 ff4c 	bl	8007610 <_tx_block_pool_performance_info_get>
 8010778:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 801077a:	697b      	ldr	r3, [r7, #20]
}
 801077c:	4618      	mov	r0, r3
 801077e:	371c      	adds	r7, #28
 8010780:	46bd      	mov	sp, r7
 8010782:	bd90      	pop	{r4, r7, pc}

08010784 <_txm_module_manager_tx_block_pool_performance_system_info_get_dispatch>:
    ULONG *releases, -> param_1
    ULONG *suspensions, -> extra_parameters[0]
    ULONG *timeouts -> extra_parameters[1]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_block_pool_performance_system_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8010784:	b580      	push	{r7, lr}
 8010786:	b086      	sub	sp, #24
 8010788:	af00      	add	r7, sp, #0
 801078a:	60f8      	str	r0, [r7, #12]
 801078c:	60b9      	str	r1, [r7, #8]
 801078e:	607a      	str	r2, [r7, #4]
 8010790:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8010792:	68fb      	ldr	r3, [r7, #12]
 8010794:	68db      	ldr	r3, [r3, #12]
 8010796:	f003 0302 	and.w	r3, r3, #2
 801079a:	2b00      	cmp	r3, #0
 801079c:	d046      	beq.n	801082c <_txm_module_manager_tx_block_pool_performance_system_info_get_dispatch+0xa8>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_0, sizeof(ULONG)))
 801079e:	2204      	movs	r2, #4
 80107a0:	68b9      	ldr	r1, [r7, #8]
 80107a2:	68f8      	ldr	r0, [r7, #12]
 80107a4:	f004 fb50 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80107a8:	4603      	mov	r3, r0
 80107aa:	2b00      	cmp	r3, #0
 80107ac:	d104      	bne.n	80107b8 <_txm_module_manager_tx_block_pool_performance_system_info_get_dispatch+0x34>
 80107ae:	68bb      	ldr	r3, [r7, #8]
 80107b0:	2b00      	cmp	r3, #0
 80107b2:	d001      	beq.n	80107b8 <_txm_module_manager_tx_block_pool_performance_system_info_get_dispatch+0x34>
            return(TXM_MODULE_INVALID_MEMORY);
 80107b4:	23f4      	movs	r3, #244	; 0xf4
 80107b6:	e045      	b.n	8010844 <_txm_module_manager_tx_block_pool_performance_system_info_get_dispatch+0xc0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(ULONG)))
 80107b8:	2204      	movs	r2, #4
 80107ba:	6879      	ldr	r1, [r7, #4]
 80107bc:	68f8      	ldr	r0, [r7, #12]
 80107be:	f004 fb43 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80107c2:	4603      	mov	r3, r0
 80107c4:	2b00      	cmp	r3, #0
 80107c6:	d104      	bne.n	80107d2 <_txm_module_manager_tx_block_pool_performance_system_info_get_dispatch+0x4e>
 80107c8:	687b      	ldr	r3, [r7, #4]
 80107ca:	2b00      	cmp	r3, #0
 80107cc:	d001      	beq.n	80107d2 <_txm_module_manager_tx_block_pool_performance_system_info_get_dispatch+0x4e>
            return(TXM_MODULE_INVALID_MEMORY);
 80107ce:	23f4      	movs	r3, #244	; 0xf4
 80107d0:	e038      	b.n	8010844 <_txm_module_manager_tx_block_pool_performance_system_info_get_dispatch+0xc0>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[2])))
 80107d2:	683b      	ldr	r3, [r7, #0]
 80107d4:	2208      	movs	r2, #8
 80107d6:	4619      	mov	r1, r3
 80107d8:	68f8      	ldr	r0, [r7, #12]
 80107da:	f004 fb35 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80107de:	4603      	mov	r3, r0
 80107e0:	2b00      	cmp	r3, #0
 80107e2:	d101      	bne.n	80107e8 <_txm_module_manager_tx_block_pool_performance_system_info_get_dispatch+0x64>
            return(TXM_MODULE_INVALID_MEMORY);
 80107e4:	23f4      	movs	r3, #244	; 0xf4
 80107e6:	e02d      	b.n	8010844 <_txm_module_manager_tx_block_pool_performance_system_info_get_dispatch+0xc0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 80107e8:	683b      	ldr	r3, [r7, #0]
 80107ea:	681b      	ldr	r3, [r3, #0]
 80107ec:	2204      	movs	r2, #4
 80107ee:	4619      	mov	r1, r3
 80107f0:	68f8      	ldr	r0, [r7, #12]
 80107f2:	f004 fb29 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80107f6:	4603      	mov	r3, r0
 80107f8:	2b00      	cmp	r3, #0
 80107fa:	d105      	bne.n	8010808 <_txm_module_manager_tx_block_pool_performance_system_info_get_dispatch+0x84>
 80107fc:	683b      	ldr	r3, [r7, #0]
 80107fe:	681b      	ldr	r3, [r3, #0]
 8010800:	2b00      	cmp	r3, #0
 8010802:	d001      	beq.n	8010808 <_txm_module_manager_tx_block_pool_performance_system_info_get_dispatch+0x84>
            return(TXM_MODULE_INVALID_MEMORY);
 8010804:	23f4      	movs	r3, #244	; 0xf4
 8010806:	e01d      	b.n	8010844 <_txm_module_manager_tx_block_pool_performance_system_info_get_dispatch+0xc0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 8010808:	683b      	ldr	r3, [r7, #0]
 801080a:	3304      	adds	r3, #4
 801080c:	681b      	ldr	r3, [r3, #0]
 801080e:	2204      	movs	r2, #4
 8010810:	4619      	mov	r1, r3
 8010812:	68f8      	ldr	r0, [r7, #12]
 8010814:	f004 fb18 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010818:	4603      	mov	r3, r0
 801081a:	2b00      	cmp	r3, #0
 801081c:	d106      	bne.n	801082c <_txm_module_manager_tx_block_pool_performance_system_info_get_dispatch+0xa8>
 801081e:	683b      	ldr	r3, [r7, #0]
 8010820:	3304      	adds	r3, #4
 8010822:	681b      	ldr	r3, [r3, #0]
 8010824:	2b00      	cmp	r3, #0
 8010826:	d001      	beq.n	801082c <_txm_module_manager_tx_block_pool_performance_system_info_get_dispatch+0xa8>
            return(TXM_MODULE_INVALID_MEMORY);
 8010828:	23f4      	movs	r3, #244	; 0xf4
 801082a:	e00b      	b.n	8010844 <_txm_module_manager_tx_block_pool_performance_system_info_get_dispatch+0xc0>
    }

    return_value = (ALIGN_TYPE) _tx_block_pool_performance_system_info_get(
 801082c:	68b8      	ldr	r0, [r7, #8]
 801082e:	6879      	ldr	r1, [r7, #4]
        (ULONG *) param_0,
        (ULONG *) param_1,
        (ULONG *) extra_parameters[0],
 8010830:	683b      	ldr	r3, [r7, #0]
 8010832:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_block_pool_performance_system_info_get(
 8010834:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[1]
 8010836:	683b      	ldr	r3, [r7, #0]
 8010838:	3304      	adds	r3, #4
 801083a:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_block_pool_performance_system_info_get(
 801083c:	f7f6 ff16 	bl	800766c <_tx_block_pool_performance_system_info_get>
 8010840:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 8010842:	697b      	ldr	r3, [r7, #20]
}
 8010844:	4618      	mov	r0, r3
 8010846:	3718      	adds	r7, #24
 8010848:	46bd      	mov	sp, r7
 801084a:	bd80      	pop	{r7, pc}

0801084c <_txm_module_manager_tx_block_pool_prioritize_dispatch>:
#ifndef TXM_BLOCK_POOL_PRIORITIZE_CALL_NOT_USED
/* UINT _txe_block_pool_prioritize(
    TX_BLOCK_POOL *pool_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_block_pool_prioritize_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 801084c:	b580      	push	{r7, lr}
 801084e:	b084      	sub	sp, #16
 8010850:	af00      	add	r7, sp, #0
 8010852:	6078      	str	r0, [r7, #4]
 8010854:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8010856:	687b      	ldr	r3, [r7, #4]
 8010858:	68db      	ldr	r3, [r3, #12]
 801085a:	f003 0302 	and.w	r3, r3, #2
 801085e:	2b00      	cmp	r3, #0
 8010860:	d01e      	beq.n	80108a0 <_txm_module_manager_tx_block_pool_prioritize_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_BLOCK_POOL)))
 8010862:	2230      	movs	r2, #48	; 0x30
 8010864:	6839      	ldr	r1, [r7, #0]
 8010866:	6878      	ldr	r0, [r7, #4]
 8010868:	f004 faee 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801086c:	4603      	mov	r3, r0
 801086e:	2b00      	cmp	r3, #0
 8010870:	d111      	bne.n	8010896 <_txm_module_manager_tx_block_pool_prioritize_dispatch+0x4a>
 8010872:	683b      	ldr	r3, [r7, #0]
 8010874:	f113 0f31 	cmn.w	r3, #49	; 0x31
 8010878:	d812      	bhi.n	80108a0 <_txm_module_manager_tx_block_pool_prioritize_dispatch+0x54>
 801087a:	687b      	ldr	r3, [r7, #4]
 801087c:	699b      	ldr	r3, [r3, #24]
 801087e:	461a      	mov	r2, r3
 8010880:	683b      	ldr	r3, [r7, #0]
 8010882:	4293      	cmp	r3, r2
 8010884:	d30c      	bcc.n	80108a0 <_txm_module_manager_tx_block_pool_prioritize_dispatch+0x54>
 8010886:	683b      	ldr	r3, [r7, #0]
 8010888:	f103 0230 	add.w	r2, r3, #48	; 0x30
 801088c:	687b      	ldr	r3, [r7, #4]
 801088e:	69db      	ldr	r3, [r3, #28]
 8010890:	3301      	adds	r3, #1
 8010892:	429a      	cmp	r2, r3
 8010894:	d804      	bhi.n	80108a0 <_txm_module_manager_tx_block_pool_prioritize_dispatch+0x54>
 8010896:	683b      	ldr	r3, [r7, #0]
 8010898:	2b00      	cmp	r3, #0
 801089a:	d001      	beq.n	80108a0 <_txm_module_manager_tx_block_pool_prioritize_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 801089c:	23f4      	movs	r3, #244	; 0xf4
 801089e:	e005      	b.n	80108ac <_txm_module_manager_tx_block_pool_prioritize_dispatch+0x60>
    }

    return_value = (ALIGN_TYPE) _txe_block_pool_prioritize(
 80108a0:	683b      	ldr	r3, [r7, #0]
 80108a2:	4618      	mov	r0, r3
 80108a4:	f7fd fa80 	bl	800dda8 <_txe_block_pool_prioritize>
 80108a8:	60f8      	str	r0, [r7, #12]
        (TX_BLOCK_POOL *) param_0
    );
    return(return_value);
 80108aa:	68fb      	ldr	r3, [r7, #12]
}
 80108ac:	4618      	mov	r0, r3
 80108ae:	3710      	adds	r7, #16
 80108b0:	46bd      	mov	sp, r7
 80108b2:	bd80      	pop	{r7, pc}

080108b4 <_txm_module_manager_tx_block_release_dispatch>:
#ifndef TXM_BLOCK_RELEASE_CALL_NOT_USED
/* UINT _txe_block_release(
    VOID *block_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_block_release_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 80108b4:	b580      	push	{r7, lr}
 80108b6:	b084      	sub	sp, #16
 80108b8:	af00      	add	r7, sp, #0
 80108ba:	6078      	str	r0, [r7, #4]
 80108bc:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;
ALIGN_TYPE block_header_start;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 80108be:	687b      	ldr	r3, [r7, #4]
 80108c0:	68db      	ldr	r3, [r3, #12]
 80108c2:	f003 0302 	and.w	r3, r3, #2
 80108c6:	2b00      	cmp	r3, #0
 80108c8:	d013      	beq.n	80108f2 <_txm_module_manager_tx_block_release_dispatch+0x3e>
    {
        /* Is the pointer non-null?  */
        if ((void *) param_0 != TX_NULL)
 80108ca:	683b      	ldr	r3, [r7, #0]
 80108cc:	2b00      	cmp	r3, #0
 80108ce:	d010      	beq.n	80108f2 <_txm_module_manager_tx_block_release_dispatch+0x3e>
        {

            /* Calculate the beginning of the header info for this block (the header
               consists of 1 pointers.  */
            block_header_start =  param_0 - sizeof(ALIGN_TYPE);
 80108d0:	683b      	ldr	r3, [r7, #0]
 80108d2:	3b04      	subs	r3, #4
 80108d4:	60fb      	str	r3, [r7, #12]

            if (/* Did we underflow when doing the subtract?  */
 80108d6:	68fa      	ldr	r2, [r7, #12]
 80108d8:	683b      	ldr	r3, [r7, #0]
 80108da:	429a      	cmp	r2, r3
 80108dc:	d807      	bhi.n	80108ee <_txm_module_manager_tx_block_release_dispatch+0x3a>
                (block_header_start > param_0) ||
                /* Ensure the pointer is inside the module's data. Note that we only
                   check the pointer in the header because only that pointer is
                   dereferenced during the pointer's validity check in _tx_block_release. */
                (!TXM_MODULE_MANAGER_CHECK_INSIDE_DATA(module_instance, block_header_start, sizeof(ALIGN_TYPE))))
 80108de:	2204      	movs	r2, #4
 80108e0:	68f9      	ldr	r1, [r7, #12]
 80108e2:	6878      	ldr	r0, [r7, #4]
 80108e4:	f004 fab0 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80108e8:	4603      	mov	r3, r0
                (block_header_start > param_0) ||
 80108ea:	2b00      	cmp	r3, #0
 80108ec:	d101      	bne.n	80108f2 <_txm_module_manager_tx_block_release_dispatch+0x3e>
            {

                /* Invalid pointer.  */
                return(TXM_MODULE_INVALID_MEMORY);
 80108ee:	23f4      	movs	r3, #244	; 0xf4
 80108f0:	e005      	b.n	80108fe <_txm_module_manager_tx_block_release_dispatch+0x4a>
            }
        }
    }

    return_value = (ALIGN_TYPE) _txe_block_release(
 80108f2:	683b      	ldr	r3, [r7, #0]
 80108f4:	4618      	mov	r0, r3
 80108f6:	f7fd fa75 	bl	800dde4 <_txe_block_release>
 80108fa:	60b8      	str	r0, [r7, #8]
        (VOID *) param_0
    );
    return(return_value);
 80108fc:	68bb      	ldr	r3, [r7, #8]
}
 80108fe:	4618      	mov	r0, r3
 8010900:	3710      	adds	r7, #16
 8010902:	46bd      	mov	sp, r7
 8010904:	bd80      	pop	{r7, pc}

08010906 <_txm_module_manager_tx_byte_allocate_dispatch>:
    VOID **memory_ptr, -> param_1
    ULONG memory_size, -> extra_parameters[0]
    ULONG wait_option -> extra_parameters[1]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_byte_allocate_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8010906:	b580      	push	{r7, lr}
 8010908:	b086      	sub	sp, #24
 801090a:	af00      	add	r7, sp, #0
 801090c:	60f8      	str	r0, [r7, #12]
 801090e:	60b9      	str	r1, [r7, #8]
 8010910:	607a      	str	r2, [r7, #4]
 8010912:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8010914:	68fb      	ldr	r3, [r7, #12]
 8010916:	68db      	ldr	r3, [r3, #12]
 8010918:	f003 0302 	and.w	r3, r3, #2
 801091c:	2b00      	cmp	r3, #0
 801091e:	d036      	beq.n	801098e <_txm_module_manager_tx_byte_allocate_dispatch+0x88>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_BYTE_POOL)))
 8010920:	2234      	movs	r2, #52	; 0x34
 8010922:	68b9      	ldr	r1, [r7, #8]
 8010924:	68f8      	ldr	r0, [r7, #12]
 8010926:	f004 fa8f 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801092a:	4603      	mov	r3, r0
 801092c:	2b00      	cmp	r3, #0
 801092e:	d111      	bne.n	8010954 <_txm_module_manager_tx_byte_allocate_dispatch+0x4e>
 8010930:	68bb      	ldr	r3, [r7, #8]
 8010932:	f113 0f35 	cmn.w	r3, #53	; 0x35
 8010936:	d812      	bhi.n	801095e <_txm_module_manager_tx_byte_allocate_dispatch+0x58>
 8010938:	68fb      	ldr	r3, [r7, #12]
 801093a:	699b      	ldr	r3, [r3, #24]
 801093c:	461a      	mov	r2, r3
 801093e:	68bb      	ldr	r3, [r7, #8]
 8010940:	4293      	cmp	r3, r2
 8010942:	d30c      	bcc.n	801095e <_txm_module_manager_tx_byte_allocate_dispatch+0x58>
 8010944:	68bb      	ldr	r3, [r7, #8]
 8010946:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801094a:	68fb      	ldr	r3, [r7, #12]
 801094c:	69db      	ldr	r3, [r3, #28]
 801094e:	3301      	adds	r3, #1
 8010950:	429a      	cmp	r2, r3
 8010952:	d804      	bhi.n	801095e <_txm_module_manager_tx_byte_allocate_dispatch+0x58>
 8010954:	68bb      	ldr	r3, [r7, #8]
 8010956:	2b00      	cmp	r3, #0
 8010958:	d001      	beq.n	801095e <_txm_module_manager_tx_byte_allocate_dispatch+0x58>
            return(TXM_MODULE_INVALID_MEMORY);
 801095a:	23f4      	movs	r3, #244	; 0xf4
 801095c:	e022      	b.n	80109a4 <_txm_module_manager_tx_byte_allocate_dispatch+0x9e>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(VOID *)))
 801095e:	2204      	movs	r2, #4
 8010960:	6879      	ldr	r1, [r7, #4]
 8010962:	68f8      	ldr	r0, [r7, #12]
 8010964:	f004 fa70 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010968:	4603      	mov	r3, r0
 801096a:	2b00      	cmp	r3, #0
 801096c:	d104      	bne.n	8010978 <_txm_module_manager_tx_byte_allocate_dispatch+0x72>
 801096e:	687b      	ldr	r3, [r7, #4]
 8010970:	2b00      	cmp	r3, #0
 8010972:	d001      	beq.n	8010978 <_txm_module_manager_tx_byte_allocate_dispatch+0x72>
            return(TXM_MODULE_INVALID_MEMORY);
 8010974:	23f4      	movs	r3, #244	; 0xf4
 8010976:	e015      	b.n	80109a4 <_txm_module_manager_tx_byte_allocate_dispatch+0x9e>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[2])))
 8010978:	683b      	ldr	r3, [r7, #0]
 801097a:	2208      	movs	r2, #8
 801097c:	4619      	mov	r1, r3
 801097e:	68f8      	ldr	r0, [r7, #12]
 8010980:	f004 fa62 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010984:	4603      	mov	r3, r0
 8010986:	2b00      	cmp	r3, #0
 8010988:	d101      	bne.n	801098e <_txm_module_manager_tx_byte_allocate_dispatch+0x88>
            return(TXM_MODULE_INVALID_MEMORY);
 801098a:	23f4      	movs	r3, #244	; 0xf4
 801098c:	e00a      	b.n	80109a4 <_txm_module_manager_tx_byte_allocate_dispatch+0x9e>
    }

    return_value = (ALIGN_TYPE) _txe_byte_allocate(
 801098e:	68b8      	ldr	r0, [r7, #8]
 8010990:	6879      	ldr	r1, [r7, #4]
 8010992:	683b      	ldr	r3, [r7, #0]
 8010994:	681a      	ldr	r2, [r3, #0]
        (TX_BYTE_POOL *) param_0,
        (VOID **) param_1,
        (ULONG) extra_parameters[0],
        (ULONG) extra_parameters[1]
 8010996:	683b      	ldr	r3, [r7, #0]
 8010998:	3304      	adds	r3, #4
    return_value = (ALIGN_TYPE) _txe_byte_allocate(
 801099a:	681b      	ldr	r3, [r3, #0]
 801099c:	f7fd fa52 	bl	800de44 <_txe_byte_allocate>
 80109a0:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 80109a2:	697b      	ldr	r3, [r7, #20]
}
 80109a4:	4618      	mov	r0, r3
 80109a6:	3718      	adds	r7, #24
 80109a8:	46bd      	mov	sp, r7
 80109aa:	bd80      	pop	{r7, pc}

080109ac <_txm_module_manager_tx_byte_pool_create_dispatch>:
    VOID *pool_start, -> extra_parameters[0]
    ULONG pool_size, -> extra_parameters[1]
    UINT pool_control_block_size -> extra_parameters[2]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_byte_pool_create_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 80109ac:	b590      	push	{r4, r7, lr}
 80109ae:	b089      	sub	sp, #36	; 0x24
 80109b0:	af02      	add	r7, sp, #8
 80109b2:	60f8      	str	r0, [r7, #12]
 80109b4:	60b9      	str	r1, [r7, #8]
 80109b6:	607a      	str	r2, [r7, #4]
 80109b8:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 80109ba:	68fb      	ldr	r3, [r7, #12]
 80109bc:	68db      	ldr	r3, [r3, #12]
 80109be:	f003 0302 	and.w	r3, r3, #2
 80109c2:	2b00      	cmp	r3, #0
 80109c4:	d05d      	beq.n	8010a82 <_txm_module_manager_tx_byte_pool_create_dispatch+0xd6>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_CREATION(module_instance, param_0, sizeof(TX_BYTE_POOL)))
 80109c6:	4b3a      	ldr	r3, [pc, #232]	; (8010ab0 <_txm_module_manager_tx_byte_pool_create_dispatch+0x104>)
 80109c8:	681b      	ldr	r3, [r3, #0]
 80109ca:	2b01      	cmp	r3, #1
 80109cc:	d119      	bne.n	8010a02 <_txm_module_manager_tx_byte_pool_create_dispatch+0x56>
 80109ce:	68bb      	ldr	r3, [r7, #8]
 80109d0:	f113 0f35 	cmn.w	r3, #53	; 0x35
 80109d4:	d815      	bhi.n	8010a02 <_txm_module_manager_tx_byte_pool_create_dispatch+0x56>
 80109d6:	4b37      	ldr	r3, [pc, #220]	; (8010ab4 <_txm_module_manager_tx_byte_pool_create_dispatch+0x108>)
 80109d8:	699b      	ldr	r3, [r3, #24]
 80109da:	3310      	adds	r3, #16
 80109dc:	68ba      	ldr	r2, [r7, #8]
 80109de:	429a      	cmp	r2, r3
 80109e0:	d30f      	bcc.n	8010a02 <_txm_module_manager_tx_byte_pool_create_dispatch+0x56>
 80109e2:	68bb      	ldr	r3, [r7, #8]
 80109e4:	3334      	adds	r3, #52	; 0x34
 80109e6:	4a33      	ldr	r2, [pc, #204]	; (8010ab4 <_txm_module_manager_tx_byte_pool_create_dispatch+0x108>)
 80109e8:	6991      	ldr	r1, [r2, #24]
 80109ea:	4a32      	ldr	r2, [pc, #200]	; (8010ab4 <_txm_module_manager_tx_byte_pool_create_dispatch+0x108>)
 80109ec:	69d2      	ldr	r2, [r2, #28]
 80109ee:	440a      	add	r2, r1
 80109f0:	4293      	cmp	r3, r2
 80109f2:	d806      	bhi.n	8010a02 <_txm_module_manager_tx_byte_pool_create_dispatch+0x56>
 80109f4:	2134      	movs	r1, #52	; 0x34
 80109f6:	68b8      	ldr	r0, [r7, #8]
 80109f8:	f005 fe4e 	bl	8016698 <_txm_module_manager_object_size_check>
 80109fc:	4603      	mov	r3, r0
 80109fe:	2b00      	cmp	r3, #0
 8010a00:	d004      	beq.n	8010a0c <_txm_module_manager_tx_byte_pool_create_dispatch+0x60>
 8010a02:	68bb      	ldr	r3, [r7, #8]
 8010a04:	2b00      	cmp	r3, #0
 8010a06:	d001      	beq.n	8010a0c <_txm_module_manager_tx_byte_pool_create_dispatch+0x60>
            return(TXM_MODULE_INVALID_MEMORY);
 8010a08:	23f4      	movs	r3, #244	; 0xf4
 8010a0a:	e04c      	b.n	8010aa6 <_txm_module_manager_tx_byte_pool_create_dispatch+0xfa>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_DEREFERENCE_STRING(module_instance, param_1))
 8010a0c:	2201      	movs	r2, #1
 8010a0e:	6879      	ldr	r1, [r7, #4]
 8010a10:	68f8      	ldr	r0, [r7, #12]
 8010a12:	f004 fa19 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010a16:	4603      	mov	r3, r0
 8010a18:	2b00      	cmp	r3, #0
 8010a1a:	d115      	bne.n	8010a48 <_txm_module_manager_tx_byte_pool_create_dispatch+0x9c>
 8010a1c:	687b      	ldr	r3, [r7, #4]
 8010a1e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8010a22:	d00c      	beq.n	8010a3e <_txm_module_manager_tx_byte_pool_create_dispatch+0x92>
 8010a24:	68fb      	ldr	r3, [r7, #12]
 8010a26:	699b      	ldr	r3, [r3, #24]
 8010a28:	461a      	mov	r2, r3
 8010a2a:	687b      	ldr	r3, [r7, #4]
 8010a2c:	4293      	cmp	r3, r2
 8010a2e:	d306      	bcc.n	8010a3e <_txm_module_manager_tx_byte_pool_create_dispatch+0x92>
 8010a30:	687b      	ldr	r3, [r7, #4]
 8010a32:	1c5a      	adds	r2, r3, #1
 8010a34:	68fb      	ldr	r3, [r7, #12]
 8010a36:	69db      	ldr	r3, [r3, #28]
 8010a38:	3301      	adds	r3, #1
 8010a3a:	429a      	cmp	r2, r3
 8010a3c:	d904      	bls.n	8010a48 <_txm_module_manager_tx_byte_pool_create_dispatch+0x9c>
 8010a3e:	687b      	ldr	r3, [r7, #4]
 8010a40:	2b00      	cmp	r3, #0
 8010a42:	d001      	beq.n	8010a48 <_txm_module_manager_tx_byte_pool_create_dispatch+0x9c>
            return(TXM_MODULE_INVALID_MEMORY);
 8010a44:	23f4      	movs	r3, #244	; 0xf4
 8010a46:	e02e      	b.n	8010aa6 <_txm_module_manager_tx_byte_pool_create_dispatch+0xfa>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[3])))
 8010a48:	683b      	ldr	r3, [r7, #0]
 8010a4a:	220c      	movs	r2, #12
 8010a4c:	4619      	mov	r1, r3
 8010a4e:	68f8      	ldr	r0, [r7, #12]
 8010a50:	f004 f9fa 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010a54:	4603      	mov	r3, r0
 8010a56:	2b00      	cmp	r3, #0
 8010a58:	d101      	bne.n	8010a5e <_txm_module_manager_tx_byte_pool_create_dispatch+0xb2>
            return(TXM_MODULE_INVALID_MEMORY);
 8010a5a:	23f4      	movs	r3, #244	; 0xf4
 8010a5c:	e023      	b.n	8010aa6 <_txm_module_manager_tx_byte_pool_create_dispatch+0xfa>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], extra_parameters[1]))
 8010a5e:	683b      	ldr	r3, [r7, #0]
 8010a60:	6819      	ldr	r1, [r3, #0]
 8010a62:	683b      	ldr	r3, [r7, #0]
 8010a64:	3304      	adds	r3, #4
 8010a66:	681b      	ldr	r3, [r3, #0]
 8010a68:	461a      	mov	r2, r3
 8010a6a:	68f8      	ldr	r0, [r7, #12]
 8010a6c:	f004 f9ec 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010a70:	4603      	mov	r3, r0
 8010a72:	2b00      	cmp	r3, #0
 8010a74:	d105      	bne.n	8010a82 <_txm_module_manager_tx_byte_pool_create_dispatch+0xd6>
 8010a76:	683b      	ldr	r3, [r7, #0]
 8010a78:	681b      	ldr	r3, [r3, #0]
 8010a7a:	2b00      	cmp	r3, #0
 8010a7c:	d001      	beq.n	8010a82 <_txm_module_manager_tx_byte_pool_create_dispatch+0xd6>
            return(TXM_MODULE_INVALID_MEMORY);
 8010a7e:	23f4      	movs	r3, #244	; 0xf4
 8010a80:	e011      	b.n	8010aa6 <_txm_module_manager_tx_byte_pool_create_dispatch+0xfa>
    }

    return_value = (ALIGN_TYPE) _txe_byte_pool_create(
 8010a82:	68b8      	ldr	r0, [r7, #8]
 8010a84:	6879      	ldr	r1, [r7, #4]
        (TX_BYTE_POOL *) param_0,
        (CHAR *) param_1,
        (VOID *) extra_parameters[0],
 8010a86:	683b      	ldr	r3, [r7, #0]
 8010a88:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_byte_pool_create(
 8010a8a:	461c      	mov	r4, r3
        (ULONG) extra_parameters[1],
 8010a8c:	683b      	ldr	r3, [r7, #0]
 8010a8e:	3304      	adds	r3, #4
    return_value = (ALIGN_TYPE) _txe_byte_pool_create(
 8010a90:	681a      	ldr	r2, [r3, #0]
        (UINT) extra_parameters[2]
 8010a92:	683b      	ldr	r3, [r7, #0]
 8010a94:	3308      	adds	r3, #8
    return_value = (ALIGN_TYPE) _txe_byte_pool_create(
 8010a96:	681b      	ldr	r3, [r3, #0]
 8010a98:	9300      	str	r3, [sp, #0]
 8010a9a:	4613      	mov	r3, r2
 8010a9c:	4622      	mov	r2, r4
 8010a9e:	f7fd fa45 	bl	800df2c <_txe_byte_pool_create>
 8010aa2:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 8010aa4:	697b      	ldr	r3, [r7, #20]
}
 8010aa6:	4618      	mov	r0, r3
 8010aa8:	371c      	adds	r7, #28
 8010aaa:	46bd      	mov	sp, r7
 8010aac:	bd90      	pop	{r4, r7, pc}
 8010aae:	bf00      	nop
 8010ab0:	2000f670 	.word	0x2000f670
 8010ab4:	2000f63c 	.word	0x2000f63c

08010ab8 <_txm_module_manager_tx_byte_pool_delete_dispatch>:
#ifndef TXM_BYTE_POOL_DELETE_CALL_NOT_USED
/* UINT _txe_byte_pool_delete(
    TX_BYTE_POOL *pool_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_byte_pool_delete_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8010ab8:	b580      	push	{r7, lr}
 8010aba:	b084      	sub	sp, #16
 8010abc:	af00      	add	r7, sp, #0
 8010abe:	6078      	str	r0, [r7, #4]
 8010ac0:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8010ac2:	687b      	ldr	r3, [r7, #4]
 8010ac4:	68db      	ldr	r3, [r3, #12]
 8010ac6:	f003 0302 	and.w	r3, r3, #2
 8010aca:	2b00      	cmp	r3, #0
 8010acc:	d01e      	beq.n	8010b0c <_txm_module_manager_tx_byte_pool_delete_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_BYTE_POOL)))
 8010ace:	2234      	movs	r2, #52	; 0x34
 8010ad0:	6839      	ldr	r1, [r7, #0]
 8010ad2:	6878      	ldr	r0, [r7, #4]
 8010ad4:	f004 f9b8 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010ad8:	4603      	mov	r3, r0
 8010ada:	2b00      	cmp	r3, #0
 8010adc:	d111      	bne.n	8010b02 <_txm_module_manager_tx_byte_pool_delete_dispatch+0x4a>
 8010ade:	683b      	ldr	r3, [r7, #0]
 8010ae0:	f113 0f35 	cmn.w	r3, #53	; 0x35
 8010ae4:	d812      	bhi.n	8010b0c <_txm_module_manager_tx_byte_pool_delete_dispatch+0x54>
 8010ae6:	687b      	ldr	r3, [r7, #4]
 8010ae8:	699b      	ldr	r3, [r3, #24]
 8010aea:	461a      	mov	r2, r3
 8010aec:	683b      	ldr	r3, [r7, #0]
 8010aee:	4293      	cmp	r3, r2
 8010af0:	d30c      	bcc.n	8010b0c <_txm_module_manager_tx_byte_pool_delete_dispatch+0x54>
 8010af2:	683b      	ldr	r3, [r7, #0]
 8010af4:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8010af8:	687b      	ldr	r3, [r7, #4]
 8010afa:	69db      	ldr	r3, [r3, #28]
 8010afc:	3301      	adds	r3, #1
 8010afe:	429a      	cmp	r2, r3
 8010b00:	d804      	bhi.n	8010b0c <_txm_module_manager_tx_byte_pool_delete_dispatch+0x54>
 8010b02:	683b      	ldr	r3, [r7, #0]
 8010b04:	2b00      	cmp	r3, #0
 8010b06:	d001      	beq.n	8010b0c <_txm_module_manager_tx_byte_pool_delete_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 8010b08:	23f4      	movs	r3, #244	; 0xf4
 8010b0a:	e00d      	b.n	8010b28 <_txm_module_manager_tx_byte_pool_delete_dispatch+0x70>
    }

    return_value = (ALIGN_TYPE) _txe_byte_pool_delete(
 8010b0c:	683b      	ldr	r3, [r7, #0]
 8010b0e:	4618      	mov	r0, r3
 8010b10:	f7fd faac 	bl	800e06c <_txe_byte_pool_delete>
 8010b14:	60f8      	str	r0, [r7, #12]
        (TX_BYTE_POOL *) param_0
    );

    /* Deallocate object memory.  */
    if (return_value == TX_SUCCESS)
 8010b16:	68fb      	ldr	r3, [r7, #12]
 8010b18:	2b00      	cmp	r3, #0
 8010b1a:	d104      	bne.n	8010b26 <_txm_module_manager_tx_byte_pool_delete_dispatch+0x6e>
    {
        return_value = _txm_module_manager_object_deallocate((VOID *) param_0);
 8010b1c:	683b      	ldr	r3, [r7, #0]
 8010b1e:	4618      	mov	r0, r3
 8010b20:	f004 fa48 	bl	8014fb4 <_txm_module_manager_object_deallocate>
 8010b24:	60f8      	str	r0, [r7, #12]
    }
    return(return_value);
 8010b26:	68fb      	ldr	r3, [r7, #12]
}
 8010b28:	4618      	mov	r0, r3
 8010b2a:	3710      	adds	r7, #16
 8010b2c:	46bd      	mov	sp, r7
 8010b2e:	bd80      	pop	{r7, pc}

08010b30 <_txm_module_manager_tx_byte_pool_info_get_dispatch>:
    TX_THREAD **first_suspended, -> extra_parameters[2]
    ULONG *suspended_count, -> extra_parameters[3]
    TX_BYTE_POOL **next_pool -> extra_parameters[4]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_byte_pool_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8010b30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010b32:	b08b      	sub	sp, #44	; 0x2c
 8010b34:	af04      	add	r7, sp, #16
 8010b36:	60f8      	str	r0, [r7, #12]
 8010b38:	60b9      	str	r1, [r7, #8]
 8010b3a:	607a      	str	r2, [r7, #4]
 8010b3c:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8010b3e:	68fb      	ldr	r3, [r7, #12]
 8010b40:	68db      	ldr	r3, [r3, #12]
 8010b42:	f003 0302 	and.w	r3, r3, #2
 8010b46:	2b00      	cmp	r3, #0
 8010b48:	f000 808f 	beq.w	8010c6a <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x13a>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_BYTE_POOL)))
 8010b4c:	2234      	movs	r2, #52	; 0x34
 8010b4e:	68b9      	ldr	r1, [r7, #8]
 8010b50:	68f8      	ldr	r0, [r7, #12]
 8010b52:	f004 f979 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010b56:	4603      	mov	r3, r0
 8010b58:	2b00      	cmp	r3, #0
 8010b5a:	d111      	bne.n	8010b80 <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x50>
 8010b5c:	68bb      	ldr	r3, [r7, #8]
 8010b5e:	f113 0f35 	cmn.w	r3, #53	; 0x35
 8010b62:	d812      	bhi.n	8010b8a <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x5a>
 8010b64:	68fb      	ldr	r3, [r7, #12]
 8010b66:	699b      	ldr	r3, [r3, #24]
 8010b68:	461a      	mov	r2, r3
 8010b6a:	68bb      	ldr	r3, [r7, #8]
 8010b6c:	4293      	cmp	r3, r2
 8010b6e:	d30c      	bcc.n	8010b8a <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x5a>
 8010b70:	68bb      	ldr	r3, [r7, #8]
 8010b72:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8010b76:	68fb      	ldr	r3, [r7, #12]
 8010b78:	69db      	ldr	r3, [r3, #28]
 8010b7a:	3301      	adds	r3, #1
 8010b7c:	429a      	cmp	r2, r3
 8010b7e:	d804      	bhi.n	8010b8a <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x5a>
 8010b80:	68bb      	ldr	r3, [r7, #8]
 8010b82:	2b00      	cmp	r3, #0
 8010b84:	d001      	beq.n	8010b8a <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x5a>
            return(TXM_MODULE_INVALID_MEMORY);
 8010b86:	23f4      	movs	r3, #244	; 0xf4
 8010b88:	e08c      	b.n	8010ca4 <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(CHAR *)))
 8010b8a:	2204      	movs	r2, #4
 8010b8c:	6879      	ldr	r1, [r7, #4]
 8010b8e:	68f8      	ldr	r0, [r7, #12]
 8010b90:	f004 f95a 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010b94:	4603      	mov	r3, r0
 8010b96:	2b00      	cmp	r3, #0
 8010b98:	d104      	bne.n	8010ba4 <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x74>
 8010b9a:	687b      	ldr	r3, [r7, #4]
 8010b9c:	2b00      	cmp	r3, #0
 8010b9e:	d001      	beq.n	8010ba4 <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x74>
            return(TXM_MODULE_INVALID_MEMORY);
 8010ba0:	23f4      	movs	r3, #244	; 0xf4
 8010ba2:	e07f      	b.n	8010ca4 <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[5])))
 8010ba4:	683b      	ldr	r3, [r7, #0]
 8010ba6:	2214      	movs	r2, #20
 8010ba8:	4619      	mov	r1, r3
 8010baa:	68f8      	ldr	r0, [r7, #12]
 8010bac:	f004 f94c 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010bb0:	4603      	mov	r3, r0
 8010bb2:	2b00      	cmp	r3, #0
 8010bb4:	d101      	bne.n	8010bba <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x8a>
            return(TXM_MODULE_INVALID_MEMORY);
 8010bb6:	23f4      	movs	r3, #244	; 0xf4
 8010bb8:	e074      	b.n	8010ca4 <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 8010bba:	683b      	ldr	r3, [r7, #0]
 8010bbc:	681b      	ldr	r3, [r3, #0]
 8010bbe:	2204      	movs	r2, #4
 8010bc0:	4619      	mov	r1, r3
 8010bc2:	68f8      	ldr	r0, [r7, #12]
 8010bc4:	f004 f940 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010bc8:	4603      	mov	r3, r0
 8010bca:	2b00      	cmp	r3, #0
 8010bcc:	d105      	bne.n	8010bda <_txm_module_manager_tx_byte_pool_info_get_dispatch+0xaa>
 8010bce:	683b      	ldr	r3, [r7, #0]
 8010bd0:	681b      	ldr	r3, [r3, #0]
 8010bd2:	2b00      	cmp	r3, #0
 8010bd4:	d001      	beq.n	8010bda <_txm_module_manager_tx_byte_pool_info_get_dispatch+0xaa>
            return(TXM_MODULE_INVALID_MEMORY);
 8010bd6:	23f4      	movs	r3, #244	; 0xf4
 8010bd8:	e064      	b.n	8010ca4 <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 8010bda:	683b      	ldr	r3, [r7, #0]
 8010bdc:	3304      	adds	r3, #4
 8010bde:	681b      	ldr	r3, [r3, #0]
 8010be0:	2204      	movs	r2, #4
 8010be2:	4619      	mov	r1, r3
 8010be4:	68f8      	ldr	r0, [r7, #12]
 8010be6:	f004 f92f 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010bea:	4603      	mov	r3, r0
 8010bec:	2b00      	cmp	r3, #0
 8010bee:	d106      	bne.n	8010bfe <_txm_module_manager_tx_byte_pool_info_get_dispatch+0xce>
 8010bf0:	683b      	ldr	r3, [r7, #0]
 8010bf2:	3304      	adds	r3, #4
 8010bf4:	681b      	ldr	r3, [r3, #0]
 8010bf6:	2b00      	cmp	r3, #0
 8010bf8:	d001      	beq.n	8010bfe <_txm_module_manager_tx_byte_pool_info_get_dispatch+0xce>
            return(TXM_MODULE_INVALID_MEMORY);
 8010bfa:	23f4      	movs	r3, #244	; 0xf4
 8010bfc:	e052      	b.n	8010ca4 <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(TX_THREAD *)))
 8010bfe:	683b      	ldr	r3, [r7, #0]
 8010c00:	3308      	adds	r3, #8
 8010c02:	681b      	ldr	r3, [r3, #0]
 8010c04:	2204      	movs	r2, #4
 8010c06:	4619      	mov	r1, r3
 8010c08:	68f8      	ldr	r0, [r7, #12]
 8010c0a:	f004 f91d 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010c0e:	4603      	mov	r3, r0
 8010c10:	2b00      	cmp	r3, #0
 8010c12:	d106      	bne.n	8010c22 <_txm_module_manager_tx_byte_pool_info_get_dispatch+0xf2>
 8010c14:	683b      	ldr	r3, [r7, #0]
 8010c16:	3308      	adds	r3, #8
 8010c18:	681b      	ldr	r3, [r3, #0]
 8010c1a:	2b00      	cmp	r3, #0
 8010c1c:	d001      	beq.n	8010c22 <_txm_module_manager_tx_byte_pool_info_get_dispatch+0xf2>
            return(TXM_MODULE_INVALID_MEMORY);
 8010c1e:	23f4      	movs	r3, #244	; 0xf4
 8010c20:	e040      	b.n	8010ca4 <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[3], sizeof(ULONG)))
 8010c22:	683b      	ldr	r3, [r7, #0]
 8010c24:	330c      	adds	r3, #12
 8010c26:	681b      	ldr	r3, [r3, #0]
 8010c28:	2204      	movs	r2, #4
 8010c2a:	4619      	mov	r1, r3
 8010c2c:	68f8      	ldr	r0, [r7, #12]
 8010c2e:	f004 f90b 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010c32:	4603      	mov	r3, r0
 8010c34:	2b00      	cmp	r3, #0
 8010c36:	d106      	bne.n	8010c46 <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x116>
 8010c38:	683b      	ldr	r3, [r7, #0]
 8010c3a:	330c      	adds	r3, #12
 8010c3c:	681b      	ldr	r3, [r3, #0]
 8010c3e:	2b00      	cmp	r3, #0
 8010c40:	d001      	beq.n	8010c46 <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x116>
            return(TXM_MODULE_INVALID_MEMORY);
 8010c42:	23f4      	movs	r3, #244	; 0xf4
 8010c44:	e02e      	b.n	8010ca4 <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[4], sizeof(TX_BYTE_POOL *)))
 8010c46:	683b      	ldr	r3, [r7, #0]
 8010c48:	3310      	adds	r3, #16
 8010c4a:	681b      	ldr	r3, [r3, #0]
 8010c4c:	2204      	movs	r2, #4
 8010c4e:	4619      	mov	r1, r3
 8010c50:	68f8      	ldr	r0, [r7, #12]
 8010c52:	f004 f8f9 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010c56:	4603      	mov	r3, r0
 8010c58:	2b00      	cmp	r3, #0
 8010c5a:	d106      	bne.n	8010c6a <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x13a>
 8010c5c:	683b      	ldr	r3, [r7, #0]
 8010c5e:	3310      	adds	r3, #16
 8010c60:	681b      	ldr	r3, [r3, #0]
 8010c62:	2b00      	cmp	r3, #0
 8010c64:	d001      	beq.n	8010c6a <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x13a>
            return(TXM_MODULE_INVALID_MEMORY);
 8010c66:	23f4      	movs	r3, #244	; 0xf4
 8010c68:	e01c      	b.n	8010ca4 <_txm_module_manager_tx_byte_pool_info_get_dispatch+0x174>
    }

    return_value = (ALIGN_TYPE) _txe_byte_pool_info_get(
 8010c6a:	68b8      	ldr	r0, [r7, #8]
 8010c6c:	6879      	ldr	r1, [r7, #4]
        (TX_BYTE_POOL *) param_0,
        (CHAR **) param_1,
        (ULONG *) extra_parameters[0],
 8010c6e:	683b      	ldr	r3, [r7, #0]
 8010c70:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_byte_pool_info_get(
 8010c72:	461d      	mov	r5, r3
        (ULONG *) extra_parameters[1],
 8010c74:	683b      	ldr	r3, [r7, #0]
 8010c76:	3304      	adds	r3, #4
 8010c78:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_byte_pool_info_get(
 8010c7a:	461e      	mov	r6, r3
        (TX_THREAD **) extra_parameters[2],
 8010c7c:	683b      	ldr	r3, [r7, #0]
 8010c7e:	3308      	adds	r3, #8
 8010c80:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_byte_pool_info_get(
 8010c82:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[3],
 8010c84:	683b      	ldr	r3, [r7, #0]
 8010c86:	330c      	adds	r3, #12
 8010c88:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_byte_pool_info_get(
 8010c8a:	461c      	mov	r4, r3
        (TX_BYTE_POOL **) extra_parameters[4]
 8010c8c:	683b      	ldr	r3, [r7, #0]
 8010c8e:	3310      	adds	r3, #16
 8010c90:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_byte_pool_info_get(
 8010c92:	9302      	str	r3, [sp, #8]
 8010c94:	9401      	str	r4, [sp, #4]
 8010c96:	9200      	str	r2, [sp, #0]
 8010c98:	4633      	mov	r3, r6
 8010c9a:	462a      	mov	r2, r5
 8010c9c:	f7fd fa24 	bl	800e0e8 <_txe_byte_pool_info_get>
 8010ca0:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 8010ca2:	697b      	ldr	r3, [r7, #20]
}
 8010ca4:	4618      	mov	r0, r3
 8010ca6:	371c      	adds	r7, #28
 8010ca8:	46bd      	mov	sp, r7
 8010caa:	bdf0      	pop	{r4, r5, r6, r7, pc}

08010cac <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch>:
    ULONG *splits, -> extra_parameters[3]
    ULONG *suspensions, -> extra_parameters[4]
    ULONG *timeouts -> extra_parameters[5]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_byte_pool_performance_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8010cac:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010cae:	b08b      	sub	sp, #44	; 0x2c
 8010cb0:	af04      	add	r7, sp, #16
 8010cb2:	60f8      	str	r0, [r7, #12]
 8010cb4:	60b9      	str	r1, [r7, #8]
 8010cb6:	607a      	str	r2, [r7, #4]
 8010cb8:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8010cba:	68fb      	ldr	r3, [r7, #12]
 8010cbc:	68db      	ldr	r3, [r3, #12]
 8010cbe:	f003 0302 	and.w	r3, r3, #2
 8010cc2:	2b00      	cmp	r3, #0
 8010cc4:	f000 80a1 	beq.w	8010e0a <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x15e>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_BYTE_POOL)))
 8010cc8:	2234      	movs	r2, #52	; 0x34
 8010cca:	68b9      	ldr	r1, [r7, #8]
 8010ccc:	68f8      	ldr	r0, [r7, #12]
 8010cce:	f004 f8bb 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010cd2:	4603      	mov	r3, r0
 8010cd4:	2b00      	cmp	r3, #0
 8010cd6:	d111      	bne.n	8010cfc <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x50>
 8010cd8:	68bb      	ldr	r3, [r7, #8]
 8010cda:	f113 0f35 	cmn.w	r3, #53	; 0x35
 8010cde:	d812      	bhi.n	8010d06 <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x5a>
 8010ce0:	68fb      	ldr	r3, [r7, #12]
 8010ce2:	699b      	ldr	r3, [r3, #24]
 8010ce4:	461a      	mov	r2, r3
 8010ce6:	68bb      	ldr	r3, [r7, #8]
 8010ce8:	4293      	cmp	r3, r2
 8010cea:	d30c      	bcc.n	8010d06 <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x5a>
 8010cec:	68bb      	ldr	r3, [r7, #8]
 8010cee:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8010cf2:	68fb      	ldr	r3, [r7, #12]
 8010cf4:	69db      	ldr	r3, [r3, #28]
 8010cf6:	3301      	adds	r3, #1
 8010cf8:	429a      	cmp	r2, r3
 8010cfa:	d804      	bhi.n	8010d06 <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x5a>
 8010cfc:	68bb      	ldr	r3, [r7, #8]
 8010cfe:	2b00      	cmp	r3, #0
 8010d00:	d001      	beq.n	8010d06 <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x5a>
            return(TXM_MODULE_INVALID_MEMORY);
 8010d02:	23f4      	movs	r3, #244	; 0xf4
 8010d04:	e0a3      	b.n	8010e4e <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x1a2>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(ULONG)))
 8010d06:	2204      	movs	r2, #4
 8010d08:	6879      	ldr	r1, [r7, #4]
 8010d0a:	68f8      	ldr	r0, [r7, #12]
 8010d0c:	f004 f89c 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010d10:	4603      	mov	r3, r0
 8010d12:	2b00      	cmp	r3, #0
 8010d14:	d104      	bne.n	8010d20 <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x74>
 8010d16:	687b      	ldr	r3, [r7, #4]
 8010d18:	2b00      	cmp	r3, #0
 8010d1a:	d001      	beq.n	8010d20 <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x74>
            return(TXM_MODULE_INVALID_MEMORY);
 8010d1c:	23f4      	movs	r3, #244	; 0xf4
 8010d1e:	e096      	b.n	8010e4e <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x1a2>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[6])))
 8010d20:	683b      	ldr	r3, [r7, #0]
 8010d22:	2218      	movs	r2, #24
 8010d24:	4619      	mov	r1, r3
 8010d26:	68f8      	ldr	r0, [r7, #12]
 8010d28:	f004 f88e 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010d2c:	4603      	mov	r3, r0
 8010d2e:	2b00      	cmp	r3, #0
 8010d30:	d101      	bne.n	8010d36 <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x8a>
            return(TXM_MODULE_INVALID_MEMORY);
 8010d32:	23f4      	movs	r3, #244	; 0xf4
 8010d34:	e08b      	b.n	8010e4e <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x1a2>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 8010d36:	683b      	ldr	r3, [r7, #0]
 8010d38:	681b      	ldr	r3, [r3, #0]
 8010d3a:	2204      	movs	r2, #4
 8010d3c:	4619      	mov	r1, r3
 8010d3e:	68f8      	ldr	r0, [r7, #12]
 8010d40:	f004 f882 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010d44:	4603      	mov	r3, r0
 8010d46:	2b00      	cmp	r3, #0
 8010d48:	d105      	bne.n	8010d56 <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0xaa>
 8010d4a:	683b      	ldr	r3, [r7, #0]
 8010d4c:	681b      	ldr	r3, [r3, #0]
 8010d4e:	2b00      	cmp	r3, #0
 8010d50:	d001      	beq.n	8010d56 <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0xaa>
            return(TXM_MODULE_INVALID_MEMORY);
 8010d52:	23f4      	movs	r3, #244	; 0xf4
 8010d54:	e07b      	b.n	8010e4e <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x1a2>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 8010d56:	683b      	ldr	r3, [r7, #0]
 8010d58:	3304      	adds	r3, #4
 8010d5a:	681b      	ldr	r3, [r3, #0]
 8010d5c:	2204      	movs	r2, #4
 8010d5e:	4619      	mov	r1, r3
 8010d60:	68f8      	ldr	r0, [r7, #12]
 8010d62:	f004 f871 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010d66:	4603      	mov	r3, r0
 8010d68:	2b00      	cmp	r3, #0
 8010d6a:	d106      	bne.n	8010d7a <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0xce>
 8010d6c:	683b      	ldr	r3, [r7, #0]
 8010d6e:	3304      	adds	r3, #4
 8010d70:	681b      	ldr	r3, [r3, #0]
 8010d72:	2b00      	cmp	r3, #0
 8010d74:	d001      	beq.n	8010d7a <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0xce>
            return(TXM_MODULE_INVALID_MEMORY);
 8010d76:	23f4      	movs	r3, #244	; 0xf4
 8010d78:	e069      	b.n	8010e4e <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x1a2>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(ULONG)))
 8010d7a:	683b      	ldr	r3, [r7, #0]
 8010d7c:	3308      	adds	r3, #8
 8010d7e:	681b      	ldr	r3, [r3, #0]
 8010d80:	2204      	movs	r2, #4
 8010d82:	4619      	mov	r1, r3
 8010d84:	68f8      	ldr	r0, [r7, #12]
 8010d86:	f004 f85f 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010d8a:	4603      	mov	r3, r0
 8010d8c:	2b00      	cmp	r3, #0
 8010d8e:	d106      	bne.n	8010d9e <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0xf2>
 8010d90:	683b      	ldr	r3, [r7, #0]
 8010d92:	3308      	adds	r3, #8
 8010d94:	681b      	ldr	r3, [r3, #0]
 8010d96:	2b00      	cmp	r3, #0
 8010d98:	d001      	beq.n	8010d9e <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0xf2>
            return(TXM_MODULE_INVALID_MEMORY);
 8010d9a:	23f4      	movs	r3, #244	; 0xf4
 8010d9c:	e057      	b.n	8010e4e <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x1a2>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[3], sizeof(ULONG)))
 8010d9e:	683b      	ldr	r3, [r7, #0]
 8010da0:	330c      	adds	r3, #12
 8010da2:	681b      	ldr	r3, [r3, #0]
 8010da4:	2204      	movs	r2, #4
 8010da6:	4619      	mov	r1, r3
 8010da8:	68f8      	ldr	r0, [r7, #12]
 8010daa:	f004 f84d 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010dae:	4603      	mov	r3, r0
 8010db0:	2b00      	cmp	r3, #0
 8010db2:	d106      	bne.n	8010dc2 <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x116>
 8010db4:	683b      	ldr	r3, [r7, #0]
 8010db6:	330c      	adds	r3, #12
 8010db8:	681b      	ldr	r3, [r3, #0]
 8010dba:	2b00      	cmp	r3, #0
 8010dbc:	d001      	beq.n	8010dc2 <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x116>
            return(TXM_MODULE_INVALID_MEMORY);
 8010dbe:	23f4      	movs	r3, #244	; 0xf4
 8010dc0:	e045      	b.n	8010e4e <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x1a2>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[4], sizeof(ULONG)))
 8010dc2:	683b      	ldr	r3, [r7, #0]
 8010dc4:	3310      	adds	r3, #16
 8010dc6:	681b      	ldr	r3, [r3, #0]
 8010dc8:	2204      	movs	r2, #4
 8010dca:	4619      	mov	r1, r3
 8010dcc:	68f8      	ldr	r0, [r7, #12]
 8010dce:	f004 f83b 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010dd2:	4603      	mov	r3, r0
 8010dd4:	2b00      	cmp	r3, #0
 8010dd6:	d106      	bne.n	8010de6 <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x13a>
 8010dd8:	683b      	ldr	r3, [r7, #0]
 8010dda:	3310      	adds	r3, #16
 8010ddc:	681b      	ldr	r3, [r3, #0]
 8010dde:	2b00      	cmp	r3, #0
 8010de0:	d001      	beq.n	8010de6 <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x13a>
            return(TXM_MODULE_INVALID_MEMORY);
 8010de2:	23f4      	movs	r3, #244	; 0xf4
 8010de4:	e033      	b.n	8010e4e <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x1a2>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[5], sizeof(ULONG)))
 8010de6:	683b      	ldr	r3, [r7, #0]
 8010de8:	3314      	adds	r3, #20
 8010dea:	681b      	ldr	r3, [r3, #0]
 8010dec:	2204      	movs	r2, #4
 8010dee:	4619      	mov	r1, r3
 8010df0:	68f8      	ldr	r0, [r7, #12]
 8010df2:	f004 f829 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010df6:	4603      	mov	r3, r0
 8010df8:	2b00      	cmp	r3, #0
 8010dfa:	d106      	bne.n	8010e0a <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x15e>
 8010dfc:	683b      	ldr	r3, [r7, #0]
 8010dfe:	3314      	adds	r3, #20
 8010e00:	681b      	ldr	r3, [r3, #0]
 8010e02:	2b00      	cmp	r3, #0
 8010e04:	d001      	beq.n	8010e0a <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x15e>
            return(TXM_MODULE_INVALID_MEMORY);
 8010e06:	23f4      	movs	r3, #244	; 0xf4
 8010e08:	e021      	b.n	8010e4e <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch+0x1a2>
    }

    return_value = (ALIGN_TYPE) _tx_byte_pool_performance_info_get(
 8010e0a:	68b8      	ldr	r0, [r7, #8]
 8010e0c:	6879      	ldr	r1, [r7, #4]
        (TX_BYTE_POOL *) param_0,
        (ULONG *) param_1,
        (ULONG *) extra_parameters[0],
 8010e0e:	683b      	ldr	r3, [r7, #0]
 8010e10:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_byte_pool_performance_info_get(
 8010e12:	461e      	mov	r6, r3
        (ULONG *) extra_parameters[1],
 8010e14:	683b      	ldr	r3, [r7, #0]
 8010e16:	3304      	adds	r3, #4
 8010e18:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_byte_pool_performance_info_get(
 8010e1a:	469c      	mov	ip, r3
        (ULONG *) extra_parameters[2],
 8010e1c:	683b      	ldr	r3, [r7, #0]
 8010e1e:	3308      	adds	r3, #8
 8010e20:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_byte_pool_performance_info_get(
 8010e22:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[3],
 8010e24:	683b      	ldr	r3, [r7, #0]
 8010e26:	330c      	adds	r3, #12
 8010e28:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_byte_pool_performance_info_get(
 8010e2a:	461c      	mov	r4, r3
        (ULONG *) extra_parameters[4],
 8010e2c:	683b      	ldr	r3, [r7, #0]
 8010e2e:	3310      	adds	r3, #16
 8010e30:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_byte_pool_performance_info_get(
 8010e32:	461d      	mov	r5, r3
        (ULONG *) extra_parameters[5]
 8010e34:	683b      	ldr	r3, [r7, #0]
 8010e36:	3314      	adds	r3, #20
 8010e38:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_byte_pool_performance_info_get(
 8010e3a:	9303      	str	r3, [sp, #12]
 8010e3c:	9502      	str	r5, [sp, #8]
 8010e3e:	9401      	str	r4, [sp, #4]
 8010e40:	9200      	str	r2, [sp, #0]
 8010e42:	4663      	mov	r3, ip
 8010e44:	4632      	mov	r2, r6
 8010e46:	f7f7 f80b 	bl	8007e60 <_tx_byte_pool_performance_info_get>
 8010e4a:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 8010e4c:	697b      	ldr	r3, [r7, #20]
}
 8010e4e:	4618      	mov	r0, r3
 8010e50:	371c      	adds	r7, #28
 8010e52:	46bd      	mov	sp, r7
 8010e54:	bdf0      	pop	{r4, r5, r6, r7, pc}

08010e56 <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch>:
    ULONG *splits, -> extra_parameters[2]
    ULONG *suspensions, -> extra_parameters[3]
    ULONG *timeouts -> extra_parameters[4]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8010e56:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010e58:	b08b      	sub	sp, #44	; 0x2c
 8010e5a:	af04      	add	r7, sp, #16
 8010e5c:	60f8      	str	r0, [r7, #12]
 8010e5e:	60b9      	str	r1, [r7, #8]
 8010e60:	607a      	str	r2, [r7, #4]
 8010e62:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8010e64:	68fb      	ldr	r3, [r7, #12]
 8010e66:	68db      	ldr	r3, [r3, #12]
 8010e68:	f003 0302 	and.w	r3, r3, #2
 8010e6c:	2b00      	cmp	r3, #0
 8010e6e:	d07c      	beq.n	8010f6a <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0x114>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_0, sizeof(ULONG)))
 8010e70:	2204      	movs	r2, #4
 8010e72:	68b9      	ldr	r1, [r7, #8]
 8010e74:	68f8      	ldr	r0, [r7, #12]
 8010e76:	f003 ffe7 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010e7a:	4603      	mov	r3, r0
 8010e7c:	2b00      	cmp	r3, #0
 8010e7e:	d104      	bne.n	8010e8a <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0x34>
 8010e80:	68bb      	ldr	r3, [r7, #8]
 8010e82:	2b00      	cmp	r3, #0
 8010e84:	d001      	beq.n	8010e8a <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0x34>
            return(TXM_MODULE_INVALID_MEMORY);
 8010e86:	23f4      	movs	r3, #244	; 0xf4
 8010e88:	e08c      	b.n	8010fa4 <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0x14e>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(ULONG)))
 8010e8a:	2204      	movs	r2, #4
 8010e8c:	6879      	ldr	r1, [r7, #4]
 8010e8e:	68f8      	ldr	r0, [r7, #12]
 8010e90:	f003 ffda 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010e94:	4603      	mov	r3, r0
 8010e96:	2b00      	cmp	r3, #0
 8010e98:	d104      	bne.n	8010ea4 <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0x4e>
 8010e9a:	687b      	ldr	r3, [r7, #4]
 8010e9c:	2b00      	cmp	r3, #0
 8010e9e:	d001      	beq.n	8010ea4 <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0x4e>
            return(TXM_MODULE_INVALID_MEMORY);
 8010ea0:	23f4      	movs	r3, #244	; 0xf4
 8010ea2:	e07f      	b.n	8010fa4 <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0x14e>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[5])))
 8010ea4:	683b      	ldr	r3, [r7, #0]
 8010ea6:	2214      	movs	r2, #20
 8010ea8:	4619      	mov	r1, r3
 8010eaa:	68f8      	ldr	r0, [r7, #12]
 8010eac:	f003 ffcc 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010eb0:	4603      	mov	r3, r0
 8010eb2:	2b00      	cmp	r3, #0
 8010eb4:	d101      	bne.n	8010eba <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0x64>
            return(TXM_MODULE_INVALID_MEMORY);
 8010eb6:	23f4      	movs	r3, #244	; 0xf4
 8010eb8:	e074      	b.n	8010fa4 <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0x14e>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 8010eba:	683b      	ldr	r3, [r7, #0]
 8010ebc:	681b      	ldr	r3, [r3, #0]
 8010ebe:	2204      	movs	r2, #4
 8010ec0:	4619      	mov	r1, r3
 8010ec2:	68f8      	ldr	r0, [r7, #12]
 8010ec4:	f003 ffc0 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010ec8:	4603      	mov	r3, r0
 8010eca:	2b00      	cmp	r3, #0
 8010ecc:	d105      	bne.n	8010eda <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0x84>
 8010ece:	683b      	ldr	r3, [r7, #0]
 8010ed0:	681b      	ldr	r3, [r3, #0]
 8010ed2:	2b00      	cmp	r3, #0
 8010ed4:	d001      	beq.n	8010eda <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0x84>
            return(TXM_MODULE_INVALID_MEMORY);
 8010ed6:	23f4      	movs	r3, #244	; 0xf4
 8010ed8:	e064      	b.n	8010fa4 <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0x14e>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 8010eda:	683b      	ldr	r3, [r7, #0]
 8010edc:	3304      	adds	r3, #4
 8010ede:	681b      	ldr	r3, [r3, #0]
 8010ee0:	2204      	movs	r2, #4
 8010ee2:	4619      	mov	r1, r3
 8010ee4:	68f8      	ldr	r0, [r7, #12]
 8010ee6:	f003 ffaf 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010eea:	4603      	mov	r3, r0
 8010eec:	2b00      	cmp	r3, #0
 8010eee:	d106      	bne.n	8010efe <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0xa8>
 8010ef0:	683b      	ldr	r3, [r7, #0]
 8010ef2:	3304      	adds	r3, #4
 8010ef4:	681b      	ldr	r3, [r3, #0]
 8010ef6:	2b00      	cmp	r3, #0
 8010ef8:	d001      	beq.n	8010efe <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0xa8>
            return(TXM_MODULE_INVALID_MEMORY);
 8010efa:	23f4      	movs	r3, #244	; 0xf4
 8010efc:	e052      	b.n	8010fa4 <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0x14e>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(ULONG)))
 8010efe:	683b      	ldr	r3, [r7, #0]
 8010f00:	3308      	adds	r3, #8
 8010f02:	681b      	ldr	r3, [r3, #0]
 8010f04:	2204      	movs	r2, #4
 8010f06:	4619      	mov	r1, r3
 8010f08:	68f8      	ldr	r0, [r7, #12]
 8010f0a:	f003 ff9d 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010f0e:	4603      	mov	r3, r0
 8010f10:	2b00      	cmp	r3, #0
 8010f12:	d106      	bne.n	8010f22 <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0xcc>
 8010f14:	683b      	ldr	r3, [r7, #0]
 8010f16:	3308      	adds	r3, #8
 8010f18:	681b      	ldr	r3, [r3, #0]
 8010f1a:	2b00      	cmp	r3, #0
 8010f1c:	d001      	beq.n	8010f22 <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0xcc>
            return(TXM_MODULE_INVALID_MEMORY);
 8010f1e:	23f4      	movs	r3, #244	; 0xf4
 8010f20:	e040      	b.n	8010fa4 <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0x14e>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[3], sizeof(ULONG)))
 8010f22:	683b      	ldr	r3, [r7, #0]
 8010f24:	330c      	adds	r3, #12
 8010f26:	681b      	ldr	r3, [r3, #0]
 8010f28:	2204      	movs	r2, #4
 8010f2a:	4619      	mov	r1, r3
 8010f2c:	68f8      	ldr	r0, [r7, #12]
 8010f2e:	f003 ff8b 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010f32:	4603      	mov	r3, r0
 8010f34:	2b00      	cmp	r3, #0
 8010f36:	d106      	bne.n	8010f46 <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0xf0>
 8010f38:	683b      	ldr	r3, [r7, #0]
 8010f3a:	330c      	adds	r3, #12
 8010f3c:	681b      	ldr	r3, [r3, #0]
 8010f3e:	2b00      	cmp	r3, #0
 8010f40:	d001      	beq.n	8010f46 <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0xf0>
            return(TXM_MODULE_INVALID_MEMORY);
 8010f42:	23f4      	movs	r3, #244	; 0xf4
 8010f44:	e02e      	b.n	8010fa4 <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0x14e>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[4], sizeof(ULONG)))
 8010f46:	683b      	ldr	r3, [r7, #0]
 8010f48:	3310      	adds	r3, #16
 8010f4a:	681b      	ldr	r3, [r3, #0]
 8010f4c:	2204      	movs	r2, #4
 8010f4e:	4619      	mov	r1, r3
 8010f50:	68f8      	ldr	r0, [r7, #12]
 8010f52:	f003 ff79 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010f56:	4603      	mov	r3, r0
 8010f58:	2b00      	cmp	r3, #0
 8010f5a:	d106      	bne.n	8010f6a <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0x114>
 8010f5c:	683b      	ldr	r3, [r7, #0]
 8010f5e:	3310      	adds	r3, #16
 8010f60:	681b      	ldr	r3, [r3, #0]
 8010f62:	2b00      	cmp	r3, #0
 8010f64:	d001      	beq.n	8010f6a <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0x114>
            return(TXM_MODULE_INVALID_MEMORY);
 8010f66:	23f4      	movs	r3, #244	; 0xf4
 8010f68:	e01c      	b.n	8010fa4 <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch+0x14e>
    }

    return_value = (ALIGN_TYPE) _tx_byte_pool_performance_system_info_get(
 8010f6a:	68b8      	ldr	r0, [r7, #8]
 8010f6c:	6879      	ldr	r1, [r7, #4]
        (ULONG *) param_0,
        (ULONG *) param_1,
        (ULONG *) extra_parameters[0],
 8010f6e:	683b      	ldr	r3, [r7, #0]
 8010f70:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_byte_pool_performance_system_info_get(
 8010f72:	461d      	mov	r5, r3
        (ULONG *) extra_parameters[1],
 8010f74:	683b      	ldr	r3, [r7, #0]
 8010f76:	3304      	adds	r3, #4
 8010f78:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_byte_pool_performance_system_info_get(
 8010f7a:	461e      	mov	r6, r3
        (ULONG *) extra_parameters[2],
 8010f7c:	683b      	ldr	r3, [r7, #0]
 8010f7e:	3308      	adds	r3, #8
 8010f80:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_byte_pool_performance_system_info_get(
 8010f82:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[3],
 8010f84:	683b      	ldr	r3, [r7, #0]
 8010f86:	330c      	adds	r3, #12
 8010f88:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_byte_pool_performance_system_info_get(
 8010f8a:	461c      	mov	r4, r3
        (ULONG *) extra_parameters[4]
 8010f8c:	683b      	ldr	r3, [r7, #0]
 8010f8e:	3310      	adds	r3, #16
 8010f90:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_byte_pool_performance_system_info_get(
 8010f92:	9302      	str	r3, [sp, #8]
 8010f94:	9401      	str	r4, [sp, #4]
 8010f96:	9200      	str	r2, [sp, #0]
 8010f98:	4633      	mov	r3, r6
 8010f9a:	462a      	mov	r2, r5
 8010f9c:	f7f6 ffa0 	bl	8007ee0 <_tx_byte_pool_performance_system_info_get>
 8010fa0:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 8010fa2:	697b      	ldr	r3, [r7, #20]
}
 8010fa4:	4618      	mov	r0, r3
 8010fa6:	371c      	adds	r7, #28
 8010fa8:	46bd      	mov	sp, r7
 8010faa:	bdf0      	pop	{r4, r5, r6, r7, pc}

08010fac <_txm_module_manager_tx_byte_pool_prioritize_dispatch>:
#ifndef TXM_BYTE_POOL_PRIORITIZE_CALL_NOT_USED
/* UINT _txe_byte_pool_prioritize(
    TX_BYTE_POOL *pool_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_byte_pool_prioritize_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8010fac:	b580      	push	{r7, lr}
 8010fae:	b084      	sub	sp, #16
 8010fb0:	af00      	add	r7, sp, #0
 8010fb2:	6078      	str	r0, [r7, #4]
 8010fb4:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8010fb6:	687b      	ldr	r3, [r7, #4]
 8010fb8:	68db      	ldr	r3, [r3, #12]
 8010fba:	f003 0302 	and.w	r3, r3, #2
 8010fbe:	2b00      	cmp	r3, #0
 8010fc0:	d01e      	beq.n	8011000 <_txm_module_manager_tx_byte_pool_prioritize_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_BYTE_POOL)))
 8010fc2:	2234      	movs	r2, #52	; 0x34
 8010fc4:	6839      	ldr	r1, [r7, #0]
 8010fc6:	6878      	ldr	r0, [r7, #4]
 8010fc8:	f003 ff3e 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8010fcc:	4603      	mov	r3, r0
 8010fce:	2b00      	cmp	r3, #0
 8010fd0:	d111      	bne.n	8010ff6 <_txm_module_manager_tx_byte_pool_prioritize_dispatch+0x4a>
 8010fd2:	683b      	ldr	r3, [r7, #0]
 8010fd4:	f113 0f35 	cmn.w	r3, #53	; 0x35
 8010fd8:	d812      	bhi.n	8011000 <_txm_module_manager_tx_byte_pool_prioritize_dispatch+0x54>
 8010fda:	687b      	ldr	r3, [r7, #4]
 8010fdc:	699b      	ldr	r3, [r3, #24]
 8010fde:	461a      	mov	r2, r3
 8010fe0:	683b      	ldr	r3, [r7, #0]
 8010fe2:	4293      	cmp	r3, r2
 8010fe4:	d30c      	bcc.n	8011000 <_txm_module_manager_tx_byte_pool_prioritize_dispatch+0x54>
 8010fe6:	683b      	ldr	r3, [r7, #0]
 8010fe8:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8010fec:	687b      	ldr	r3, [r7, #4]
 8010fee:	69db      	ldr	r3, [r3, #28]
 8010ff0:	3301      	adds	r3, #1
 8010ff2:	429a      	cmp	r2, r3
 8010ff4:	d804      	bhi.n	8011000 <_txm_module_manager_tx_byte_pool_prioritize_dispatch+0x54>
 8010ff6:	683b      	ldr	r3, [r7, #0]
 8010ff8:	2b00      	cmp	r3, #0
 8010ffa:	d001      	beq.n	8011000 <_txm_module_manager_tx_byte_pool_prioritize_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 8010ffc:	23f4      	movs	r3, #244	; 0xf4
 8010ffe:	e005      	b.n	801100c <_txm_module_manager_tx_byte_pool_prioritize_dispatch+0x60>
    }

    return_value = (ALIGN_TYPE) _txe_byte_pool_prioritize(
 8011000:	683b      	ldr	r3, [r7, #0]
 8011002:	4618      	mov	r0, r3
 8011004:	f7fd f89a 	bl	800e13c <_txe_byte_pool_prioritize>
 8011008:	60f8      	str	r0, [r7, #12]
        (TX_BYTE_POOL *) param_0
    );
    return(return_value);
 801100a:	68fb      	ldr	r3, [r7, #12]
}
 801100c:	4618      	mov	r0, r3
 801100e:	3710      	adds	r7, #16
 8011010:	46bd      	mov	sp, r7
 8011012:	bd80      	pop	{r7, pc}

08011014 <_txm_module_manager_tx_byte_release_dispatch>:
#ifndef TXM_BYTE_RELEASE_CALL_NOT_USED
/* UINT _txe_byte_release(
    VOID *memory_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_byte_release_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8011014:	b580      	push	{r7, lr}
 8011016:	b084      	sub	sp, #16
 8011018:	af00      	add	r7, sp, #0
 801101a:	6078      	str	r0, [r7, #4]
 801101c:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;
ALIGN_TYPE block_header_start;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 801101e:	687b      	ldr	r3, [r7, #4]
 8011020:	68db      	ldr	r3, [r3, #12]
 8011022:	f003 0302 	and.w	r3, r3, #2
 8011026:	2b00      	cmp	r3, #0
 8011028:	d013      	beq.n	8011052 <_txm_module_manager_tx_byte_release_dispatch+0x3e>
    {
        /* Is the pointer non-null?  */
        if ((void *) param_0 != TX_NULL)
 801102a:	683b      	ldr	r3, [r7, #0]
 801102c:	2b00      	cmp	r3, #0
 801102e:	d010      	beq.n	8011052 <_txm_module_manager_tx_byte_release_dispatch+0x3e>
        {

            /* Calculate the beginning of the header info for this block (the header
               consists of 2 pointers).  */
            block_header_start =  param_0 - 2*sizeof(ALIGN_TYPE);
 8011030:	683b      	ldr	r3, [r7, #0]
 8011032:	3b08      	subs	r3, #8
 8011034:	60fb      	str	r3, [r7, #12]

            if (/* Did we underflow when doing the subtract?  */
 8011036:	68fa      	ldr	r2, [r7, #12]
 8011038:	683b      	ldr	r3, [r7, #0]
 801103a:	429a      	cmp	r2, r3
 801103c:	d807      	bhi.n	801104e <_txm_module_manager_tx_byte_release_dispatch+0x3a>
                (block_header_start > param_0) ||
                /* Ensure the pointer is inside the module's data. Note that we only
                   check the pointers in the header because only those two are
                   dereferenced during the pointer's validity check in _tx_byte_release. */
                (!TXM_MODULE_MANAGER_CHECK_INSIDE_DATA(module_instance, block_header_start, 2*sizeof(ALIGN_TYPE))))
 801103e:	2208      	movs	r2, #8
 8011040:	68f9      	ldr	r1, [r7, #12]
 8011042:	6878      	ldr	r0, [r7, #4]
 8011044:	f003 ff00 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011048:	4603      	mov	r3, r0
                (block_header_start > param_0) ||
 801104a:	2b00      	cmp	r3, #0
 801104c:	d101      	bne.n	8011052 <_txm_module_manager_tx_byte_release_dispatch+0x3e>
            {

                /* Invalid pointer.  */
                return(TXM_MODULE_INVALID_MEMORY);
 801104e:	23f4      	movs	r3, #244	; 0xf4
 8011050:	e005      	b.n	801105e <_txm_module_manager_tx_byte_release_dispatch+0x4a>
            }
        }
    }

    return_value = (ALIGN_TYPE) _txe_byte_release(
 8011052:	683b      	ldr	r3, [r7, #0]
 8011054:	4618      	mov	r0, r3
 8011056:	f7fd f88f 	bl	800e178 <_txe_byte_release>
 801105a:	60b8      	str	r0, [r7, #8]
        (VOID *) param_0
    );
    return(return_value);
 801105c:	68bb      	ldr	r3, [r7, #8]
}
 801105e:	4618      	mov	r0, r3
 8011060:	3710      	adds	r7, #16
 8011062:	46bd      	mov	sp, r7
 8011064:	bd80      	pop	{r7, pc}
	...

08011068 <_txm_module_manager_tx_event_flags_create_dispatch>:
    TX_EVENT_FLAGS_GROUP *group_ptr, -> param_0
    CHAR *name_ptr, -> param_1
    UINT event_control_block_size -> param_2
   ); */
static ALIGN_TYPE _txm_module_manager_tx_event_flags_create_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE param_2)
{
 8011068:	b580      	push	{r7, lr}
 801106a:	b086      	sub	sp, #24
 801106c:	af00      	add	r7, sp, #0
 801106e:	60f8      	str	r0, [r7, #12]
 8011070:	60b9      	str	r1, [r7, #8]
 8011072:	607a      	str	r2, [r7, #4]
 8011074:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8011076:	68fb      	ldr	r3, [r7, #12]
 8011078:	68db      	ldr	r3, [r3, #12]
 801107a:	f003 0302 	and.w	r3, r3, #2
 801107e:	2b00      	cmp	r3, #0
 8011080:	d040      	beq.n	8011104 <_txm_module_manager_tx_event_flags_create_dispatch+0x9c>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_CREATION(module_instance, param_0, sizeof(TX_EVENT_FLAGS_GROUP)))
 8011082:	4b26      	ldr	r3, [pc, #152]	; (801111c <_txm_module_manager_tx_event_flags_create_dispatch+0xb4>)
 8011084:	681b      	ldr	r3, [r3, #0]
 8011086:	2b01      	cmp	r3, #1
 8011088:	d119      	bne.n	80110be <_txm_module_manager_tx_event_flags_create_dispatch+0x56>
 801108a:	68bb      	ldr	r3, [r7, #8]
 801108c:	f113 0f31 	cmn.w	r3, #49	; 0x31
 8011090:	d815      	bhi.n	80110be <_txm_module_manager_tx_event_flags_create_dispatch+0x56>
 8011092:	4b23      	ldr	r3, [pc, #140]	; (8011120 <_txm_module_manager_tx_event_flags_create_dispatch+0xb8>)
 8011094:	699b      	ldr	r3, [r3, #24]
 8011096:	3310      	adds	r3, #16
 8011098:	68ba      	ldr	r2, [r7, #8]
 801109a:	429a      	cmp	r2, r3
 801109c:	d30f      	bcc.n	80110be <_txm_module_manager_tx_event_flags_create_dispatch+0x56>
 801109e:	68bb      	ldr	r3, [r7, #8]
 80110a0:	3330      	adds	r3, #48	; 0x30
 80110a2:	4a1f      	ldr	r2, [pc, #124]	; (8011120 <_txm_module_manager_tx_event_flags_create_dispatch+0xb8>)
 80110a4:	6991      	ldr	r1, [r2, #24]
 80110a6:	4a1e      	ldr	r2, [pc, #120]	; (8011120 <_txm_module_manager_tx_event_flags_create_dispatch+0xb8>)
 80110a8:	69d2      	ldr	r2, [r2, #28]
 80110aa:	440a      	add	r2, r1
 80110ac:	4293      	cmp	r3, r2
 80110ae:	d806      	bhi.n	80110be <_txm_module_manager_tx_event_flags_create_dispatch+0x56>
 80110b0:	2130      	movs	r1, #48	; 0x30
 80110b2:	68b8      	ldr	r0, [r7, #8]
 80110b4:	f005 faf0 	bl	8016698 <_txm_module_manager_object_size_check>
 80110b8:	4603      	mov	r3, r0
 80110ba:	2b00      	cmp	r3, #0
 80110bc:	d004      	beq.n	80110c8 <_txm_module_manager_tx_event_flags_create_dispatch+0x60>
 80110be:	68bb      	ldr	r3, [r7, #8]
 80110c0:	2b00      	cmp	r3, #0
 80110c2:	d001      	beq.n	80110c8 <_txm_module_manager_tx_event_flags_create_dispatch+0x60>
            return(TXM_MODULE_INVALID_MEMORY);
 80110c4:	23f4      	movs	r3, #244	; 0xf4
 80110c6:	e025      	b.n	8011114 <_txm_module_manager_tx_event_flags_create_dispatch+0xac>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_DEREFERENCE_STRING(module_instance, param_1))
 80110c8:	2201      	movs	r2, #1
 80110ca:	6879      	ldr	r1, [r7, #4]
 80110cc:	68f8      	ldr	r0, [r7, #12]
 80110ce:	f003 febb 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80110d2:	4603      	mov	r3, r0
 80110d4:	2b00      	cmp	r3, #0
 80110d6:	d115      	bne.n	8011104 <_txm_module_manager_tx_event_flags_create_dispatch+0x9c>
 80110d8:	687b      	ldr	r3, [r7, #4]
 80110da:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80110de:	d00c      	beq.n	80110fa <_txm_module_manager_tx_event_flags_create_dispatch+0x92>
 80110e0:	68fb      	ldr	r3, [r7, #12]
 80110e2:	699b      	ldr	r3, [r3, #24]
 80110e4:	461a      	mov	r2, r3
 80110e6:	687b      	ldr	r3, [r7, #4]
 80110e8:	4293      	cmp	r3, r2
 80110ea:	d306      	bcc.n	80110fa <_txm_module_manager_tx_event_flags_create_dispatch+0x92>
 80110ec:	687b      	ldr	r3, [r7, #4]
 80110ee:	1c5a      	adds	r2, r3, #1
 80110f0:	68fb      	ldr	r3, [r7, #12]
 80110f2:	69db      	ldr	r3, [r3, #28]
 80110f4:	3301      	adds	r3, #1
 80110f6:	429a      	cmp	r2, r3
 80110f8:	d904      	bls.n	8011104 <_txm_module_manager_tx_event_flags_create_dispatch+0x9c>
 80110fa:	687b      	ldr	r3, [r7, #4]
 80110fc:	2b00      	cmp	r3, #0
 80110fe:	d001      	beq.n	8011104 <_txm_module_manager_tx_event_flags_create_dispatch+0x9c>
            return(TXM_MODULE_INVALID_MEMORY);
 8011100:	23f4      	movs	r3, #244	; 0xf4
 8011102:	e007      	b.n	8011114 <_txm_module_manager_tx_event_flags_create_dispatch+0xac>
    }

    return_value = (ALIGN_TYPE) _txe_event_flags_create(
 8011104:	68bb      	ldr	r3, [r7, #8]
 8011106:	6879      	ldr	r1, [r7, #4]
 8011108:	683a      	ldr	r2, [r7, #0]
 801110a:	4618      	mov	r0, r3
 801110c:	f7fd f870 	bl	800e1f0 <_txe_event_flags_create>
 8011110:	6178      	str	r0, [r7, #20]
        (TX_EVENT_FLAGS_GROUP *) param_0,
        (CHAR *) param_1,
        (UINT) param_2
    );
    return(return_value);
 8011112:	697b      	ldr	r3, [r7, #20]
}
 8011114:	4618      	mov	r0, r3
 8011116:	3718      	adds	r7, #24
 8011118:	46bd      	mov	sp, r7
 801111a:	bd80      	pop	{r7, pc}
 801111c:	2000f670 	.word	0x2000f670
 8011120:	2000f63c 	.word	0x2000f63c

08011124 <_txm_module_manager_tx_event_flags_delete_dispatch>:
#ifndef TXM_EVENT_FLAGS_DELETE_CALL_NOT_USED
/* UINT _txe_event_flags_delete(
    TX_EVENT_FLAGS_GROUP *group_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_event_flags_delete_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8011124:	b580      	push	{r7, lr}
 8011126:	b084      	sub	sp, #16
 8011128:	af00      	add	r7, sp, #0
 801112a:	6078      	str	r0, [r7, #4]
 801112c:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 801112e:	687b      	ldr	r3, [r7, #4]
 8011130:	68db      	ldr	r3, [r3, #12]
 8011132:	f003 0302 	and.w	r3, r3, #2
 8011136:	2b00      	cmp	r3, #0
 8011138:	d01e      	beq.n	8011178 <_txm_module_manager_tx_event_flags_delete_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_EVENT_FLAGS_GROUP)))
 801113a:	2230      	movs	r2, #48	; 0x30
 801113c:	6839      	ldr	r1, [r7, #0]
 801113e:	6878      	ldr	r0, [r7, #4]
 8011140:	f003 fe82 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011144:	4603      	mov	r3, r0
 8011146:	2b00      	cmp	r3, #0
 8011148:	d111      	bne.n	801116e <_txm_module_manager_tx_event_flags_delete_dispatch+0x4a>
 801114a:	683b      	ldr	r3, [r7, #0]
 801114c:	f113 0f31 	cmn.w	r3, #49	; 0x31
 8011150:	d812      	bhi.n	8011178 <_txm_module_manager_tx_event_flags_delete_dispatch+0x54>
 8011152:	687b      	ldr	r3, [r7, #4]
 8011154:	699b      	ldr	r3, [r3, #24]
 8011156:	461a      	mov	r2, r3
 8011158:	683b      	ldr	r3, [r7, #0]
 801115a:	4293      	cmp	r3, r2
 801115c:	d30c      	bcc.n	8011178 <_txm_module_manager_tx_event_flags_delete_dispatch+0x54>
 801115e:	683b      	ldr	r3, [r7, #0]
 8011160:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8011164:	687b      	ldr	r3, [r7, #4]
 8011166:	69db      	ldr	r3, [r3, #28]
 8011168:	3301      	adds	r3, #1
 801116a:	429a      	cmp	r2, r3
 801116c:	d804      	bhi.n	8011178 <_txm_module_manager_tx_event_flags_delete_dispatch+0x54>
 801116e:	683b      	ldr	r3, [r7, #0]
 8011170:	2b00      	cmp	r3, #0
 8011172:	d001      	beq.n	8011178 <_txm_module_manager_tx_event_flags_delete_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 8011174:	23f4      	movs	r3, #244	; 0xf4
 8011176:	e00d      	b.n	8011194 <_txm_module_manager_tx_event_flags_delete_dispatch+0x70>
    }

    return_value = (ALIGN_TYPE) _txe_event_flags_delete(
 8011178:	683b      	ldr	r3, [r7, #0]
 801117a:	4618      	mov	r0, r3
 801117c:	f7fd f8ca 	bl	800e314 <_txe_event_flags_delete>
 8011180:	60f8      	str	r0, [r7, #12]
        (TX_EVENT_FLAGS_GROUP *) param_0
    );

    /* Deallocate object memory.  */
    if (return_value == TX_SUCCESS)
 8011182:	68fb      	ldr	r3, [r7, #12]
 8011184:	2b00      	cmp	r3, #0
 8011186:	d104      	bne.n	8011192 <_txm_module_manager_tx_event_flags_delete_dispatch+0x6e>
    {
        return_value = _txm_module_manager_object_deallocate((VOID *) param_0);
 8011188:	683b      	ldr	r3, [r7, #0]
 801118a:	4618      	mov	r0, r3
 801118c:	f003 ff12 	bl	8014fb4 <_txm_module_manager_object_deallocate>
 8011190:	60f8      	str	r0, [r7, #12]
    }
    return(return_value);
 8011192:	68fb      	ldr	r3, [r7, #12]
}
 8011194:	4618      	mov	r0, r3
 8011196:	3710      	adds	r7, #16
 8011198:	46bd      	mov	sp, r7
 801119a:	bd80      	pop	{r7, pc}

0801119c <_txm_module_manager_tx_event_flags_get_dispatch>:
    UINT get_option, -> extra_parameters[0]
    ULONG *actual_flags_ptr, -> extra_parameters[1]
    ULONG wait_option -> extra_parameters[2]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_event_flags_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 801119c:	b580      	push	{r7, lr}
 801119e:	b088      	sub	sp, #32
 80111a0:	af02      	add	r7, sp, #8
 80111a2:	60f8      	str	r0, [r7, #12]
 80111a4:	60b9      	str	r1, [r7, #8]
 80111a6:	607a      	str	r2, [r7, #4]
 80111a8:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 80111aa:	68fb      	ldr	r3, [r7, #12]
 80111ac:	68db      	ldr	r3, [r3, #12]
 80111ae:	f003 0302 	and.w	r3, r3, #2
 80111b2:	2b00      	cmp	r3, #0
 80111b4:	d03b      	beq.n	801122e <_txm_module_manager_tx_event_flags_get_dispatch+0x92>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_EVENT_FLAGS_GROUP)))
 80111b6:	2230      	movs	r2, #48	; 0x30
 80111b8:	68b9      	ldr	r1, [r7, #8]
 80111ba:	68f8      	ldr	r0, [r7, #12]
 80111bc:	f003 fe44 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80111c0:	4603      	mov	r3, r0
 80111c2:	2b00      	cmp	r3, #0
 80111c4:	d111      	bne.n	80111ea <_txm_module_manager_tx_event_flags_get_dispatch+0x4e>
 80111c6:	68bb      	ldr	r3, [r7, #8]
 80111c8:	f113 0f31 	cmn.w	r3, #49	; 0x31
 80111cc:	d812      	bhi.n	80111f4 <_txm_module_manager_tx_event_flags_get_dispatch+0x58>
 80111ce:	68fb      	ldr	r3, [r7, #12]
 80111d0:	699b      	ldr	r3, [r3, #24]
 80111d2:	461a      	mov	r2, r3
 80111d4:	68bb      	ldr	r3, [r7, #8]
 80111d6:	4293      	cmp	r3, r2
 80111d8:	d30c      	bcc.n	80111f4 <_txm_module_manager_tx_event_flags_get_dispatch+0x58>
 80111da:	68bb      	ldr	r3, [r7, #8]
 80111dc:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80111e0:	68fb      	ldr	r3, [r7, #12]
 80111e2:	69db      	ldr	r3, [r3, #28]
 80111e4:	3301      	adds	r3, #1
 80111e6:	429a      	cmp	r2, r3
 80111e8:	d804      	bhi.n	80111f4 <_txm_module_manager_tx_event_flags_get_dispatch+0x58>
 80111ea:	68bb      	ldr	r3, [r7, #8]
 80111ec:	2b00      	cmp	r3, #0
 80111ee:	d001      	beq.n	80111f4 <_txm_module_manager_tx_event_flags_get_dispatch+0x58>
            return(TXM_MODULE_INVALID_MEMORY);
 80111f0:	23f4      	movs	r3, #244	; 0xf4
 80111f2:	e02d      	b.n	8011250 <_txm_module_manager_tx_event_flags_get_dispatch+0xb4>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 80111f4:	683b      	ldr	r3, [r7, #0]
 80111f6:	3304      	adds	r3, #4
 80111f8:	681b      	ldr	r3, [r3, #0]
 80111fa:	2204      	movs	r2, #4
 80111fc:	4619      	mov	r1, r3
 80111fe:	68f8      	ldr	r0, [r7, #12]
 8011200:	f003 fe22 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011204:	4603      	mov	r3, r0
 8011206:	2b00      	cmp	r3, #0
 8011208:	d106      	bne.n	8011218 <_txm_module_manager_tx_event_flags_get_dispatch+0x7c>
 801120a:	683b      	ldr	r3, [r7, #0]
 801120c:	3304      	adds	r3, #4
 801120e:	681b      	ldr	r3, [r3, #0]
 8011210:	2b00      	cmp	r3, #0
 8011212:	d001      	beq.n	8011218 <_txm_module_manager_tx_event_flags_get_dispatch+0x7c>
            return(TXM_MODULE_INVALID_MEMORY);
 8011214:	23f4      	movs	r3, #244	; 0xf4
 8011216:	e01b      	b.n	8011250 <_txm_module_manager_tx_event_flags_get_dispatch+0xb4>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[3])))
 8011218:	683b      	ldr	r3, [r7, #0]
 801121a:	220c      	movs	r2, #12
 801121c:	4619      	mov	r1, r3
 801121e:	68f8      	ldr	r0, [r7, #12]
 8011220:	f003 fe12 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011224:	4603      	mov	r3, r0
 8011226:	2b00      	cmp	r3, #0
 8011228:	d101      	bne.n	801122e <_txm_module_manager_tx_event_flags_get_dispatch+0x92>
            return(TXM_MODULE_INVALID_MEMORY);
 801122a:	23f4      	movs	r3, #244	; 0xf4
 801122c:	e010      	b.n	8011250 <_txm_module_manager_tx_event_flags_get_dispatch+0xb4>
    }

    return_value = (ALIGN_TYPE) _txe_event_flags_get(
 801122e:	68b8      	ldr	r0, [r7, #8]
 8011230:	683b      	ldr	r3, [r7, #0]
 8011232:	681a      	ldr	r2, [r3, #0]
        (TX_EVENT_FLAGS_GROUP *) param_0,
        (ULONG) param_1,
        (UINT) extra_parameters[0],
        (ULONG *) extra_parameters[1],
 8011234:	683b      	ldr	r3, [r7, #0]
 8011236:	3304      	adds	r3, #4
 8011238:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_event_flags_get(
 801123a:	4619      	mov	r1, r3
        (ULONG) extra_parameters[2]
 801123c:	683b      	ldr	r3, [r7, #0]
 801123e:	3308      	adds	r3, #8
    return_value = (ALIGN_TYPE) _txe_event_flags_get(
 8011240:	681b      	ldr	r3, [r3, #0]
 8011242:	9300      	str	r3, [sp, #0]
 8011244:	460b      	mov	r3, r1
 8011246:	6879      	ldr	r1, [r7, #4]
 8011248:	f7fd f8a2 	bl	800e390 <_txe_event_flags_get>
 801124c:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 801124e:	697b      	ldr	r3, [r7, #20]
}
 8011250:	4618      	mov	r0, r3
 8011252:	3718      	adds	r7, #24
 8011254:	46bd      	mov	sp, r7
 8011256:	bd80      	pop	{r7, pc}

08011258 <_txm_module_manager_tx_event_flags_info_get_dispatch>:
    TX_THREAD **first_suspended, -> extra_parameters[1]
    ULONG *suspended_count, -> extra_parameters[2]
    TX_EVENT_FLAGS_GROUP **next_group -> extra_parameters[3]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_event_flags_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8011258:	b5b0      	push	{r4, r5, r7, lr}
 801125a:	b088      	sub	sp, #32
 801125c:	af02      	add	r7, sp, #8
 801125e:	60f8      	str	r0, [r7, #12]
 8011260:	60b9      	str	r1, [r7, #8]
 8011262:	607a      	str	r2, [r7, #4]
 8011264:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8011266:	68fb      	ldr	r3, [r7, #12]
 8011268:	68db      	ldr	r3, [r3, #12]
 801126a:	f003 0302 	and.w	r3, r3, #2
 801126e:	2b00      	cmp	r3, #0
 8011270:	d07c      	beq.n	801136c <_txm_module_manager_tx_event_flags_info_get_dispatch+0x114>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_EVENT_FLAGS_GROUP)))
 8011272:	2230      	movs	r2, #48	; 0x30
 8011274:	68b9      	ldr	r1, [r7, #8]
 8011276:	68f8      	ldr	r0, [r7, #12]
 8011278:	f003 fde6 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801127c:	4603      	mov	r3, r0
 801127e:	2b00      	cmp	r3, #0
 8011280:	d111      	bne.n	80112a6 <_txm_module_manager_tx_event_flags_info_get_dispatch+0x4e>
 8011282:	68bb      	ldr	r3, [r7, #8]
 8011284:	f113 0f31 	cmn.w	r3, #49	; 0x31
 8011288:	d812      	bhi.n	80112b0 <_txm_module_manager_tx_event_flags_info_get_dispatch+0x58>
 801128a:	68fb      	ldr	r3, [r7, #12]
 801128c:	699b      	ldr	r3, [r3, #24]
 801128e:	461a      	mov	r2, r3
 8011290:	68bb      	ldr	r3, [r7, #8]
 8011292:	4293      	cmp	r3, r2
 8011294:	d30c      	bcc.n	80112b0 <_txm_module_manager_tx_event_flags_info_get_dispatch+0x58>
 8011296:	68bb      	ldr	r3, [r7, #8]
 8011298:	f103 0230 	add.w	r2, r3, #48	; 0x30
 801129c:	68fb      	ldr	r3, [r7, #12]
 801129e:	69db      	ldr	r3, [r3, #28]
 80112a0:	3301      	adds	r3, #1
 80112a2:	429a      	cmp	r2, r3
 80112a4:	d804      	bhi.n	80112b0 <_txm_module_manager_tx_event_flags_info_get_dispatch+0x58>
 80112a6:	68bb      	ldr	r3, [r7, #8]
 80112a8:	2b00      	cmp	r3, #0
 80112aa:	d001      	beq.n	80112b0 <_txm_module_manager_tx_event_flags_info_get_dispatch+0x58>
            return(TXM_MODULE_INVALID_MEMORY);
 80112ac:	23f4      	movs	r3, #244	; 0xf4
 80112ae:	e075      	b.n	801139c <_txm_module_manager_tx_event_flags_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(CHAR *)))
 80112b0:	2204      	movs	r2, #4
 80112b2:	6879      	ldr	r1, [r7, #4]
 80112b4:	68f8      	ldr	r0, [r7, #12]
 80112b6:	f003 fdc7 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80112ba:	4603      	mov	r3, r0
 80112bc:	2b00      	cmp	r3, #0
 80112be:	d104      	bne.n	80112ca <_txm_module_manager_tx_event_flags_info_get_dispatch+0x72>
 80112c0:	687b      	ldr	r3, [r7, #4]
 80112c2:	2b00      	cmp	r3, #0
 80112c4:	d001      	beq.n	80112ca <_txm_module_manager_tx_event_flags_info_get_dispatch+0x72>
            return(TXM_MODULE_INVALID_MEMORY);
 80112c6:	23f4      	movs	r3, #244	; 0xf4
 80112c8:	e068      	b.n	801139c <_txm_module_manager_tx_event_flags_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[4])))
 80112ca:	683b      	ldr	r3, [r7, #0]
 80112cc:	2210      	movs	r2, #16
 80112ce:	4619      	mov	r1, r3
 80112d0:	68f8      	ldr	r0, [r7, #12]
 80112d2:	f003 fdb9 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80112d6:	4603      	mov	r3, r0
 80112d8:	2b00      	cmp	r3, #0
 80112da:	d101      	bne.n	80112e0 <_txm_module_manager_tx_event_flags_info_get_dispatch+0x88>
            return(TXM_MODULE_INVALID_MEMORY);
 80112dc:	23f4      	movs	r3, #244	; 0xf4
 80112de:	e05d      	b.n	801139c <_txm_module_manager_tx_event_flags_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 80112e0:	683b      	ldr	r3, [r7, #0]
 80112e2:	681b      	ldr	r3, [r3, #0]
 80112e4:	2204      	movs	r2, #4
 80112e6:	4619      	mov	r1, r3
 80112e8:	68f8      	ldr	r0, [r7, #12]
 80112ea:	f003 fdad 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80112ee:	4603      	mov	r3, r0
 80112f0:	2b00      	cmp	r3, #0
 80112f2:	d105      	bne.n	8011300 <_txm_module_manager_tx_event_flags_info_get_dispatch+0xa8>
 80112f4:	683b      	ldr	r3, [r7, #0]
 80112f6:	681b      	ldr	r3, [r3, #0]
 80112f8:	2b00      	cmp	r3, #0
 80112fa:	d001      	beq.n	8011300 <_txm_module_manager_tx_event_flags_info_get_dispatch+0xa8>
            return(TXM_MODULE_INVALID_MEMORY);
 80112fc:	23f4      	movs	r3, #244	; 0xf4
 80112fe:	e04d      	b.n	801139c <_txm_module_manager_tx_event_flags_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(TX_THREAD *)))
 8011300:	683b      	ldr	r3, [r7, #0]
 8011302:	3304      	adds	r3, #4
 8011304:	681b      	ldr	r3, [r3, #0]
 8011306:	2204      	movs	r2, #4
 8011308:	4619      	mov	r1, r3
 801130a:	68f8      	ldr	r0, [r7, #12]
 801130c:	f003 fd9c 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011310:	4603      	mov	r3, r0
 8011312:	2b00      	cmp	r3, #0
 8011314:	d106      	bne.n	8011324 <_txm_module_manager_tx_event_flags_info_get_dispatch+0xcc>
 8011316:	683b      	ldr	r3, [r7, #0]
 8011318:	3304      	adds	r3, #4
 801131a:	681b      	ldr	r3, [r3, #0]
 801131c:	2b00      	cmp	r3, #0
 801131e:	d001      	beq.n	8011324 <_txm_module_manager_tx_event_flags_info_get_dispatch+0xcc>
            return(TXM_MODULE_INVALID_MEMORY);
 8011320:	23f4      	movs	r3, #244	; 0xf4
 8011322:	e03b      	b.n	801139c <_txm_module_manager_tx_event_flags_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(ULONG)))
 8011324:	683b      	ldr	r3, [r7, #0]
 8011326:	3308      	adds	r3, #8
 8011328:	681b      	ldr	r3, [r3, #0]
 801132a:	2204      	movs	r2, #4
 801132c:	4619      	mov	r1, r3
 801132e:	68f8      	ldr	r0, [r7, #12]
 8011330:	f003 fd8a 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011334:	4603      	mov	r3, r0
 8011336:	2b00      	cmp	r3, #0
 8011338:	d106      	bne.n	8011348 <_txm_module_manager_tx_event_flags_info_get_dispatch+0xf0>
 801133a:	683b      	ldr	r3, [r7, #0]
 801133c:	3308      	adds	r3, #8
 801133e:	681b      	ldr	r3, [r3, #0]
 8011340:	2b00      	cmp	r3, #0
 8011342:	d001      	beq.n	8011348 <_txm_module_manager_tx_event_flags_info_get_dispatch+0xf0>
            return(TXM_MODULE_INVALID_MEMORY);
 8011344:	23f4      	movs	r3, #244	; 0xf4
 8011346:	e029      	b.n	801139c <_txm_module_manager_tx_event_flags_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[3], sizeof(TX_EVENT_FLAGS_GROUP *)))
 8011348:	683b      	ldr	r3, [r7, #0]
 801134a:	330c      	adds	r3, #12
 801134c:	681b      	ldr	r3, [r3, #0]
 801134e:	2204      	movs	r2, #4
 8011350:	4619      	mov	r1, r3
 8011352:	68f8      	ldr	r0, [r7, #12]
 8011354:	f003 fd78 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011358:	4603      	mov	r3, r0
 801135a:	2b00      	cmp	r3, #0
 801135c:	d106      	bne.n	801136c <_txm_module_manager_tx_event_flags_info_get_dispatch+0x114>
 801135e:	683b      	ldr	r3, [r7, #0]
 8011360:	330c      	adds	r3, #12
 8011362:	681b      	ldr	r3, [r3, #0]
 8011364:	2b00      	cmp	r3, #0
 8011366:	d001      	beq.n	801136c <_txm_module_manager_tx_event_flags_info_get_dispatch+0x114>
            return(TXM_MODULE_INVALID_MEMORY);
 8011368:	23f4      	movs	r3, #244	; 0xf4
 801136a:	e017      	b.n	801139c <_txm_module_manager_tx_event_flags_info_get_dispatch+0x144>
    }

    return_value = (ALIGN_TYPE) _txe_event_flags_info_get(
 801136c:	68b8      	ldr	r0, [r7, #8]
 801136e:	6879      	ldr	r1, [r7, #4]
        (TX_EVENT_FLAGS_GROUP *) param_0,
        (CHAR **) param_1,
        (ULONG *) extra_parameters[0],
 8011370:	683b      	ldr	r3, [r7, #0]
 8011372:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_event_flags_info_get(
 8011374:	461c      	mov	r4, r3
        (TX_THREAD **) extra_parameters[1],
 8011376:	683b      	ldr	r3, [r7, #0]
 8011378:	3304      	adds	r3, #4
 801137a:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_event_flags_info_get(
 801137c:	461d      	mov	r5, r3
        (ULONG *) extra_parameters[2],
 801137e:	683b      	ldr	r3, [r7, #0]
 8011380:	3308      	adds	r3, #8
 8011382:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_event_flags_info_get(
 8011384:	461a      	mov	r2, r3
        (TX_EVENT_FLAGS_GROUP **) extra_parameters[3]
 8011386:	683b      	ldr	r3, [r7, #0]
 8011388:	330c      	adds	r3, #12
 801138a:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_event_flags_info_get(
 801138c:	9301      	str	r3, [sp, #4]
 801138e:	9200      	str	r2, [sp, #0]
 8011390:	462b      	mov	r3, r5
 8011392:	4622      	mov	r2, r4
 8011394:	f7fd f852 	bl	800e43c <_txe_event_flags_info_get>
 8011398:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 801139a:	697b      	ldr	r3, [r7, #20]
}
 801139c:	4618      	mov	r0, r3
 801139e:	3718      	adds	r7, #24
 80113a0:	46bd      	mov	sp, r7
 80113a2:	bdb0      	pop	{r4, r5, r7, pc}

080113a4 <_txm_module_manager_tx_event_flags_performance_info_get_dispatch>:
    ULONG *gets, -> extra_parameters[0]
    ULONG *suspensions, -> extra_parameters[1]
    ULONG *timeouts -> extra_parameters[2]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_event_flags_performance_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 80113a4:	b590      	push	{r4, r7, lr}
 80113a6:	b089      	sub	sp, #36	; 0x24
 80113a8:	af02      	add	r7, sp, #8
 80113aa:	60f8      	str	r0, [r7, #12]
 80113ac:	60b9      	str	r1, [r7, #8]
 80113ae:	607a      	str	r2, [r7, #4]
 80113b0:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 80113b2:	68fb      	ldr	r3, [r7, #12]
 80113b4:	68db      	ldr	r3, [r3, #12]
 80113b6:	f003 0302 	and.w	r3, r3, #2
 80113ba:	2b00      	cmp	r3, #0
 80113bc:	d06a      	beq.n	8011494 <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0xf0>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_EVENT_FLAGS_GROUP)))
 80113be:	2230      	movs	r2, #48	; 0x30
 80113c0:	68b9      	ldr	r1, [r7, #8]
 80113c2:	68f8      	ldr	r0, [r7, #12]
 80113c4:	f003 fd40 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80113c8:	4603      	mov	r3, r0
 80113ca:	2b00      	cmp	r3, #0
 80113cc:	d111      	bne.n	80113f2 <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0x4e>
 80113ce:	68bb      	ldr	r3, [r7, #8]
 80113d0:	f113 0f31 	cmn.w	r3, #49	; 0x31
 80113d4:	d812      	bhi.n	80113fc <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0x58>
 80113d6:	68fb      	ldr	r3, [r7, #12]
 80113d8:	699b      	ldr	r3, [r3, #24]
 80113da:	461a      	mov	r2, r3
 80113dc:	68bb      	ldr	r3, [r7, #8]
 80113de:	4293      	cmp	r3, r2
 80113e0:	d30c      	bcc.n	80113fc <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0x58>
 80113e2:	68bb      	ldr	r3, [r7, #8]
 80113e4:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80113e8:	68fb      	ldr	r3, [r7, #12]
 80113ea:	69db      	ldr	r3, [r3, #28]
 80113ec:	3301      	adds	r3, #1
 80113ee:	429a      	cmp	r2, r3
 80113f0:	d804      	bhi.n	80113fc <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0x58>
 80113f2:	68bb      	ldr	r3, [r7, #8]
 80113f4:	2b00      	cmp	r3, #0
 80113f6:	d001      	beq.n	80113fc <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0x58>
            return(TXM_MODULE_INVALID_MEMORY);
 80113f8:	23f4      	movs	r3, #244	; 0xf4
 80113fa:	e05d      	b.n	80114b8 <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0x114>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(ULONG)))
 80113fc:	2204      	movs	r2, #4
 80113fe:	6879      	ldr	r1, [r7, #4]
 8011400:	68f8      	ldr	r0, [r7, #12]
 8011402:	f003 fd21 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011406:	4603      	mov	r3, r0
 8011408:	2b00      	cmp	r3, #0
 801140a:	d104      	bne.n	8011416 <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0x72>
 801140c:	687b      	ldr	r3, [r7, #4]
 801140e:	2b00      	cmp	r3, #0
 8011410:	d001      	beq.n	8011416 <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0x72>
            return(TXM_MODULE_INVALID_MEMORY);
 8011412:	23f4      	movs	r3, #244	; 0xf4
 8011414:	e050      	b.n	80114b8 <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0x114>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[3])))
 8011416:	683b      	ldr	r3, [r7, #0]
 8011418:	220c      	movs	r2, #12
 801141a:	4619      	mov	r1, r3
 801141c:	68f8      	ldr	r0, [r7, #12]
 801141e:	f003 fd13 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011422:	4603      	mov	r3, r0
 8011424:	2b00      	cmp	r3, #0
 8011426:	d101      	bne.n	801142c <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0x88>
            return(TXM_MODULE_INVALID_MEMORY);
 8011428:	23f4      	movs	r3, #244	; 0xf4
 801142a:	e045      	b.n	80114b8 <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0x114>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 801142c:	683b      	ldr	r3, [r7, #0]
 801142e:	681b      	ldr	r3, [r3, #0]
 8011430:	2204      	movs	r2, #4
 8011432:	4619      	mov	r1, r3
 8011434:	68f8      	ldr	r0, [r7, #12]
 8011436:	f003 fd07 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801143a:	4603      	mov	r3, r0
 801143c:	2b00      	cmp	r3, #0
 801143e:	d105      	bne.n	801144c <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0xa8>
 8011440:	683b      	ldr	r3, [r7, #0]
 8011442:	681b      	ldr	r3, [r3, #0]
 8011444:	2b00      	cmp	r3, #0
 8011446:	d001      	beq.n	801144c <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0xa8>
            return(TXM_MODULE_INVALID_MEMORY);
 8011448:	23f4      	movs	r3, #244	; 0xf4
 801144a:	e035      	b.n	80114b8 <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0x114>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 801144c:	683b      	ldr	r3, [r7, #0]
 801144e:	3304      	adds	r3, #4
 8011450:	681b      	ldr	r3, [r3, #0]
 8011452:	2204      	movs	r2, #4
 8011454:	4619      	mov	r1, r3
 8011456:	68f8      	ldr	r0, [r7, #12]
 8011458:	f003 fcf6 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801145c:	4603      	mov	r3, r0
 801145e:	2b00      	cmp	r3, #0
 8011460:	d106      	bne.n	8011470 <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0xcc>
 8011462:	683b      	ldr	r3, [r7, #0]
 8011464:	3304      	adds	r3, #4
 8011466:	681b      	ldr	r3, [r3, #0]
 8011468:	2b00      	cmp	r3, #0
 801146a:	d001      	beq.n	8011470 <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0xcc>
            return(TXM_MODULE_INVALID_MEMORY);
 801146c:	23f4      	movs	r3, #244	; 0xf4
 801146e:	e023      	b.n	80114b8 <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0x114>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(ULONG)))
 8011470:	683b      	ldr	r3, [r7, #0]
 8011472:	3308      	adds	r3, #8
 8011474:	681b      	ldr	r3, [r3, #0]
 8011476:	2204      	movs	r2, #4
 8011478:	4619      	mov	r1, r3
 801147a:	68f8      	ldr	r0, [r7, #12]
 801147c:	f003 fce4 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011480:	4603      	mov	r3, r0
 8011482:	2b00      	cmp	r3, #0
 8011484:	d106      	bne.n	8011494 <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0xf0>
 8011486:	683b      	ldr	r3, [r7, #0]
 8011488:	3308      	adds	r3, #8
 801148a:	681b      	ldr	r3, [r3, #0]
 801148c:	2b00      	cmp	r3, #0
 801148e:	d001      	beq.n	8011494 <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0xf0>
            return(TXM_MODULE_INVALID_MEMORY);
 8011490:	23f4      	movs	r3, #244	; 0xf4
 8011492:	e011      	b.n	80114b8 <_txm_module_manager_tx_event_flags_performance_info_get_dispatch+0x114>
    }

    return_value = (ALIGN_TYPE) _tx_event_flags_performance_info_get(
 8011494:	68b8      	ldr	r0, [r7, #8]
 8011496:	6879      	ldr	r1, [r7, #4]
        (TX_EVENT_FLAGS_GROUP *) param_0,
        (ULONG *) param_1,
        (ULONG *) extra_parameters[0],
 8011498:	683b      	ldr	r3, [r7, #0]
 801149a:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_event_flags_performance_info_get(
 801149c:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[1],
 801149e:	683b      	ldr	r3, [r7, #0]
 80114a0:	3304      	adds	r3, #4
 80114a2:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_event_flags_performance_info_get(
 80114a4:	461c      	mov	r4, r3
        (ULONG *) extra_parameters[2]
 80114a6:	683b      	ldr	r3, [r7, #0]
 80114a8:	3308      	adds	r3, #8
 80114aa:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_event_flags_performance_info_get(
 80114ac:	9300      	str	r3, [sp, #0]
 80114ae:	4623      	mov	r3, r4
 80114b0:	f7f7 fac5 	bl	8008a3e <_tx_event_flags_performance_info_get>
 80114b4:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 80114b6:	697b      	ldr	r3, [r7, #20]
}
 80114b8:	4618      	mov	r0, r3
 80114ba:	371c      	adds	r7, #28
 80114bc:	46bd      	mov	sp, r7
 80114be:	bd90      	pop	{r4, r7, pc}

080114c0 <_txm_module_manager_tx_event_flags_performance_system_info_get_dispatch>:
    ULONG *gets, -> param_1
    ULONG *suspensions, -> extra_parameters[0]
    ULONG *timeouts -> extra_parameters[1]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_event_flags_performance_system_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 80114c0:	b580      	push	{r7, lr}
 80114c2:	b086      	sub	sp, #24
 80114c4:	af00      	add	r7, sp, #0
 80114c6:	60f8      	str	r0, [r7, #12]
 80114c8:	60b9      	str	r1, [r7, #8]
 80114ca:	607a      	str	r2, [r7, #4]
 80114cc:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 80114ce:	68fb      	ldr	r3, [r7, #12]
 80114d0:	68db      	ldr	r3, [r3, #12]
 80114d2:	f003 0302 	and.w	r3, r3, #2
 80114d6:	2b00      	cmp	r3, #0
 80114d8:	d046      	beq.n	8011568 <_txm_module_manager_tx_event_flags_performance_system_info_get_dispatch+0xa8>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_0, sizeof(ULONG)))
 80114da:	2204      	movs	r2, #4
 80114dc:	68b9      	ldr	r1, [r7, #8]
 80114de:	68f8      	ldr	r0, [r7, #12]
 80114e0:	f003 fcb2 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80114e4:	4603      	mov	r3, r0
 80114e6:	2b00      	cmp	r3, #0
 80114e8:	d104      	bne.n	80114f4 <_txm_module_manager_tx_event_flags_performance_system_info_get_dispatch+0x34>
 80114ea:	68bb      	ldr	r3, [r7, #8]
 80114ec:	2b00      	cmp	r3, #0
 80114ee:	d001      	beq.n	80114f4 <_txm_module_manager_tx_event_flags_performance_system_info_get_dispatch+0x34>
            return(TXM_MODULE_INVALID_MEMORY);
 80114f0:	23f4      	movs	r3, #244	; 0xf4
 80114f2:	e045      	b.n	8011580 <_txm_module_manager_tx_event_flags_performance_system_info_get_dispatch+0xc0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(ULONG)))
 80114f4:	2204      	movs	r2, #4
 80114f6:	6879      	ldr	r1, [r7, #4]
 80114f8:	68f8      	ldr	r0, [r7, #12]
 80114fa:	f003 fca5 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80114fe:	4603      	mov	r3, r0
 8011500:	2b00      	cmp	r3, #0
 8011502:	d104      	bne.n	801150e <_txm_module_manager_tx_event_flags_performance_system_info_get_dispatch+0x4e>
 8011504:	687b      	ldr	r3, [r7, #4]
 8011506:	2b00      	cmp	r3, #0
 8011508:	d001      	beq.n	801150e <_txm_module_manager_tx_event_flags_performance_system_info_get_dispatch+0x4e>
            return(TXM_MODULE_INVALID_MEMORY);
 801150a:	23f4      	movs	r3, #244	; 0xf4
 801150c:	e038      	b.n	8011580 <_txm_module_manager_tx_event_flags_performance_system_info_get_dispatch+0xc0>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[2])))
 801150e:	683b      	ldr	r3, [r7, #0]
 8011510:	2208      	movs	r2, #8
 8011512:	4619      	mov	r1, r3
 8011514:	68f8      	ldr	r0, [r7, #12]
 8011516:	f003 fc97 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801151a:	4603      	mov	r3, r0
 801151c:	2b00      	cmp	r3, #0
 801151e:	d101      	bne.n	8011524 <_txm_module_manager_tx_event_flags_performance_system_info_get_dispatch+0x64>
            return(TXM_MODULE_INVALID_MEMORY);
 8011520:	23f4      	movs	r3, #244	; 0xf4
 8011522:	e02d      	b.n	8011580 <_txm_module_manager_tx_event_flags_performance_system_info_get_dispatch+0xc0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 8011524:	683b      	ldr	r3, [r7, #0]
 8011526:	681b      	ldr	r3, [r3, #0]
 8011528:	2204      	movs	r2, #4
 801152a:	4619      	mov	r1, r3
 801152c:	68f8      	ldr	r0, [r7, #12]
 801152e:	f003 fc8b 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011532:	4603      	mov	r3, r0
 8011534:	2b00      	cmp	r3, #0
 8011536:	d105      	bne.n	8011544 <_txm_module_manager_tx_event_flags_performance_system_info_get_dispatch+0x84>
 8011538:	683b      	ldr	r3, [r7, #0]
 801153a:	681b      	ldr	r3, [r3, #0]
 801153c:	2b00      	cmp	r3, #0
 801153e:	d001      	beq.n	8011544 <_txm_module_manager_tx_event_flags_performance_system_info_get_dispatch+0x84>
            return(TXM_MODULE_INVALID_MEMORY);
 8011540:	23f4      	movs	r3, #244	; 0xf4
 8011542:	e01d      	b.n	8011580 <_txm_module_manager_tx_event_flags_performance_system_info_get_dispatch+0xc0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 8011544:	683b      	ldr	r3, [r7, #0]
 8011546:	3304      	adds	r3, #4
 8011548:	681b      	ldr	r3, [r3, #0]
 801154a:	2204      	movs	r2, #4
 801154c:	4619      	mov	r1, r3
 801154e:	68f8      	ldr	r0, [r7, #12]
 8011550:	f003 fc7a 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011554:	4603      	mov	r3, r0
 8011556:	2b00      	cmp	r3, #0
 8011558:	d106      	bne.n	8011568 <_txm_module_manager_tx_event_flags_performance_system_info_get_dispatch+0xa8>
 801155a:	683b      	ldr	r3, [r7, #0]
 801155c:	3304      	adds	r3, #4
 801155e:	681b      	ldr	r3, [r3, #0]
 8011560:	2b00      	cmp	r3, #0
 8011562:	d001      	beq.n	8011568 <_txm_module_manager_tx_event_flags_performance_system_info_get_dispatch+0xa8>
            return(TXM_MODULE_INVALID_MEMORY);
 8011564:	23f4      	movs	r3, #244	; 0xf4
 8011566:	e00b      	b.n	8011580 <_txm_module_manager_tx_event_flags_performance_system_info_get_dispatch+0xc0>
    }

    return_value = (ALIGN_TYPE) _tx_event_flags_performance_system_info_get(
 8011568:	68b8      	ldr	r0, [r7, #8]
 801156a:	6879      	ldr	r1, [r7, #4]
        (ULONG *) param_0,
        (ULONG *) param_1,
        (ULONG *) extra_parameters[0],
 801156c:	683b      	ldr	r3, [r7, #0]
 801156e:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_event_flags_performance_system_info_get(
 8011570:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[1]
 8011572:	683b      	ldr	r3, [r7, #0]
 8011574:	3304      	adds	r3, #4
 8011576:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_event_flags_performance_system_info_get(
 8011578:	f7f7 fa8f 	bl	8008a9a <_tx_event_flags_performance_system_info_get>
 801157c:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 801157e:	697b      	ldr	r3, [r7, #20]
}
 8011580:	4618      	mov	r0, r3
 8011582:	3718      	adds	r7, #24
 8011584:	46bd      	mov	sp, r7
 8011586:	bd80      	pop	{r7, pc}

08011588 <_txm_module_manager_tx_event_flags_set_dispatch>:
    TX_EVENT_FLAGS_GROUP *group_ptr, -> param_0
    ULONG flags_to_set, -> param_1
    UINT set_option -> param_2
   ); */
static ALIGN_TYPE _txm_module_manager_tx_event_flags_set_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE param_2)
{
 8011588:	b580      	push	{r7, lr}
 801158a:	b086      	sub	sp, #24
 801158c:	af00      	add	r7, sp, #0
 801158e:	60f8      	str	r0, [r7, #12]
 8011590:	60b9      	str	r1, [r7, #8]
 8011592:	607a      	str	r2, [r7, #4]
 8011594:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8011596:	68fb      	ldr	r3, [r7, #12]
 8011598:	68db      	ldr	r3, [r3, #12]
 801159a:	f003 0302 	and.w	r3, r3, #2
 801159e:	2b00      	cmp	r3, #0
 80115a0:	d01e      	beq.n	80115e0 <_txm_module_manager_tx_event_flags_set_dispatch+0x58>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_EVENT_FLAGS_GROUP)))
 80115a2:	2230      	movs	r2, #48	; 0x30
 80115a4:	68b9      	ldr	r1, [r7, #8]
 80115a6:	68f8      	ldr	r0, [r7, #12]
 80115a8:	f003 fc4e 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80115ac:	4603      	mov	r3, r0
 80115ae:	2b00      	cmp	r3, #0
 80115b0:	d111      	bne.n	80115d6 <_txm_module_manager_tx_event_flags_set_dispatch+0x4e>
 80115b2:	68bb      	ldr	r3, [r7, #8]
 80115b4:	f113 0f31 	cmn.w	r3, #49	; 0x31
 80115b8:	d812      	bhi.n	80115e0 <_txm_module_manager_tx_event_flags_set_dispatch+0x58>
 80115ba:	68fb      	ldr	r3, [r7, #12]
 80115bc:	699b      	ldr	r3, [r3, #24]
 80115be:	461a      	mov	r2, r3
 80115c0:	68bb      	ldr	r3, [r7, #8]
 80115c2:	4293      	cmp	r3, r2
 80115c4:	d30c      	bcc.n	80115e0 <_txm_module_manager_tx_event_flags_set_dispatch+0x58>
 80115c6:	68bb      	ldr	r3, [r7, #8]
 80115c8:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80115cc:	68fb      	ldr	r3, [r7, #12]
 80115ce:	69db      	ldr	r3, [r3, #28]
 80115d0:	3301      	adds	r3, #1
 80115d2:	429a      	cmp	r2, r3
 80115d4:	d804      	bhi.n	80115e0 <_txm_module_manager_tx_event_flags_set_dispatch+0x58>
 80115d6:	68bb      	ldr	r3, [r7, #8]
 80115d8:	2b00      	cmp	r3, #0
 80115da:	d001      	beq.n	80115e0 <_txm_module_manager_tx_event_flags_set_dispatch+0x58>
            return(TXM_MODULE_INVALID_MEMORY);
 80115dc:	23f4      	movs	r3, #244	; 0xf4
 80115de:	e007      	b.n	80115f0 <_txm_module_manager_tx_event_flags_set_dispatch+0x68>
    }

    return_value = (ALIGN_TYPE) _txe_event_flags_set(
 80115e0:	68bb      	ldr	r3, [r7, #8]
 80115e2:	683a      	ldr	r2, [r7, #0]
 80115e4:	6879      	ldr	r1, [r7, #4]
 80115e6:	4618      	mov	r0, r3
 80115e8:	f7fc ff50 	bl	800e48c <_txe_event_flags_set>
 80115ec:	6178      	str	r0, [r7, #20]
        (TX_EVENT_FLAGS_GROUP *) param_0,
        (ULONG) param_1,
        (UINT) param_2
    );
    return(return_value);
 80115ee:	697b      	ldr	r3, [r7, #20]
}
 80115f0:	4618      	mov	r0, r3
 80115f2:	3718      	adds	r7, #24
 80115f4:	46bd      	mov	sp, r7
 80115f6:	bd80      	pop	{r7, pc}

080115f8 <_txm_module_manager_tx_event_flags_set_notify_dispatch>:
/* UINT _txe_event_flags_set_notify(
    TX_EVENT_FLAGS_GROUP *group_ptr, -> param_0
    VOID (*events_set_notify)(TX_EVENT_FLAGS_GROUP *) -> param_1
   ); */
static ALIGN_TYPE _txm_module_manager_tx_event_flags_set_notify_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1)
{
 80115f8:	b580      	push	{r7, lr}
 80115fa:	b088      	sub	sp, #32
 80115fc:	af00      	add	r7, sp, #0
 80115fe:	60f8      	str	r0, [r7, #12]
 8011600:	60b9      	str	r1, [r7, #8]
 8011602:	607a      	str	r2, [r7, #4]

ALIGN_TYPE return_value;
TX_EVENT_FLAGS_GROUP *event_flags_ptr = (TX_EVENT_FLAGS_GROUP *)param_0;
 8011604:	68bb      	ldr	r3, [r7, #8]
 8011606:	61bb      	str	r3, [r7, #24]
VOID (*events_set_notify)(TX_EVENT_FLAGS_GROUP *);

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8011608:	68fb      	ldr	r3, [r7, #12]
 801160a:	68db      	ldr	r3, [r3, #12]
 801160c:	f003 0302 	and.w	r3, r3, #2
 8011610:	2b00      	cmp	r3, #0
 8011612:	d028      	beq.n	8011666 <_txm_module_manager_tx_event_flags_set_notify_dispatch+0x6e>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_EVENT_FLAGS_GROUP)))
 8011614:	2230      	movs	r2, #48	; 0x30
 8011616:	68b9      	ldr	r1, [r7, #8]
 8011618:	68f8      	ldr	r0, [r7, #12]
 801161a:	f003 fc15 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801161e:	4603      	mov	r3, r0
 8011620:	2b00      	cmp	r3, #0
 8011622:	d111      	bne.n	8011648 <_txm_module_manager_tx_event_flags_set_notify_dispatch+0x50>
 8011624:	68bb      	ldr	r3, [r7, #8]
 8011626:	f113 0f31 	cmn.w	r3, #49	; 0x31
 801162a:	d812      	bhi.n	8011652 <_txm_module_manager_tx_event_flags_set_notify_dispatch+0x5a>
 801162c:	68fb      	ldr	r3, [r7, #12]
 801162e:	699b      	ldr	r3, [r3, #24]
 8011630:	461a      	mov	r2, r3
 8011632:	68bb      	ldr	r3, [r7, #8]
 8011634:	4293      	cmp	r3, r2
 8011636:	d30c      	bcc.n	8011652 <_txm_module_manager_tx_event_flags_set_notify_dispatch+0x5a>
 8011638:	68bb      	ldr	r3, [r7, #8]
 801163a:	f103 0230 	add.w	r2, r3, #48	; 0x30
 801163e:	68fb      	ldr	r3, [r7, #12]
 8011640:	69db      	ldr	r3, [r3, #28]
 8011642:	3301      	adds	r3, #1
 8011644:	429a      	cmp	r2, r3
 8011646:	d804      	bhi.n	8011652 <_txm_module_manager_tx_event_flags_set_notify_dispatch+0x5a>
 8011648:	68bb      	ldr	r3, [r7, #8]
 801164a:	2b00      	cmp	r3, #0
 801164c:	d001      	beq.n	8011652 <_txm_module_manager_tx_event_flags_set_notify_dispatch+0x5a>
            return(TXM_MODULE_INVALID_MEMORY);
 801164e:	23f4      	movs	r3, #244	; 0xf4
 8011650:	e01e      	b.n	8011690 <_txm_module_manager_tx_event_flags_set_notify_dispatch+0x98>

        /* Since we need to write to the object, ensure it's valid.  */
        if ((event_flags_ptr == TX_NULL) || (event_flags_ptr -> tx_event_flags_group_id != TX_EVENT_FLAGS_ID))
 8011652:	69bb      	ldr	r3, [r7, #24]
 8011654:	2b00      	cmp	r3, #0
 8011656:	d004      	beq.n	8011662 <_txm_module_manager_tx_event_flags_set_notify_dispatch+0x6a>
 8011658:	69bb      	ldr	r3, [r7, #24]
 801165a:	681b      	ldr	r3, [r3, #0]
 801165c:	4a0e      	ldr	r2, [pc, #56]	; (8011698 <_txm_module_manager_tx_event_flags_set_notify_dispatch+0xa0>)
 801165e:	4293      	cmp	r3, r2
 8011660:	d001      	beq.n	8011666 <_txm_module_manager_tx_event_flags_set_notify_dispatch+0x6e>
            return(TX_GROUP_ERROR);
 8011662:	2306      	movs	r3, #6
 8011664:	e014      	b.n	8011690 <_txm_module_manager_tx_event_flags_set_notify_dispatch+0x98>
    }

    /* Is it a disable request?  */
    if ((void *) param_1 == TX_NULL)
 8011666:	687b      	ldr	r3, [r7, #4]
 8011668:	2b00      	cmp	r3, #0
 801166a:	d102      	bne.n	8011672 <_txm_module_manager_tx_event_flags_set_notify_dispatch+0x7a>
    {

        /* Clear the callback.  */
        events_set_notify = (VOID (*)(TX_EVENT_FLAGS_GROUP *)) TX_NULL;
 801166c:	2300      	movs	r3, #0
 801166e:	61fb      	str	r3, [r7, #28]
 8011670:	e007      	b.n	8011682 <_txm_module_manager_tx_event_flags_set_notify_dispatch+0x8a>
    }
    else
    {

        /* Setup trampoline values.  */
        event_flags_ptr -> tx_event_flags_group_module_instance = (VOID *) module_instance;
 8011672:	69bb      	ldr	r3, [r7, #24]
 8011674:	68fa      	ldr	r2, [r7, #12]
 8011676:	629a      	str	r2, [r3, #40]	; 0x28
        event_flags_ptr -> tx_event_flags_group_set_module_notify = (VOID (*)(TX_EVENT_FLAGS_GROUP *)) param_1;
 8011678:	687a      	ldr	r2, [r7, #4]
 801167a:	69bb      	ldr	r3, [r7, #24]
 801167c:	62da      	str	r2, [r3, #44]	; 0x2c
        events_set_notify = _txm_module_manager_event_flags_notify_trampoline;
 801167e:	4b07      	ldr	r3, [pc, #28]	; (801169c <_txm_module_manager_tx_event_flags_set_notify_dispatch+0xa4>)
 8011680:	61fb      	str	r3, [r7, #28]
    }

    return_value = (ALIGN_TYPE) _txe_event_flags_set_notify(
 8011682:	68bb      	ldr	r3, [r7, #8]
 8011684:	69f9      	ldr	r1, [r7, #28]
 8011686:	4618      	mov	r0, r3
 8011688:	f7fc ff2e 	bl	800e4e8 <_txe_event_flags_set_notify>
 801168c:	6178      	str	r0, [r7, #20]
        (TX_EVENT_FLAGS_GROUP *) param_0,
        (VOID (*)(TX_EVENT_FLAGS_GROUP *)) events_set_notify
    );
    return(return_value);
 801168e:	697b      	ldr	r3, [r7, #20]
}
 8011690:	4618      	mov	r0, r3
 8011692:	3720      	adds	r7, #32
 8011694:	46bd      	mov	sp, r7
 8011696:	bd80      	pop	{r7, pc}
 8011698:	4456444e 	.word	0x4456444e
 801169c:	0800fb65 	.word	0x0800fb65

080116a0 <_txm_module_manager_tx_mutex_create_dispatch>:
    CHAR *name_ptr, -> param_1
    UINT inherit, -> extra_parameters[0]
    UINT mutex_control_block_size -> extra_parameters[1]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_mutex_create_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 80116a0:	b580      	push	{r7, lr}
 80116a2:	b086      	sub	sp, #24
 80116a4:	af00      	add	r7, sp, #0
 80116a6:	60f8      	str	r0, [r7, #12]
 80116a8:	60b9      	str	r1, [r7, #8]
 80116aa:	607a      	str	r2, [r7, #4]
 80116ac:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 80116ae:	68fb      	ldr	r3, [r7, #12]
 80116b0:	68db      	ldr	r3, [r3, #12]
 80116b2:	f003 0302 	and.w	r3, r3, #2
 80116b6:	2b00      	cmp	r3, #0
 80116b8:	d04b      	beq.n	8011752 <_txm_module_manager_tx_mutex_create_dispatch+0xb2>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_CREATION(module_instance, param_0, sizeof(TX_MUTEX)))
 80116ba:	4b2d      	ldr	r3, [pc, #180]	; (8011770 <_txm_module_manager_tx_mutex_create_dispatch+0xd0>)
 80116bc:	681b      	ldr	r3, [r3, #0]
 80116be:	2b01      	cmp	r3, #1
 80116c0:	d119      	bne.n	80116f6 <_txm_module_manager_tx_mutex_create_dispatch+0x56>
 80116c2:	68bb      	ldr	r3, [r7, #8]
 80116c4:	f113 0f35 	cmn.w	r3, #53	; 0x35
 80116c8:	d815      	bhi.n	80116f6 <_txm_module_manager_tx_mutex_create_dispatch+0x56>
 80116ca:	4b2a      	ldr	r3, [pc, #168]	; (8011774 <_txm_module_manager_tx_mutex_create_dispatch+0xd4>)
 80116cc:	699b      	ldr	r3, [r3, #24]
 80116ce:	3310      	adds	r3, #16
 80116d0:	68ba      	ldr	r2, [r7, #8]
 80116d2:	429a      	cmp	r2, r3
 80116d4:	d30f      	bcc.n	80116f6 <_txm_module_manager_tx_mutex_create_dispatch+0x56>
 80116d6:	68bb      	ldr	r3, [r7, #8]
 80116d8:	3334      	adds	r3, #52	; 0x34
 80116da:	4a26      	ldr	r2, [pc, #152]	; (8011774 <_txm_module_manager_tx_mutex_create_dispatch+0xd4>)
 80116dc:	6991      	ldr	r1, [r2, #24]
 80116de:	4a25      	ldr	r2, [pc, #148]	; (8011774 <_txm_module_manager_tx_mutex_create_dispatch+0xd4>)
 80116e0:	69d2      	ldr	r2, [r2, #28]
 80116e2:	440a      	add	r2, r1
 80116e4:	4293      	cmp	r3, r2
 80116e6:	d806      	bhi.n	80116f6 <_txm_module_manager_tx_mutex_create_dispatch+0x56>
 80116e8:	2134      	movs	r1, #52	; 0x34
 80116ea:	68b8      	ldr	r0, [r7, #8]
 80116ec:	f004 ffd4 	bl	8016698 <_txm_module_manager_object_size_check>
 80116f0:	4603      	mov	r3, r0
 80116f2:	2b00      	cmp	r3, #0
 80116f4:	d004      	beq.n	8011700 <_txm_module_manager_tx_mutex_create_dispatch+0x60>
 80116f6:	68bb      	ldr	r3, [r7, #8]
 80116f8:	2b00      	cmp	r3, #0
 80116fa:	d001      	beq.n	8011700 <_txm_module_manager_tx_mutex_create_dispatch+0x60>
            return(TXM_MODULE_INVALID_MEMORY);
 80116fc:	23f4      	movs	r3, #244	; 0xf4
 80116fe:	e033      	b.n	8011768 <_txm_module_manager_tx_mutex_create_dispatch+0xc8>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_DEREFERENCE_STRING(module_instance, param_1))
 8011700:	2201      	movs	r2, #1
 8011702:	6879      	ldr	r1, [r7, #4]
 8011704:	68f8      	ldr	r0, [r7, #12]
 8011706:	f003 fb9f 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801170a:	4603      	mov	r3, r0
 801170c:	2b00      	cmp	r3, #0
 801170e:	d115      	bne.n	801173c <_txm_module_manager_tx_mutex_create_dispatch+0x9c>
 8011710:	687b      	ldr	r3, [r7, #4]
 8011712:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8011716:	d00c      	beq.n	8011732 <_txm_module_manager_tx_mutex_create_dispatch+0x92>
 8011718:	68fb      	ldr	r3, [r7, #12]
 801171a:	699b      	ldr	r3, [r3, #24]
 801171c:	461a      	mov	r2, r3
 801171e:	687b      	ldr	r3, [r7, #4]
 8011720:	4293      	cmp	r3, r2
 8011722:	d306      	bcc.n	8011732 <_txm_module_manager_tx_mutex_create_dispatch+0x92>
 8011724:	687b      	ldr	r3, [r7, #4]
 8011726:	1c5a      	adds	r2, r3, #1
 8011728:	68fb      	ldr	r3, [r7, #12]
 801172a:	69db      	ldr	r3, [r3, #28]
 801172c:	3301      	adds	r3, #1
 801172e:	429a      	cmp	r2, r3
 8011730:	d904      	bls.n	801173c <_txm_module_manager_tx_mutex_create_dispatch+0x9c>
 8011732:	687b      	ldr	r3, [r7, #4]
 8011734:	2b00      	cmp	r3, #0
 8011736:	d001      	beq.n	801173c <_txm_module_manager_tx_mutex_create_dispatch+0x9c>
            return(TXM_MODULE_INVALID_MEMORY);
 8011738:	23f4      	movs	r3, #244	; 0xf4
 801173a:	e015      	b.n	8011768 <_txm_module_manager_tx_mutex_create_dispatch+0xc8>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[2])))
 801173c:	683b      	ldr	r3, [r7, #0]
 801173e:	2208      	movs	r2, #8
 8011740:	4619      	mov	r1, r3
 8011742:	68f8      	ldr	r0, [r7, #12]
 8011744:	f003 fb80 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011748:	4603      	mov	r3, r0
 801174a:	2b00      	cmp	r3, #0
 801174c:	d101      	bne.n	8011752 <_txm_module_manager_tx_mutex_create_dispatch+0xb2>
            return(TXM_MODULE_INVALID_MEMORY);
 801174e:	23f4      	movs	r3, #244	; 0xf4
 8011750:	e00a      	b.n	8011768 <_txm_module_manager_tx_mutex_create_dispatch+0xc8>
    }

    return_value = (ALIGN_TYPE) _txe_mutex_create(
 8011752:	68b8      	ldr	r0, [r7, #8]
 8011754:	6879      	ldr	r1, [r7, #4]
 8011756:	683b      	ldr	r3, [r7, #0]
 8011758:	681a      	ldr	r2, [r3, #0]
        (TX_MUTEX *) param_0,
        (CHAR *) param_1,
        (UINT) extra_parameters[0],
        (UINT) extra_parameters[1]
 801175a:	683b      	ldr	r3, [r7, #0]
 801175c:	3304      	adds	r3, #4
    return_value = (ALIGN_TYPE) _txe_mutex_create(
 801175e:	681b      	ldr	r3, [r3, #0]
 8011760:	f7fc fee2 	bl	800e528 <_txe_mutex_create>
 8011764:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 8011766:	697b      	ldr	r3, [r7, #20]
}
 8011768:	4618      	mov	r0, r3
 801176a:	3718      	adds	r7, #24
 801176c:	46bd      	mov	sp, r7
 801176e:	bd80      	pop	{r7, pc}
 8011770:	2000f670 	.word	0x2000f670
 8011774:	2000f63c 	.word	0x2000f63c

08011778 <_txm_module_manager_tx_mutex_delete_dispatch>:
#ifndef TXM_MUTEX_DELETE_CALL_NOT_USED
/* UINT _txe_mutex_delete(
    TX_MUTEX *mutex_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_mutex_delete_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8011778:	b580      	push	{r7, lr}
 801177a:	b084      	sub	sp, #16
 801177c:	af00      	add	r7, sp, #0
 801177e:	6078      	str	r0, [r7, #4]
 8011780:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8011782:	687b      	ldr	r3, [r7, #4]
 8011784:	68db      	ldr	r3, [r3, #12]
 8011786:	f003 0302 	and.w	r3, r3, #2
 801178a:	2b00      	cmp	r3, #0
 801178c:	d01e      	beq.n	80117cc <_txm_module_manager_tx_mutex_delete_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_MUTEX)))
 801178e:	2234      	movs	r2, #52	; 0x34
 8011790:	6839      	ldr	r1, [r7, #0]
 8011792:	6878      	ldr	r0, [r7, #4]
 8011794:	f003 fb58 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011798:	4603      	mov	r3, r0
 801179a:	2b00      	cmp	r3, #0
 801179c:	d111      	bne.n	80117c2 <_txm_module_manager_tx_mutex_delete_dispatch+0x4a>
 801179e:	683b      	ldr	r3, [r7, #0]
 80117a0:	f113 0f35 	cmn.w	r3, #53	; 0x35
 80117a4:	d812      	bhi.n	80117cc <_txm_module_manager_tx_mutex_delete_dispatch+0x54>
 80117a6:	687b      	ldr	r3, [r7, #4]
 80117a8:	699b      	ldr	r3, [r3, #24]
 80117aa:	461a      	mov	r2, r3
 80117ac:	683b      	ldr	r3, [r7, #0]
 80117ae:	4293      	cmp	r3, r2
 80117b0:	d30c      	bcc.n	80117cc <_txm_module_manager_tx_mutex_delete_dispatch+0x54>
 80117b2:	683b      	ldr	r3, [r7, #0]
 80117b4:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80117b8:	687b      	ldr	r3, [r7, #4]
 80117ba:	69db      	ldr	r3, [r3, #28]
 80117bc:	3301      	adds	r3, #1
 80117be:	429a      	cmp	r2, r3
 80117c0:	d804      	bhi.n	80117cc <_txm_module_manager_tx_mutex_delete_dispatch+0x54>
 80117c2:	683b      	ldr	r3, [r7, #0]
 80117c4:	2b00      	cmp	r3, #0
 80117c6:	d001      	beq.n	80117cc <_txm_module_manager_tx_mutex_delete_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 80117c8:	23f4      	movs	r3, #244	; 0xf4
 80117ca:	e00d      	b.n	80117e8 <_txm_module_manager_tx_mutex_delete_dispatch+0x70>
    }

    return_value = (ALIGN_TYPE) _txe_mutex_delete(
 80117cc:	683b      	ldr	r3, [r7, #0]
 80117ce:	4618      	mov	r0, r3
 80117d0:	f7fc ff48 	bl	800e664 <_txe_mutex_delete>
 80117d4:	60f8      	str	r0, [r7, #12]
        (TX_MUTEX *) param_0
    );

    /* Deallocate object memory.  */
    if (return_value == TX_SUCCESS)
 80117d6:	68fb      	ldr	r3, [r7, #12]
 80117d8:	2b00      	cmp	r3, #0
 80117da:	d104      	bne.n	80117e6 <_txm_module_manager_tx_mutex_delete_dispatch+0x6e>
    {
        return_value = _txm_module_manager_object_deallocate((VOID *) param_0);
 80117dc:	683b      	ldr	r3, [r7, #0]
 80117de:	4618      	mov	r0, r3
 80117e0:	f003 fbe8 	bl	8014fb4 <_txm_module_manager_object_deallocate>
 80117e4:	60f8      	str	r0, [r7, #12]
    }
    return(return_value);
 80117e6:	68fb      	ldr	r3, [r7, #12]
}
 80117e8:	4618      	mov	r0, r3
 80117ea:	3710      	adds	r7, #16
 80117ec:	46bd      	mov	sp, r7
 80117ee:	bd80      	pop	{r7, pc}

080117f0 <_txm_module_manager_tx_mutex_get_dispatch>:
/* UINT _txe_mutex_get(
    TX_MUTEX *mutex_ptr, -> param_0
    ULONG wait_option -> param_1
   ); */
static ALIGN_TYPE _txm_module_manager_tx_mutex_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1)
{
 80117f0:	b580      	push	{r7, lr}
 80117f2:	b086      	sub	sp, #24
 80117f4:	af00      	add	r7, sp, #0
 80117f6:	60f8      	str	r0, [r7, #12]
 80117f8:	60b9      	str	r1, [r7, #8]
 80117fa:	607a      	str	r2, [r7, #4]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 80117fc:	68fb      	ldr	r3, [r7, #12]
 80117fe:	68db      	ldr	r3, [r3, #12]
 8011800:	f003 0302 	and.w	r3, r3, #2
 8011804:	2b00      	cmp	r3, #0
 8011806:	d01e      	beq.n	8011846 <_txm_module_manager_tx_mutex_get_dispatch+0x56>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_MUTEX)))
 8011808:	2234      	movs	r2, #52	; 0x34
 801180a:	68b9      	ldr	r1, [r7, #8]
 801180c:	68f8      	ldr	r0, [r7, #12]
 801180e:	f003 fb1b 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011812:	4603      	mov	r3, r0
 8011814:	2b00      	cmp	r3, #0
 8011816:	d111      	bne.n	801183c <_txm_module_manager_tx_mutex_get_dispatch+0x4c>
 8011818:	68bb      	ldr	r3, [r7, #8]
 801181a:	f113 0f35 	cmn.w	r3, #53	; 0x35
 801181e:	d812      	bhi.n	8011846 <_txm_module_manager_tx_mutex_get_dispatch+0x56>
 8011820:	68fb      	ldr	r3, [r7, #12]
 8011822:	699b      	ldr	r3, [r3, #24]
 8011824:	461a      	mov	r2, r3
 8011826:	68bb      	ldr	r3, [r7, #8]
 8011828:	4293      	cmp	r3, r2
 801182a:	d30c      	bcc.n	8011846 <_txm_module_manager_tx_mutex_get_dispatch+0x56>
 801182c:	68bb      	ldr	r3, [r7, #8]
 801182e:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8011832:	68fb      	ldr	r3, [r7, #12]
 8011834:	69db      	ldr	r3, [r3, #28]
 8011836:	3301      	adds	r3, #1
 8011838:	429a      	cmp	r2, r3
 801183a:	d804      	bhi.n	8011846 <_txm_module_manager_tx_mutex_get_dispatch+0x56>
 801183c:	68bb      	ldr	r3, [r7, #8]
 801183e:	2b00      	cmp	r3, #0
 8011840:	d001      	beq.n	8011846 <_txm_module_manager_tx_mutex_get_dispatch+0x56>
            return(TXM_MODULE_INVALID_MEMORY);
 8011842:	23f4      	movs	r3, #244	; 0xf4
 8011844:	e006      	b.n	8011854 <_txm_module_manager_tx_mutex_get_dispatch+0x64>
    }

    return_value = (ALIGN_TYPE) _txe_mutex_get(
 8011846:	68bb      	ldr	r3, [r7, #8]
 8011848:	6879      	ldr	r1, [r7, #4]
 801184a:	4618      	mov	r0, r3
 801184c:	f7fc ff48 	bl	800e6e0 <_txe_mutex_get>
 8011850:	6178      	str	r0, [r7, #20]
        (TX_MUTEX *) param_0,
        (ULONG) param_1
    );
    return(return_value);
 8011852:	697b      	ldr	r3, [r7, #20]
}
 8011854:	4618      	mov	r0, r3
 8011856:	3718      	adds	r7, #24
 8011858:	46bd      	mov	sp, r7
 801185a:	bd80      	pop	{r7, pc}

0801185c <_txm_module_manager_tx_mutex_info_get_dispatch>:
    TX_THREAD **first_suspended, -> extra_parameters[2]
    ULONG *suspended_count, -> extra_parameters[3]
    TX_MUTEX **next_mutex -> extra_parameters[4]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_mutex_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 801185c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801185e:	b08b      	sub	sp, #44	; 0x2c
 8011860:	af04      	add	r7, sp, #16
 8011862:	60f8      	str	r0, [r7, #12]
 8011864:	60b9      	str	r1, [r7, #8]
 8011866:	607a      	str	r2, [r7, #4]
 8011868:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 801186a:	68fb      	ldr	r3, [r7, #12]
 801186c:	68db      	ldr	r3, [r3, #12]
 801186e:	f003 0302 	and.w	r3, r3, #2
 8011872:	2b00      	cmp	r3, #0
 8011874:	f000 808f 	beq.w	8011996 <_txm_module_manager_tx_mutex_info_get_dispatch+0x13a>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_MUTEX)))
 8011878:	2234      	movs	r2, #52	; 0x34
 801187a:	68b9      	ldr	r1, [r7, #8]
 801187c:	68f8      	ldr	r0, [r7, #12]
 801187e:	f003 fae3 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011882:	4603      	mov	r3, r0
 8011884:	2b00      	cmp	r3, #0
 8011886:	d111      	bne.n	80118ac <_txm_module_manager_tx_mutex_info_get_dispatch+0x50>
 8011888:	68bb      	ldr	r3, [r7, #8]
 801188a:	f113 0f35 	cmn.w	r3, #53	; 0x35
 801188e:	d812      	bhi.n	80118b6 <_txm_module_manager_tx_mutex_info_get_dispatch+0x5a>
 8011890:	68fb      	ldr	r3, [r7, #12]
 8011892:	699b      	ldr	r3, [r3, #24]
 8011894:	461a      	mov	r2, r3
 8011896:	68bb      	ldr	r3, [r7, #8]
 8011898:	4293      	cmp	r3, r2
 801189a:	d30c      	bcc.n	80118b6 <_txm_module_manager_tx_mutex_info_get_dispatch+0x5a>
 801189c:	68bb      	ldr	r3, [r7, #8]
 801189e:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80118a2:	68fb      	ldr	r3, [r7, #12]
 80118a4:	69db      	ldr	r3, [r3, #28]
 80118a6:	3301      	adds	r3, #1
 80118a8:	429a      	cmp	r2, r3
 80118aa:	d804      	bhi.n	80118b6 <_txm_module_manager_tx_mutex_info_get_dispatch+0x5a>
 80118ac:	68bb      	ldr	r3, [r7, #8]
 80118ae:	2b00      	cmp	r3, #0
 80118b0:	d001      	beq.n	80118b6 <_txm_module_manager_tx_mutex_info_get_dispatch+0x5a>
            return(TXM_MODULE_INVALID_MEMORY);
 80118b2:	23f4      	movs	r3, #244	; 0xf4
 80118b4:	e08c      	b.n	80119d0 <_txm_module_manager_tx_mutex_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(CHAR *)))
 80118b6:	2204      	movs	r2, #4
 80118b8:	6879      	ldr	r1, [r7, #4]
 80118ba:	68f8      	ldr	r0, [r7, #12]
 80118bc:	f003 fac4 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80118c0:	4603      	mov	r3, r0
 80118c2:	2b00      	cmp	r3, #0
 80118c4:	d104      	bne.n	80118d0 <_txm_module_manager_tx_mutex_info_get_dispatch+0x74>
 80118c6:	687b      	ldr	r3, [r7, #4]
 80118c8:	2b00      	cmp	r3, #0
 80118ca:	d001      	beq.n	80118d0 <_txm_module_manager_tx_mutex_info_get_dispatch+0x74>
            return(TXM_MODULE_INVALID_MEMORY);
 80118cc:	23f4      	movs	r3, #244	; 0xf4
 80118ce:	e07f      	b.n	80119d0 <_txm_module_manager_tx_mutex_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[5])))
 80118d0:	683b      	ldr	r3, [r7, #0]
 80118d2:	2214      	movs	r2, #20
 80118d4:	4619      	mov	r1, r3
 80118d6:	68f8      	ldr	r0, [r7, #12]
 80118d8:	f003 fab6 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80118dc:	4603      	mov	r3, r0
 80118de:	2b00      	cmp	r3, #0
 80118e0:	d101      	bne.n	80118e6 <_txm_module_manager_tx_mutex_info_get_dispatch+0x8a>
            return(TXM_MODULE_INVALID_MEMORY);
 80118e2:	23f4      	movs	r3, #244	; 0xf4
 80118e4:	e074      	b.n	80119d0 <_txm_module_manager_tx_mutex_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 80118e6:	683b      	ldr	r3, [r7, #0]
 80118e8:	681b      	ldr	r3, [r3, #0]
 80118ea:	2204      	movs	r2, #4
 80118ec:	4619      	mov	r1, r3
 80118ee:	68f8      	ldr	r0, [r7, #12]
 80118f0:	f003 faaa 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80118f4:	4603      	mov	r3, r0
 80118f6:	2b00      	cmp	r3, #0
 80118f8:	d105      	bne.n	8011906 <_txm_module_manager_tx_mutex_info_get_dispatch+0xaa>
 80118fa:	683b      	ldr	r3, [r7, #0]
 80118fc:	681b      	ldr	r3, [r3, #0]
 80118fe:	2b00      	cmp	r3, #0
 8011900:	d001      	beq.n	8011906 <_txm_module_manager_tx_mutex_info_get_dispatch+0xaa>
            return(TXM_MODULE_INVALID_MEMORY);
 8011902:	23f4      	movs	r3, #244	; 0xf4
 8011904:	e064      	b.n	80119d0 <_txm_module_manager_tx_mutex_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(TX_THREAD *)))
 8011906:	683b      	ldr	r3, [r7, #0]
 8011908:	3304      	adds	r3, #4
 801190a:	681b      	ldr	r3, [r3, #0]
 801190c:	2204      	movs	r2, #4
 801190e:	4619      	mov	r1, r3
 8011910:	68f8      	ldr	r0, [r7, #12]
 8011912:	f003 fa99 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011916:	4603      	mov	r3, r0
 8011918:	2b00      	cmp	r3, #0
 801191a:	d106      	bne.n	801192a <_txm_module_manager_tx_mutex_info_get_dispatch+0xce>
 801191c:	683b      	ldr	r3, [r7, #0]
 801191e:	3304      	adds	r3, #4
 8011920:	681b      	ldr	r3, [r3, #0]
 8011922:	2b00      	cmp	r3, #0
 8011924:	d001      	beq.n	801192a <_txm_module_manager_tx_mutex_info_get_dispatch+0xce>
            return(TXM_MODULE_INVALID_MEMORY);
 8011926:	23f4      	movs	r3, #244	; 0xf4
 8011928:	e052      	b.n	80119d0 <_txm_module_manager_tx_mutex_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(TX_THREAD *)))
 801192a:	683b      	ldr	r3, [r7, #0]
 801192c:	3308      	adds	r3, #8
 801192e:	681b      	ldr	r3, [r3, #0]
 8011930:	2204      	movs	r2, #4
 8011932:	4619      	mov	r1, r3
 8011934:	68f8      	ldr	r0, [r7, #12]
 8011936:	f003 fa87 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801193a:	4603      	mov	r3, r0
 801193c:	2b00      	cmp	r3, #0
 801193e:	d106      	bne.n	801194e <_txm_module_manager_tx_mutex_info_get_dispatch+0xf2>
 8011940:	683b      	ldr	r3, [r7, #0]
 8011942:	3308      	adds	r3, #8
 8011944:	681b      	ldr	r3, [r3, #0]
 8011946:	2b00      	cmp	r3, #0
 8011948:	d001      	beq.n	801194e <_txm_module_manager_tx_mutex_info_get_dispatch+0xf2>
            return(TXM_MODULE_INVALID_MEMORY);
 801194a:	23f4      	movs	r3, #244	; 0xf4
 801194c:	e040      	b.n	80119d0 <_txm_module_manager_tx_mutex_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[3], sizeof(ULONG)))
 801194e:	683b      	ldr	r3, [r7, #0]
 8011950:	330c      	adds	r3, #12
 8011952:	681b      	ldr	r3, [r3, #0]
 8011954:	2204      	movs	r2, #4
 8011956:	4619      	mov	r1, r3
 8011958:	68f8      	ldr	r0, [r7, #12]
 801195a:	f003 fa75 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801195e:	4603      	mov	r3, r0
 8011960:	2b00      	cmp	r3, #0
 8011962:	d106      	bne.n	8011972 <_txm_module_manager_tx_mutex_info_get_dispatch+0x116>
 8011964:	683b      	ldr	r3, [r7, #0]
 8011966:	330c      	adds	r3, #12
 8011968:	681b      	ldr	r3, [r3, #0]
 801196a:	2b00      	cmp	r3, #0
 801196c:	d001      	beq.n	8011972 <_txm_module_manager_tx_mutex_info_get_dispatch+0x116>
            return(TXM_MODULE_INVALID_MEMORY);
 801196e:	23f4      	movs	r3, #244	; 0xf4
 8011970:	e02e      	b.n	80119d0 <_txm_module_manager_tx_mutex_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[4], sizeof(TX_MUTEX *)))
 8011972:	683b      	ldr	r3, [r7, #0]
 8011974:	3310      	adds	r3, #16
 8011976:	681b      	ldr	r3, [r3, #0]
 8011978:	2204      	movs	r2, #4
 801197a:	4619      	mov	r1, r3
 801197c:	68f8      	ldr	r0, [r7, #12]
 801197e:	f003 fa63 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011982:	4603      	mov	r3, r0
 8011984:	2b00      	cmp	r3, #0
 8011986:	d106      	bne.n	8011996 <_txm_module_manager_tx_mutex_info_get_dispatch+0x13a>
 8011988:	683b      	ldr	r3, [r7, #0]
 801198a:	3310      	adds	r3, #16
 801198c:	681b      	ldr	r3, [r3, #0]
 801198e:	2b00      	cmp	r3, #0
 8011990:	d001      	beq.n	8011996 <_txm_module_manager_tx_mutex_info_get_dispatch+0x13a>
            return(TXM_MODULE_INVALID_MEMORY);
 8011992:	23f4      	movs	r3, #244	; 0xf4
 8011994:	e01c      	b.n	80119d0 <_txm_module_manager_tx_mutex_info_get_dispatch+0x174>
    }

    return_value = (ALIGN_TYPE) _txe_mutex_info_get(
 8011996:	68b8      	ldr	r0, [r7, #8]
 8011998:	6879      	ldr	r1, [r7, #4]
        (TX_MUTEX *) param_0,
        (CHAR **) param_1,
        (ULONG *) extra_parameters[0],
 801199a:	683b      	ldr	r3, [r7, #0]
 801199c:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_mutex_info_get(
 801199e:	461d      	mov	r5, r3
        (TX_THREAD **) extra_parameters[1],
 80119a0:	683b      	ldr	r3, [r7, #0]
 80119a2:	3304      	adds	r3, #4
 80119a4:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_mutex_info_get(
 80119a6:	461e      	mov	r6, r3
        (TX_THREAD **) extra_parameters[2],
 80119a8:	683b      	ldr	r3, [r7, #0]
 80119aa:	3308      	adds	r3, #8
 80119ac:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_mutex_info_get(
 80119ae:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[3],
 80119b0:	683b      	ldr	r3, [r7, #0]
 80119b2:	330c      	adds	r3, #12
 80119b4:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_mutex_info_get(
 80119b6:	461c      	mov	r4, r3
        (TX_MUTEX **) extra_parameters[4]
 80119b8:	683b      	ldr	r3, [r7, #0]
 80119ba:	3310      	adds	r3, #16
 80119bc:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_mutex_info_get(
 80119be:	9302      	str	r3, [sp, #8]
 80119c0:	9401      	str	r4, [sp, #4]
 80119c2:	9200      	str	r2, [sp, #0]
 80119c4:	4633      	mov	r3, r6
 80119c6:	462a      	mov	r2, r5
 80119c8:	f7fc fee4 	bl	800e794 <_txe_mutex_info_get>
 80119cc:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 80119ce:	697b      	ldr	r3, [r7, #20]
}
 80119d0:	4618      	mov	r0, r3
 80119d2:	371c      	adds	r7, #28
 80119d4:	46bd      	mov	sp, r7
 80119d6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080119d8 <_txm_module_manager_tx_mutex_performance_info_get_dispatch>:
    ULONG *timeouts, -> extra_parameters[2]
    ULONG *inversions, -> extra_parameters[3]
    ULONG *inheritances -> extra_parameters[4]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_mutex_performance_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 80119d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80119da:	b08b      	sub	sp, #44	; 0x2c
 80119dc:	af04      	add	r7, sp, #16
 80119de:	60f8      	str	r0, [r7, #12]
 80119e0:	60b9      	str	r1, [r7, #8]
 80119e2:	607a      	str	r2, [r7, #4]
 80119e4:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 80119e6:	68fb      	ldr	r3, [r7, #12]
 80119e8:	68db      	ldr	r3, [r3, #12]
 80119ea:	f003 0302 	and.w	r3, r3, #2
 80119ee:	2b00      	cmp	r3, #0
 80119f0:	f000 808f 	beq.w	8011b12 <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x13a>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_MUTEX)))
 80119f4:	2234      	movs	r2, #52	; 0x34
 80119f6:	68b9      	ldr	r1, [r7, #8]
 80119f8:	68f8      	ldr	r0, [r7, #12]
 80119fa:	f003 fa25 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80119fe:	4603      	mov	r3, r0
 8011a00:	2b00      	cmp	r3, #0
 8011a02:	d111      	bne.n	8011a28 <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x50>
 8011a04:	68bb      	ldr	r3, [r7, #8]
 8011a06:	f113 0f35 	cmn.w	r3, #53	; 0x35
 8011a0a:	d812      	bhi.n	8011a32 <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x5a>
 8011a0c:	68fb      	ldr	r3, [r7, #12]
 8011a0e:	699b      	ldr	r3, [r3, #24]
 8011a10:	461a      	mov	r2, r3
 8011a12:	68bb      	ldr	r3, [r7, #8]
 8011a14:	4293      	cmp	r3, r2
 8011a16:	d30c      	bcc.n	8011a32 <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x5a>
 8011a18:	68bb      	ldr	r3, [r7, #8]
 8011a1a:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8011a1e:	68fb      	ldr	r3, [r7, #12]
 8011a20:	69db      	ldr	r3, [r3, #28]
 8011a22:	3301      	adds	r3, #1
 8011a24:	429a      	cmp	r2, r3
 8011a26:	d804      	bhi.n	8011a32 <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x5a>
 8011a28:	68bb      	ldr	r3, [r7, #8]
 8011a2a:	2b00      	cmp	r3, #0
 8011a2c:	d001      	beq.n	8011a32 <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x5a>
            return(TXM_MODULE_INVALID_MEMORY);
 8011a2e:	23f4      	movs	r3, #244	; 0xf4
 8011a30:	e08c      	b.n	8011b4c <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(ULONG)))
 8011a32:	2204      	movs	r2, #4
 8011a34:	6879      	ldr	r1, [r7, #4]
 8011a36:	68f8      	ldr	r0, [r7, #12]
 8011a38:	f003 fa06 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011a3c:	4603      	mov	r3, r0
 8011a3e:	2b00      	cmp	r3, #0
 8011a40:	d104      	bne.n	8011a4c <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x74>
 8011a42:	687b      	ldr	r3, [r7, #4]
 8011a44:	2b00      	cmp	r3, #0
 8011a46:	d001      	beq.n	8011a4c <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x74>
            return(TXM_MODULE_INVALID_MEMORY);
 8011a48:	23f4      	movs	r3, #244	; 0xf4
 8011a4a:	e07f      	b.n	8011b4c <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[5])))
 8011a4c:	683b      	ldr	r3, [r7, #0]
 8011a4e:	2214      	movs	r2, #20
 8011a50:	4619      	mov	r1, r3
 8011a52:	68f8      	ldr	r0, [r7, #12]
 8011a54:	f003 f9f8 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011a58:	4603      	mov	r3, r0
 8011a5a:	2b00      	cmp	r3, #0
 8011a5c:	d101      	bne.n	8011a62 <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x8a>
            return(TXM_MODULE_INVALID_MEMORY);
 8011a5e:	23f4      	movs	r3, #244	; 0xf4
 8011a60:	e074      	b.n	8011b4c <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 8011a62:	683b      	ldr	r3, [r7, #0]
 8011a64:	681b      	ldr	r3, [r3, #0]
 8011a66:	2204      	movs	r2, #4
 8011a68:	4619      	mov	r1, r3
 8011a6a:	68f8      	ldr	r0, [r7, #12]
 8011a6c:	f003 f9ec 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011a70:	4603      	mov	r3, r0
 8011a72:	2b00      	cmp	r3, #0
 8011a74:	d105      	bne.n	8011a82 <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0xaa>
 8011a76:	683b      	ldr	r3, [r7, #0]
 8011a78:	681b      	ldr	r3, [r3, #0]
 8011a7a:	2b00      	cmp	r3, #0
 8011a7c:	d001      	beq.n	8011a82 <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0xaa>
            return(TXM_MODULE_INVALID_MEMORY);
 8011a7e:	23f4      	movs	r3, #244	; 0xf4
 8011a80:	e064      	b.n	8011b4c <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 8011a82:	683b      	ldr	r3, [r7, #0]
 8011a84:	3304      	adds	r3, #4
 8011a86:	681b      	ldr	r3, [r3, #0]
 8011a88:	2204      	movs	r2, #4
 8011a8a:	4619      	mov	r1, r3
 8011a8c:	68f8      	ldr	r0, [r7, #12]
 8011a8e:	f003 f9db 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011a92:	4603      	mov	r3, r0
 8011a94:	2b00      	cmp	r3, #0
 8011a96:	d106      	bne.n	8011aa6 <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0xce>
 8011a98:	683b      	ldr	r3, [r7, #0]
 8011a9a:	3304      	adds	r3, #4
 8011a9c:	681b      	ldr	r3, [r3, #0]
 8011a9e:	2b00      	cmp	r3, #0
 8011aa0:	d001      	beq.n	8011aa6 <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0xce>
            return(TXM_MODULE_INVALID_MEMORY);
 8011aa2:	23f4      	movs	r3, #244	; 0xf4
 8011aa4:	e052      	b.n	8011b4c <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(ULONG)))
 8011aa6:	683b      	ldr	r3, [r7, #0]
 8011aa8:	3308      	adds	r3, #8
 8011aaa:	681b      	ldr	r3, [r3, #0]
 8011aac:	2204      	movs	r2, #4
 8011aae:	4619      	mov	r1, r3
 8011ab0:	68f8      	ldr	r0, [r7, #12]
 8011ab2:	f003 f9c9 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011ab6:	4603      	mov	r3, r0
 8011ab8:	2b00      	cmp	r3, #0
 8011aba:	d106      	bne.n	8011aca <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0xf2>
 8011abc:	683b      	ldr	r3, [r7, #0]
 8011abe:	3308      	adds	r3, #8
 8011ac0:	681b      	ldr	r3, [r3, #0]
 8011ac2:	2b00      	cmp	r3, #0
 8011ac4:	d001      	beq.n	8011aca <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0xf2>
            return(TXM_MODULE_INVALID_MEMORY);
 8011ac6:	23f4      	movs	r3, #244	; 0xf4
 8011ac8:	e040      	b.n	8011b4c <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[3], sizeof(ULONG)))
 8011aca:	683b      	ldr	r3, [r7, #0]
 8011acc:	330c      	adds	r3, #12
 8011ace:	681b      	ldr	r3, [r3, #0]
 8011ad0:	2204      	movs	r2, #4
 8011ad2:	4619      	mov	r1, r3
 8011ad4:	68f8      	ldr	r0, [r7, #12]
 8011ad6:	f003 f9b7 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011ada:	4603      	mov	r3, r0
 8011adc:	2b00      	cmp	r3, #0
 8011ade:	d106      	bne.n	8011aee <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x116>
 8011ae0:	683b      	ldr	r3, [r7, #0]
 8011ae2:	330c      	adds	r3, #12
 8011ae4:	681b      	ldr	r3, [r3, #0]
 8011ae6:	2b00      	cmp	r3, #0
 8011ae8:	d001      	beq.n	8011aee <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x116>
            return(TXM_MODULE_INVALID_MEMORY);
 8011aea:	23f4      	movs	r3, #244	; 0xf4
 8011aec:	e02e      	b.n	8011b4c <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[4], sizeof(ULONG)))
 8011aee:	683b      	ldr	r3, [r7, #0]
 8011af0:	3310      	adds	r3, #16
 8011af2:	681b      	ldr	r3, [r3, #0]
 8011af4:	2204      	movs	r2, #4
 8011af6:	4619      	mov	r1, r3
 8011af8:	68f8      	ldr	r0, [r7, #12]
 8011afa:	f003 f9a5 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011afe:	4603      	mov	r3, r0
 8011b00:	2b00      	cmp	r3, #0
 8011b02:	d106      	bne.n	8011b12 <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x13a>
 8011b04:	683b      	ldr	r3, [r7, #0]
 8011b06:	3310      	adds	r3, #16
 8011b08:	681b      	ldr	r3, [r3, #0]
 8011b0a:	2b00      	cmp	r3, #0
 8011b0c:	d001      	beq.n	8011b12 <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x13a>
            return(TXM_MODULE_INVALID_MEMORY);
 8011b0e:	23f4      	movs	r3, #244	; 0xf4
 8011b10:	e01c      	b.n	8011b4c <_txm_module_manager_tx_mutex_performance_info_get_dispatch+0x174>
    }

    return_value = (ALIGN_TYPE) _tx_mutex_performance_info_get(
 8011b12:	68b8      	ldr	r0, [r7, #8]
 8011b14:	6879      	ldr	r1, [r7, #4]
        (TX_MUTEX *) param_0,
        (ULONG *) param_1,
        (ULONG *) extra_parameters[0],
 8011b16:	683b      	ldr	r3, [r7, #0]
 8011b18:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_mutex_performance_info_get(
 8011b1a:	461d      	mov	r5, r3
        (ULONG *) extra_parameters[1],
 8011b1c:	683b      	ldr	r3, [r7, #0]
 8011b1e:	3304      	adds	r3, #4
 8011b20:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_mutex_performance_info_get(
 8011b22:	461e      	mov	r6, r3
        (ULONG *) extra_parameters[2],
 8011b24:	683b      	ldr	r3, [r7, #0]
 8011b26:	3308      	adds	r3, #8
 8011b28:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_mutex_performance_info_get(
 8011b2a:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[3],
 8011b2c:	683b      	ldr	r3, [r7, #0]
 8011b2e:	330c      	adds	r3, #12
 8011b30:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_mutex_performance_info_get(
 8011b32:	461c      	mov	r4, r3
        (ULONG *) extra_parameters[4]
 8011b34:	683b      	ldr	r3, [r7, #0]
 8011b36:	3310      	adds	r3, #16
 8011b38:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_mutex_performance_info_get(
 8011b3a:	9302      	str	r3, [sp, #8]
 8011b3c:	9401      	str	r4, [sp, #4]
 8011b3e:	9200      	str	r2, [sp, #0]
 8011b40:	4633      	mov	r3, r6
 8011b42:	462a      	mov	r2, r5
 8011b44:	f7f7 fd9e 	bl	8009684 <_tx_mutex_performance_info_get>
 8011b48:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 8011b4a:	697b      	ldr	r3, [r7, #20]
}
 8011b4c:	4618      	mov	r0, r3
 8011b4e:	371c      	adds	r7, #28
 8011b50:	46bd      	mov	sp, r7
 8011b52:	bdf0      	pop	{r4, r5, r6, r7, pc}

08011b54 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch>:
    ULONG *timeouts, -> extra_parameters[1]
    ULONG *inversions, -> extra_parameters[2]
    ULONG *inheritances -> extra_parameters[3]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_mutex_performance_system_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8011b54:	b5b0      	push	{r4, r5, r7, lr}
 8011b56:	b088      	sub	sp, #32
 8011b58:	af02      	add	r7, sp, #8
 8011b5a:	60f8      	str	r0, [r7, #12]
 8011b5c:	60b9      	str	r1, [r7, #8]
 8011b5e:	607a      	str	r2, [r7, #4]
 8011b60:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8011b62:	68fb      	ldr	r3, [r7, #12]
 8011b64:	68db      	ldr	r3, [r3, #12]
 8011b66:	f003 0302 	and.w	r3, r3, #2
 8011b6a:	2b00      	cmp	r3, #0
 8011b6c:	d06a      	beq.n	8011c44 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0xf0>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_0, sizeof(ULONG)))
 8011b6e:	2204      	movs	r2, #4
 8011b70:	68b9      	ldr	r1, [r7, #8]
 8011b72:	68f8      	ldr	r0, [r7, #12]
 8011b74:	f003 f968 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011b78:	4603      	mov	r3, r0
 8011b7a:	2b00      	cmp	r3, #0
 8011b7c:	d104      	bne.n	8011b88 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0x34>
 8011b7e:	68bb      	ldr	r3, [r7, #8]
 8011b80:	2b00      	cmp	r3, #0
 8011b82:	d001      	beq.n	8011b88 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0x34>
            return(TXM_MODULE_INVALID_MEMORY);
 8011b84:	23f4      	movs	r3, #244	; 0xf4
 8011b86:	e075      	b.n	8011c74 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0x120>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(ULONG)))
 8011b88:	2204      	movs	r2, #4
 8011b8a:	6879      	ldr	r1, [r7, #4]
 8011b8c:	68f8      	ldr	r0, [r7, #12]
 8011b8e:	f003 f95b 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011b92:	4603      	mov	r3, r0
 8011b94:	2b00      	cmp	r3, #0
 8011b96:	d104      	bne.n	8011ba2 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0x4e>
 8011b98:	687b      	ldr	r3, [r7, #4]
 8011b9a:	2b00      	cmp	r3, #0
 8011b9c:	d001      	beq.n	8011ba2 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0x4e>
            return(TXM_MODULE_INVALID_MEMORY);
 8011b9e:	23f4      	movs	r3, #244	; 0xf4
 8011ba0:	e068      	b.n	8011c74 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0x120>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[4])))
 8011ba2:	683b      	ldr	r3, [r7, #0]
 8011ba4:	2210      	movs	r2, #16
 8011ba6:	4619      	mov	r1, r3
 8011ba8:	68f8      	ldr	r0, [r7, #12]
 8011baa:	f003 f94d 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011bae:	4603      	mov	r3, r0
 8011bb0:	2b00      	cmp	r3, #0
 8011bb2:	d101      	bne.n	8011bb8 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0x64>
            return(TXM_MODULE_INVALID_MEMORY);
 8011bb4:	23f4      	movs	r3, #244	; 0xf4
 8011bb6:	e05d      	b.n	8011c74 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0x120>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 8011bb8:	683b      	ldr	r3, [r7, #0]
 8011bba:	681b      	ldr	r3, [r3, #0]
 8011bbc:	2204      	movs	r2, #4
 8011bbe:	4619      	mov	r1, r3
 8011bc0:	68f8      	ldr	r0, [r7, #12]
 8011bc2:	f003 f941 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011bc6:	4603      	mov	r3, r0
 8011bc8:	2b00      	cmp	r3, #0
 8011bca:	d105      	bne.n	8011bd8 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0x84>
 8011bcc:	683b      	ldr	r3, [r7, #0]
 8011bce:	681b      	ldr	r3, [r3, #0]
 8011bd0:	2b00      	cmp	r3, #0
 8011bd2:	d001      	beq.n	8011bd8 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0x84>
            return(TXM_MODULE_INVALID_MEMORY);
 8011bd4:	23f4      	movs	r3, #244	; 0xf4
 8011bd6:	e04d      	b.n	8011c74 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0x120>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 8011bd8:	683b      	ldr	r3, [r7, #0]
 8011bda:	3304      	adds	r3, #4
 8011bdc:	681b      	ldr	r3, [r3, #0]
 8011bde:	2204      	movs	r2, #4
 8011be0:	4619      	mov	r1, r3
 8011be2:	68f8      	ldr	r0, [r7, #12]
 8011be4:	f003 f930 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011be8:	4603      	mov	r3, r0
 8011bea:	2b00      	cmp	r3, #0
 8011bec:	d106      	bne.n	8011bfc <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0xa8>
 8011bee:	683b      	ldr	r3, [r7, #0]
 8011bf0:	3304      	adds	r3, #4
 8011bf2:	681b      	ldr	r3, [r3, #0]
 8011bf4:	2b00      	cmp	r3, #0
 8011bf6:	d001      	beq.n	8011bfc <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0xa8>
            return(TXM_MODULE_INVALID_MEMORY);
 8011bf8:	23f4      	movs	r3, #244	; 0xf4
 8011bfa:	e03b      	b.n	8011c74 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0x120>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(ULONG)))
 8011bfc:	683b      	ldr	r3, [r7, #0]
 8011bfe:	3308      	adds	r3, #8
 8011c00:	681b      	ldr	r3, [r3, #0]
 8011c02:	2204      	movs	r2, #4
 8011c04:	4619      	mov	r1, r3
 8011c06:	68f8      	ldr	r0, [r7, #12]
 8011c08:	f003 f91e 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011c0c:	4603      	mov	r3, r0
 8011c0e:	2b00      	cmp	r3, #0
 8011c10:	d106      	bne.n	8011c20 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0xcc>
 8011c12:	683b      	ldr	r3, [r7, #0]
 8011c14:	3308      	adds	r3, #8
 8011c16:	681b      	ldr	r3, [r3, #0]
 8011c18:	2b00      	cmp	r3, #0
 8011c1a:	d001      	beq.n	8011c20 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0xcc>
            return(TXM_MODULE_INVALID_MEMORY);
 8011c1c:	23f4      	movs	r3, #244	; 0xf4
 8011c1e:	e029      	b.n	8011c74 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0x120>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[3], sizeof(ULONG)))
 8011c20:	683b      	ldr	r3, [r7, #0]
 8011c22:	330c      	adds	r3, #12
 8011c24:	681b      	ldr	r3, [r3, #0]
 8011c26:	2204      	movs	r2, #4
 8011c28:	4619      	mov	r1, r3
 8011c2a:	68f8      	ldr	r0, [r7, #12]
 8011c2c:	f003 f90c 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011c30:	4603      	mov	r3, r0
 8011c32:	2b00      	cmp	r3, #0
 8011c34:	d106      	bne.n	8011c44 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0xf0>
 8011c36:	683b      	ldr	r3, [r7, #0]
 8011c38:	330c      	adds	r3, #12
 8011c3a:	681b      	ldr	r3, [r3, #0]
 8011c3c:	2b00      	cmp	r3, #0
 8011c3e:	d001      	beq.n	8011c44 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0xf0>
            return(TXM_MODULE_INVALID_MEMORY);
 8011c40:	23f4      	movs	r3, #244	; 0xf4
 8011c42:	e017      	b.n	8011c74 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch+0x120>
    }

    return_value = (ALIGN_TYPE) _tx_mutex_performance_system_info_get(
 8011c44:	68b8      	ldr	r0, [r7, #8]
 8011c46:	6879      	ldr	r1, [r7, #4]
        (ULONG *) param_0,
        (ULONG *) param_1,
        (ULONG *) extra_parameters[0],
 8011c48:	683b      	ldr	r3, [r7, #0]
 8011c4a:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_mutex_performance_system_info_get(
 8011c4c:	461c      	mov	r4, r3
        (ULONG *) extra_parameters[1],
 8011c4e:	683b      	ldr	r3, [r7, #0]
 8011c50:	3304      	adds	r3, #4
 8011c52:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_mutex_performance_system_info_get(
 8011c54:	461d      	mov	r5, r3
        (ULONG *) extra_parameters[2],
 8011c56:	683b      	ldr	r3, [r7, #0]
 8011c58:	3308      	adds	r3, #8
 8011c5a:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_mutex_performance_system_info_get(
 8011c5c:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[3]
 8011c5e:	683b      	ldr	r3, [r7, #0]
 8011c60:	330c      	adds	r3, #12
 8011c62:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_mutex_performance_system_info_get(
 8011c64:	9301      	str	r3, [sp, #4]
 8011c66:	9200      	str	r2, [sp, #0]
 8011c68:	462b      	mov	r3, r5
 8011c6a:	4622      	mov	r2, r4
 8011c6c:	f7f7 fd44 	bl	80096f8 <_tx_mutex_performance_system_info_get>
 8011c70:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 8011c72:	697b      	ldr	r3, [r7, #20]
}
 8011c74:	4618      	mov	r0, r3
 8011c76:	3718      	adds	r7, #24
 8011c78:	46bd      	mov	sp, r7
 8011c7a:	bdb0      	pop	{r4, r5, r7, pc}

08011c7c <_txm_module_manager_tx_mutex_prioritize_dispatch>:
#ifndef TXM_MUTEX_PRIORITIZE_CALL_NOT_USED
/* UINT _txe_mutex_prioritize(
    TX_MUTEX *mutex_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_mutex_prioritize_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8011c7c:	b580      	push	{r7, lr}
 8011c7e:	b084      	sub	sp, #16
 8011c80:	af00      	add	r7, sp, #0
 8011c82:	6078      	str	r0, [r7, #4]
 8011c84:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8011c86:	687b      	ldr	r3, [r7, #4]
 8011c88:	68db      	ldr	r3, [r3, #12]
 8011c8a:	f003 0302 	and.w	r3, r3, #2
 8011c8e:	2b00      	cmp	r3, #0
 8011c90:	d01e      	beq.n	8011cd0 <_txm_module_manager_tx_mutex_prioritize_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_MUTEX)))
 8011c92:	2234      	movs	r2, #52	; 0x34
 8011c94:	6839      	ldr	r1, [r7, #0]
 8011c96:	6878      	ldr	r0, [r7, #4]
 8011c98:	f003 f8d6 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011c9c:	4603      	mov	r3, r0
 8011c9e:	2b00      	cmp	r3, #0
 8011ca0:	d111      	bne.n	8011cc6 <_txm_module_manager_tx_mutex_prioritize_dispatch+0x4a>
 8011ca2:	683b      	ldr	r3, [r7, #0]
 8011ca4:	f113 0f35 	cmn.w	r3, #53	; 0x35
 8011ca8:	d812      	bhi.n	8011cd0 <_txm_module_manager_tx_mutex_prioritize_dispatch+0x54>
 8011caa:	687b      	ldr	r3, [r7, #4]
 8011cac:	699b      	ldr	r3, [r3, #24]
 8011cae:	461a      	mov	r2, r3
 8011cb0:	683b      	ldr	r3, [r7, #0]
 8011cb2:	4293      	cmp	r3, r2
 8011cb4:	d30c      	bcc.n	8011cd0 <_txm_module_manager_tx_mutex_prioritize_dispatch+0x54>
 8011cb6:	683b      	ldr	r3, [r7, #0]
 8011cb8:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8011cbc:	687b      	ldr	r3, [r7, #4]
 8011cbe:	69db      	ldr	r3, [r3, #28]
 8011cc0:	3301      	adds	r3, #1
 8011cc2:	429a      	cmp	r2, r3
 8011cc4:	d804      	bhi.n	8011cd0 <_txm_module_manager_tx_mutex_prioritize_dispatch+0x54>
 8011cc6:	683b      	ldr	r3, [r7, #0]
 8011cc8:	2b00      	cmp	r3, #0
 8011cca:	d001      	beq.n	8011cd0 <_txm_module_manager_tx_mutex_prioritize_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 8011ccc:	23f4      	movs	r3, #244	; 0xf4
 8011cce:	e005      	b.n	8011cdc <_txm_module_manager_tx_mutex_prioritize_dispatch+0x60>
    }

    return_value = (ALIGN_TYPE) _txe_mutex_prioritize(
 8011cd0:	683b      	ldr	r3, [r7, #0]
 8011cd2:	4618      	mov	r0, r3
 8011cd4:	f7fc fd88 	bl	800e7e8 <_txe_mutex_prioritize>
 8011cd8:	60f8      	str	r0, [r7, #12]
        (TX_MUTEX *) param_0
    );
    return(return_value);
 8011cda:	68fb      	ldr	r3, [r7, #12]
}
 8011cdc:	4618      	mov	r0, r3
 8011cde:	3710      	adds	r7, #16
 8011ce0:	46bd      	mov	sp, r7
 8011ce2:	bd80      	pop	{r7, pc}

08011ce4 <_txm_module_manager_tx_mutex_put_dispatch>:
#ifndef TXM_MUTEX_PUT_CALL_NOT_USED
/* UINT _txe_mutex_put(
    TX_MUTEX *mutex_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_mutex_put_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8011ce4:	b580      	push	{r7, lr}
 8011ce6:	b084      	sub	sp, #16
 8011ce8:	af00      	add	r7, sp, #0
 8011cea:	6078      	str	r0, [r7, #4]
 8011cec:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8011cee:	687b      	ldr	r3, [r7, #4]
 8011cf0:	68db      	ldr	r3, [r3, #12]
 8011cf2:	f003 0302 	and.w	r3, r3, #2
 8011cf6:	2b00      	cmp	r3, #0
 8011cf8:	d01e      	beq.n	8011d38 <_txm_module_manager_tx_mutex_put_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_MUTEX)))
 8011cfa:	2234      	movs	r2, #52	; 0x34
 8011cfc:	6839      	ldr	r1, [r7, #0]
 8011cfe:	6878      	ldr	r0, [r7, #4]
 8011d00:	f003 f8a2 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011d04:	4603      	mov	r3, r0
 8011d06:	2b00      	cmp	r3, #0
 8011d08:	d111      	bne.n	8011d2e <_txm_module_manager_tx_mutex_put_dispatch+0x4a>
 8011d0a:	683b      	ldr	r3, [r7, #0]
 8011d0c:	f113 0f35 	cmn.w	r3, #53	; 0x35
 8011d10:	d812      	bhi.n	8011d38 <_txm_module_manager_tx_mutex_put_dispatch+0x54>
 8011d12:	687b      	ldr	r3, [r7, #4]
 8011d14:	699b      	ldr	r3, [r3, #24]
 8011d16:	461a      	mov	r2, r3
 8011d18:	683b      	ldr	r3, [r7, #0]
 8011d1a:	4293      	cmp	r3, r2
 8011d1c:	d30c      	bcc.n	8011d38 <_txm_module_manager_tx_mutex_put_dispatch+0x54>
 8011d1e:	683b      	ldr	r3, [r7, #0]
 8011d20:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8011d24:	687b      	ldr	r3, [r7, #4]
 8011d26:	69db      	ldr	r3, [r3, #28]
 8011d28:	3301      	adds	r3, #1
 8011d2a:	429a      	cmp	r2, r3
 8011d2c:	d804      	bhi.n	8011d38 <_txm_module_manager_tx_mutex_put_dispatch+0x54>
 8011d2e:	683b      	ldr	r3, [r7, #0]
 8011d30:	2b00      	cmp	r3, #0
 8011d32:	d001      	beq.n	8011d38 <_txm_module_manager_tx_mutex_put_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 8011d34:	23f4      	movs	r3, #244	; 0xf4
 8011d36:	e005      	b.n	8011d44 <_txm_module_manager_tx_mutex_put_dispatch+0x60>
    }

    return_value = (ALIGN_TYPE) _txe_mutex_put(
 8011d38:	683b      	ldr	r3, [r7, #0]
 8011d3a:	4618      	mov	r0, r3
 8011d3c:	f7fc fd72 	bl	800e824 <_txe_mutex_put>
 8011d40:	60f8      	str	r0, [r7, #12]
        (TX_MUTEX *) param_0
    );
    return(return_value);
 8011d42:	68fb      	ldr	r3, [r7, #12]
}
 8011d44:	4618      	mov	r0, r3
 8011d46:	3710      	adds	r7, #16
 8011d48:	46bd      	mov	sp, r7
 8011d4a:	bd80      	pop	{r7, pc}

08011d4c <_txm_module_manager_tx_queue_create_dispatch>:
    VOID *queue_start, -> extra_parameters[1]
    ULONG queue_size, -> extra_parameters[2]
    UINT queue_control_block_size -> extra_parameters[3]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_queue_create_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8011d4c:	b5b0      	push	{r4, r5, r7, lr}
 8011d4e:	b088      	sub	sp, #32
 8011d50:	af02      	add	r7, sp, #8
 8011d52:	60f8      	str	r0, [r7, #12]
 8011d54:	60b9      	str	r1, [r7, #8]
 8011d56:	607a      	str	r2, [r7, #4]
 8011d58:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8011d5a:	68fb      	ldr	r3, [r7, #12]
 8011d5c:	68db      	ldr	r3, [r3, #12]
 8011d5e:	f003 0302 	and.w	r3, r3, #2
 8011d62:	2b00      	cmp	r3, #0
 8011d64:	d05f      	beq.n	8011e26 <_txm_module_manager_tx_queue_create_dispatch+0xda>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_CREATION(module_instance, param_0, sizeof(TX_QUEUE)))
 8011d66:	4b3d      	ldr	r3, [pc, #244]	; (8011e5c <_txm_module_manager_tx_queue_create_dispatch+0x110>)
 8011d68:	681b      	ldr	r3, [r3, #0]
 8011d6a:	2b01      	cmp	r3, #1
 8011d6c:	d119      	bne.n	8011da2 <_txm_module_manager_tx_queue_create_dispatch+0x56>
 8011d6e:	68bb      	ldr	r3, [r7, #8]
 8011d70:	f113 0f45 	cmn.w	r3, #69	; 0x45
 8011d74:	d815      	bhi.n	8011da2 <_txm_module_manager_tx_queue_create_dispatch+0x56>
 8011d76:	4b3a      	ldr	r3, [pc, #232]	; (8011e60 <_txm_module_manager_tx_queue_create_dispatch+0x114>)
 8011d78:	699b      	ldr	r3, [r3, #24]
 8011d7a:	3310      	adds	r3, #16
 8011d7c:	68ba      	ldr	r2, [r7, #8]
 8011d7e:	429a      	cmp	r2, r3
 8011d80:	d30f      	bcc.n	8011da2 <_txm_module_manager_tx_queue_create_dispatch+0x56>
 8011d82:	68bb      	ldr	r3, [r7, #8]
 8011d84:	3344      	adds	r3, #68	; 0x44
 8011d86:	4a36      	ldr	r2, [pc, #216]	; (8011e60 <_txm_module_manager_tx_queue_create_dispatch+0x114>)
 8011d88:	6991      	ldr	r1, [r2, #24]
 8011d8a:	4a35      	ldr	r2, [pc, #212]	; (8011e60 <_txm_module_manager_tx_queue_create_dispatch+0x114>)
 8011d8c:	69d2      	ldr	r2, [r2, #28]
 8011d8e:	440a      	add	r2, r1
 8011d90:	4293      	cmp	r3, r2
 8011d92:	d806      	bhi.n	8011da2 <_txm_module_manager_tx_queue_create_dispatch+0x56>
 8011d94:	2144      	movs	r1, #68	; 0x44
 8011d96:	68b8      	ldr	r0, [r7, #8]
 8011d98:	f004 fc7e 	bl	8016698 <_txm_module_manager_object_size_check>
 8011d9c:	4603      	mov	r3, r0
 8011d9e:	2b00      	cmp	r3, #0
 8011da0:	d004      	beq.n	8011dac <_txm_module_manager_tx_queue_create_dispatch+0x60>
 8011da2:	68bb      	ldr	r3, [r7, #8]
 8011da4:	2b00      	cmp	r3, #0
 8011da6:	d001      	beq.n	8011dac <_txm_module_manager_tx_queue_create_dispatch+0x60>
            return(TXM_MODULE_INVALID_MEMORY);
 8011da8:	23f4      	movs	r3, #244	; 0xf4
 8011daa:	e052      	b.n	8011e52 <_txm_module_manager_tx_queue_create_dispatch+0x106>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_DEREFERENCE_STRING(module_instance, param_1))
 8011dac:	2201      	movs	r2, #1
 8011dae:	6879      	ldr	r1, [r7, #4]
 8011db0:	68f8      	ldr	r0, [r7, #12]
 8011db2:	f003 f849 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011db6:	4603      	mov	r3, r0
 8011db8:	2b00      	cmp	r3, #0
 8011dba:	d115      	bne.n	8011de8 <_txm_module_manager_tx_queue_create_dispatch+0x9c>
 8011dbc:	687b      	ldr	r3, [r7, #4]
 8011dbe:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8011dc2:	d00c      	beq.n	8011dde <_txm_module_manager_tx_queue_create_dispatch+0x92>
 8011dc4:	68fb      	ldr	r3, [r7, #12]
 8011dc6:	699b      	ldr	r3, [r3, #24]
 8011dc8:	461a      	mov	r2, r3
 8011dca:	687b      	ldr	r3, [r7, #4]
 8011dcc:	4293      	cmp	r3, r2
 8011dce:	d306      	bcc.n	8011dde <_txm_module_manager_tx_queue_create_dispatch+0x92>
 8011dd0:	687b      	ldr	r3, [r7, #4]
 8011dd2:	1c5a      	adds	r2, r3, #1
 8011dd4:	68fb      	ldr	r3, [r7, #12]
 8011dd6:	69db      	ldr	r3, [r3, #28]
 8011dd8:	3301      	adds	r3, #1
 8011dda:	429a      	cmp	r2, r3
 8011ddc:	d904      	bls.n	8011de8 <_txm_module_manager_tx_queue_create_dispatch+0x9c>
 8011dde:	687b      	ldr	r3, [r7, #4]
 8011de0:	2b00      	cmp	r3, #0
 8011de2:	d001      	beq.n	8011de8 <_txm_module_manager_tx_queue_create_dispatch+0x9c>
            return(TXM_MODULE_INVALID_MEMORY);
 8011de4:	23f4      	movs	r3, #244	; 0xf4
 8011de6:	e034      	b.n	8011e52 <_txm_module_manager_tx_queue_create_dispatch+0x106>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[4])))
 8011de8:	683b      	ldr	r3, [r7, #0]
 8011dea:	2210      	movs	r2, #16
 8011dec:	4619      	mov	r1, r3
 8011dee:	68f8      	ldr	r0, [r7, #12]
 8011df0:	f003 f82a 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011df4:	4603      	mov	r3, r0
 8011df6:	2b00      	cmp	r3, #0
 8011df8:	d101      	bne.n	8011dfe <_txm_module_manager_tx_queue_create_dispatch+0xb2>
            return(TXM_MODULE_INVALID_MEMORY);
 8011dfa:	23f4      	movs	r3, #244	; 0xf4
 8011dfc:	e029      	b.n	8011e52 <_txm_module_manager_tx_queue_create_dispatch+0x106>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], extra_parameters[2]))
 8011dfe:	683b      	ldr	r3, [r7, #0]
 8011e00:	3304      	adds	r3, #4
 8011e02:	6819      	ldr	r1, [r3, #0]
 8011e04:	683b      	ldr	r3, [r7, #0]
 8011e06:	3308      	adds	r3, #8
 8011e08:	681b      	ldr	r3, [r3, #0]
 8011e0a:	461a      	mov	r2, r3
 8011e0c:	68f8      	ldr	r0, [r7, #12]
 8011e0e:	f003 f81b 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011e12:	4603      	mov	r3, r0
 8011e14:	2b00      	cmp	r3, #0
 8011e16:	d106      	bne.n	8011e26 <_txm_module_manager_tx_queue_create_dispatch+0xda>
 8011e18:	683b      	ldr	r3, [r7, #0]
 8011e1a:	3304      	adds	r3, #4
 8011e1c:	681b      	ldr	r3, [r3, #0]
 8011e1e:	2b00      	cmp	r3, #0
 8011e20:	d001      	beq.n	8011e26 <_txm_module_manager_tx_queue_create_dispatch+0xda>
            return(TXM_MODULE_INVALID_MEMORY);
 8011e22:	23f4      	movs	r3, #244	; 0xf4
 8011e24:	e015      	b.n	8011e52 <_txm_module_manager_tx_queue_create_dispatch+0x106>
    }

    return_value = (ALIGN_TYPE) _txe_queue_create(
 8011e26:	68b8      	ldr	r0, [r7, #8]
 8011e28:	6879      	ldr	r1, [r7, #4]
 8011e2a:	683b      	ldr	r3, [r7, #0]
 8011e2c:	681c      	ldr	r4, [r3, #0]
        (TX_QUEUE *) param_0,
        (CHAR *) param_1,
        (UINT) extra_parameters[0],
        (VOID *) extra_parameters[1],
 8011e2e:	683b      	ldr	r3, [r7, #0]
 8011e30:	3304      	adds	r3, #4
 8011e32:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_queue_create(
 8011e34:	461d      	mov	r5, r3
        (ULONG) extra_parameters[2],
 8011e36:	683b      	ldr	r3, [r7, #0]
 8011e38:	3308      	adds	r3, #8
    return_value = (ALIGN_TYPE) _txe_queue_create(
 8011e3a:	681b      	ldr	r3, [r3, #0]
        (UINT) extra_parameters[3]
 8011e3c:	683a      	ldr	r2, [r7, #0]
 8011e3e:	320c      	adds	r2, #12
    return_value = (ALIGN_TYPE) _txe_queue_create(
 8011e40:	6812      	ldr	r2, [r2, #0]
 8011e42:	9201      	str	r2, [sp, #4]
 8011e44:	9300      	str	r3, [sp, #0]
 8011e46:	462b      	mov	r3, r5
 8011e48:	4622      	mov	r2, r4
 8011e4a:	f7fc fd25 	bl	800e898 <_txe_queue_create>
 8011e4e:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 8011e50:	697b      	ldr	r3, [r7, #20]
}
 8011e52:	4618      	mov	r0, r3
 8011e54:	3718      	adds	r7, #24
 8011e56:	46bd      	mov	sp, r7
 8011e58:	bdb0      	pop	{r4, r5, r7, pc}
 8011e5a:	bf00      	nop
 8011e5c:	2000f670 	.word	0x2000f670
 8011e60:	2000f63c 	.word	0x2000f63c

08011e64 <_txm_module_manager_tx_queue_delete_dispatch>:
#ifndef TXM_QUEUE_DELETE_CALL_NOT_USED
/* UINT _txe_queue_delete(
    TX_QUEUE *queue_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_queue_delete_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8011e64:	b580      	push	{r7, lr}
 8011e66:	b084      	sub	sp, #16
 8011e68:	af00      	add	r7, sp, #0
 8011e6a:	6078      	str	r0, [r7, #4]
 8011e6c:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8011e6e:	687b      	ldr	r3, [r7, #4]
 8011e70:	68db      	ldr	r3, [r3, #12]
 8011e72:	f003 0302 	and.w	r3, r3, #2
 8011e76:	2b00      	cmp	r3, #0
 8011e78:	d01e      	beq.n	8011eb8 <_txm_module_manager_tx_queue_delete_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_QUEUE)))
 8011e7a:	2244      	movs	r2, #68	; 0x44
 8011e7c:	6839      	ldr	r1, [r7, #0]
 8011e7e:	6878      	ldr	r0, [r7, #4]
 8011e80:	f002 ffe2 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011e84:	4603      	mov	r3, r0
 8011e86:	2b00      	cmp	r3, #0
 8011e88:	d111      	bne.n	8011eae <_txm_module_manager_tx_queue_delete_dispatch+0x4a>
 8011e8a:	683b      	ldr	r3, [r7, #0]
 8011e8c:	f113 0f45 	cmn.w	r3, #69	; 0x45
 8011e90:	d812      	bhi.n	8011eb8 <_txm_module_manager_tx_queue_delete_dispatch+0x54>
 8011e92:	687b      	ldr	r3, [r7, #4]
 8011e94:	699b      	ldr	r3, [r3, #24]
 8011e96:	461a      	mov	r2, r3
 8011e98:	683b      	ldr	r3, [r7, #0]
 8011e9a:	4293      	cmp	r3, r2
 8011e9c:	d30c      	bcc.n	8011eb8 <_txm_module_manager_tx_queue_delete_dispatch+0x54>
 8011e9e:	683b      	ldr	r3, [r7, #0]
 8011ea0:	f103 0244 	add.w	r2, r3, #68	; 0x44
 8011ea4:	687b      	ldr	r3, [r7, #4]
 8011ea6:	69db      	ldr	r3, [r3, #28]
 8011ea8:	3301      	adds	r3, #1
 8011eaa:	429a      	cmp	r2, r3
 8011eac:	d804      	bhi.n	8011eb8 <_txm_module_manager_tx_queue_delete_dispatch+0x54>
 8011eae:	683b      	ldr	r3, [r7, #0]
 8011eb0:	2b00      	cmp	r3, #0
 8011eb2:	d001      	beq.n	8011eb8 <_txm_module_manager_tx_queue_delete_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 8011eb4:	23f4      	movs	r3, #244	; 0xf4
 8011eb6:	e00d      	b.n	8011ed4 <_txm_module_manager_tx_queue_delete_dispatch+0x70>
    }

    return_value = (ALIGN_TYPE) _txe_queue_delete(
 8011eb8:	683b      	ldr	r3, [r7, #0]
 8011eba:	4618      	mov	r0, r3
 8011ebc:	f7fc fd9c 	bl	800e9f8 <_txe_queue_delete>
 8011ec0:	60f8      	str	r0, [r7, #12]
        (TX_QUEUE *) param_0
    );

    /* Deallocate object memory.  */
    if (return_value == TX_SUCCESS)
 8011ec2:	68fb      	ldr	r3, [r7, #12]
 8011ec4:	2b00      	cmp	r3, #0
 8011ec6:	d104      	bne.n	8011ed2 <_txm_module_manager_tx_queue_delete_dispatch+0x6e>
    {
        return_value = _txm_module_manager_object_deallocate((VOID *) param_0);
 8011ec8:	683b      	ldr	r3, [r7, #0]
 8011eca:	4618      	mov	r0, r3
 8011ecc:	f003 f872 	bl	8014fb4 <_txm_module_manager_object_deallocate>
 8011ed0:	60f8      	str	r0, [r7, #12]
    }
    return(return_value);
 8011ed2:	68fb      	ldr	r3, [r7, #12]
}
 8011ed4:	4618      	mov	r0, r3
 8011ed6:	3710      	adds	r7, #16
 8011ed8:	46bd      	mov	sp, r7
 8011eda:	bd80      	pop	{r7, pc}

08011edc <_txm_module_manager_tx_queue_flush_dispatch>:
#ifndef TXM_QUEUE_FLUSH_CALL_NOT_USED
/* UINT _txe_queue_flush(
    TX_QUEUE *queue_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_queue_flush_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8011edc:	b580      	push	{r7, lr}
 8011ede:	b084      	sub	sp, #16
 8011ee0:	af00      	add	r7, sp, #0
 8011ee2:	6078      	str	r0, [r7, #4]
 8011ee4:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8011ee6:	687b      	ldr	r3, [r7, #4]
 8011ee8:	68db      	ldr	r3, [r3, #12]
 8011eea:	f003 0302 	and.w	r3, r3, #2
 8011eee:	2b00      	cmp	r3, #0
 8011ef0:	d01e      	beq.n	8011f30 <_txm_module_manager_tx_queue_flush_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_QUEUE)))
 8011ef2:	2244      	movs	r2, #68	; 0x44
 8011ef4:	6839      	ldr	r1, [r7, #0]
 8011ef6:	6878      	ldr	r0, [r7, #4]
 8011ef8:	f002 ffa6 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011efc:	4603      	mov	r3, r0
 8011efe:	2b00      	cmp	r3, #0
 8011f00:	d111      	bne.n	8011f26 <_txm_module_manager_tx_queue_flush_dispatch+0x4a>
 8011f02:	683b      	ldr	r3, [r7, #0]
 8011f04:	f113 0f45 	cmn.w	r3, #69	; 0x45
 8011f08:	d812      	bhi.n	8011f30 <_txm_module_manager_tx_queue_flush_dispatch+0x54>
 8011f0a:	687b      	ldr	r3, [r7, #4]
 8011f0c:	699b      	ldr	r3, [r3, #24]
 8011f0e:	461a      	mov	r2, r3
 8011f10:	683b      	ldr	r3, [r7, #0]
 8011f12:	4293      	cmp	r3, r2
 8011f14:	d30c      	bcc.n	8011f30 <_txm_module_manager_tx_queue_flush_dispatch+0x54>
 8011f16:	683b      	ldr	r3, [r7, #0]
 8011f18:	f103 0244 	add.w	r2, r3, #68	; 0x44
 8011f1c:	687b      	ldr	r3, [r7, #4]
 8011f1e:	69db      	ldr	r3, [r3, #28]
 8011f20:	3301      	adds	r3, #1
 8011f22:	429a      	cmp	r2, r3
 8011f24:	d804      	bhi.n	8011f30 <_txm_module_manager_tx_queue_flush_dispatch+0x54>
 8011f26:	683b      	ldr	r3, [r7, #0]
 8011f28:	2b00      	cmp	r3, #0
 8011f2a:	d001      	beq.n	8011f30 <_txm_module_manager_tx_queue_flush_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 8011f2c:	23f4      	movs	r3, #244	; 0xf4
 8011f2e:	e005      	b.n	8011f3c <_txm_module_manager_tx_queue_flush_dispatch+0x60>
    }

    return_value = (ALIGN_TYPE) _txe_queue_flush(
 8011f30:	683b      	ldr	r3, [r7, #0]
 8011f32:	4618      	mov	r0, r3
 8011f34:	f7fc fd9e 	bl	800ea74 <_txe_queue_flush>
 8011f38:	60f8      	str	r0, [r7, #12]
        (TX_QUEUE *) param_0
    );
    return(return_value);
 8011f3a:	68fb      	ldr	r3, [r7, #12]
}
 8011f3c:	4618      	mov	r0, r3
 8011f3e:	3710      	adds	r7, #16
 8011f40:	46bd      	mov	sp, r7
 8011f42:	bd80      	pop	{r7, pc}

08011f44 <_txm_module_manager_tx_queue_front_send_dispatch>:
    TX_QUEUE *queue_ptr, -> param_0
    VOID *source_ptr, -> param_1
    ULONG wait_option -> param_2
   ); */
static ALIGN_TYPE _txm_module_manager_tx_queue_front_send_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE param_2)
{
 8011f44:	b580      	push	{r7, lr}
 8011f46:	b086      	sub	sp, #24
 8011f48:	af00      	add	r7, sp, #0
 8011f4a:	60f8      	str	r0, [r7, #12]
 8011f4c:	60b9      	str	r1, [r7, #8]
 8011f4e:	607a      	str	r2, [r7, #4]
 8011f50:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;
TX_QUEUE *queue_ptr;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8011f52:	68fb      	ldr	r3, [r7, #12]
 8011f54:	68db      	ldr	r3, [r3, #12]
 8011f56:	f003 0302 	and.w	r3, r3, #2
 8011f5a:	2b00      	cmp	r3, #0
 8011f5c:	d045      	beq.n	8011fea <_txm_module_manager_tx_queue_front_send_dispatch+0xa6>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_QUEUE)))
 8011f5e:	2244      	movs	r2, #68	; 0x44
 8011f60:	68b9      	ldr	r1, [r7, #8]
 8011f62:	68f8      	ldr	r0, [r7, #12]
 8011f64:	f002 ff70 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011f68:	4603      	mov	r3, r0
 8011f6a:	2b00      	cmp	r3, #0
 8011f6c:	d111      	bne.n	8011f92 <_txm_module_manager_tx_queue_front_send_dispatch+0x4e>
 8011f6e:	68bb      	ldr	r3, [r7, #8]
 8011f70:	f113 0f45 	cmn.w	r3, #69	; 0x45
 8011f74:	d812      	bhi.n	8011f9c <_txm_module_manager_tx_queue_front_send_dispatch+0x58>
 8011f76:	68fb      	ldr	r3, [r7, #12]
 8011f78:	699b      	ldr	r3, [r3, #24]
 8011f7a:	461a      	mov	r2, r3
 8011f7c:	68bb      	ldr	r3, [r7, #8]
 8011f7e:	4293      	cmp	r3, r2
 8011f80:	d30c      	bcc.n	8011f9c <_txm_module_manager_tx_queue_front_send_dispatch+0x58>
 8011f82:	68bb      	ldr	r3, [r7, #8]
 8011f84:	f103 0244 	add.w	r2, r3, #68	; 0x44
 8011f88:	68fb      	ldr	r3, [r7, #12]
 8011f8a:	69db      	ldr	r3, [r3, #28]
 8011f8c:	3301      	adds	r3, #1
 8011f8e:	429a      	cmp	r2, r3
 8011f90:	d804      	bhi.n	8011f9c <_txm_module_manager_tx_queue_front_send_dispatch+0x58>
 8011f92:	68bb      	ldr	r3, [r7, #8]
 8011f94:	2b00      	cmp	r3, #0
 8011f96:	d001      	beq.n	8011f9c <_txm_module_manager_tx_queue_front_send_dispatch+0x58>
            return(TXM_MODULE_INVALID_MEMORY);
 8011f98:	23f4      	movs	r3, #244	; 0xf4
 8011f9a:	e02e      	b.n	8011ffa <_txm_module_manager_tx_queue_front_send_dispatch+0xb6>

        /* We need to get the size of the message from the queue.  */
        queue_ptr =  (TX_QUEUE *) param_0;
 8011f9c:	68bb      	ldr	r3, [r7, #8]
 8011f9e:	617b      	str	r3, [r7, #20]
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_READ(module_instance, param_1, queue_ptr -> tx_queue_message_size))
 8011fa0:	697b      	ldr	r3, [r7, #20]
 8011fa2:	689b      	ldr	r3, [r3, #8]
 8011fa4:	461a      	mov	r2, r3
 8011fa6:	6879      	ldr	r1, [r7, #4]
 8011fa8:	68f8      	ldr	r0, [r7, #12]
 8011faa:	f002 ff4d 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8011fae:	4603      	mov	r3, r0
 8011fb0:	2b00      	cmp	r3, #0
 8011fb2:	d11a      	bne.n	8011fea <_txm_module_manager_tx_queue_front_send_dispatch+0xa6>
 8011fb4:	697b      	ldr	r3, [r7, #20]
 8011fb6:	689a      	ldr	r2, [r3, #8]
 8011fb8:	687b      	ldr	r3, [r7, #4]
 8011fba:	4413      	add	r3, r2
 8011fbc:	687a      	ldr	r2, [r7, #4]
 8011fbe:	429a      	cmp	r2, r3
 8011fc0:	d20e      	bcs.n	8011fe0 <_txm_module_manager_tx_queue_front_send_dispatch+0x9c>
 8011fc2:	68fb      	ldr	r3, [r7, #12]
 8011fc4:	699b      	ldr	r3, [r3, #24]
 8011fc6:	461a      	mov	r2, r3
 8011fc8:	687b      	ldr	r3, [r7, #4]
 8011fca:	4293      	cmp	r3, r2
 8011fcc:	d308      	bcc.n	8011fe0 <_txm_module_manager_tx_queue_front_send_dispatch+0x9c>
 8011fce:	697b      	ldr	r3, [r7, #20]
 8011fd0:	689a      	ldr	r2, [r3, #8]
 8011fd2:	687b      	ldr	r3, [r7, #4]
 8011fd4:	441a      	add	r2, r3
 8011fd6:	68fb      	ldr	r3, [r7, #12]
 8011fd8:	69db      	ldr	r3, [r3, #28]
 8011fda:	3301      	adds	r3, #1
 8011fdc:	429a      	cmp	r2, r3
 8011fde:	d904      	bls.n	8011fea <_txm_module_manager_tx_queue_front_send_dispatch+0xa6>
 8011fe0:	687b      	ldr	r3, [r7, #4]
 8011fe2:	2b00      	cmp	r3, #0
 8011fe4:	d001      	beq.n	8011fea <_txm_module_manager_tx_queue_front_send_dispatch+0xa6>
            return(TXM_MODULE_INVALID_MEMORY);
 8011fe6:	23f4      	movs	r3, #244	; 0xf4
 8011fe8:	e007      	b.n	8011ffa <_txm_module_manager_tx_queue_front_send_dispatch+0xb6>
    }

    return_value = (ALIGN_TYPE) _txe_queue_front_send(
 8011fea:	68bb      	ldr	r3, [r7, #8]
 8011fec:	6879      	ldr	r1, [r7, #4]
 8011fee:	683a      	ldr	r2, [r7, #0]
 8011ff0:	4618      	mov	r0, r3
 8011ff2:	f7fc fd5d 	bl	800eab0 <_txe_queue_front_send>
 8011ff6:	6138      	str	r0, [r7, #16]
        (TX_QUEUE *) param_0,
        (VOID *) param_1,
        (ULONG) param_2
    );
    return(return_value);
 8011ff8:	693b      	ldr	r3, [r7, #16]
}
 8011ffa:	4618      	mov	r0, r3
 8011ffc:	3718      	adds	r7, #24
 8011ffe:	46bd      	mov	sp, r7
 8012000:	bd80      	pop	{r7, pc}

08012002 <_txm_module_manager_tx_queue_info_get_dispatch>:
    TX_THREAD **first_suspended, -> extra_parameters[2]
    ULONG *suspended_count, -> extra_parameters[3]
    TX_QUEUE **next_queue -> extra_parameters[4]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_queue_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8012002:	b5f0      	push	{r4, r5, r6, r7, lr}
 8012004:	b08b      	sub	sp, #44	; 0x2c
 8012006:	af04      	add	r7, sp, #16
 8012008:	60f8      	str	r0, [r7, #12]
 801200a:	60b9      	str	r1, [r7, #8]
 801200c:	607a      	str	r2, [r7, #4]
 801200e:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8012010:	68fb      	ldr	r3, [r7, #12]
 8012012:	68db      	ldr	r3, [r3, #12]
 8012014:	f003 0302 	and.w	r3, r3, #2
 8012018:	2b00      	cmp	r3, #0
 801201a:	f000 808f 	beq.w	801213c <_txm_module_manager_tx_queue_info_get_dispatch+0x13a>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_QUEUE)))
 801201e:	2244      	movs	r2, #68	; 0x44
 8012020:	68b9      	ldr	r1, [r7, #8]
 8012022:	68f8      	ldr	r0, [r7, #12]
 8012024:	f002 ff10 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012028:	4603      	mov	r3, r0
 801202a:	2b00      	cmp	r3, #0
 801202c:	d111      	bne.n	8012052 <_txm_module_manager_tx_queue_info_get_dispatch+0x50>
 801202e:	68bb      	ldr	r3, [r7, #8]
 8012030:	f113 0f45 	cmn.w	r3, #69	; 0x45
 8012034:	d812      	bhi.n	801205c <_txm_module_manager_tx_queue_info_get_dispatch+0x5a>
 8012036:	68fb      	ldr	r3, [r7, #12]
 8012038:	699b      	ldr	r3, [r3, #24]
 801203a:	461a      	mov	r2, r3
 801203c:	68bb      	ldr	r3, [r7, #8]
 801203e:	4293      	cmp	r3, r2
 8012040:	d30c      	bcc.n	801205c <_txm_module_manager_tx_queue_info_get_dispatch+0x5a>
 8012042:	68bb      	ldr	r3, [r7, #8]
 8012044:	f103 0244 	add.w	r2, r3, #68	; 0x44
 8012048:	68fb      	ldr	r3, [r7, #12]
 801204a:	69db      	ldr	r3, [r3, #28]
 801204c:	3301      	adds	r3, #1
 801204e:	429a      	cmp	r2, r3
 8012050:	d804      	bhi.n	801205c <_txm_module_manager_tx_queue_info_get_dispatch+0x5a>
 8012052:	68bb      	ldr	r3, [r7, #8]
 8012054:	2b00      	cmp	r3, #0
 8012056:	d001      	beq.n	801205c <_txm_module_manager_tx_queue_info_get_dispatch+0x5a>
            return(TXM_MODULE_INVALID_MEMORY);
 8012058:	23f4      	movs	r3, #244	; 0xf4
 801205a:	e08c      	b.n	8012176 <_txm_module_manager_tx_queue_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(CHAR *)))
 801205c:	2204      	movs	r2, #4
 801205e:	6879      	ldr	r1, [r7, #4]
 8012060:	68f8      	ldr	r0, [r7, #12]
 8012062:	f002 fef1 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012066:	4603      	mov	r3, r0
 8012068:	2b00      	cmp	r3, #0
 801206a:	d104      	bne.n	8012076 <_txm_module_manager_tx_queue_info_get_dispatch+0x74>
 801206c:	687b      	ldr	r3, [r7, #4]
 801206e:	2b00      	cmp	r3, #0
 8012070:	d001      	beq.n	8012076 <_txm_module_manager_tx_queue_info_get_dispatch+0x74>
            return(TXM_MODULE_INVALID_MEMORY);
 8012072:	23f4      	movs	r3, #244	; 0xf4
 8012074:	e07f      	b.n	8012176 <_txm_module_manager_tx_queue_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[5])))
 8012076:	683b      	ldr	r3, [r7, #0]
 8012078:	2214      	movs	r2, #20
 801207a:	4619      	mov	r1, r3
 801207c:	68f8      	ldr	r0, [r7, #12]
 801207e:	f002 fee3 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012082:	4603      	mov	r3, r0
 8012084:	2b00      	cmp	r3, #0
 8012086:	d101      	bne.n	801208c <_txm_module_manager_tx_queue_info_get_dispatch+0x8a>
            return(TXM_MODULE_INVALID_MEMORY);
 8012088:	23f4      	movs	r3, #244	; 0xf4
 801208a:	e074      	b.n	8012176 <_txm_module_manager_tx_queue_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 801208c:	683b      	ldr	r3, [r7, #0]
 801208e:	681b      	ldr	r3, [r3, #0]
 8012090:	2204      	movs	r2, #4
 8012092:	4619      	mov	r1, r3
 8012094:	68f8      	ldr	r0, [r7, #12]
 8012096:	f002 fed7 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801209a:	4603      	mov	r3, r0
 801209c:	2b00      	cmp	r3, #0
 801209e:	d105      	bne.n	80120ac <_txm_module_manager_tx_queue_info_get_dispatch+0xaa>
 80120a0:	683b      	ldr	r3, [r7, #0]
 80120a2:	681b      	ldr	r3, [r3, #0]
 80120a4:	2b00      	cmp	r3, #0
 80120a6:	d001      	beq.n	80120ac <_txm_module_manager_tx_queue_info_get_dispatch+0xaa>
            return(TXM_MODULE_INVALID_MEMORY);
 80120a8:	23f4      	movs	r3, #244	; 0xf4
 80120aa:	e064      	b.n	8012176 <_txm_module_manager_tx_queue_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 80120ac:	683b      	ldr	r3, [r7, #0]
 80120ae:	3304      	adds	r3, #4
 80120b0:	681b      	ldr	r3, [r3, #0]
 80120b2:	2204      	movs	r2, #4
 80120b4:	4619      	mov	r1, r3
 80120b6:	68f8      	ldr	r0, [r7, #12]
 80120b8:	f002 fec6 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80120bc:	4603      	mov	r3, r0
 80120be:	2b00      	cmp	r3, #0
 80120c0:	d106      	bne.n	80120d0 <_txm_module_manager_tx_queue_info_get_dispatch+0xce>
 80120c2:	683b      	ldr	r3, [r7, #0]
 80120c4:	3304      	adds	r3, #4
 80120c6:	681b      	ldr	r3, [r3, #0]
 80120c8:	2b00      	cmp	r3, #0
 80120ca:	d001      	beq.n	80120d0 <_txm_module_manager_tx_queue_info_get_dispatch+0xce>
            return(TXM_MODULE_INVALID_MEMORY);
 80120cc:	23f4      	movs	r3, #244	; 0xf4
 80120ce:	e052      	b.n	8012176 <_txm_module_manager_tx_queue_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(TX_THREAD *)))
 80120d0:	683b      	ldr	r3, [r7, #0]
 80120d2:	3308      	adds	r3, #8
 80120d4:	681b      	ldr	r3, [r3, #0]
 80120d6:	2204      	movs	r2, #4
 80120d8:	4619      	mov	r1, r3
 80120da:	68f8      	ldr	r0, [r7, #12]
 80120dc:	f002 feb4 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80120e0:	4603      	mov	r3, r0
 80120e2:	2b00      	cmp	r3, #0
 80120e4:	d106      	bne.n	80120f4 <_txm_module_manager_tx_queue_info_get_dispatch+0xf2>
 80120e6:	683b      	ldr	r3, [r7, #0]
 80120e8:	3308      	adds	r3, #8
 80120ea:	681b      	ldr	r3, [r3, #0]
 80120ec:	2b00      	cmp	r3, #0
 80120ee:	d001      	beq.n	80120f4 <_txm_module_manager_tx_queue_info_get_dispatch+0xf2>
            return(TXM_MODULE_INVALID_MEMORY);
 80120f0:	23f4      	movs	r3, #244	; 0xf4
 80120f2:	e040      	b.n	8012176 <_txm_module_manager_tx_queue_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[3], sizeof(ULONG)))
 80120f4:	683b      	ldr	r3, [r7, #0]
 80120f6:	330c      	adds	r3, #12
 80120f8:	681b      	ldr	r3, [r3, #0]
 80120fa:	2204      	movs	r2, #4
 80120fc:	4619      	mov	r1, r3
 80120fe:	68f8      	ldr	r0, [r7, #12]
 8012100:	f002 fea2 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012104:	4603      	mov	r3, r0
 8012106:	2b00      	cmp	r3, #0
 8012108:	d106      	bne.n	8012118 <_txm_module_manager_tx_queue_info_get_dispatch+0x116>
 801210a:	683b      	ldr	r3, [r7, #0]
 801210c:	330c      	adds	r3, #12
 801210e:	681b      	ldr	r3, [r3, #0]
 8012110:	2b00      	cmp	r3, #0
 8012112:	d001      	beq.n	8012118 <_txm_module_manager_tx_queue_info_get_dispatch+0x116>
            return(TXM_MODULE_INVALID_MEMORY);
 8012114:	23f4      	movs	r3, #244	; 0xf4
 8012116:	e02e      	b.n	8012176 <_txm_module_manager_tx_queue_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[4], sizeof(TX_QUEUE *)))
 8012118:	683b      	ldr	r3, [r7, #0]
 801211a:	3310      	adds	r3, #16
 801211c:	681b      	ldr	r3, [r3, #0]
 801211e:	2204      	movs	r2, #4
 8012120:	4619      	mov	r1, r3
 8012122:	68f8      	ldr	r0, [r7, #12]
 8012124:	f002 fe90 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012128:	4603      	mov	r3, r0
 801212a:	2b00      	cmp	r3, #0
 801212c:	d106      	bne.n	801213c <_txm_module_manager_tx_queue_info_get_dispatch+0x13a>
 801212e:	683b      	ldr	r3, [r7, #0]
 8012130:	3310      	adds	r3, #16
 8012132:	681b      	ldr	r3, [r3, #0]
 8012134:	2b00      	cmp	r3, #0
 8012136:	d001      	beq.n	801213c <_txm_module_manager_tx_queue_info_get_dispatch+0x13a>
            return(TXM_MODULE_INVALID_MEMORY);
 8012138:	23f4      	movs	r3, #244	; 0xf4
 801213a:	e01c      	b.n	8012176 <_txm_module_manager_tx_queue_info_get_dispatch+0x174>
    }

    return_value = (ALIGN_TYPE) _txe_queue_info_get(
 801213c:	68b8      	ldr	r0, [r7, #8]
 801213e:	6879      	ldr	r1, [r7, #4]
        (TX_QUEUE *) param_0,
        (CHAR **) param_1,
        (ULONG *) extra_parameters[0],
 8012140:	683b      	ldr	r3, [r7, #0]
 8012142:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_queue_info_get(
 8012144:	461d      	mov	r5, r3
        (ULONG *) extra_parameters[1],
 8012146:	683b      	ldr	r3, [r7, #0]
 8012148:	3304      	adds	r3, #4
 801214a:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_queue_info_get(
 801214c:	461e      	mov	r6, r3
        (TX_THREAD **) extra_parameters[2],
 801214e:	683b      	ldr	r3, [r7, #0]
 8012150:	3308      	adds	r3, #8
 8012152:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_queue_info_get(
 8012154:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[3],
 8012156:	683b      	ldr	r3, [r7, #0]
 8012158:	330c      	adds	r3, #12
 801215a:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_queue_info_get(
 801215c:	461c      	mov	r4, r3
        (TX_QUEUE **) extra_parameters[4]
 801215e:	683b      	ldr	r3, [r7, #0]
 8012160:	3310      	adds	r3, #16
 8012162:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_queue_info_get(
 8012164:	9302      	str	r3, [sp, #8]
 8012166:	9401      	str	r4, [sp, #4]
 8012168:	9200      	str	r2, [sp, #0]
 801216a:	4633      	mov	r3, r6
 801216c:	462a      	mov	r2, r5
 801216e:	f7fc fce9 	bl	800eb44 <_txe_queue_info_get>
 8012172:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 8012174:	697b      	ldr	r3, [r7, #20]
}
 8012176:	4618      	mov	r0, r3
 8012178:	371c      	adds	r7, #28
 801217a:	46bd      	mov	sp, r7
 801217c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801217e <_txm_module_manager_tx_queue_performance_info_get_dispatch>:
    ULONG *full_suspensions, -> extra_parameters[2]
    ULONG *full_errors, -> extra_parameters[3]
    ULONG *timeouts -> extra_parameters[4]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_queue_performance_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 801217e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8012180:	b08b      	sub	sp, #44	; 0x2c
 8012182:	af04      	add	r7, sp, #16
 8012184:	60f8      	str	r0, [r7, #12]
 8012186:	60b9      	str	r1, [r7, #8]
 8012188:	607a      	str	r2, [r7, #4]
 801218a:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 801218c:	68fb      	ldr	r3, [r7, #12]
 801218e:	68db      	ldr	r3, [r3, #12]
 8012190:	f003 0302 	and.w	r3, r3, #2
 8012194:	2b00      	cmp	r3, #0
 8012196:	f000 808f 	beq.w	80122b8 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x13a>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_QUEUE)))
 801219a:	2244      	movs	r2, #68	; 0x44
 801219c:	68b9      	ldr	r1, [r7, #8]
 801219e:	68f8      	ldr	r0, [r7, #12]
 80121a0:	f002 fe52 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80121a4:	4603      	mov	r3, r0
 80121a6:	2b00      	cmp	r3, #0
 80121a8:	d111      	bne.n	80121ce <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x50>
 80121aa:	68bb      	ldr	r3, [r7, #8]
 80121ac:	f113 0f45 	cmn.w	r3, #69	; 0x45
 80121b0:	d812      	bhi.n	80121d8 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x5a>
 80121b2:	68fb      	ldr	r3, [r7, #12]
 80121b4:	699b      	ldr	r3, [r3, #24]
 80121b6:	461a      	mov	r2, r3
 80121b8:	68bb      	ldr	r3, [r7, #8]
 80121ba:	4293      	cmp	r3, r2
 80121bc:	d30c      	bcc.n	80121d8 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x5a>
 80121be:	68bb      	ldr	r3, [r7, #8]
 80121c0:	f103 0244 	add.w	r2, r3, #68	; 0x44
 80121c4:	68fb      	ldr	r3, [r7, #12]
 80121c6:	69db      	ldr	r3, [r3, #28]
 80121c8:	3301      	adds	r3, #1
 80121ca:	429a      	cmp	r2, r3
 80121cc:	d804      	bhi.n	80121d8 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x5a>
 80121ce:	68bb      	ldr	r3, [r7, #8]
 80121d0:	2b00      	cmp	r3, #0
 80121d2:	d001      	beq.n	80121d8 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x5a>
            return(TXM_MODULE_INVALID_MEMORY);
 80121d4:	23f4      	movs	r3, #244	; 0xf4
 80121d6:	e08c      	b.n	80122f2 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(ULONG)))
 80121d8:	2204      	movs	r2, #4
 80121da:	6879      	ldr	r1, [r7, #4]
 80121dc:	68f8      	ldr	r0, [r7, #12]
 80121de:	f002 fe33 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80121e2:	4603      	mov	r3, r0
 80121e4:	2b00      	cmp	r3, #0
 80121e6:	d104      	bne.n	80121f2 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x74>
 80121e8:	687b      	ldr	r3, [r7, #4]
 80121ea:	2b00      	cmp	r3, #0
 80121ec:	d001      	beq.n	80121f2 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x74>
            return(TXM_MODULE_INVALID_MEMORY);
 80121ee:	23f4      	movs	r3, #244	; 0xf4
 80121f0:	e07f      	b.n	80122f2 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[5])))
 80121f2:	683b      	ldr	r3, [r7, #0]
 80121f4:	2214      	movs	r2, #20
 80121f6:	4619      	mov	r1, r3
 80121f8:	68f8      	ldr	r0, [r7, #12]
 80121fa:	f002 fe25 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80121fe:	4603      	mov	r3, r0
 8012200:	2b00      	cmp	r3, #0
 8012202:	d101      	bne.n	8012208 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x8a>
            return(TXM_MODULE_INVALID_MEMORY);
 8012204:	23f4      	movs	r3, #244	; 0xf4
 8012206:	e074      	b.n	80122f2 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 8012208:	683b      	ldr	r3, [r7, #0]
 801220a:	681b      	ldr	r3, [r3, #0]
 801220c:	2204      	movs	r2, #4
 801220e:	4619      	mov	r1, r3
 8012210:	68f8      	ldr	r0, [r7, #12]
 8012212:	f002 fe19 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012216:	4603      	mov	r3, r0
 8012218:	2b00      	cmp	r3, #0
 801221a:	d105      	bne.n	8012228 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0xaa>
 801221c:	683b      	ldr	r3, [r7, #0]
 801221e:	681b      	ldr	r3, [r3, #0]
 8012220:	2b00      	cmp	r3, #0
 8012222:	d001      	beq.n	8012228 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0xaa>
            return(TXM_MODULE_INVALID_MEMORY);
 8012224:	23f4      	movs	r3, #244	; 0xf4
 8012226:	e064      	b.n	80122f2 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 8012228:	683b      	ldr	r3, [r7, #0]
 801222a:	3304      	adds	r3, #4
 801222c:	681b      	ldr	r3, [r3, #0]
 801222e:	2204      	movs	r2, #4
 8012230:	4619      	mov	r1, r3
 8012232:	68f8      	ldr	r0, [r7, #12]
 8012234:	f002 fe08 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012238:	4603      	mov	r3, r0
 801223a:	2b00      	cmp	r3, #0
 801223c:	d106      	bne.n	801224c <_txm_module_manager_tx_queue_performance_info_get_dispatch+0xce>
 801223e:	683b      	ldr	r3, [r7, #0]
 8012240:	3304      	adds	r3, #4
 8012242:	681b      	ldr	r3, [r3, #0]
 8012244:	2b00      	cmp	r3, #0
 8012246:	d001      	beq.n	801224c <_txm_module_manager_tx_queue_performance_info_get_dispatch+0xce>
            return(TXM_MODULE_INVALID_MEMORY);
 8012248:	23f4      	movs	r3, #244	; 0xf4
 801224a:	e052      	b.n	80122f2 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(ULONG)))
 801224c:	683b      	ldr	r3, [r7, #0]
 801224e:	3308      	adds	r3, #8
 8012250:	681b      	ldr	r3, [r3, #0]
 8012252:	2204      	movs	r2, #4
 8012254:	4619      	mov	r1, r3
 8012256:	68f8      	ldr	r0, [r7, #12]
 8012258:	f002 fdf6 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801225c:	4603      	mov	r3, r0
 801225e:	2b00      	cmp	r3, #0
 8012260:	d106      	bne.n	8012270 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0xf2>
 8012262:	683b      	ldr	r3, [r7, #0]
 8012264:	3308      	adds	r3, #8
 8012266:	681b      	ldr	r3, [r3, #0]
 8012268:	2b00      	cmp	r3, #0
 801226a:	d001      	beq.n	8012270 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0xf2>
            return(TXM_MODULE_INVALID_MEMORY);
 801226c:	23f4      	movs	r3, #244	; 0xf4
 801226e:	e040      	b.n	80122f2 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[3], sizeof(ULONG)))
 8012270:	683b      	ldr	r3, [r7, #0]
 8012272:	330c      	adds	r3, #12
 8012274:	681b      	ldr	r3, [r3, #0]
 8012276:	2204      	movs	r2, #4
 8012278:	4619      	mov	r1, r3
 801227a:	68f8      	ldr	r0, [r7, #12]
 801227c:	f002 fde4 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012280:	4603      	mov	r3, r0
 8012282:	2b00      	cmp	r3, #0
 8012284:	d106      	bne.n	8012294 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x116>
 8012286:	683b      	ldr	r3, [r7, #0]
 8012288:	330c      	adds	r3, #12
 801228a:	681b      	ldr	r3, [r3, #0]
 801228c:	2b00      	cmp	r3, #0
 801228e:	d001      	beq.n	8012294 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x116>
            return(TXM_MODULE_INVALID_MEMORY);
 8012290:	23f4      	movs	r3, #244	; 0xf4
 8012292:	e02e      	b.n	80122f2 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x174>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[4], sizeof(ULONG)))
 8012294:	683b      	ldr	r3, [r7, #0]
 8012296:	3310      	adds	r3, #16
 8012298:	681b      	ldr	r3, [r3, #0]
 801229a:	2204      	movs	r2, #4
 801229c:	4619      	mov	r1, r3
 801229e:	68f8      	ldr	r0, [r7, #12]
 80122a0:	f002 fdd2 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80122a4:	4603      	mov	r3, r0
 80122a6:	2b00      	cmp	r3, #0
 80122a8:	d106      	bne.n	80122b8 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x13a>
 80122aa:	683b      	ldr	r3, [r7, #0]
 80122ac:	3310      	adds	r3, #16
 80122ae:	681b      	ldr	r3, [r3, #0]
 80122b0:	2b00      	cmp	r3, #0
 80122b2:	d001      	beq.n	80122b8 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x13a>
            return(TXM_MODULE_INVALID_MEMORY);
 80122b4:	23f4      	movs	r3, #244	; 0xf4
 80122b6:	e01c      	b.n	80122f2 <_txm_module_manager_tx_queue_performance_info_get_dispatch+0x174>
    }

    return_value = (ALIGN_TYPE) _tx_queue_performance_info_get(
 80122b8:	68b8      	ldr	r0, [r7, #8]
 80122ba:	6879      	ldr	r1, [r7, #4]
        (TX_QUEUE *) param_0,
        (ULONG *) param_1,
        (ULONG *) extra_parameters[0],
 80122bc:	683b      	ldr	r3, [r7, #0]
 80122be:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_queue_performance_info_get(
 80122c0:	461d      	mov	r5, r3
        (ULONG *) extra_parameters[1],
 80122c2:	683b      	ldr	r3, [r7, #0]
 80122c4:	3304      	adds	r3, #4
 80122c6:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_queue_performance_info_get(
 80122c8:	461e      	mov	r6, r3
        (ULONG *) extra_parameters[2],
 80122ca:	683b      	ldr	r3, [r7, #0]
 80122cc:	3308      	adds	r3, #8
 80122ce:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_queue_performance_info_get(
 80122d0:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[3],
 80122d2:	683b      	ldr	r3, [r7, #0]
 80122d4:	330c      	adds	r3, #12
 80122d6:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_queue_performance_info_get(
 80122d8:	461c      	mov	r4, r3
        (ULONG *) extra_parameters[4]
 80122da:	683b      	ldr	r3, [r7, #0]
 80122dc:	3310      	adds	r3, #16
 80122de:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_queue_performance_info_get(
 80122e0:	9302      	str	r3, [sp, #8]
 80122e2:	9401      	str	r4, [sp, #4]
 80122e4:	9200      	str	r2, [sp, #0]
 80122e6:	4633      	mov	r3, r6
 80122e8:	462a      	mov	r2, r5
 80122ea:	f7f8 f999 	bl	800a620 <_tx_queue_performance_info_get>
 80122ee:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 80122f0:	697b      	ldr	r3, [r7, #20]
}
 80122f2:	4618      	mov	r0, r3
 80122f4:	371c      	adds	r7, #28
 80122f6:	46bd      	mov	sp, r7
 80122f8:	bdf0      	pop	{r4, r5, r6, r7, pc}

080122fa <_txm_module_manager_tx_queue_performance_system_info_get_dispatch>:
    ULONG *full_suspensions, -> extra_parameters[1]
    ULONG *full_errors, -> extra_parameters[2]
    ULONG *timeouts -> extra_parameters[3]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_queue_performance_system_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 80122fa:	b5b0      	push	{r4, r5, r7, lr}
 80122fc:	b088      	sub	sp, #32
 80122fe:	af02      	add	r7, sp, #8
 8012300:	60f8      	str	r0, [r7, #12]
 8012302:	60b9      	str	r1, [r7, #8]
 8012304:	607a      	str	r2, [r7, #4]
 8012306:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8012308:	68fb      	ldr	r3, [r7, #12]
 801230a:	68db      	ldr	r3, [r3, #12]
 801230c:	f003 0302 	and.w	r3, r3, #2
 8012310:	2b00      	cmp	r3, #0
 8012312:	d06a      	beq.n	80123ea <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0xf0>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_0, sizeof(ULONG)))
 8012314:	2204      	movs	r2, #4
 8012316:	68b9      	ldr	r1, [r7, #8]
 8012318:	68f8      	ldr	r0, [r7, #12]
 801231a:	f002 fd95 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801231e:	4603      	mov	r3, r0
 8012320:	2b00      	cmp	r3, #0
 8012322:	d104      	bne.n	801232e <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0x34>
 8012324:	68bb      	ldr	r3, [r7, #8]
 8012326:	2b00      	cmp	r3, #0
 8012328:	d001      	beq.n	801232e <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0x34>
            return(TXM_MODULE_INVALID_MEMORY);
 801232a:	23f4      	movs	r3, #244	; 0xf4
 801232c:	e075      	b.n	801241a <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0x120>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(ULONG)))
 801232e:	2204      	movs	r2, #4
 8012330:	6879      	ldr	r1, [r7, #4]
 8012332:	68f8      	ldr	r0, [r7, #12]
 8012334:	f002 fd88 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012338:	4603      	mov	r3, r0
 801233a:	2b00      	cmp	r3, #0
 801233c:	d104      	bne.n	8012348 <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0x4e>
 801233e:	687b      	ldr	r3, [r7, #4]
 8012340:	2b00      	cmp	r3, #0
 8012342:	d001      	beq.n	8012348 <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0x4e>
            return(TXM_MODULE_INVALID_MEMORY);
 8012344:	23f4      	movs	r3, #244	; 0xf4
 8012346:	e068      	b.n	801241a <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0x120>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[4])))
 8012348:	683b      	ldr	r3, [r7, #0]
 801234a:	2210      	movs	r2, #16
 801234c:	4619      	mov	r1, r3
 801234e:	68f8      	ldr	r0, [r7, #12]
 8012350:	f002 fd7a 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012354:	4603      	mov	r3, r0
 8012356:	2b00      	cmp	r3, #0
 8012358:	d101      	bne.n	801235e <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0x64>
            return(TXM_MODULE_INVALID_MEMORY);
 801235a:	23f4      	movs	r3, #244	; 0xf4
 801235c:	e05d      	b.n	801241a <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0x120>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 801235e:	683b      	ldr	r3, [r7, #0]
 8012360:	681b      	ldr	r3, [r3, #0]
 8012362:	2204      	movs	r2, #4
 8012364:	4619      	mov	r1, r3
 8012366:	68f8      	ldr	r0, [r7, #12]
 8012368:	f002 fd6e 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801236c:	4603      	mov	r3, r0
 801236e:	2b00      	cmp	r3, #0
 8012370:	d105      	bne.n	801237e <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0x84>
 8012372:	683b      	ldr	r3, [r7, #0]
 8012374:	681b      	ldr	r3, [r3, #0]
 8012376:	2b00      	cmp	r3, #0
 8012378:	d001      	beq.n	801237e <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0x84>
            return(TXM_MODULE_INVALID_MEMORY);
 801237a:	23f4      	movs	r3, #244	; 0xf4
 801237c:	e04d      	b.n	801241a <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0x120>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 801237e:	683b      	ldr	r3, [r7, #0]
 8012380:	3304      	adds	r3, #4
 8012382:	681b      	ldr	r3, [r3, #0]
 8012384:	2204      	movs	r2, #4
 8012386:	4619      	mov	r1, r3
 8012388:	68f8      	ldr	r0, [r7, #12]
 801238a:	f002 fd5d 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801238e:	4603      	mov	r3, r0
 8012390:	2b00      	cmp	r3, #0
 8012392:	d106      	bne.n	80123a2 <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0xa8>
 8012394:	683b      	ldr	r3, [r7, #0]
 8012396:	3304      	adds	r3, #4
 8012398:	681b      	ldr	r3, [r3, #0]
 801239a:	2b00      	cmp	r3, #0
 801239c:	d001      	beq.n	80123a2 <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0xa8>
            return(TXM_MODULE_INVALID_MEMORY);
 801239e:	23f4      	movs	r3, #244	; 0xf4
 80123a0:	e03b      	b.n	801241a <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0x120>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(ULONG)))
 80123a2:	683b      	ldr	r3, [r7, #0]
 80123a4:	3308      	adds	r3, #8
 80123a6:	681b      	ldr	r3, [r3, #0]
 80123a8:	2204      	movs	r2, #4
 80123aa:	4619      	mov	r1, r3
 80123ac:	68f8      	ldr	r0, [r7, #12]
 80123ae:	f002 fd4b 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80123b2:	4603      	mov	r3, r0
 80123b4:	2b00      	cmp	r3, #0
 80123b6:	d106      	bne.n	80123c6 <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0xcc>
 80123b8:	683b      	ldr	r3, [r7, #0]
 80123ba:	3308      	adds	r3, #8
 80123bc:	681b      	ldr	r3, [r3, #0]
 80123be:	2b00      	cmp	r3, #0
 80123c0:	d001      	beq.n	80123c6 <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0xcc>
            return(TXM_MODULE_INVALID_MEMORY);
 80123c2:	23f4      	movs	r3, #244	; 0xf4
 80123c4:	e029      	b.n	801241a <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0x120>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[3], sizeof(ULONG)))
 80123c6:	683b      	ldr	r3, [r7, #0]
 80123c8:	330c      	adds	r3, #12
 80123ca:	681b      	ldr	r3, [r3, #0]
 80123cc:	2204      	movs	r2, #4
 80123ce:	4619      	mov	r1, r3
 80123d0:	68f8      	ldr	r0, [r7, #12]
 80123d2:	f002 fd39 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80123d6:	4603      	mov	r3, r0
 80123d8:	2b00      	cmp	r3, #0
 80123da:	d106      	bne.n	80123ea <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0xf0>
 80123dc:	683b      	ldr	r3, [r7, #0]
 80123de:	330c      	adds	r3, #12
 80123e0:	681b      	ldr	r3, [r3, #0]
 80123e2:	2b00      	cmp	r3, #0
 80123e4:	d001      	beq.n	80123ea <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0xf0>
            return(TXM_MODULE_INVALID_MEMORY);
 80123e6:	23f4      	movs	r3, #244	; 0xf4
 80123e8:	e017      	b.n	801241a <_txm_module_manager_tx_queue_performance_system_info_get_dispatch+0x120>
    }

    return_value = (ALIGN_TYPE) _tx_queue_performance_system_info_get(
 80123ea:	68b8      	ldr	r0, [r7, #8]
 80123ec:	6879      	ldr	r1, [r7, #4]
        (ULONG *) param_0,
        (ULONG *) param_1,
        (ULONG *) extra_parameters[0],
 80123ee:	683b      	ldr	r3, [r7, #0]
 80123f0:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_queue_performance_system_info_get(
 80123f2:	461c      	mov	r4, r3
        (ULONG *) extra_parameters[1],
 80123f4:	683b      	ldr	r3, [r7, #0]
 80123f6:	3304      	adds	r3, #4
 80123f8:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_queue_performance_system_info_get(
 80123fa:	461d      	mov	r5, r3
        (ULONG *) extra_parameters[2],
 80123fc:	683b      	ldr	r3, [r7, #0]
 80123fe:	3308      	adds	r3, #8
 8012400:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_queue_performance_system_info_get(
 8012402:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[3]
 8012404:	683b      	ldr	r3, [r7, #0]
 8012406:	330c      	adds	r3, #12
 8012408:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_queue_performance_system_info_get(
 801240a:	9301      	str	r3, [sp, #4]
 801240c:	9200      	str	r2, [sp, #0]
 801240e:	462b      	mov	r3, r5
 8012410:	4622      	mov	r2, r4
 8012412:	f7f8 f93f 	bl	800a694 <_tx_queue_performance_system_info_get>
 8012416:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 8012418:	697b      	ldr	r3, [r7, #20]
}
 801241a:	4618      	mov	r0, r3
 801241c:	3718      	adds	r7, #24
 801241e:	46bd      	mov	sp, r7
 8012420:	bdb0      	pop	{r4, r5, r7, pc}

08012422 <_txm_module_manager_tx_queue_prioritize_dispatch>:
#ifndef TXM_QUEUE_PRIORITIZE_CALL_NOT_USED
/* UINT _txe_queue_prioritize(
    TX_QUEUE *queue_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_queue_prioritize_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8012422:	b580      	push	{r7, lr}
 8012424:	b084      	sub	sp, #16
 8012426:	af00      	add	r7, sp, #0
 8012428:	6078      	str	r0, [r7, #4]
 801242a:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 801242c:	687b      	ldr	r3, [r7, #4]
 801242e:	68db      	ldr	r3, [r3, #12]
 8012430:	f003 0302 	and.w	r3, r3, #2
 8012434:	2b00      	cmp	r3, #0
 8012436:	d01e      	beq.n	8012476 <_txm_module_manager_tx_queue_prioritize_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_QUEUE)))
 8012438:	2244      	movs	r2, #68	; 0x44
 801243a:	6839      	ldr	r1, [r7, #0]
 801243c:	6878      	ldr	r0, [r7, #4]
 801243e:	f002 fd03 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012442:	4603      	mov	r3, r0
 8012444:	2b00      	cmp	r3, #0
 8012446:	d111      	bne.n	801246c <_txm_module_manager_tx_queue_prioritize_dispatch+0x4a>
 8012448:	683b      	ldr	r3, [r7, #0]
 801244a:	f113 0f45 	cmn.w	r3, #69	; 0x45
 801244e:	d812      	bhi.n	8012476 <_txm_module_manager_tx_queue_prioritize_dispatch+0x54>
 8012450:	687b      	ldr	r3, [r7, #4]
 8012452:	699b      	ldr	r3, [r3, #24]
 8012454:	461a      	mov	r2, r3
 8012456:	683b      	ldr	r3, [r7, #0]
 8012458:	4293      	cmp	r3, r2
 801245a:	d30c      	bcc.n	8012476 <_txm_module_manager_tx_queue_prioritize_dispatch+0x54>
 801245c:	683b      	ldr	r3, [r7, #0]
 801245e:	f103 0244 	add.w	r2, r3, #68	; 0x44
 8012462:	687b      	ldr	r3, [r7, #4]
 8012464:	69db      	ldr	r3, [r3, #28]
 8012466:	3301      	adds	r3, #1
 8012468:	429a      	cmp	r2, r3
 801246a:	d804      	bhi.n	8012476 <_txm_module_manager_tx_queue_prioritize_dispatch+0x54>
 801246c:	683b      	ldr	r3, [r7, #0]
 801246e:	2b00      	cmp	r3, #0
 8012470:	d001      	beq.n	8012476 <_txm_module_manager_tx_queue_prioritize_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 8012472:	23f4      	movs	r3, #244	; 0xf4
 8012474:	e005      	b.n	8012482 <_txm_module_manager_tx_queue_prioritize_dispatch+0x60>
    }

    return_value = (ALIGN_TYPE) _txe_queue_prioritize(
 8012476:	683b      	ldr	r3, [r7, #0]
 8012478:	4618      	mov	r0, r3
 801247a:	f7fc fb8d 	bl	800eb98 <_txe_queue_prioritize>
 801247e:	60f8      	str	r0, [r7, #12]
        (TX_QUEUE *) param_0
    );
    return(return_value);
 8012480:	68fb      	ldr	r3, [r7, #12]
}
 8012482:	4618      	mov	r0, r3
 8012484:	3710      	adds	r7, #16
 8012486:	46bd      	mov	sp, r7
 8012488:	bd80      	pop	{r7, pc}

0801248a <_txm_module_manager_tx_queue_receive_dispatch>:
    TX_QUEUE *queue_ptr, -> param_0
    VOID *destination_ptr, -> param_1
    ULONG wait_option -> param_2
   ); */
static ALIGN_TYPE _txm_module_manager_tx_queue_receive_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE param_2)
{
 801248a:	b580      	push	{r7, lr}
 801248c:	b086      	sub	sp, #24
 801248e:	af00      	add	r7, sp, #0
 8012490:	60f8      	str	r0, [r7, #12]
 8012492:	60b9      	str	r1, [r7, #8]
 8012494:	607a      	str	r2, [r7, #4]
 8012496:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;
TX_QUEUE *queue_ptr;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8012498:	68fb      	ldr	r3, [r7, #12]
 801249a:	68db      	ldr	r3, [r3, #12]
 801249c:	f003 0302 	and.w	r3, r3, #2
 80124a0:	2b00      	cmp	r3, #0
 80124a2:	d030      	beq.n	8012506 <_txm_module_manager_tx_queue_receive_dispatch+0x7c>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_QUEUE)))
 80124a4:	2244      	movs	r2, #68	; 0x44
 80124a6:	68b9      	ldr	r1, [r7, #8]
 80124a8:	68f8      	ldr	r0, [r7, #12]
 80124aa:	f002 fccd 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80124ae:	4603      	mov	r3, r0
 80124b0:	2b00      	cmp	r3, #0
 80124b2:	d111      	bne.n	80124d8 <_txm_module_manager_tx_queue_receive_dispatch+0x4e>
 80124b4:	68bb      	ldr	r3, [r7, #8]
 80124b6:	f113 0f45 	cmn.w	r3, #69	; 0x45
 80124ba:	d812      	bhi.n	80124e2 <_txm_module_manager_tx_queue_receive_dispatch+0x58>
 80124bc:	68fb      	ldr	r3, [r7, #12]
 80124be:	699b      	ldr	r3, [r3, #24]
 80124c0:	461a      	mov	r2, r3
 80124c2:	68bb      	ldr	r3, [r7, #8]
 80124c4:	4293      	cmp	r3, r2
 80124c6:	d30c      	bcc.n	80124e2 <_txm_module_manager_tx_queue_receive_dispatch+0x58>
 80124c8:	68bb      	ldr	r3, [r7, #8]
 80124ca:	f103 0244 	add.w	r2, r3, #68	; 0x44
 80124ce:	68fb      	ldr	r3, [r7, #12]
 80124d0:	69db      	ldr	r3, [r3, #28]
 80124d2:	3301      	adds	r3, #1
 80124d4:	429a      	cmp	r2, r3
 80124d6:	d804      	bhi.n	80124e2 <_txm_module_manager_tx_queue_receive_dispatch+0x58>
 80124d8:	68bb      	ldr	r3, [r7, #8]
 80124da:	2b00      	cmp	r3, #0
 80124dc:	d001      	beq.n	80124e2 <_txm_module_manager_tx_queue_receive_dispatch+0x58>
            return(TXM_MODULE_INVALID_MEMORY);
 80124de:	23f4      	movs	r3, #244	; 0xf4
 80124e0:	e019      	b.n	8012516 <_txm_module_manager_tx_queue_receive_dispatch+0x8c>

        /* We need to get the max size of the buffer from the queue.  */
        queue_ptr =  (TX_QUEUE *) param_0;
 80124e2:	68bb      	ldr	r3, [r7, #8]
 80124e4:	617b      	str	r3, [r7, #20]
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(ULONG)*queue_ptr -> tx_queue_message_size))
 80124e6:	697b      	ldr	r3, [r7, #20]
 80124e8:	689b      	ldr	r3, [r3, #8]
 80124ea:	009b      	lsls	r3, r3, #2
 80124ec:	461a      	mov	r2, r3
 80124ee:	6879      	ldr	r1, [r7, #4]
 80124f0:	68f8      	ldr	r0, [r7, #12]
 80124f2:	f002 fca9 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80124f6:	4603      	mov	r3, r0
 80124f8:	2b00      	cmp	r3, #0
 80124fa:	d104      	bne.n	8012506 <_txm_module_manager_tx_queue_receive_dispatch+0x7c>
 80124fc:	687b      	ldr	r3, [r7, #4]
 80124fe:	2b00      	cmp	r3, #0
 8012500:	d001      	beq.n	8012506 <_txm_module_manager_tx_queue_receive_dispatch+0x7c>
            return(TXM_MODULE_INVALID_MEMORY);
 8012502:	23f4      	movs	r3, #244	; 0xf4
 8012504:	e007      	b.n	8012516 <_txm_module_manager_tx_queue_receive_dispatch+0x8c>
    }

    return_value = (ALIGN_TYPE) _txe_queue_receive(
 8012506:	68bb      	ldr	r3, [r7, #8]
 8012508:	6879      	ldr	r1, [r7, #4]
 801250a:	683a      	ldr	r2, [r7, #0]
 801250c:	4618      	mov	r0, r3
 801250e:	f7fc fb61 	bl	800ebd4 <_txe_queue_receive>
 8012512:	6138      	str	r0, [r7, #16]
        (TX_QUEUE *) param_0,
        (VOID *) param_1,
        (ULONG) param_2
    );
    return(return_value);
 8012514:	693b      	ldr	r3, [r7, #16]
}
 8012516:	4618      	mov	r0, r3
 8012518:	3718      	adds	r7, #24
 801251a:	46bd      	mov	sp, r7
 801251c:	bd80      	pop	{r7, pc}

0801251e <_txm_module_manager_tx_queue_send_dispatch>:
    TX_QUEUE *queue_ptr, -> param_0
    VOID *source_ptr, -> param_1
    ULONG wait_option -> param_2
   ); */
static ALIGN_TYPE _txm_module_manager_tx_queue_send_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE param_2)
{
 801251e:	b580      	push	{r7, lr}
 8012520:	b086      	sub	sp, #24
 8012522:	af00      	add	r7, sp, #0
 8012524:	60f8      	str	r0, [r7, #12]
 8012526:	60b9      	str	r1, [r7, #8]
 8012528:	607a      	str	r2, [r7, #4]
 801252a:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;
TX_QUEUE *queue_ptr;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 801252c:	68fb      	ldr	r3, [r7, #12]
 801252e:	68db      	ldr	r3, [r3, #12]
 8012530:	f003 0302 	and.w	r3, r3, #2
 8012534:	2b00      	cmp	r3, #0
 8012536:	d048      	beq.n	80125ca <_txm_module_manager_tx_queue_send_dispatch+0xac>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_QUEUE)))
 8012538:	2244      	movs	r2, #68	; 0x44
 801253a:	68b9      	ldr	r1, [r7, #8]
 801253c:	68f8      	ldr	r0, [r7, #12]
 801253e:	f002 fc83 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012542:	4603      	mov	r3, r0
 8012544:	2b00      	cmp	r3, #0
 8012546:	d111      	bne.n	801256c <_txm_module_manager_tx_queue_send_dispatch+0x4e>
 8012548:	68bb      	ldr	r3, [r7, #8]
 801254a:	f113 0f45 	cmn.w	r3, #69	; 0x45
 801254e:	d812      	bhi.n	8012576 <_txm_module_manager_tx_queue_send_dispatch+0x58>
 8012550:	68fb      	ldr	r3, [r7, #12]
 8012552:	699b      	ldr	r3, [r3, #24]
 8012554:	461a      	mov	r2, r3
 8012556:	68bb      	ldr	r3, [r7, #8]
 8012558:	4293      	cmp	r3, r2
 801255a:	d30c      	bcc.n	8012576 <_txm_module_manager_tx_queue_send_dispatch+0x58>
 801255c:	68bb      	ldr	r3, [r7, #8]
 801255e:	f103 0244 	add.w	r2, r3, #68	; 0x44
 8012562:	68fb      	ldr	r3, [r7, #12]
 8012564:	69db      	ldr	r3, [r3, #28]
 8012566:	3301      	adds	r3, #1
 8012568:	429a      	cmp	r2, r3
 801256a:	d804      	bhi.n	8012576 <_txm_module_manager_tx_queue_send_dispatch+0x58>
 801256c:	68bb      	ldr	r3, [r7, #8]
 801256e:	2b00      	cmp	r3, #0
 8012570:	d001      	beq.n	8012576 <_txm_module_manager_tx_queue_send_dispatch+0x58>
            return(TXM_MODULE_INVALID_MEMORY);
 8012572:	23f4      	movs	r3, #244	; 0xf4
 8012574:	e031      	b.n	80125da <_txm_module_manager_tx_queue_send_dispatch+0xbc>

        /* We need to get the size of the message from the queue.  */
        queue_ptr =  (TX_QUEUE *) param_0;
 8012576:	68bb      	ldr	r3, [r7, #8]
 8012578:	617b      	str	r3, [r7, #20]
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_READ(module_instance, param_1, sizeof(ULONG)*queue_ptr -> tx_queue_message_size))
 801257a:	697b      	ldr	r3, [r7, #20]
 801257c:	689b      	ldr	r3, [r3, #8]
 801257e:	009b      	lsls	r3, r3, #2
 8012580:	461a      	mov	r2, r3
 8012582:	6879      	ldr	r1, [r7, #4]
 8012584:	68f8      	ldr	r0, [r7, #12]
 8012586:	f002 fc5f 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801258a:	4603      	mov	r3, r0
 801258c:	2b00      	cmp	r3, #0
 801258e:	d11c      	bne.n	80125ca <_txm_module_manager_tx_queue_send_dispatch+0xac>
 8012590:	697b      	ldr	r3, [r7, #20]
 8012592:	689b      	ldr	r3, [r3, #8]
 8012594:	009a      	lsls	r2, r3, #2
 8012596:	687b      	ldr	r3, [r7, #4]
 8012598:	4413      	add	r3, r2
 801259a:	687a      	ldr	r2, [r7, #4]
 801259c:	429a      	cmp	r2, r3
 801259e:	d20f      	bcs.n	80125c0 <_txm_module_manager_tx_queue_send_dispatch+0xa2>
 80125a0:	68fb      	ldr	r3, [r7, #12]
 80125a2:	699b      	ldr	r3, [r3, #24]
 80125a4:	461a      	mov	r2, r3
 80125a6:	687b      	ldr	r3, [r7, #4]
 80125a8:	4293      	cmp	r3, r2
 80125aa:	d309      	bcc.n	80125c0 <_txm_module_manager_tx_queue_send_dispatch+0xa2>
 80125ac:	697b      	ldr	r3, [r7, #20]
 80125ae:	689b      	ldr	r3, [r3, #8]
 80125b0:	009a      	lsls	r2, r3, #2
 80125b2:	687b      	ldr	r3, [r7, #4]
 80125b4:	441a      	add	r2, r3
 80125b6:	68fb      	ldr	r3, [r7, #12]
 80125b8:	69db      	ldr	r3, [r3, #28]
 80125ba:	3301      	adds	r3, #1
 80125bc:	429a      	cmp	r2, r3
 80125be:	d904      	bls.n	80125ca <_txm_module_manager_tx_queue_send_dispatch+0xac>
 80125c0:	687b      	ldr	r3, [r7, #4]
 80125c2:	2b00      	cmp	r3, #0
 80125c4:	d001      	beq.n	80125ca <_txm_module_manager_tx_queue_send_dispatch+0xac>
            return(TXM_MODULE_INVALID_MEMORY);
 80125c6:	23f4      	movs	r3, #244	; 0xf4
 80125c8:	e007      	b.n	80125da <_txm_module_manager_tx_queue_send_dispatch+0xbc>
    }

    return_value = (ALIGN_TYPE) _txe_queue_send(
 80125ca:	68bb      	ldr	r3, [r7, #8]
 80125cc:	6879      	ldr	r1, [r7, #4]
 80125ce:	683a      	ldr	r2, [r7, #0]
 80125d0:	4618      	mov	r0, r3
 80125d2:	f7fc fb49 	bl	800ec68 <_txe_queue_send>
 80125d6:	6138      	str	r0, [r7, #16]
        (TX_QUEUE *) param_0,
        (VOID *) param_1,
        (ULONG) param_2
    );
    return(return_value);
 80125d8:	693b      	ldr	r3, [r7, #16]
}
 80125da:	4618      	mov	r0, r3
 80125dc:	3718      	adds	r7, #24
 80125de:	46bd      	mov	sp, r7
 80125e0:	bd80      	pop	{r7, pc}
	...

080125e4 <_txm_module_manager_tx_queue_send_notify_dispatch>:
/* UINT _txe_queue_send_notify(
    TX_QUEUE *queue_ptr, -> param_0
    VOID (*queue_send_notify)(TX_QUEUE *notify_queue_ptr) -> param_1
   ); */
static ALIGN_TYPE _txm_module_manager_tx_queue_send_notify_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1)
{
 80125e4:	b580      	push	{r7, lr}
 80125e6:	b088      	sub	sp, #32
 80125e8:	af00      	add	r7, sp, #0
 80125ea:	60f8      	str	r0, [r7, #12]
 80125ec:	60b9      	str	r1, [r7, #8]
 80125ee:	607a      	str	r2, [r7, #4]

ALIGN_TYPE return_value;
TX_QUEUE *queue_ptr = (TX_QUEUE *) param_0;
 80125f0:	68bb      	ldr	r3, [r7, #8]
 80125f2:	61bb      	str	r3, [r7, #24]
VOID (*queue_send_notify)(TX_QUEUE *);

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 80125f4:	68fb      	ldr	r3, [r7, #12]
 80125f6:	68db      	ldr	r3, [r3, #12]
 80125f8:	f003 0302 	and.w	r3, r3, #2
 80125fc:	2b00      	cmp	r3, #0
 80125fe:	d028      	beq.n	8012652 <_txm_module_manager_tx_queue_send_notify_dispatch+0x6e>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_QUEUE)))
 8012600:	2244      	movs	r2, #68	; 0x44
 8012602:	68b9      	ldr	r1, [r7, #8]
 8012604:	68f8      	ldr	r0, [r7, #12]
 8012606:	f002 fc1f 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801260a:	4603      	mov	r3, r0
 801260c:	2b00      	cmp	r3, #0
 801260e:	d111      	bne.n	8012634 <_txm_module_manager_tx_queue_send_notify_dispatch+0x50>
 8012610:	68bb      	ldr	r3, [r7, #8]
 8012612:	f113 0f45 	cmn.w	r3, #69	; 0x45
 8012616:	d812      	bhi.n	801263e <_txm_module_manager_tx_queue_send_notify_dispatch+0x5a>
 8012618:	68fb      	ldr	r3, [r7, #12]
 801261a:	699b      	ldr	r3, [r3, #24]
 801261c:	461a      	mov	r2, r3
 801261e:	68bb      	ldr	r3, [r7, #8]
 8012620:	4293      	cmp	r3, r2
 8012622:	d30c      	bcc.n	801263e <_txm_module_manager_tx_queue_send_notify_dispatch+0x5a>
 8012624:	68bb      	ldr	r3, [r7, #8]
 8012626:	f103 0244 	add.w	r2, r3, #68	; 0x44
 801262a:	68fb      	ldr	r3, [r7, #12]
 801262c:	69db      	ldr	r3, [r3, #28]
 801262e:	3301      	adds	r3, #1
 8012630:	429a      	cmp	r2, r3
 8012632:	d804      	bhi.n	801263e <_txm_module_manager_tx_queue_send_notify_dispatch+0x5a>
 8012634:	68bb      	ldr	r3, [r7, #8]
 8012636:	2b00      	cmp	r3, #0
 8012638:	d001      	beq.n	801263e <_txm_module_manager_tx_queue_send_notify_dispatch+0x5a>
            return(TXM_MODULE_INVALID_MEMORY);
 801263a:	23f4      	movs	r3, #244	; 0xf4
 801263c:	e01e      	b.n	801267c <_txm_module_manager_tx_queue_send_notify_dispatch+0x98>

        /* Since we need to write to the object, ensure it's valid.  */
        if ((queue_ptr == TX_NULL) || (queue_ptr -> tx_queue_id != TX_QUEUE_ID))
 801263e:	69bb      	ldr	r3, [r7, #24]
 8012640:	2b00      	cmp	r3, #0
 8012642:	d004      	beq.n	801264e <_txm_module_manager_tx_queue_send_notify_dispatch+0x6a>
 8012644:	69bb      	ldr	r3, [r7, #24]
 8012646:	681b      	ldr	r3, [r3, #0]
 8012648:	4a0e      	ldr	r2, [pc, #56]	; (8012684 <_txm_module_manager_tx_queue_send_notify_dispatch+0xa0>)
 801264a:	4293      	cmp	r3, r2
 801264c:	d001      	beq.n	8012652 <_txm_module_manager_tx_queue_send_notify_dispatch+0x6e>
            return(TX_QUEUE_ERROR);
 801264e:	2309      	movs	r3, #9
 8012650:	e014      	b.n	801267c <_txm_module_manager_tx_queue_send_notify_dispatch+0x98>
    }

    /* Is it a disable request?  */
    if ((void *) param_1 == TX_NULL)
 8012652:	687b      	ldr	r3, [r7, #4]
 8012654:	2b00      	cmp	r3, #0
 8012656:	d102      	bne.n	801265e <_txm_module_manager_tx_queue_send_notify_dispatch+0x7a>
    {

        /* Clear the callback.  */
        queue_send_notify = (VOID (*)(TX_QUEUE *)) TX_NULL;
 8012658:	2300      	movs	r3, #0
 801265a:	61fb      	str	r3, [r7, #28]
 801265c:	e007      	b.n	801266e <_txm_module_manager_tx_queue_send_notify_dispatch+0x8a>
    }
    else
    {

        /* Setup trampoline values.  */
        queue_ptr -> tx_queue_module_instance = (VOID *) module_instance;
 801265e:	69bb      	ldr	r3, [r7, #24]
 8012660:	68fa      	ldr	r2, [r7, #12]
 8012662:	63da      	str	r2, [r3, #60]	; 0x3c
        queue_ptr -> tx_queue_send_module_notify = (VOID (*)(TX_QUEUE *)) param_1;
 8012664:	687a      	ldr	r2, [r7, #4]
 8012666:	69bb      	ldr	r3, [r7, #24]
 8012668:	641a      	str	r2, [r3, #64]	; 0x40
        queue_send_notify = _txm_module_manager_queue_notify_trampoline;
 801266a:	4b07      	ldr	r3, [pc, #28]	; (8012688 <_txm_module_manager_tx_queue_send_notify_dispatch+0xa4>)
 801266c:	61fb      	str	r3, [r7, #28]
    }

    return_value = (ALIGN_TYPE) _txe_queue_send_notify(
 801266e:	68bb      	ldr	r3, [r7, #8]
 8012670:	69f9      	ldr	r1, [r7, #28]
 8012672:	4618      	mov	r0, r3
 8012674:	f7fc fb42 	bl	800ecfc <_txe_queue_send_notify>
 8012678:	6178      	str	r0, [r7, #20]
        (TX_QUEUE *) param_0,
        (VOID (*)(TX_QUEUE *notify_queue_ptr)) queue_send_notify
    );
    return(return_value);
 801267a:	697b      	ldr	r3, [r7, #20]
}
 801267c:	4618      	mov	r0, r3
 801267e:	3720      	adds	r7, #32
 8012680:	46bd      	mov	sp, r7
 8012682:	bd80      	pop	{r7, pc}
 8012684:	51554555 	.word	0x51554555
 8012688:	08015599 	.word	0x08015599

0801268c <_txm_module_manager_tx_semaphore_ceiling_put_dispatch>:
/* UINT _txe_semaphore_ceiling_put(
    TX_SEMAPHORE *semaphore_ptr, -> param_0
    ULONG ceiling -> param_1
   ); */
static ALIGN_TYPE _txm_module_manager_tx_semaphore_ceiling_put_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1)
{
 801268c:	b580      	push	{r7, lr}
 801268e:	b086      	sub	sp, #24
 8012690:	af00      	add	r7, sp, #0
 8012692:	60f8      	str	r0, [r7, #12]
 8012694:	60b9      	str	r1, [r7, #8]
 8012696:	607a      	str	r2, [r7, #4]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8012698:	68fb      	ldr	r3, [r7, #12]
 801269a:	68db      	ldr	r3, [r3, #12]
 801269c:	f003 0302 	and.w	r3, r3, #2
 80126a0:	2b00      	cmp	r3, #0
 80126a2:	d01e      	beq.n	80126e2 <_txm_module_manager_tx_semaphore_ceiling_put_dispatch+0x56>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_SEMAPHORE)))
 80126a4:	2228      	movs	r2, #40	; 0x28
 80126a6:	68b9      	ldr	r1, [r7, #8]
 80126a8:	68f8      	ldr	r0, [r7, #12]
 80126aa:	f002 fbcd 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80126ae:	4603      	mov	r3, r0
 80126b0:	2b00      	cmp	r3, #0
 80126b2:	d111      	bne.n	80126d8 <_txm_module_manager_tx_semaphore_ceiling_put_dispatch+0x4c>
 80126b4:	68bb      	ldr	r3, [r7, #8]
 80126b6:	f113 0f29 	cmn.w	r3, #41	; 0x29
 80126ba:	d812      	bhi.n	80126e2 <_txm_module_manager_tx_semaphore_ceiling_put_dispatch+0x56>
 80126bc:	68fb      	ldr	r3, [r7, #12]
 80126be:	699b      	ldr	r3, [r3, #24]
 80126c0:	461a      	mov	r2, r3
 80126c2:	68bb      	ldr	r3, [r7, #8]
 80126c4:	4293      	cmp	r3, r2
 80126c6:	d30c      	bcc.n	80126e2 <_txm_module_manager_tx_semaphore_ceiling_put_dispatch+0x56>
 80126c8:	68bb      	ldr	r3, [r7, #8]
 80126ca:	f103 0228 	add.w	r2, r3, #40	; 0x28
 80126ce:	68fb      	ldr	r3, [r7, #12]
 80126d0:	69db      	ldr	r3, [r3, #28]
 80126d2:	3301      	adds	r3, #1
 80126d4:	429a      	cmp	r2, r3
 80126d6:	d804      	bhi.n	80126e2 <_txm_module_manager_tx_semaphore_ceiling_put_dispatch+0x56>
 80126d8:	68bb      	ldr	r3, [r7, #8]
 80126da:	2b00      	cmp	r3, #0
 80126dc:	d001      	beq.n	80126e2 <_txm_module_manager_tx_semaphore_ceiling_put_dispatch+0x56>
            return(TXM_MODULE_INVALID_MEMORY);
 80126de:	23f4      	movs	r3, #244	; 0xf4
 80126e0:	e006      	b.n	80126f0 <_txm_module_manager_tx_semaphore_ceiling_put_dispatch+0x64>
    }

    return_value = (ALIGN_TYPE) _txe_semaphore_ceiling_put(
 80126e2:	68bb      	ldr	r3, [r7, #8]
 80126e4:	6879      	ldr	r1, [r7, #4]
 80126e6:	4618      	mov	r0, r3
 80126e8:	f7fc fb28 	bl	800ed3c <_txe_semaphore_ceiling_put>
 80126ec:	6178      	str	r0, [r7, #20]
        (TX_SEMAPHORE *) param_0,
        (ULONG) param_1
    );
    return(return_value);
 80126ee:	697b      	ldr	r3, [r7, #20]
}
 80126f0:	4618      	mov	r0, r3
 80126f2:	3718      	adds	r7, #24
 80126f4:	46bd      	mov	sp, r7
 80126f6:	bd80      	pop	{r7, pc}

080126f8 <_txm_module_manager_tx_semaphore_create_dispatch>:
    CHAR *name_ptr, -> param_1
    ULONG initial_count, -> extra_parameters[0]
    UINT semaphore_control_block_size -> extra_parameters[1]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_semaphore_create_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 80126f8:	b580      	push	{r7, lr}
 80126fa:	b086      	sub	sp, #24
 80126fc:	af00      	add	r7, sp, #0
 80126fe:	60f8      	str	r0, [r7, #12]
 8012700:	60b9      	str	r1, [r7, #8]
 8012702:	607a      	str	r2, [r7, #4]
 8012704:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8012706:	68fb      	ldr	r3, [r7, #12]
 8012708:	68db      	ldr	r3, [r3, #12]
 801270a:	f003 0302 	and.w	r3, r3, #2
 801270e:	2b00      	cmp	r3, #0
 8012710:	d04b      	beq.n	80127aa <_txm_module_manager_tx_semaphore_create_dispatch+0xb2>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_CREATION(module_instance, param_0, sizeof(TX_SEMAPHORE)))
 8012712:	4b2d      	ldr	r3, [pc, #180]	; (80127c8 <_txm_module_manager_tx_semaphore_create_dispatch+0xd0>)
 8012714:	681b      	ldr	r3, [r3, #0]
 8012716:	2b01      	cmp	r3, #1
 8012718:	d119      	bne.n	801274e <_txm_module_manager_tx_semaphore_create_dispatch+0x56>
 801271a:	68bb      	ldr	r3, [r7, #8]
 801271c:	f113 0f29 	cmn.w	r3, #41	; 0x29
 8012720:	d815      	bhi.n	801274e <_txm_module_manager_tx_semaphore_create_dispatch+0x56>
 8012722:	4b2a      	ldr	r3, [pc, #168]	; (80127cc <_txm_module_manager_tx_semaphore_create_dispatch+0xd4>)
 8012724:	699b      	ldr	r3, [r3, #24]
 8012726:	3310      	adds	r3, #16
 8012728:	68ba      	ldr	r2, [r7, #8]
 801272a:	429a      	cmp	r2, r3
 801272c:	d30f      	bcc.n	801274e <_txm_module_manager_tx_semaphore_create_dispatch+0x56>
 801272e:	68bb      	ldr	r3, [r7, #8]
 8012730:	3328      	adds	r3, #40	; 0x28
 8012732:	4a26      	ldr	r2, [pc, #152]	; (80127cc <_txm_module_manager_tx_semaphore_create_dispatch+0xd4>)
 8012734:	6991      	ldr	r1, [r2, #24]
 8012736:	4a25      	ldr	r2, [pc, #148]	; (80127cc <_txm_module_manager_tx_semaphore_create_dispatch+0xd4>)
 8012738:	69d2      	ldr	r2, [r2, #28]
 801273a:	440a      	add	r2, r1
 801273c:	4293      	cmp	r3, r2
 801273e:	d806      	bhi.n	801274e <_txm_module_manager_tx_semaphore_create_dispatch+0x56>
 8012740:	2128      	movs	r1, #40	; 0x28
 8012742:	68b8      	ldr	r0, [r7, #8]
 8012744:	f003 ffa8 	bl	8016698 <_txm_module_manager_object_size_check>
 8012748:	4603      	mov	r3, r0
 801274a:	2b00      	cmp	r3, #0
 801274c:	d004      	beq.n	8012758 <_txm_module_manager_tx_semaphore_create_dispatch+0x60>
 801274e:	68bb      	ldr	r3, [r7, #8]
 8012750:	2b00      	cmp	r3, #0
 8012752:	d001      	beq.n	8012758 <_txm_module_manager_tx_semaphore_create_dispatch+0x60>
            return(TXM_MODULE_INVALID_MEMORY);
 8012754:	23f4      	movs	r3, #244	; 0xf4
 8012756:	e033      	b.n	80127c0 <_txm_module_manager_tx_semaphore_create_dispatch+0xc8>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_DEREFERENCE_STRING(module_instance, param_1))
 8012758:	2201      	movs	r2, #1
 801275a:	6879      	ldr	r1, [r7, #4]
 801275c:	68f8      	ldr	r0, [r7, #12]
 801275e:	f002 fb73 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012762:	4603      	mov	r3, r0
 8012764:	2b00      	cmp	r3, #0
 8012766:	d115      	bne.n	8012794 <_txm_module_manager_tx_semaphore_create_dispatch+0x9c>
 8012768:	687b      	ldr	r3, [r7, #4]
 801276a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 801276e:	d00c      	beq.n	801278a <_txm_module_manager_tx_semaphore_create_dispatch+0x92>
 8012770:	68fb      	ldr	r3, [r7, #12]
 8012772:	699b      	ldr	r3, [r3, #24]
 8012774:	461a      	mov	r2, r3
 8012776:	687b      	ldr	r3, [r7, #4]
 8012778:	4293      	cmp	r3, r2
 801277a:	d306      	bcc.n	801278a <_txm_module_manager_tx_semaphore_create_dispatch+0x92>
 801277c:	687b      	ldr	r3, [r7, #4]
 801277e:	1c5a      	adds	r2, r3, #1
 8012780:	68fb      	ldr	r3, [r7, #12]
 8012782:	69db      	ldr	r3, [r3, #28]
 8012784:	3301      	adds	r3, #1
 8012786:	429a      	cmp	r2, r3
 8012788:	d904      	bls.n	8012794 <_txm_module_manager_tx_semaphore_create_dispatch+0x9c>
 801278a:	687b      	ldr	r3, [r7, #4]
 801278c:	2b00      	cmp	r3, #0
 801278e:	d001      	beq.n	8012794 <_txm_module_manager_tx_semaphore_create_dispatch+0x9c>
            return(TXM_MODULE_INVALID_MEMORY);
 8012790:	23f4      	movs	r3, #244	; 0xf4
 8012792:	e015      	b.n	80127c0 <_txm_module_manager_tx_semaphore_create_dispatch+0xc8>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[2])))
 8012794:	683b      	ldr	r3, [r7, #0]
 8012796:	2208      	movs	r2, #8
 8012798:	4619      	mov	r1, r3
 801279a:	68f8      	ldr	r0, [r7, #12]
 801279c:	f002 fb54 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80127a0:	4603      	mov	r3, r0
 80127a2:	2b00      	cmp	r3, #0
 80127a4:	d101      	bne.n	80127aa <_txm_module_manager_tx_semaphore_create_dispatch+0xb2>
            return(TXM_MODULE_INVALID_MEMORY);
 80127a6:	23f4      	movs	r3, #244	; 0xf4
 80127a8:	e00a      	b.n	80127c0 <_txm_module_manager_tx_semaphore_create_dispatch+0xc8>
    }

    return_value = (ALIGN_TYPE) _txe_semaphore_create(
 80127aa:	68b8      	ldr	r0, [r7, #8]
 80127ac:	6879      	ldr	r1, [r7, #4]
 80127ae:	683b      	ldr	r3, [r7, #0]
 80127b0:	681a      	ldr	r2, [r3, #0]
        (TX_SEMAPHORE *) param_0,
        (CHAR *) param_1,
        (ULONG) extra_parameters[0],
        (UINT) extra_parameters[1]
 80127b2:	683b      	ldr	r3, [r7, #0]
 80127b4:	3304      	adds	r3, #4
    return_value = (ALIGN_TYPE) _txe_semaphore_create(
 80127b6:	681b      	ldr	r3, [r3, #0]
 80127b8:	f7fc fae6 	bl	800ed88 <_txe_semaphore_create>
 80127bc:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 80127be:	697b      	ldr	r3, [r7, #20]
}
 80127c0:	4618      	mov	r0, r3
 80127c2:	3718      	adds	r7, #24
 80127c4:	46bd      	mov	sp, r7
 80127c6:	bd80      	pop	{r7, pc}
 80127c8:	2000f670 	.word	0x2000f670
 80127cc:	2000f63c 	.word	0x2000f63c

080127d0 <_txm_module_manager_tx_semaphore_delete_dispatch>:
#ifndef TXM_SEMAPHORE_DELETE_CALL_NOT_USED
/* UINT _txe_semaphore_delete(
    TX_SEMAPHORE *semaphore_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_semaphore_delete_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 80127d0:	b580      	push	{r7, lr}
 80127d2:	b084      	sub	sp, #16
 80127d4:	af00      	add	r7, sp, #0
 80127d6:	6078      	str	r0, [r7, #4]
 80127d8:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 80127da:	687b      	ldr	r3, [r7, #4]
 80127dc:	68db      	ldr	r3, [r3, #12]
 80127de:	f003 0302 	and.w	r3, r3, #2
 80127e2:	2b00      	cmp	r3, #0
 80127e4:	d01e      	beq.n	8012824 <_txm_module_manager_tx_semaphore_delete_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_SEMAPHORE)))
 80127e6:	2228      	movs	r2, #40	; 0x28
 80127e8:	6839      	ldr	r1, [r7, #0]
 80127ea:	6878      	ldr	r0, [r7, #4]
 80127ec:	f002 fb2c 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80127f0:	4603      	mov	r3, r0
 80127f2:	2b00      	cmp	r3, #0
 80127f4:	d111      	bne.n	801281a <_txm_module_manager_tx_semaphore_delete_dispatch+0x4a>
 80127f6:	683b      	ldr	r3, [r7, #0]
 80127f8:	f113 0f29 	cmn.w	r3, #41	; 0x29
 80127fc:	d812      	bhi.n	8012824 <_txm_module_manager_tx_semaphore_delete_dispatch+0x54>
 80127fe:	687b      	ldr	r3, [r7, #4]
 8012800:	699b      	ldr	r3, [r3, #24]
 8012802:	461a      	mov	r2, r3
 8012804:	683b      	ldr	r3, [r7, #0]
 8012806:	4293      	cmp	r3, r2
 8012808:	d30c      	bcc.n	8012824 <_txm_module_manager_tx_semaphore_delete_dispatch+0x54>
 801280a:	683b      	ldr	r3, [r7, #0]
 801280c:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8012810:	687b      	ldr	r3, [r7, #4]
 8012812:	69db      	ldr	r3, [r3, #28]
 8012814:	3301      	adds	r3, #1
 8012816:	429a      	cmp	r2, r3
 8012818:	d804      	bhi.n	8012824 <_txm_module_manager_tx_semaphore_delete_dispatch+0x54>
 801281a:	683b      	ldr	r3, [r7, #0]
 801281c:	2b00      	cmp	r3, #0
 801281e:	d001      	beq.n	8012824 <_txm_module_manager_tx_semaphore_delete_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 8012820:	23f4      	movs	r3, #244	; 0xf4
 8012822:	e00d      	b.n	8012840 <_txm_module_manager_tx_semaphore_delete_dispatch+0x70>
    }

    return_value = (ALIGN_TYPE) _txe_semaphore_delete(
 8012824:	683b      	ldr	r3, [r7, #0]
 8012826:	4618      	mov	r0, r3
 8012828:	f7fc fb44 	bl	800eeb4 <_txe_semaphore_delete>
 801282c:	60f8      	str	r0, [r7, #12]
        (TX_SEMAPHORE *) param_0
    );

    /* Deallocate object memory.  */
    if (return_value == TX_SUCCESS)
 801282e:	68fb      	ldr	r3, [r7, #12]
 8012830:	2b00      	cmp	r3, #0
 8012832:	d104      	bne.n	801283e <_txm_module_manager_tx_semaphore_delete_dispatch+0x6e>
    {
        return_value = _txm_module_manager_object_deallocate((VOID *) param_0);
 8012834:	683b      	ldr	r3, [r7, #0]
 8012836:	4618      	mov	r0, r3
 8012838:	f002 fbbc 	bl	8014fb4 <_txm_module_manager_object_deallocate>
 801283c:	60f8      	str	r0, [r7, #12]
    }
    return(return_value);
 801283e:	68fb      	ldr	r3, [r7, #12]
}
 8012840:	4618      	mov	r0, r3
 8012842:	3710      	adds	r7, #16
 8012844:	46bd      	mov	sp, r7
 8012846:	bd80      	pop	{r7, pc}

08012848 <_txm_module_manager_tx_semaphore_get_dispatch>:
/* UINT _txe_semaphore_get(
    TX_SEMAPHORE *semaphore_ptr, -> param_0
    ULONG wait_option -> param_1
   ); */
static ALIGN_TYPE _txm_module_manager_tx_semaphore_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1)
{
 8012848:	b580      	push	{r7, lr}
 801284a:	b086      	sub	sp, #24
 801284c:	af00      	add	r7, sp, #0
 801284e:	60f8      	str	r0, [r7, #12]
 8012850:	60b9      	str	r1, [r7, #8]
 8012852:	607a      	str	r2, [r7, #4]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8012854:	68fb      	ldr	r3, [r7, #12]
 8012856:	68db      	ldr	r3, [r3, #12]
 8012858:	f003 0302 	and.w	r3, r3, #2
 801285c:	2b00      	cmp	r3, #0
 801285e:	d01e      	beq.n	801289e <_txm_module_manager_tx_semaphore_get_dispatch+0x56>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_SEMAPHORE)))
 8012860:	2228      	movs	r2, #40	; 0x28
 8012862:	68b9      	ldr	r1, [r7, #8]
 8012864:	68f8      	ldr	r0, [r7, #12]
 8012866:	f002 faef 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801286a:	4603      	mov	r3, r0
 801286c:	2b00      	cmp	r3, #0
 801286e:	d111      	bne.n	8012894 <_txm_module_manager_tx_semaphore_get_dispatch+0x4c>
 8012870:	68bb      	ldr	r3, [r7, #8]
 8012872:	f113 0f29 	cmn.w	r3, #41	; 0x29
 8012876:	d812      	bhi.n	801289e <_txm_module_manager_tx_semaphore_get_dispatch+0x56>
 8012878:	68fb      	ldr	r3, [r7, #12]
 801287a:	699b      	ldr	r3, [r3, #24]
 801287c:	461a      	mov	r2, r3
 801287e:	68bb      	ldr	r3, [r7, #8]
 8012880:	4293      	cmp	r3, r2
 8012882:	d30c      	bcc.n	801289e <_txm_module_manager_tx_semaphore_get_dispatch+0x56>
 8012884:	68bb      	ldr	r3, [r7, #8]
 8012886:	f103 0228 	add.w	r2, r3, #40	; 0x28
 801288a:	68fb      	ldr	r3, [r7, #12]
 801288c:	69db      	ldr	r3, [r3, #28]
 801288e:	3301      	adds	r3, #1
 8012890:	429a      	cmp	r2, r3
 8012892:	d804      	bhi.n	801289e <_txm_module_manager_tx_semaphore_get_dispatch+0x56>
 8012894:	68bb      	ldr	r3, [r7, #8]
 8012896:	2b00      	cmp	r3, #0
 8012898:	d001      	beq.n	801289e <_txm_module_manager_tx_semaphore_get_dispatch+0x56>
            return(TXM_MODULE_INVALID_MEMORY);
 801289a:	23f4      	movs	r3, #244	; 0xf4
 801289c:	e006      	b.n	80128ac <_txm_module_manager_tx_semaphore_get_dispatch+0x64>
    }

    return_value = (ALIGN_TYPE) _txe_semaphore_get(
 801289e:	68bb      	ldr	r3, [r7, #8]
 80128a0:	6879      	ldr	r1, [r7, #4]
 80128a2:	4618      	mov	r0, r3
 80128a4:	f7fc fb44 	bl	800ef30 <_txe_semaphore_get>
 80128a8:	6178      	str	r0, [r7, #20]
        (TX_SEMAPHORE *) param_0,
        (ULONG) param_1
    );
    return(return_value);
 80128aa:	697b      	ldr	r3, [r7, #20]
}
 80128ac:	4618      	mov	r0, r3
 80128ae:	3718      	adds	r7, #24
 80128b0:	46bd      	mov	sp, r7
 80128b2:	bd80      	pop	{r7, pc}

080128b4 <_txm_module_manager_tx_semaphore_info_get_dispatch>:
    TX_THREAD **first_suspended, -> extra_parameters[1]
    ULONG *suspended_count, -> extra_parameters[2]
    TX_SEMAPHORE **next_semaphore -> extra_parameters[3]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_semaphore_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 80128b4:	b5b0      	push	{r4, r5, r7, lr}
 80128b6:	b088      	sub	sp, #32
 80128b8:	af02      	add	r7, sp, #8
 80128ba:	60f8      	str	r0, [r7, #12]
 80128bc:	60b9      	str	r1, [r7, #8]
 80128be:	607a      	str	r2, [r7, #4]
 80128c0:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 80128c2:	68fb      	ldr	r3, [r7, #12]
 80128c4:	68db      	ldr	r3, [r3, #12]
 80128c6:	f003 0302 	and.w	r3, r3, #2
 80128ca:	2b00      	cmp	r3, #0
 80128cc:	d07c      	beq.n	80129c8 <_txm_module_manager_tx_semaphore_info_get_dispatch+0x114>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_SEMAPHORE)))
 80128ce:	2228      	movs	r2, #40	; 0x28
 80128d0:	68b9      	ldr	r1, [r7, #8]
 80128d2:	68f8      	ldr	r0, [r7, #12]
 80128d4:	f002 fab8 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80128d8:	4603      	mov	r3, r0
 80128da:	2b00      	cmp	r3, #0
 80128dc:	d111      	bne.n	8012902 <_txm_module_manager_tx_semaphore_info_get_dispatch+0x4e>
 80128de:	68bb      	ldr	r3, [r7, #8]
 80128e0:	f113 0f29 	cmn.w	r3, #41	; 0x29
 80128e4:	d812      	bhi.n	801290c <_txm_module_manager_tx_semaphore_info_get_dispatch+0x58>
 80128e6:	68fb      	ldr	r3, [r7, #12]
 80128e8:	699b      	ldr	r3, [r3, #24]
 80128ea:	461a      	mov	r2, r3
 80128ec:	68bb      	ldr	r3, [r7, #8]
 80128ee:	4293      	cmp	r3, r2
 80128f0:	d30c      	bcc.n	801290c <_txm_module_manager_tx_semaphore_info_get_dispatch+0x58>
 80128f2:	68bb      	ldr	r3, [r7, #8]
 80128f4:	f103 0228 	add.w	r2, r3, #40	; 0x28
 80128f8:	68fb      	ldr	r3, [r7, #12]
 80128fa:	69db      	ldr	r3, [r3, #28]
 80128fc:	3301      	adds	r3, #1
 80128fe:	429a      	cmp	r2, r3
 8012900:	d804      	bhi.n	801290c <_txm_module_manager_tx_semaphore_info_get_dispatch+0x58>
 8012902:	68bb      	ldr	r3, [r7, #8]
 8012904:	2b00      	cmp	r3, #0
 8012906:	d001      	beq.n	801290c <_txm_module_manager_tx_semaphore_info_get_dispatch+0x58>
            return(TXM_MODULE_INVALID_MEMORY);
 8012908:	23f4      	movs	r3, #244	; 0xf4
 801290a:	e075      	b.n	80129f8 <_txm_module_manager_tx_semaphore_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(CHAR *)))
 801290c:	2204      	movs	r2, #4
 801290e:	6879      	ldr	r1, [r7, #4]
 8012910:	68f8      	ldr	r0, [r7, #12]
 8012912:	f002 fa99 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012916:	4603      	mov	r3, r0
 8012918:	2b00      	cmp	r3, #0
 801291a:	d104      	bne.n	8012926 <_txm_module_manager_tx_semaphore_info_get_dispatch+0x72>
 801291c:	687b      	ldr	r3, [r7, #4]
 801291e:	2b00      	cmp	r3, #0
 8012920:	d001      	beq.n	8012926 <_txm_module_manager_tx_semaphore_info_get_dispatch+0x72>
            return(TXM_MODULE_INVALID_MEMORY);
 8012922:	23f4      	movs	r3, #244	; 0xf4
 8012924:	e068      	b.n	80129f8 <_txm_module_manager_tx_semaphore_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[4])))
 8012926:	683b      	ldr	r3, [r7, #0]
 8012928:	2210      	movs	r2, #16
 801292a:	4619      	mov	r1, r3
 801292c:	68f8      	ldr	r0, [r7, #12]
 801292e:	f002 fa8b 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012932:	4603      	mov	r3, r0
 8012934:	2b00      	cmp	r3, #0
 8012936:	d101      	bne.n	801293c <_txm_module_manager_tx_semaphore_info_get_dispatch+0x88>
            return(TXM_MODULE_INVALID_MEMORY);
 8012938:	23f4      	movs	r3, #244	; 0xf4
 801293a:	e05d      	b.n	80129f8 <_txm_module_manager_tx_semaphore_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 801293c:	683b      	ldr	r3, [r7, #0]
 801293e:	681b      	ldr	r3, [r3, #0]
 8012940:	2204      	movs	r2, #4
 8012942:	4619      	mov	r1, r3
 8012944:	68f8      	ldr	r0, [r7, #12]
 8012946:	f002 fa7f 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801294a:	4603      	mov	r3, r0
 801294c:	2b00      	cmp	r3, #0
 801294e:	d105      	bne.n	801295c <_txm_module_manager_tx_semaphore_info_get_dispatch+0xa8>
 8012950:	683b      	ldr	r3, [r7, #0]
 8012952:	681b      	ldr	r3, [r3, #0]
 8012954:	2b00      	cmp	r3, #0
 8012956:	d001      	beq.n	801295c <_txm_module_manager_tx_semaphore_info_get_dispatch+0xa8>
            return(TXM_MODULE_INVALID_MEMORY);
 8012958:	23f4      	movs	r3, #244	; 0xf4
 801295a:	e04d      	b.n	80129f8 <_txm_module_manager_tx_semaphore_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(TX_THREAD *)))
 801295c:	683b      	ldr	r3, [r7, #0]
 801295e:	3304      	adds	r3, #4
 8012960:	681b      	ldr	r3, [r3, #0]
 8012962:	2204      	movs	r2, #4
 8012964:	4619      	mov	r1, r3
 8012966:	68f8      	ldr	r0, [r7, #12]
 8012968:	f002 fa6e 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801296c:	4603      	mov	r3, r0
 801296e:	2b00      	cmp	r3, #0
 8012970:	d106      	bne.n	8012980 <_txm_module_manager_tx_semaphore_info_get_dispatch+0xcc>
 8012972:	683b      	ldr	r3, [r7, #0]
 8012974:	3304      	adds	r3, #4
 8012976:	681b      	ldr	r3, [r3, #0]
 8012978:	2b00      	cmp	r3, #0
 801297a:	d001      	beq.n	8012980 <_txm_module_manager_tx_semaphore_info_get_dispatch+0xcc>
            return(TXM_MODULE_INVALID_MEMORY);
 801297c:	23f4      	movs	r3, #244	; 0xf4
 801297e:	e03b      	b.n	80129f8 <_txm_module_manager_tx_semaphore_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(ULONG)))
 8012980:	683b      	ldr	r3, [r7, #0]
 8012982:	3308      	adds	r3, #8
 8012984:	681b      	ldr	r3, [r3, #0]
 8012986:	2204      	movs	r2, #4
 8012988:	4619      	mov	r1, r3
 801298a:	68f8      	ldr	r0, [r7, #12]
 801298c:	f002 fa5c 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012990:	4603      	mov	r3, r0
 8012992:	2b00      	cmp	r3, #0
 8012994:	d106      	bne.n	80129a4 <_txm_module_manager_tx_semaphore_info_get_dispatch+0xf0>
 8012996:	683b      	ldr	r3, [r7, #0]
 8012998:	3308      	adds	r3, #8
 801299a:	681b      	ldr	r3, [r3, #0]
 801299c:	2b00      	cmp	r3, #0
 801299e:	d001      	beq.n	80129a4 <_txm_module_manager_tx_semaphore_info_get_dispatch+0xf0>
            return(TXM_MODULE_INVALID_MEMORY);
 80129a0:	23f4      	movs	r3, #244	; 0xf4
 80129a2:	e029      	b.n	80129f8 <_txm_module_manager_tx_semaphore_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[3], sizeof(TX_SEMAPHORE *)))
 80129a4:	683b      	ldr	r3, [r7, #0]
 80129a6:	330c      	adds	r3, #12
 80129a8:	681b      	ldr	r3, [r3, #0]
 80129aa:	2204      	movs	r2, #4
 80129ac:	4619      	mov	r1, r3
 80129ae:	68f8      	ldr	r0, [r7, #12]
 80129b0:	f002 fa4a 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80129b4:	4603      	mov	r3, r0
 80129b6:	2b00      	cmp	r3, #0
 80129b8:	d106      	bne.n	80129c8 <_txm_module_manager_tx_semaphore_info_get_dispatch+0x114>
 80129ba:	683b      	ldr	r3, [r7, #0]
 80129bc:	330c      	adds	r3, #12
 80129be:	681b      	ldr	r3, [r3, #0]
 80129c0:	2b00      	cmp	r3, #0
 80129c2:	d001      	beq.n	80129c8 <_txm_module_manager_tx_semaphore_info_get_dispatch+0x114>
            return(TXM_MODULE_INVALID_MEMORY);
 80129c4:	23f4      	movs	r3, #244	; 0xf4
 80129c6:	e017      	b.n	80129f8 <_txm_module_manager_tx_semaphore_info_get_dispatch+0x144>
    }

    return_value = (ALIGN_TYPE) _txe_semaphore_info_get(
 80129c8:	68b8      	ldr	r0, [r7, #8]
 80129ca:	6879      	ldr	r1, [r7, #4]
        (TX_SEMAPHORE *) param_0,
        (CHAR **) param_1,
        (ULONG *) extra_parameters[0],
 80129cc:	683b      	ldr	r3, [r7, #0]
 80129ce:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_semaphore_info_get(
 80129d0:	461c      	mov	r4, r3
        (TX_THREAD **) extra_parameters[1],
 80129d2:	683b      	ldr	r3, [r7, #0]
 80129d4:	3304      	adds	r3, #4
 80129d6:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_semaphore_info_get(
 80129d8:	461d      	mov	r5, r3
        (ULONG *) extra_parameters[2],
 80129da:	683b      	ldr	r3, [r7, #0]
 80129dc:	3308      	adds	r3, #8
 80129de:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_semaphore_info_get(
 80129e0:	461a      	mov	r2, r3
        (TX_SEMAPHORE **) extra_parameters[3]
 80129e2:	683b      	ldr	r3, [r7, #0]
 80129e4:	330c      	adds	r3, #12
 80129e6:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_semaphore_info_get(
 80129e8:	9301      	str	r3, [sp, #4]
 80129ea:	9200      	str	r2, [sp, #0]
 80129ec:	462b      	mov	r3, r5
 80129ee:	4622      	mov	r2, r4
 80129f0:	f7fc fae0 	bl	800efb4 <_txe_semaphore_info_get>
 80129f4:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 80129f6:	697b      	ldr	r3, [r7, #20]
}
 80129f8:	4618      	mov	r0, r3
 80129fa:	3718      	adds	r7, #24
 80129fc:	46bd      	mov	sp, r7
 80129fe:	bdb0      	pop	{r4, r5, r7, pc}

08012a00 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch>:
    ULONG *gets, -> extra_parameters[0]
    ULONG *suspensions, -> extra_parameters[1]
    ULONG *timeouts -> extra_parameters[2]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_semaphore_performance_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8012a00:	b590      	push	{r4, r7, lr}
 8012a02:	b089      	sub	sp, #36	; 0x24
 8012a04:	af02      	add	r7, sp, #8
 8012a06:	60f8      	str	r0, [r7, #12]
 8012a08:	60b9      	str	r1, [r7, #8]
 8012a0a:	607a      	str	r2, [r7, #4]
 8012a0c:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8012a0e:	68fb      	ldr	r3, [r7, #12]
 8012a10:	68db      	ldr	r3, [r3, #12]
 8012a12:	f003 0302 	and.w	r3, r3, #2
 8012a16:	2b00      	cmp	r3, #0
 8012a18:	d06a      	beq.n	8012af0 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0xf0>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_SEMAPHORE)))
 8012a1a:	2228      	movs	r2, #40	; 0x28
 8012a1c:	68b9      	ldr	r1, [r7, #8]
 8012a1e:	68f8      	ldr	r0, [r7, #12]
 8012a20:	f002 fa12 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012a24:	4603      	mov	r3, r0
 8012a26:	2b00      	cmp	r3, #0
 8012a28:	d111      	bne.n	8012a4e <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0x4e>
 8012a2a:	68bb      	ldr	r3, [r7, #8]
 8012a2c:	f113 0f29 	cmn.w	r3, #41	; 0x29
 8012a30:	d812      	bhi.n	8012a58 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0x58>
 8012a32:	68fb      	ldr	r3, [r7, #12]
 8012a34:	699b      	ldr	r3, [r3, #24]
 8012a36:	461a      	mov	r2, r3
 8012a38:	68bb      	ldr	r3, [r7, #8]
 8012a3a:	4293      	cmp	r3, r2
 8012a3c:	d30c      	bcc.n	8012a58 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0x58>
 8012a3e:	68bb      	ldr	r3, [r7, #8]
 8012a40:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8012a44:	68fb      	ldr	r3, [r7, #12]
 8012a46:	69db      	ldr	r3, [r3, #28]
 8012a48:	3301      	adds	r3, #1
 8012a4a:	429a      	cmp	r2, r3
 8012a4c:	d804      	bhi.n	8012a58 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0x58>
 8012a4e:	68bb      	ldr	r3, [r7, #8]
 8012a50:	2b00      	cmp	r3, #0
 8012a52:	d001      	beq.n	8012a58 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0x58>
            return(TXM_MODULE_INVALID_MEMORY);
 8012a54:	23f4      	movs	r3, #244	; 0xf4
 8012a56:	e05d      	b.n	8012b14 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0x114>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(ULONG)))
 8012a58:	2204      	movs	r2, #4
 8012a5a:	6879      	ldr	r1, [r7, #4]
 8012a5c:	68f8      	ldr	r0, [r7, #12]
 8012a5e:	f002 f9f3 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012a62:	4603      	mov	r3, r0
 8012a64:	2b00      	cmp	r3, #0
 8012a66:	d104      	bne.n	8012a72 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0x72>
 8012a68:	687b      	ldr	r3, [r7, #4]
 8012a6a:	2b00      	cmp	r3, #0
 8012a6c:	d001      	beq.n	8012a72 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0x72>
            return(TXM_MODULE_INVALID_MEMORY);
 8012a6e:	23f4      	movs	r3, #244	; 0xf4
 8012a70:	e050      	b.n	8012b14 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0x114>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[3])))
 8012a72:	683b      	ldr	r3, [r7, #0]
 8012a74:	220c      	movs	r2, #12
 8012a76:	4619      	mov	r1, r3
 8012a78:	68f8      	ldr	r0, [r7, #12]
 8012a7a:	f002 f9e5 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012a7e:	4603      	mov	r3, r0
 8012a80:	2b00      	cmp	r3, #0
 8012a82:	d101      	bne.n	8012a88 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0x88>
            return(TXM_MODULE_INVALID_MEMORY);
 8012a84:	23f4      	movs	r3, #244	; 0xf4
 8012a86:	e045      	b.n	8012b14 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0x114>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 8012a88:	683b      	ldr	r3, [r7, #0]
 8012a8a:	681b      	ldr	r3, [r3, #0]
 8012a8c:	2204      	movs	r2, #4
 8012a8e:	4619      	mov	r1, r3
 8012a90:	68f8      	ldr	r0, [r7, #12]
 8012a92:	f002 f9d9 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012a96:	4603      	mov	r3, r0
 8012a98:	2b00      	cmp	r3, #0
 8012a9a:	d105      	bne.n	8012aa8 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0xa8>
 8012a9c:	683b      	ldr	r3, [r7, #0]
 8012a9e:	681b      	ldr	r3, [r3, #0]
 8012aa0:	2b00      	cmp	r3, #0
 8012aa2:	d001      	beq.n	8012aa8 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0xa8>
            return(TXM_MODULE_INVALID_MEMORY);
 8012aa4:	23f4      	movs	r3, #244	; 0xf4
 8012aa6:	e035      	b.n	8012b14 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0x114>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 8012aa8:	683b      	ldr	r3, [r7, #0]
 8012aaa:	3304      	adds	r3, #4
 8012aac:	681b      	ldr	r3, [r3, #0]
 8012aae:	2204      	movs	r2, #4
 8012ab0:	4619      	mov	r1, r3
 8012ab2:	68f8      	ldr	r0, [r7, #12]
 8012ab4:	f002 f9c8 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012ab8:	4603      	mov	r3, r0
 8012aba:	2b00      	cmp	r3, #0
 8012abc:	d106      	bne.n	8012acc <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0xcc>
 8012abe:	683b      	ldr	r3, [r7, #0]
 8012ac0:	3304      	adds	r3, #4
 8012ac2:	681b      	ldr	r3, [r3, #0]
 8012ac4:	2b00      	cmp	r3, #0
 8012ac6:	d001      	beq.n	8012acc <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0xcc>
            return(TXM_MODULE_INVALID_MEMORY);
 8012ac8:	23f4      	movs	r3, #244	; 0xf4
 8012aca:	e023      	b.n	8012b14 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0x114>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(ULONG)))
 8012acc:	683b      	ldr	r3, [r7, #0]
 8012ace:	3308      	adds	r3, #8
 8012ad0:	681b      	ldr	r3, [r3, #0]
 8012ad2:	2204      	movs	r2, #4
 8012ad4:	4619      	mov	r1, r3
 8012ad6:	68f8      	ldr	r0, [r7, #12]
 8012ad8:	f002 f9b6 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012adc:	4603      	mov	r3, r0
 8012ade:	2b00      	cmp	r3, #0
 8012ae0:	d106      	bne.n	8012af0 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0xf0>
 8012ae2:	683b      	ldr	r3, [r7, #0]
 8012ae4:	3308      	adds	r3, #8
 8012ae6:	681b      	ldr	r3, [r3, #0]
 8012ae8:	2b00      	cmp	r3, #0
 8012aea:	d001      	beq.n	8012af0 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0xf0>
            return(TXM_MODULE_INVALID_MEMORY);
 8012aec:	23f4      	movs	r3, #244	; 0xf4
 8012aee:	e011      	b.n	8012b14 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch+0x114>
    }

    return_value = (ALIGN_TYPE) _tx_semaphore_performance_info_get(
 8012af0:	68b8      	ldr	r0, [r7, #8]
 8012af2:	6879      	ldr	r1, [r7, #4]
        (TX_SEMAPHORE *) param_0,
        (ULONG *) param_1,
        (ULONG *) extra_parameters[0],
 8012af4:	683b      	ldr	r3, [r7, #0]
 8012af6:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_semaphore_performance_info_get(
 8012af8:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[1],
 8012afa:	683b      	ldr	r3, [r7, #0]
 8012afc:	3304      	adds	r3, #4
 8012afe:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_semaphore_performance_info_get(
 8012b00:	461c      	mov	r4, r3
        (ULONG *) extra_parameters[2]
 8012b02:	683b      	ldr	r3, [r7, #0]
 8012b04:	3308      	adds	r3, #8
 8012b06:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_semaphore_performance_info_get(
 8012b08:	9300      	str	r3, [sp, #0]
 8012b0a:	4623      	mov	r3, r4
 8012b0c:	f7f8 fc89 	bl	800b422 <_tx_semaphore_performance_info_get>
 8012b10:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 8012b12:	697b      	ldr	r3, [r7, #20]
}
 8012b14:	4618      	mov	r0, r3
 8012b16:	371c      	adds	r7, #28
 8012b18:	46bd      	mov	sp, r7
 8012b1a:	bd90      	pop	{r4, r7, pc}

08012b1c <_txm_module_manager_tx_semaphore_performance_system_info_get_dispatch>:
    ULONG *gets, -> param_1
    ULONG *suspensions, -> extra_parameters[0]
    ULONG *timeouts -> extra_parameters[1]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_semaphore_performance_system_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8012b1c:	b580      	push	{r7, lr}
 8012b1e:	b086      	sub	sp, #24
 8012b20:	af00      	add	r7, sp, #0
 8012b22:	60f8      	str	r0, [r7, #12]
 8012b24:	60b9      	str	r1, [r7, #8]
 8012b26:	607a      	str	r2, [r7, #4]
 8012b28:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8012b2a:	68fb      	ldr	r3, [r7, #12]
 8012b2c:	68db      	ldr	r3, [r3, #12]
 8012b2e:	f003 0302 	and.w	r3, r3, #2
 8012b32:	2b00      	cmp	r3, #0
 8012b34:	d046      	beq.n	8012bc4 <_txm_module_manager_tx_semaphore_performance_system_info_get_dispatch+0xa8>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_0, sizeof(ULONG)))
 8012b36:	2204      	movs	r2, #4
 8012b38:	68b9      	ldr	r1, [r7, #8]
 8012b3a:	68f8      	ldr	r0, [r7, #12]
 8012b3c:	f002 f984 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012b40:	4603      	mov	r3, r0
 8012b42:	2b00      	cmp	r3, #0
 8012b44:	d104      	bne.n	8012b50 <_txm_module_manager_tx_semaphore_performance_system_info_get_dispatch+0x34>
 8012b46:	68bb      	ldr	r3, [r7, #8]
 8012b48:	2b00      	cmp	r3, #0
 8012b4a:	d001      	beq.n	8012b50 <_txm_module_manager_tx_semaphore_performance_system_info_get_dispatch+0x34>
            return(TXM_MODULE_INVALID_MEMORY);
 8012b4c:	23f4      	movs	r3, #244	; 0xf4
 8012b4e:	e045      	b.n	8012bdc <_txm_module_manager_tx_semaphore_performance_system_info_get_dispatch+0xc0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(ULONG)))
 8012b50:	2204      	movs	r2, #4
 8012b52:	6879      	ldr	r1, [r7, #4]
 8012b54:	68f8      	ldr	r0, [r7, #12]
 8012b56:	f002 f977 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012b5a:	4603      	mov	r3, r0
 8012b5c:	2b00      	cmp	r3, #0
 8012b5e:	d104      	bne.n	8012b6a <_txm_module_manager_tx_semaphore_performance_system_info_get_dispatch+0x4e>
 8012b60:	687b      	ldr	r3, [r7, #4]
 8012b62:	2b00      	cmp	r3, #0
 8012b64:	d001      	beq.n	8012b6a <_txm_module_manager_tx_semaphore_performance_system_info_get_dispatch+0x4e>
            return(TXM_MODULE_INVALID_MEMORY);
 8012b66:	23f4      	movs	r3, #244	; 0xf4
 8012b68:	e038      	b.n	8012bdc <_txm_module_manager_tx_semaphore_performance_system_info_get_dispatch+0xc0>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[2])))
 8012b6a:	683b      	ldr	r3, [r7, #0]
 8012b6c:	2208      	movs	r2, #8
 8012b6e:	4619      	mov	r1, r3
 8012b70:	68f8      	ldr	r0, [r7, #12]
 8012b72:	f002 f969 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012b76:	4603      	mov	r3, r0
 8012b78:	2b00      	cmp	r3, #0
 8012b7a:	d101      	bne.n	8012b80 <_txm_module_manager_tx_semaphore_performance_system_info_get_dispatch+0x64>
            return(TXM_MODULE_INVALID_MEMORY);
 8012b7c:	23f4      	movs	r3, #244	; 0xf4
 8012b7e:	e02d      	b.n	8012bdc <_txm_module_manager_tx_semaphore_performance_system_info_get_dispatch+0xc0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 8012b80:	683b      	ldr	r3, [r7, #0]
 8012b82:	681b      	ldr	r3, [r3, #0]
 8012b84:	2204      	movs	r2, #4
 8012b86:	4619      	mov	r1, r3
 8012b88:	68f8      	ldr	r0, [r7, #12]
 8012b8a:	f002 f95d 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012b8e:	4603      	mov	r3, r0
 8012b90:	2b00      	cmp	r3, #0
 8012b92:	d105      	bne.n	8012ba0 <_txm_module_manager_tx_semaphore_performance_system_info_get_dispatch+0x84>
 8012b94:	683b      	ldr	r3, [r7, #0]
 8012b96:	681b      	ldr	r3, [r3, #0]
 8012b98:	2b00      	cmp	r3, #0
 8012b9a:	d001      	beq.n	8012ba0 <_txm_module_manager_tx_semaphore_performance_system_info_get_dispatch+0x84>
            return(TXM_MODULE_INVALID_MEMORY);
 8012b9c:	23f4      	movs	r3, #244	; 0xf4
 8012b9e:	e01d      	b.n	8012bdc <_txm_module_manager_tx_semaphore_performance_system_info_get_dispatch+0xc0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 8012ba0:	683b      	ldr	r3, [r7, #0]
 8012ba2:	3304      	adds	r3, #4
 8012ba4:	681b      	ldr	r3, [r3, #0]
 8012ba6:	2204      	movs	r2, #4
 8012ba8:	4619      	mov	r1, r3
 8012baa:	68f8      	ldr	r0, [r7, #12]
 8012bac:	f002 f94c 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012bb0:	4603      	mov	r3, r0
 8012bb2:	2b00      	cmp	r3, #0
 8012bb4:	d106      	bne.n	8012bc4 <_txm_module_manager_tx_semaphore_performance_system_info_get_dispatch+0xa8>
 8012bb6:	683b      	ldr	r3, [r7, #0]
 8012bb8:	3304      	adds	r3, #4
 8012bba:	681b      	ldr	r3, [r3, #0]
 8012bbc:	2b00      	cmp	r3, #0
 8012bbe:	d001      	beq.n	8012bc4 <_txm_module_manager_tx_semaphore_performance_system_info_get_dispatch+0xa8>
            return(TXM_MODULE_INVALID_MEMORY);
 8012bc0:	23f4      	movs	r3, #244	; 0xf4
 8012bc2:	e00b      	b.n	8012bdc <_txm_module_manager_tx_semaphore_performance_system_info_get_dispatch+0xc0>
    }

    return_value = (ALIGN_TYPE) _tx_semaphore_performance_system_info_get(
 8012bc4:	68b8      	ldr	r0, [r7, #8]
 8012bc6:	6879      	ldr	r1, [r7, #4]
        (ULONG *) param_0,
        (ULONG *) param_1,
        (ULONG *) extra_parameters[0],
 8012bc8:	683b      	ldr	r3, [r7, #0]
 8012bca:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_semaphore_performance_system_info_get(
 8012bcc:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[1]
 8012bce:	683b      	ldr	r3, [r7, #0]
 8012bd0:	3304      	adds	r3, #4
 8012bd2:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_semaphore_performance_system_info_get(
 8012bd4:	f7f8 fc53 	bl	800b47e <_tx_semaphore_performance_system_info_get>
 8012bd8:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 8012bda:	697b      	ldr	r3, [r7, #20]
}
 8012bdc:	4618      	mov	r0, r3
 8012bde:	3718      	adds	r7, #24
 8012be0:	46bd      	mov	sp, r7
 8012be2:	bd80      	pop	{r7, pc}

08012be4 <_txm_module_manager_tx_semaphore_prioritize_dispatch>:
#ifndef TXM_SEMAPHORE_PRIORITIZE_CALL_NOT_USED
/* UINT _txe_semaphore_prioritize(
    TX_SEMAPHORE *semaphore_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_semaphore_prioritize_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8012be4:	b580      	push	{r7, lr}
 8012be6:	b084      	sub	sp, #16
 8012be8:	af00      	add	r7, sp, #0
 8012bea:	6078      	str	r0, [r7, #4]
 8012bec:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8012bee:	687b      	ldr	r3, [r7, #4]
 8012bf0:	68db      	ldr	r3, [r3, #12]
 8012bf2:	f003 0302 	and.w	r3, r3, #2
 8012bf6:	2b00      	cmp	r3, #0
 8012bf8:	d01e      	beq.n	8012c38 <_txm_module_manager_tx_semaphore_prioritize_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_SEMAPHORE)))
 8012bfa:	2228      	movs	r2, #40	; 0x28
 8012bfc:	6839      	ldr	r1, [r7, #0]
 8012bfe:	6878      	ldr	r0, [r7, #4]
 8012c00:	f002 f922 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012c04:	4603      	mov	r3, r0
 8012c06:	2b00      	cmp	r3, #0
 8012c08:	d111      	bne.n	8012c2e <_txm_module_manager_tx_semaphore_prioritize_dispatch+0x4a>
 8012c0a:	683b      	ldr	r3, [r7, #0]
 8012c0c:	f113 0f29 	cmn.w	r3, #41	; 0x29
 8012c10:	d812      	bhi.n	8012c38 <_txm_module_manager_tx_semaphore_prioritize_dispatch+0x54>
 8012c12:	687b      	ldr	r3, [r7, #4]
 8012c14:	699b      	ldr	r3, [r3, #24]
 8012c16:	461a      	mov	r2, r3
 8012c18:	683b      	ldr	r3, [r7, #0]
 8012c1a:	4293      	cmp	r3, r2
 8012c1c:	d30c      	bcc.n	8012c38 <_txm_module_manager_tx_semaphore_prioritize_dispatch+0x54>
 8012c1e:	683b      	ldr	r3, [r7, #0]
 8012c20:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8012c24:	687b      	ldr	r3, [r7, #4]
 8012c26:	69db      	ldr	r3, [r3, #28]
 8012c28:	3301      	adds	r3, #1
 8012c2a:	429a      	cmp	r2, r3
 8012c2c:	d804      	bhi.n	8012c38 <_txm_module_manager_tx_semaphore_prioritize_dispatch+0x54>
 8012c2e:	683b      	ldr	r3, [r7, #0]
 8012c30:	2b00      	cmp	r3, #0
 8012c32:	d001      	beq.n	8012c38 <_txm_module_manager_tx_semaphore_prioritize_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 8012c34:	23f4      	movs	r3, #244	; 0xf4
 8012c36:	e005      	b.n	8012c44 <_txm_module_manager_tx_semaphore_prioritize_dispatch+0x60>
    }

    return_value = (ALIGN_TYPE) _txe_semaphore_prioritize(
 8012c38:	683b      	ldr	r3, [r7, #0]
 8012c3a:	4618      	mov	r0, r3
 8012c3c:	f7fc f9e2 	bl	800f004 <_txe_semaphore_prioritize>
 8012c40:	60f8      	str	r0, [r7, #12]
        (TX_SEMAPHORE *) param_0
    );
    return(return_value);
 8012c42:	68fb      	ldr	r3, [r7, #12]
}
 8012c44:	4618      	mov	r0, r3
 8012c46:	3710      	adds	r7, #16
 8012c48:	46bd      	mov	sp, r7
 8012c4a:	bd80      	pop	{r7, pc}

08012c4c <_txm_module_manager_tx_semaphore_put_dispatch>:
#ifndef TXM_SEMAPHORE_PUT_CALL_NOT_USED
/* UINT _txe_semaphore_put(
    TX_SEMAPHORE *semaphore_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_semaphore_put_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8012c4c:	b580      	push	{r7, lr}
 8012c4e:	b084      	sub	sp, #16
 8012c50:	af00      	add	r7, sp, #0
 8012c52:	6078      	str	r0, [r7, #4]
 8012c54:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8012c56:	687b      	ldr	r3, [r7, #4]
 8012c58:	68db      	ldr	r3, [r3, #12]
 8012c5a:	f003 0302 	and.w	r3, r3, #2
 8012c5e:	2b00      	cmp	r3, #0
 8012c60:	d01e      	beq.n	8012ca0 <_txm_module_manager_tx_semaphore_put_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_SEMAPHORE)))
 8012c62:	2228      	movs	r2, #40	; 0x28
 8012c64:	6839      	ldr	r1, [r7, #0]
 8012c66:	6878      	ldr	r0, [r7, #4]
 8012c68:	f002 f8ee 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012c6c:	4603      	mov	r3, r0
 8012c6e:	2b00      	cmp	r3, #0
 8012c70:	d111      	bne.n	8012c96 <_txm_module_manager_tx_semaphore_put_dispatch+0x4a>
 8012c72:	683b      	ldr	r3, [r7, #0]
 8012c74:	f113 0f29 	cmn.w	r3, #41	; 0x29
 8012c78:	d812      	bhi.n	8012ca0 <_txm_module_manager_tx_semaphore_put_dispatch+0x54>
 8012c7a:	687b      	ldr	r3, [r7, #4]
 8012c7c:	699b      	ldr	r3, [r3, #24]
 8012c7e:	461a      	mov	r2, r3
 8012c80:	683b      	ldr	r3, [r7, #0]
 8012c82:	4293      	cmp	r3, r2
 8012c84:	d30c      	bcc.n	8012ca0 <_txm_module_manager_tx_semaphore_put_dispatch+0x54>
 8012c86:	683b      	ldr	r3, [r7, #0]
 8012c88:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8012c8c:	687b      	ldr	r3, [r7, #4]
 8012c8e:	69db      	ldr	r3, [r3, #28]
 8012c90:	3301      	adds	r3, #1
 8012c92:	429a      	cmp	r2, r3
 8012c94:	d804      	bhi.n	8012ca0 <_txm_module_manager_tx_semaphore_put_dispatch+0x54>
 8012c96:	683b      	ldr	r3, [r7, #0]
 8012c98:	2b00      	cmp	r3, #0
 8012c9a:	d001      	beq.n	8012ca0 <_txm_module_manager_tx_semaphore_put_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 8012c9c:	23f4      	movs	r3, #244	; 0xf4
 8012c9e:	e005      	b.n	8012cac <_txm_module_manager_tx_semaphore_put_dispatch+0x60>
    }

    return_value = (ALIGN_TYPE) _txe_semaphore_put(
 8012ca0:	683b      	ldr	r3, [r7, #0]
 8012ca2:	4618      	mov	r0, r3
 8012ca4:	f7fc f9cc 	bl	800f040 <_txe_semaphore_put>
 8012ca8:	60f8      	str	r0, [r7, #12]
        (TX_SEMAPHORE *) param_0
    );
    return(return_value);
 8012caa:	68fb      	ldr	r3, [r7, #12]
}
 8012cac:	4618      	mov	r0, r3
 8012cae:	3710      	adds	r7, #16
 8012cb0:	46bd      	mov	sp, r7
 8012cb2:	bd80      	pop	{r7, pc}

08012cb4 <_txm_module_manager_tx_semaphore_put_notify_dispatch>:
/* UINT _txe_semaphore_put_notify(
    TX_SEMAPHORE *semaphore_ptr, -> param_0
    VOID (*semaphore_put_notify)(TX_SEMAPHORE *notify_semaphore_ptr) -> param_1
   ); */
static ALIGN_TYPE _txm_module_manager_tx_semaphore_put_notify_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1)
{
 8012cb4:	b580      	push	{r7, lr}
 8012cb6:	b088      	sub	sp, #32
 8012cb8:	af00      	add	r7, sp, #0
 8012cba:	60f8      	str	r0, [r7, #12]
 8012cbc:	60b9      	str	r1, [r7, #8]
 8012cbe:	607a      	str	r2, [r7, #4]

ALIGN_TYPE return_value;
TX_SEMAPHORE *semaphore_ptr = (TX_SEMAPHORE *) param_0;
 8012cc0:	68bb      	ldr	r3, [r7, #8]
 8012cc2:	61bb      	str	r3, [r7, #24]
VOID (*semaphore_put_notify)(TX_SEMAPHORE *);

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8012cc4:	68fb      	ldr	r3, [r7, #12]
 8012cc6:	68db      	ldr	r3, [r3, #12]
 8012cc8:	f003 0302 	and.w	r3, r3, #2
 8012ccc:	2b00      	cmp	r3, #0
 8012cce:	d028      	beq.n	8012d22 <_txm_module_manager_tx_semaphore_put_notify_dispatch+0x6e>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_SEMAPHORE)))
 8012cd0:	2228      	movs	r2, #40	; 0x28
 8012cd2:	68b9      	ldr	r1, [r7, #8]
 8012cd4:	68f8      	ldr	r0, [r7, #12]
 8012cd6:	f002 f8b7 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012cda:	4603      	mov	r3, r0
 8012cdc:	2b00      	cmp	r3, #0
 8012cde:	d111      	bne.n	8012d04 <_txm_module_manager_tx_semaphore_put_notify_dispatch+0x50>
 8012ce0:	68bb      	ldr	r3, [r7, #8]
 8012ce2:	f113 0f29 	cmn.w	r3, #41	; 0x29
 8012ce6:	d812      	bhi.n	8012d0e <_txm_module_manager_tx_semaphore_put_notify_dispatch+0x5a>
 8012ce8:	68fb      	ldr	r3, [r7, #12]
 8012cea:	699b      	ldr	r3, [r3, #24]
 8012cec:	461a      	mov	r2, r3
 8012cee:	68bb      	ldr	r3, [r7, #8]
 8012cf0:	4293      	cmp	r3, r2
 8012cf2:	d30c      	bcc.n	8012d0e <_txm_module_manager_tx_semaphore_put_notify_dispatch+0x5a>
 8012cf4:	68bb      	ldr	r3, [r7, #8]
 8012cf6:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8012cfa:	68fb      	ldr	r3, [r7, #12]
 8012cfc:	69db      	ldr	r3, [r3, #28]
 8012cfe:	3301      	adds	r3, #1
 8012d00:	429a      	cmp	r2, r3
 8012d02:	d804      	bhi.n	8012d0e <_txm_module_manager_tx_semaphore_put_notify_dispatch+0x5a>
 8012d04:	68bb      	ldr	r3, [r7, #8]
 8012d06:	2b00      	cmp	r3, #0
 8012d08:	d001      	beq.n	8012d0e <_txm_module_manager_tx_semaphore_put_notify_dispatch+0x5a>
            return(TXM_MODULE_INVALID_MEMORY);
 8012d0a:	23f4      	movs	r3, #244	; 0xf4
 8012d0c:	e01e      	b.n	8012d4c <_txm_module_manager_tx_semaphore_put_notify_dispatch+0x98>

        /* Since we need to write to the object, ensure it's valid.  */
        if ((semaphore_ptr == TX_NULL) || (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID))
 8012d0e:	69bb      	ldr	r3, [r7, #24]
 8012d10:	2b00      	cmp	r3, #0
 8012d12:	d004      	beq.n	8012d1e <_txm_module_manager_tx_semaphore_put_notify_dispatch+0x6a>
 8012d14:	69bb      	ldr	r3, [r7, #24]
 8012d16:	681b      	ldr	r3, [r3, #0]
 8012d18:	4a0e      	ldr	r2, [pc, #56]	; (8012d54 <_txm_module_manager_tx_semaphore_put_notify_dispatch+0xa0>)
 8012d1a:	4293      	cmp	r3, r2
 8012d1c:	d001      	beq.n	8012d22 <_txm_module_manager_tx_semaphore_put_notify_dispatch+0x6e>
            return(TX_SEMAPHORE_ERROR);
 8012d1e:	230c      	movs	r3, #12
 8012d20:	e014      	b.n	8012d4c <_txm_module_manager_tx_semaphore_put_notify_dispatch+0x98>
    }

    /* Is it a disable request?  */
    if ((void *) param_1 == TX_NULL)
 8012d22:	687b      	ldr	r3, [r7, #4]
 8012d24:	2b00      	cmp	r3, #0
 8012d26:	d102      	bne.n	8012d2e <_txm_module_manager_tx_semaphore_put_notify_dispatch+0x7a>
    {

        /* Clear the callback.  */
        semaphore_put_notify = (VOID (*)(TX_SEMAPHORE *)) TX_NULL;
 8012d28:	2300      	movs	r3, #0
 8012d2a:	61fb      	str	r3, [r7, #28]
 8012d2c:	e007      	b.n	8012d3e <_txm_module_manager_tx_semaphore_put_notify_dispatch+0x8a>
    }
    else
    {

        /* Setup trampoline values.  */
        semaphore_ptr -> tx_semaphore_module_instance = (VOID *) module_instance;
 8012d2e:	69bb      	ldr	r3, [r7, #24]
 8012d30:	68fa      	ldr	r2, [r7, #12]
 8012d32:	621a      	str	r2, [r3, #32]
        semaphore_ptr -> tx_semaphore_put_module_notify = (VOID (*)(TX_SEMAPHORE *)) param_1;
 8012d34:	687a      	ldr	r2, [r7, #4]
 8012d36:	69bb      	ldr	r3, [r7, #24]
 8012d38:	625a      	str	r2, [r3, #36]	; 0x24
        semaphore_put_notify = _txm_module_manager_semaphore_notify_trampoline;
 8012d3a:	4b07      	ldr	r3, [pc, #28]	; (8012d58 <_txm_module_manager_tx_semaphore_put_notify_dispatch+0xa4>)
 8012d3c:	61fb      	str	r3, [r7, #28]
    }

    return_value = (ALIGN_TYPE) _txe_semaphore_put_notify(
 8012d3e:	68bb      	ldr	r3, [r7, #8]
 8012d40:	69f9      	ldr	r1, [r7, #28]
 8012d42:	4618      	mov	r0, r3
 8012d44:	f7fc f99a 	bl	800f07c <_txe_semaphore_put_notify>
 8012d48:	6178      	str	r0, [r7, #20]
        (TX_SEMAPHORE *) param_0,
        (VOID (*)(TX_SEMAPHORE *notify_semaphore_ptr)) semaphore_put_notify
    );
    return(return_value);
 8012d4a:	697b      	ldr	r3, [r7, #20]
}
 8012d4c:	4618      	mov	r0, r3
 8012d4e:	3720      	adds	r7, #32
 8012d50:	46bd      	mov	sp, r7
 8012d52:	bd80      	pop	{r7, pc}
 8012d54:	53454d41 	.word	0x53454d41
 8012d58:	0801564d 	.word	0x0801564d

08012d5c <_txm_module_manager_tx_thread_create_dispatch>:
    ULONG time_slice, -> extra_parameters[6]
    UINT auto_start, -> extra_parameters[7]
    UINT thread_control_block_size -> extra_parameters[8]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_thread_create_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8012d5c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8012d5e:	b097      	sub	sp, #92	; 0x5c
 8012d60:	af0a      	add	r7, sp, #40	; 0x28
 8012d62:	6278      	str	r0, [r7, #36]	; 0x24
 8012d64:	6239      	str	r1, [r7, #32]
 8012d66:	61fa      	str	r2, [r7, #28]
 8012d68:	61bb      	str	r3, [r7, #24]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8012d6a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012d6c:	68db      	ldr	r3, [r3, #12]
 8012d6e:	f003 0302 	and.w	r3, r3, #2
 8012d72:	2b00      	cmp	r3, #0
 8012d74:	d073      	beq.n	8012e5e <_txm_module_manager_tx_thread_create_dispatch+0x102>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_CREATION(module_instance, param_0, sizeof(TX_THREAD)))
 8012d76:	4b58      	ldr	r3, [pc, #352]	; (8012ed8 <_txm_module_manager_tx_thread_create_dispatch+0x17c>)
 8012d78:	681b      	ldr	r3, [r3, #0]
 8012d7a:	2b01      	cmp	r3, #1
 8012d7c:	d119      	bne.n	8012db2 <_txm_module_manager_tx_thread_create_dispatch+0x56>
 8012d7e:	6a3b      	ldr	r3, [r7, #32]
 8012d80:	f113 0fe9 	cmn.w	r3, #233	; 0xe9
 8012d84:	d815      	bhi.n	8012db2 <_txm_module_manager_tx_thread_create_dispatch+0x56>
 8012d86:	4b55      	ldr	r3, [pc, #340]	; (8012edc <_txm_module_manager_tx_thread_create_dispatch+0x180>)
 8012d88:	699b      	ldr	r3, [r3, #24]
 8012d8a:	3310      	adds	r3, #16
 8012d8c:	6a3a      	ldr	r2, [r7, #32]
 8012d8e:	429a      	cmp	r2, r3
 8012d90:	d30f      	bcc.n	8012db2 <_txm_module_manager_tx_thread_create_dispatch+0x56>
 8012d92:	6a3b      	ldr	r3, [r7, #32]
 8012d94:	33e8      	adds	r3, #232	; 0xe8
 8012d96:	4a51      	ldr	r2, [pc, #324]	; (8012edc <_txm_module_manager_tx_thread_create_dispatch+0x180>)
 8012d98:	6991      	ldr	r1, [r2, #24]
 8012d9a:	4a50      	ldr	r2, [pc, #320]	; (8012edc <_txm_module_manager_tx_thread_create_dispatch+0x180>)
 8012d9c:	69d2      	ldr	r2, [r2, #28]
 8012d9e:	440a      	add	r2, r1
 8012da0:	4293      	cmp	r3, r2
 8012da2:	d806      	bhi.n	8012db2 <_txm_module_manager_tx_thread_create_dispatch+0x56>
 8012da4:	21e8      	movs	r1, #232	; 0xe8
 8012da6:	6a38      	ldr	r0, [r7, #32]
 8012da8:	f003 fc76 	bl	8016698 <_txm_module_manager_object_size_check>
 8012dac:	4603      	mov	r3, r0
 8012dae:	2b00      	cmp	r3, #0
 8012db0:	d004      	beq.n	8012dbc <_txm_module_manager_tx_thread_create_dispatch+0x60>
 8012db2:	6a3b      	ldr	r3, [r7, #32]
 8012db4:	2b00      	cmp	r3, #0
 8012db6:	d001      	beq.n	8012dbc <_txm_module_manager_tx_thread_create_dispatch+0x60>
            return(TXM_MODULE_INVALID_MEMORY);
 8012db8:	23f4      	movs	r3, #244	; 0xf4
 8012dba:	e088      	b.n	8012ece <_txm_module_manager_tx_thread_create_dispatch+0x172>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_DEREFERENCE_STRING(module_instance, param_1))
 8012dbc:	2201      	movs	r2, #1
 8012dbe:	69f9      	ldr	r1, [r7, #28]
 8012dc0:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8012dc2:	f002 f841 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012dc6:	4603      	mov	r3, r0
 8012dc8:	2b00      	cmp	r3, #0
 8012dca:	d115      	bne.n	8012df8 <_txm_module_manager_tx_thread_create_dispatch+0x9c>
 8012dcc:	69fb      	ldr	r3, [r7, #28]
 8012dce:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8012dd2:	d00c      	beq.n	8012dee <_txm_module_manager_tx_thread_create_dispatch+0x92>
 8012dd4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012dd6:	699b      	ldr	r3, [r3, #24]
 8012dd8:	461a      	mov	r2, r3
 8012dda:	69fb      	ldr	r3, [r7, #28]
 8012ddc:	4293      	cmp	r3, r2
 8012dde:	d306      	bcc.n	8012dee <_txm_module_manager_tx_thread_create_dispatch+0x92>
 8012de0:	69fb      	ldr	r3, [r7, #28]
 8012de2:	1c5a      	adds	r2, r3, #1
 8012de4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012de6:	69db      	ldr	r3, [r3, #28]
 8012de8:	3301      	adds	r3, #1
 8012dea:	429a      	cmp	r2, r3
 8012dec:	d904      	bls.n	8012df8 <_txm_module_manager_tx_thread_create_dispatch+0x9c>
 8012dee:	69fb      	ldr	r3, [r7, #28]
 8012df0:	2b00      	cmp	r3, #0
 8012df2:	d001      	beq.n	8012df8 <_txm_module_manager_tx_thread_create_dispatch+0x9c>
            return(TXM_MODULE_INVALID_MEMORY);
 8012df4:	23f4      	movs	r3, #244	; 0xf4
 8012df6:	e06a      	b.n	8012ece <_txm_module_manager_tx_thread_create_dispatch+0x172>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[9])))
 8012df8:	69bb      	ldr	r3, [r7, #24]
 8012dfa:	2224      	movs	r2, #36	; 0x24
 8012dfc:	4619      	mov	r1, r3
 8012dfe:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8012e00:	f002 f822 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012e04:	4603      	mov	r3, r0
 8012e06:	2b00      	cmp	r3, #0
 8012e08:	d101      	bne.n	8012e0e <_txm_module_manager_tx_thread_create_dispatch+0xb2>
            return(TXM_MODULE_INVALID_MEMORY);
 8012e0a:	23f4      	movs	r3, #244	; 0xf4
 8012e0c:	e05f      	b.n	8012ece <_txm_module_manager_tx_thread_create_dispatch+0x172>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], extra_parameters[3]))
 8012e0e:	69bb      	ldr	r3, [r7, #24]
 8012e10:	3308      	adds	r3, #8
 8012e12:	6819      	ldr	r1, [r3, #0]
 8012e14:	69bb      	ldr	r3, [r7, #24]
 8012e16:	330c      	adds	r3, #12
 8012e18:	681b      	ldr	r3, [r3, #0]
 8012e1a:	461a      	mov	r2, r3
 8012e1c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8012e1e:	f002 f813 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012e22:	4603      	mov	r3, r0
 8012e24:	2b00      	cmp	r3, #0
 8012e26:	d106      	bne.n	8012e36 <_txm_module_manager_tx_thread_create_dispatch+0xda>
 8012e28:	69bb      	ldr	r3, [r7, #24]
 8012e2a:	3308      	adds	r3, #8
 8012e2c:	681b      	ldr	r3, [r3, #0]
 8012e2e:	2b00      	cmp	r3, #0
 8012e30:	d001      	beq.n	8012e36 <_txm_module_manager_tx_thread_create_dispatch+0xda>
            return(TXM_MODULE_INVALID_MEMORY);
 8012e32:	23f4      	movs	r3, #244	; 0xf4
 8012e34:	e04b      	b.n	8012ece <_txm_module_manager_tx_thread_create_dispatch+0x172>

        if (extra_parameters[4] < module_instance -> txm_module_instance_maximum_priority)
 8012e36:	69bb      	ldr	r3, [r7, #24]
 8012e38:	3310      	adds	r3, #16
 8012e3a:	681a      	ldr	r2, [r3, #0]
 8012e3c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012e3e:	f8d3 3498 	ldr.w	r3, [r3, #1176]	; 0x498
 8012e42:	429a      	cmp	r2, r3
 8012e44:	d201      	bcs.n	8012e4a <_txm_module_manager_tx_thread_create_dispatch+0xee>
            return(TX_PRIORITY_ERROR);
 8012e46:	230f      	movs	r3, #15
 8012e48:	e041      	b.n	8012ece <_txm_module_manager_tx_thread_create_dispatch+0x172>

        if (extra_parameters[5] < module_instance -> txm_module_instance_maximum_priority)
 8012e4a:	69bb      	ldr	r3, [r7, #24]
 8012e4c:	3314      	adds	r3, #20
 8012e4e:	681a      	ldr	r2, [r3, #0]
 8012e50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012e52:	f8d3 3498 	ldr.w	r3, [r3, #1176]	; 0x498
 8012e56:	429a      	cmp	r2, r3
 8012e58:	d201      	bcs.n	8012e5e <_txm_module_manager_tx_thread_create_dispatch+0x102>
            return(TX_THRESH_ERROR);
 8012e5a:	2318      	movs	r3, #24
 8012e5c:	e037      	b.n	8012ece <_txm_module_manager_tx_thread_create_dispatch+0x172>
    }

    return_value = (ALIGN_TYPE) _txm_module_manager_thread_create(
 8012e5e:	6a3b      	ldr	r3, [r7, #32]
 8012e60:	617b      	str	r3, [r7, #20]
 8012e62:	69fa      	ldr	r2, [r7, #28]
 8012e64:	613a      	str	r2, [r7, #16]
        (TX_THREAD *) param_0,
        (CHAR *) param_1,
        module_instance -> txm_module_instance_shell_entry_function,
 8012e66:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012e68:	6d5c      	ldr	r4, [r3, #84]	; 0x54
 8012e6a:	60fc      	str	r4, [r7, #12]
        (VOID (*)(ULONG entry_input)) extra_parameters[0],
 8012e6c:	69bb      	ldr	r3, [r7, #24]
 8012e6e:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txm_module_manager_thread_create(
 8012e70:	469c      	mov	ip, r3
        (ULONG) extra_parameters[1],
 8012e72:	69bb      	ldr	r3, [r7, #24]
 8012e74:	3304      	adds	r3, #4
    return_value = (ALIGN_TYPE) _txm_module_manager_thread_create(
 8012e76:	681b      	ldr	r3, [r3, #0]
        (VOID *) extra_parameters[2],
 8012e78:	69ba      	ldr	r2, [r7, #24]
 8012e7a:	3208      	adds	r2, #8
 8012e7c:	6812      	ldr	r2, [r2, #0]
    return_value = (ALIGN_TYPE) _txm_module_manager_thread_create(
 8012e7e:	60ba      	str	r2, [r7, #8]
        (ULONG) extra_parameters[3],
 8012e80:	69ba      	ldr	r2, [r7, #24]
 8012e82:	320c      	adds	r2, #12
    return_value = (ALIGN_TYPE) _txm_module_manager_thread_create(
 8012e84:	6812      	ldr	r2, [r2, #0]
        (UINT) extra_parameters[4],
 8012e86:	69b9      	ldr	r1, [r7, #24]
 8012e88:	3110      	adds	r1, #16
    return_value = (ALIGN_TYPE) _txm_module_manager_thread_create(
 8012e8a:	6809      	ldr	r1, [r1, #0]
        (UINT) extra_parameters[5],
 8012e8c:	69b8      	ldr	r0, [r7, #24]
 8012e8e:	3014      	adds	r0, #20
    return_value = (ALIGN_TYPE) _txm_module_manager_thread_create(
 8012e90:	6800      	ldr	r0, [r0, #0]
        (ULONG) extra_parameters[6],
 8012e92:	69bc      	ldr	r4, [r7, #24]
 8012e94:	3418      	adds	r4, #24
    return_value = (ALIGN_TYPE) _txm_module_manager_thread_create(
 8012e96:	6824      	ldr	r4, [r4, #0]
        (UINT) extra_parameters[7],
 8012e98:	69bd      	ldr	r5, [r7, #24]
 8012e9a:	351c      	adds	r5, #28
    return_value = (ALIGN_TYPE) _txm_module_manager_thread_create(
 8012e9c:	682d      	ldr	r5, [r5, #0]
 8012e9e:	607d      	str	r5, [r7, #4]
        (UINT) extra_parameters[8],
 8012ea0:	69be      	ldr	r6, [r7, #24]
 8012ea2:	3620      	adds	r6, #32
    return_value = (ALIGN_TYPE) _txm_module_manager_thread_create(
 8012ea4:	6836      	ldr	r6, [r6, #0]
 8012ea6:	6a7d      	ldr	r5, [r7, #36]	; 0x24
 8012ea8:	9508      	str	r5, [sp, #32]
 8012eaa:	9607      	str	r6, [sp, #28]
 8012eac:	687d      	ldr	r5, [r7, #4]
 8012eae:	9506      	str	r5, [sp, #24]
 8012eb0:	9405      	str	r4, [sp, #20]
 8012eb2:	9004      	str	r0, [sp, #16]
 8012eb4:	9103      	str	r1, [sp, #12]
 8012eb6:	9202      	str	r2, [sp, #8]
 8012eb8:	68bd      	ldr	r5, [r7, #8]
 8012eba:	9501      	str	r5, [sp, #4]
 8012ebc:	9300      	str	r3, [sp, #0]
 8012ebe:	4663      	mov	r3, ip
 8012ec0:	68fa      	ldr	r2, [r7, #12]
 8012ec2:	6939      	ldr	r1, [r7, #16]
 8012ec4:	6978      	ldr	r0, [r7, #20]
 8012ec6:	f002 ff6b 	bl	8015da0 <_txm_module_manager_thread_create>
 8012eca:	62f8      	str	r0, [r7, #44]	; 0x2c
        module_instance
    );
    return(return_value);
 8012ecc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 8012ece:	4618      	mov	r0, r3
 8012ed0:	3734      	adds	r7, #52	; 0x34
 8012ed2:	46bd      	mov	sp, r7
 8012ed4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8012ed6:	bf00      	nop
 8012ed8:	2000f670 	.word	0x2000f670
 8012edc:	2000f63c 	.word	0x2000f63c

08012ee0 <_txm_module_manager_tx_thread_delete_dispatch>:
#ifndef TXM_THREAD_DELETE_CALL_NOT_USED
/* UINT _txe_thread_delete(
    TX_THREAD *thread_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_thread_delete_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8012ee0:	b580      	push	{r7, lr}
 8012ee2:	b084      	sub	sp, #16
 8012ee4:	af00      	add	r7, sp, #0
 8012ee6:	6078      	str	r0, [r7, #4]
 8012ee8:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8012eea:	687b      	ldr	r3, [r7, #4]
 8012eec:	68db      	ldr	r3, [r3, #12]
 8012eee:	f003 0302 	and.w	r3, r3, #2
 8012ef2:	2b00      	cmp	r3, #0
 8012ef4:	d01e      	beq.n	8012f34 <_txm_module_manager_tx_thread_delete_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_THREAD)))
 8012ef6:	22e8      	movs	r2, #232	; 0xe8
 8012ef8:	6839      	ldr	r1, [r7, #0]
 8012efa:	6878      	ldr	r0, [r7, #4]
 8012efc:	f001 ffa4 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012f00:	4603      	mov	r3, r0
 8012f02:	2b00      	cmp	r3, #0
 8012f04:	d111      	bne.n	8012f2a <_txm_module_manager_tx_thread_delete_dispatch+0x4a>
 8012f06:	683b      	ldr	r3, [r7, #0]
 8012f08:	f113 0fe9 	cmn.w	r3, #233	; 0xe9
 8012f0c:	d812      	bhi.n	8012f34 <_txm_module_manager_tx_thread_delete_dispatch+0x54>
 8012f0e:	687b      	ldr	r3, [r7, #4]
 8012f10:	699b      	ldr	r3, [r3, #24]
 8012f12:	461a      	mov	r2, r3
 8012f14:	683b      	ldr	r3, [r7, #0]
 8012f16:	4293      	cmp	r3, r2
 8012f18:	d30c      	bcc.n	8012f34 <_txm_module_manager_tx_thread_delete_dispatch+0x54>
 8012f1a:	683b      	ldr	r3, [r7, #0]
 8012f1c:	f103 02e8 	add.w	r2, r3, #232	; 0xe8
 8012f20:	687b      	ldr	r3, [r7, #4]
 8012f22:	69db      	ldr	r3, [r3, #28]
 8012f24:	3301      	adds	r3, #1
 8012f26:	429a      	cmp	r2, r3
 8012f28:	d804      	bhi.n	8012f34 <_txm_module_manager_tx_thread_delete_dispatch+0x54>
 8012f2a:	683b      	ldr	r3, [r7, #0]
 8012f2c:	2b00      	cmp	r3, #0
 8012f2e:	d001      	beq.n	8012f34 <_txm_module_manager_tx_thread_delete_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 8012f30:	23f4      	movs	r3, #244	; 0xf4
 8012f32:	e00d      	b.n	8012f50 <_txm_module_manager_tx_thread_delete_dispatch+0x70>
    }

    return_value = (ALIGN_TYPE) _txe_thread_delete(
 8012f34:	683b      	ldr	r3, [r7, #0]
 8012f36:	4618      	mov	r0, r3
 8012f38:	f7fc f9b2 	bl	800f2a0 <_txe_thread_delete>
 8012f3c:	60f8      	str	r0, [r7, #12]
        (TX_THREAD *) param_0
    );

    /* Deallocate object memory.  */
    if (return_value == TX_SUCCESS)
 8012f3e:	68fb      	ldr	r3, [r7, #12]
 8012f40:	2b00      	cmp	r3, #0
 8012f42:	d104      	bne.n	8012f4e <_txm_module_manager_tx_thread_delete_dispatch+0x6e>
    {
        return_value = _txm_module_manager_object_deallocate((VOID *) param_0);
 8012f44:	683b      	ldr	r3, [r7, #0]
 8012f46:	4618      	mov	r0, r3
 8012f48:	f002 f834 	bl	8014fb4 <_txm_module_manager_object_deallocate>
 8012f4c:	60f8      	str	r0, [r7, #12]
    }
    return(return_value);
 8012f4e:	68fb      	ldr	r3, [r7, #12]
}
 8012f50:	4618      	mov	r0, r3
 8012f52:	3710      	adds	r7, #16
 8012f54:	46bd      	mov	sp, r7
 8012f56:	bd80      	pop	{r7, pc}

08012f58 <_txm_module_manager_tx_thread_entry_exit_notify_dispatch>:
/* UINT _txe_thread_entry_exit_notify(
    TX_THREAD *thread_ptr, -> param_0
    VOID (*thread_entry_exit_notify)(TX_THREAD *notify_thread_ptr, UINT type) -> param_1
   ); */
static ALIGN_TYPE _txm_module_manager_tx_thread_entry_exit_notify_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1)
{
 8012f58:	b580      	push	{r7, lr}
 8012f5a:	b088      	sub	sp, #32
 8012f5c:	af00      	add	r7, sp, #0
 8012f5e:	60f8      	str	r0, [r7, #12]
 8012f60:	60b9      	str	r1, [r7, #8]
 8012f62:	607a      	str	r2, [r7, #4]

ALIGN_TYPE return_value;
TX_THREAD *thread_ptr = (TX_THREAD *) param_0;
 8012f64:	68bb      	ldr	r3, [r7, #8]
 8012f66:	61bb      	str	r3, [r7, #24]
TXM_MODULE_THREAD_ENTRY_INFO *thread_entry_info_ptr;
VOID (*thread_entry_exit_notify)(TX_THREAD *, UINT);

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8012f68:	68fb      	ldr	r3, [r7, #12]
 8012f6a:	68db      	ldr	r3, [r3, #12]
 8012f6c:	f003 0302 	and.w	r3, r3, #2
 8012f70:	2b00      	cmp	r3, #0
 8012f72:	d030      	beq.n	8012fd6 <_txm_module_manager_tx_thread_entry_exit_notify_dispatch+0x7e>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_THREAD)))
 8012f74:	22e8      	movs	r2, #232	; 0xe8
 8012f76:	68b9      	ldr	r1, [r7, #8]
 8012f78:	68f8      	ldr	r0, [r7, #12]
 8012f7a:	f001 ff65 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8012f7e:	4603      	mov	r3, r0
 8012f80:	2b00      	cmp	r3, #0
 8012f82:	d111      	bne.n	8012fa8 <_txm_module_manager_tx_thread_entry_exit_notify_dispatch+0x50>
 8012f84:	68bb      	ldr	r3, [r7, #8]
 8012f86:	f113 0fe9 	cmn.w	r3, #233	; 0xe9
 8012f8a:	d812      	bhi.n	8012fb2 <_txm_module_manager_tx_thread_entry_exit_notify_dispatch+0x5a>
 8012f8c:	68fb      	ldr	r3, [r7, #12]
 8012f8e:	699b      	ldr	r3, [r3, #24]
 8012f90:	461a      	mov	r2, r3
 8012f92:	68bb      	ldr	r3, [r7, #8]
 8012f94:	4293      	cmp	r3, r2
 8012f96:	d30c      	bcc.n	8012fb2 <_txm_module_manager_tx_thread_entry_exit_notify_dispatch+0x5a>
 8012f98:	68bb      	ldr	r3, [r7, #8]
 8012f9a:	f103 02e8 	add.w	r2, r3, #232	; 0xe8
 8012f9e:	68fb      	ldr	r3, [r7, #12]
 8012fa0:	69db      	ldr	r3, [r3, #28]
 8012fa2:	3301      	adds	r3, #1
 8012fa4:	429a      	cmp	r2, r3
 8012fa6:	d804      	bhi.n	8012fb2 <_txm_module_manager_tx_thread_entry_exit_notify_dispatch+0x5a>
 8012fa8:	68bb      	ldr	r3, [r7, #8]
 8012faa:	2b00      	cmp	r3, #0
 8012fac:	d001      	beq.n	8012fb2 <_txm_module_manager_tx_thread_entry_exit_notify_dispatch+0x5a>
            return(TXM_MODULE_INVALID_MEMORY);
 8012fae:	23f4      	movs	r3, #244	; 0xf4
 8012fb0:	e027      	b.n	8013002 <_txm_module_manager_tx_thread_entry_exit_notify_dispatch+0xaa>

        /* Since we need to write to the object, ensure it's valid.  */
        if ((thread_ptr == TX_NULL) || (thread_ptr -> tx_thread_id != TX_THREAD_ID))
 8012fb2:	69bb      	ldr	r3, [r7, #24]
 8012fb4:	2b00      	cmp	r3, #0
 8012fb6:	d004      	beq.n	8012fc2 <_txm_module_manager_tx_thread_entry_exit_notify_dispatch+0x6a>
 8012fb8:	69bb      	ldr	r3, [r7, #24]
 8012fba:	681b      	ldr	r3, [r3, #0]
 8012fbc:	4a13      	ldr	r2, [pc, #76]	; (801300c <_txm_module_manager_tx_thread_entry_exit_notify_dispatch+0xb4>)
 8012fbe:	4293      	cmp	r3, r2
 8012fc0:	d001      	beq.n	8012fc6 <_txm_module_manager_tx_thread_entry_exit_notify_dispatch+0x6e>
            return(TX_THREAD_ERROR);
 8012fc2:	230e      	movs	r3, #14
 8012fc4:	e01d      	b.n	8013002 <_txm_module_manager_tx_thread_entry_exit_notify_dispatch+0xaa>

        /* Ensure this thread is from the module trying to set the callback.  */
        if (thread_ptr -> tx_thread_module_instance_ptr != module_instance)
 8012fc6:	69bb      	ldr	r3, [r7, #24]
 8012fc8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8012fcc:	68fa      	ldr	r2, [r7, #12]
 8012fce:	429a      	cmp	r2, r3
 8012fd0:	d001      	beq.n	8012fd6 <_txm_module_manager_tx_thread_entry_exit_notify_dispatch+0x7e>
            return(TXM_MODULE_INVALID);
 8012fd2:	23f2      	movs	r3, #242	; 0xf2
 8012fd4:	e015      	b.n	8013002 <_txm_module_manager_tx_thread_entry_exit_notify_dispatch+0xaa>
    }

    /* Is it a disable request?  */
    if ((void *) param_1 == TX_NULL)
 8012fd6:	687b      	ldr	r3, [r7, #4]
 8012fd8:	2b00      	cmp	r3, #0
 8012fda:	d102      	bne.n	8012fe2 <_txm_module_manager_tx_thread_entry_exit_notify_dispatch+0x8a>
    {

        /* Clear the callback.  */
        thread_entry_exit_notify = (VOID (*)(TX_THREAD *, UINT)) TX_NULL;
 8012fdc:	2300      	movs	r3, #0
 8012fde:	61fb      	str	r3, [r7, #28]
 8012fe0:	e008      	b.n	8012ff4 <_txm_module_manager_tx_thread_entry_exit_notify_dispatch+0x9c>
    }
    else
    {

        /* Setup trampoline values.  */
        thread_entry_info_ptr = (TXM_MODULE_THREAD_ENTRY_INFO *) thread_ptr -> tx_thread_module_entry_info_ptr;
 8012fe2:	69bb      	ldr	r3, [r7, #24]
 8012fe4:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8012fe8:	617b      	str	r3, [r7, #20]
        thread_entry_info_ptr -> txm_module_thread_entry_info_exit_notify = (VOID (*)(TX_THREAD *, UINT)) param_1;
 8012fea:	687a      	ldr	r2, [r7, #4]
 8012fec:	697b      	ldr	r3, [r7, #20]
 8012fee:	619a      	str	r2, [r3, #24]
        thread_entry_exit_notify = _txm_module_manager_thread_notify_trampoline;
 8012ff0:	4b07      	ldr	r3, [pc, #28]	; (8013010 <_txm_module_manager_tx_thread_entry_exit_notify_dispatch+0xb8>)
 8012ff2:	61fb      	str	r3, [r7, #28]
    }

    return_value = (ALIGN_TYPE) _txe_thread_entry_exit_notify(
 8012ff4:	68bb      	ldr	r3, [r7, #8]
 8012ff6:	69f9      	ldr	r1, [r7, #28]
 8012ff8:	4618      	mov	r0, r3
 8012ffa:	f7fc f97d 	bl	800f2f8 <_txe_thread_entry_exit_notify>
 8012ffe:	6138      	str	r0, [r7, #16]
        (TX_THREAD *) param_0,
        (VOID (*)(TX_THREAD *notify_thread_ptr, UINT type)) thread_entry_exit_notify
    );
    return(return_value);
 8013000:	693b      	ldr	r3, [r7, #16]
}
 8013002:	4618      	mov	r0, r3
 8013004:	3720      	adds	r7, #32
 8013006:	46bd      	mov	sp, r7
 8013008:	bd80      	pop	{r7, pc}
 801300a:	bf00      	nop
 801300c:	54485244 	.word	0x54485244
 8013010:	08016259 	.word	0x08016259

08013014 <_txm_module_manager_tx_thread_identify_dispatch>:
#endif

#ifndef TXM_THREAD_IDENTIFY_CALL_NOT_USED
/* TX_THREAD *_tx_thread_identify(); */
static ALIGN_TYPE _txm_module_manager_tx_thread_identify_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8013014:	b580      	push	{r7, lr}
 8013016:	b086      	sub	sp, #24
 8013018:	af00      	add	r7, sp, #0
 801301a:	60f8      	str	r0, [r7, #12]
 801301c:	60b9      	str	r1, [r7, #8]
 801301e:	607a      	str	r2, [r7, #4]
 8013020:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    return_value = (ALIGN_TYPE) _tx_thread_identify();
 8013022:	f7f8 fcf3 	bl	800ba0c <_tx_thread_identify>
 8013026:	4603      	mov	r3, r0
 8013028:	617b      	str	r3, [r7, #20]
    return(return_value);
 801302a:	697b      	ldr	r3, [r7, #20]
}
 801302c:	4618      	mov	r0, r3
 801302e:	3718      	adds	r7, #24
 8013030:	46bd      	mov	sp, r7
 8013032:	bd80      	pop	{r7, pc}

08013034 <_txm_module_manager_tx_thread_info_get_dispatch>:
    ULONG *time_slice, -> extra_parameters[4]
    TX_THREAD **next_thread, -> extra_parameters[5]
    TX_THREAD **next_suspended_thread -> extra_parameters[6]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_thread_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8013034:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013036:	b08d      	sub	sp, #52	; 0x34
 8013038:	af06      	add	r7, sp, #24
 801303a:	60f8      	str	r0, [r7, #12]
 801303c:	60b9      	str	r1, [r7, #8]
 801303e:	607a      	str	r2, [r7, #4]
 8013040:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8013042:	68fb      	ldr	r3, [r7, #12]
 8013044:	68db      	ldr	r3, [r3, #12]
 8013046:	f003 0302 	and.w	r3, r3, #2
 801304a:	2b00      	cmp	r3, #0
 801304c:	f000 80b3 	beq.w	80131b6 <_txm_module_manager_tx_thread_info_get_dispatch+0x182>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_THREAD)))
 8013050:	22e8      	movs	r2, #232	; 0xe8
 8013052:	68b9      	ldr	r1, [r7, #8]
 8013054:	68f8      	ldr	r0, [r7, #12]
 8013056:	f001 fef7 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801305a:	4603      	mov	r3, r0
 801305c:	2b00      	cmp	r3, #0
 801305e:	d111      	bne.n	8013084 <_txm_module_manager_tx_thread_info_get_dispatch+0x50>
 8013060:	68bb      	ldr	r3, [r7, #8]
 8013062:	f113 0fe9 	cmn.w	r3, #233	; 0xe9
 8013066:	d812      	bhi.n	801308e <_txm_module_manager_tx_thread_info_get_dispatch+0x5a>
 8013068:	68fb      	ldr	r3, [r7, #12]
 801306a:	699b      	ldr	r3, [r3, #24]
 801306c:	461a      	mov	r2, r3
 801306e:	68bb      	ldr	r3, [r7, #8]
 8013070:	4293      	cmp	r3, r2
 8013072:	d30c      	bcc.n	801308e <_txm_module_manager_tx_thread_info_get_dispatch+0x5a>
 8013074:	68bb      	ldr	r3, [r7, #8]
 8013076:	f103 02e8 	add.w	r2, r3, #232	; 0xe8
 801307a:	68fb      	ldr	r3, [r7, #12]
 801307c:	69db      	ldr	r3, [r3, #28]
 801307e:	3301      	adds	r3, #1
 8013080:	429a      	cmp	r2, r3
 8013082:	d804      	bhi.n	801308e <_txm_module_manager_tx_thread_info_get_dispatch+0x5a>
 8013084:	68bb      	ldr	r3, [r7, #8]
 8013086:	2b00      	cmp	r3, #0
 8013088:	d001      	beq.n	801308e <_txm_module_manager_tx_thread_info_get_dispatch+0x5a>
            return(TXM_MODULE_INVALID_MEMORY);
 801308a:	23f4      	movs	r3, #244	; 0xf4
 801308c:	e0ba      	b.n	8013204 <_txm_module_manager_tx_thread_info_get_dispatch+0x1d0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(CHAR *)))
 801308e:	2204      	movs	r2, #4
 8013090:	6879      	ldr	r1, [r7, #4]
 8013092:	68f8      	ldr	r0, [r7, #12]
 8013094:	f001 fed8 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013098:	4603      	mov	r3, r0
 801309a:	2b00      	cmp	r3, #0
 801309c:	d104      	bne.n	80130a8 <_txm_module_manager_tx_thread_info_get_dispatch+0x74>
 801309e:	687b      	ldr	r3, [r7, #4]
 80130a0:	2b00      	cmp	r3, #0
 80130a2:	d001      	beq.n	80130a8 <_txm_module_manager_tx_thread_info_get_dispatch+0x74>
            return(TXM_MODULE_INVALID_MEMORY);
 80130a4:	23f4      	movs	r3, #244	; 0xf4
 80130a6:	e0ad      	b.n	8013204 <_txm_module_manager_tx_thread_info_get_dispatch+0x1d0>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[7])))
 80130a8:	683b      	ldr	r3, [r7, #0]
 80130aa:	221c      	movs	r2, #28
 80130ac:	4619      	mov	r1, r3
 80130ae:	68f8      	ldr	r0, [r7, #12]
 80130b0:	f001 feca 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80130b4:	4603      	mov	r3, r0
 80130b6:	2b00      	cmp	r3, #0
 80130b8:	d101      	bne.n	80130be <_txm_module_manager_tx_thread_info_get_dispatch+0x8a>
            return(TXM_MODULE_INVALID_MEMORY);
 80130ba:	23f4      	movs	r3, #244	; 0xf4
 80130bc:	e0a2      	b.n	8013204 <_txm_module_manager_tx_thread_info_get_dispatch+0x1d0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(UINT)))
 80130be:	683b      	ldr	r3, [r7, #0]
 80130c0:	681b      	ldr	r3, [r3, #0]
 80130c2:	2204      	movs	r2, #4
 80130c4:	4619      	mov	r1, r3
 80130c6:	68f8      	ldr	r0, [r7, #12]
 80130c8:	f001 febe 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80130cc:	4603      	mov	r3, r0
 80130ce:	2b00      	cmp	r3, #0
 80130d0:	d105      	bne.n	80130de <_txm_module_manager_tx_thread_info_get_dispatch+0xaa>
 80130d2:	683b      	ldr	r3, [r7, #0]
 80130d4:	681b      	ldr	r3, [r3, #0]
 80130d6:	2b00      	cmp	r3, #0
 80130d8:	d001      	beq.n	80130de <_txm_module_manager_tx_thread_info_get_dispatch+0xaa>
            return(TXM_MODULE_INVALID_MEMORY);
 80130da:	23f4      	movs	r3, #244	; 0xf4
 80130dc:	e092      	b.n	8013204 <_txm_module_manager_tx_thread_info_get_dispatch+0x1d0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 80130de:	683b      	ldr	r3, [r7, #0]
 80130e0:	3304      	adds	r3, #4
 80130e2:	681b      	ldr	r3, [r3, #0]
 80130e4:	2204      	movs	r2, #4
 80130e6:	4619      	mov	r1, r3
 80130e8:	68f8      	ldr	r0, [r7, #12]
 80130ea:	f001 fead 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80130ee:	4603      	mov	r3, r0
 80130f0:	2b00      	cmp	r3, #0
 80130f2:	d106      	bne.n	8013102 <_txm_module_manager_tx_thread_info_get_dispatch+0xce>
 80130f4:	683b      	ldr	r3, [r7, #0]
 80130f6:	3304      	adds	r3, #4
 80130f8:	681b      	ldr	r3, [r3, #0]
 80130fa:	2b00      	cmp	r3, #0
 80130fc:	d001      	beq.n	8013102 <_txm_module_manager_tx_thread_info_get_dispatch+0xce>
            return(TXM_MODULE_INVALID_MEMORY);
 80130fe:	23f4      	movs	r3, #244	; 0xf4
 8013100:	e080      	b.n	8013204 <_txm_module_manager_tx_thread_info_get_dispatch+0x1d0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(UINT)))
 8013102:	683b      	ldr	r3, [r7, #0]
 8013104:	3308      	adds	r3, #8
 8013106:	681b      	ldr	r3, [r3, #0]
 8013108:	2204      	movs	r2, #4
 801310a:	4619      	mov	r1, r3
 801310c:	68f8      	ldr	r0, [r7, #12]
 801310e:	f001 fe9b 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013112:	4603      	mov	r3, r0
 8013114:	2b00      	cmp	r3, #0
 8013116:	d106      	bne.n	8013126 <_txm_module_manager_tx_thread_info_get_dispatch+0xf2>
 8013118:	683b      	ldr	r3, [r7, #0]
 801311a:	3308      	adds	r3, #8
 801311c:	681b      	ldr	r3, [r3, #0]
 801311e:	2b00      	cmp	r3, #0
 8013120:	d001      	beq.n	8013126 <_txm_module_manager_tx_thread_info_get_dispatch+0xf2>
            return(TXM_MODULE_INVALID_MEMORY);
 8013122:	23f4      	movs	r3, #244	; 0xf4
 8013124:	e06e      	b.n	8013204 <_txm_module_manager_tx_thread_info_get_dispatch+0x1d0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[3], sizeof(UINT)))
 8013126:	683b      	ldr	r3, [r7, #0]
 8013128:	330c      	adds	r3, #12
 801312a:	681b      	ldr	r3, [r3, #0]
 801312c:	2204      	movs	r2, #4
 801312e:	4619      	mov	r1, r3
 8013130:	68f8      	ldr	r0, [r7, #12]
 8013132:	f001 fe89 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013136:	4603      	mov	r3, r0
 8013138:	2b00      	cmp	r3, #0
 801313a:	d106      	bne.n	801314a <_txm_module_manager_tx_thread_info_get_dispatch+0x116>
 801313c:	683b      	ldr	r3, [r7, #0]
 801313e:	330c      	adds	r3, #12
 8013140:	681b      	ldr	r3, [r3, #0]
 8013142:	2b00      	cmp	r3, #0
 8013144:	d001      	beq.n	801314a <_txm_module_manager_tx_thread_info_get_dispatch+0x116>
            return(TXM_MODULE_INVALID_MEMORY);
 8013146:	23f4      	movs	r3, #244	; 0xf4
 8013148:	e05c      	b.n	8013204 <_txm_module_manager_tx_thread_info_get_dispatch+0x1d0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[4], sizeof(ULONG)))
 801314a:	683b      	ldr	r3, [r7, #0]
 801314c:	3310      	adds	r3, #16
 801314e:	681b      	ldr	r3, [r3, #0]
 8013150:	2204      	movs	r2, #4
 8013152:	4619      	mov	r1, r3
 8013154:	68f8      	ldr	r0, [r7, #12]
 8013156:	f001 fe77 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801315a:	4603      	mov	r3, r0
 801315c:	2b00      	cmp	r3, #0
 801315e:	d106      	bne.n	801316e <_txm_module_manager_tx_thread_info_get_dispatch+0x13a>
 8013160:	683b      	ldr	r3, [r7, #0]
 8013162:	3310      	adds	r3, #16
 8013164:	681b      	ldr	r3, [r3, #0]
 8013166:	2b00      	cmp	r3, #0
 8013168:	d001      	beq.n	801316e <_txm_module_manager_tx_thread_info_get_dispatch+0x13a>
            return(TXM_MODULE_INVALID_MEMORY);
 801316a:	23f4      	movs	r3, #244	; 0xf4
 801316c:	e04a      	b.n	8013204 <_txm_module_manager_tx_thread_info_get_dispatch+0x1d0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[5], sizeof(TX_THREAD *)))
 801316e:	683b      	ldr	r3, [r7, #0]
 8013170:	3314      	adds	r3, #20
 8013172:	681b      	ldr	r3, [r3, #0]
 8013174:	2204      	movs	r2, #4
 8013176:	4619      	mov	r1, r3
 8013178:	68f8      	ldr	r0, [r7, #12]
 801317a:	f001 fe65 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801317e:	4603      	mov	r3, r0
 8013180:	2b00      	cmp	r3, #0
 8013182:	d106      	bne.n	8013192 <_txm_module_manager_tx_thread_info_get_dispatch+0x15e>
 8013184:	683b      	ldr	r3, [r7, #0]
 8013186:	3314      	adds	r3, #20
 8013188:	681b      	ldr	r3, [r3, #0]
 801318a:	2b00      	cmp	r3, #0
 801318c:	d001      	beq.n	8013192 <_txm_module_manager_tx_thread_info_get_dispatch+0x15e>
            return(TXM_MODULE_INVALID_MEMORY);
 801318e:	23f4      	movs	r3, #244	; 0xf4
 8013190:	e038      	b.n	8013204 <_txm_module_manager_tx_thread_info_get_dispatch+0x1d0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[6], sizeof(TX_THREAD *)))
 8013192:	683b      	ldr	r3, [r7, #0]
 8013194:	3318      	adds	r3, #24
 8013196:	681b      	ldr	r3, [r3, #0]
 8013198:	2204      	movs	r2, #4
 801319a:	4619      	mov	r1, r3
 801319c:	68f8      	ldr	r0, [r7, #12]
 801319e:	f001 fe53 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80131a2:	4603      	mov	r3, r0
 80131a4:	2b00      	cmp	r3, #0
 80131a6:	d106      	bne.n	80131b6 <_txm_module_manager_tx_thread_info_get_dispatch+0x182>
 80131a8:	683b      	ldr	r3, [r7, #0]
 80131aa:	3318      	adds	r3, #24
 80131ac:	681b      	ldr	r3, [r3, #0]
 80131ae:	2b00      	cmp	r3, #0
 80131b0:	d001      	beq.n	80131b6 <_txm_module_manager_tx_thread_info_get_dispatch+0x182>
            return(TXM_MODULE_INVALID_MEMORY);
 80131b2:	23f4      	movs	r3, #244	; 0xf4
 80131b4:	e026      	b.n	8013204 <_txm_module_manager_tx_thread_info_get_dispatch+0x1d0>
    }

    return_value = (ALIGN_TYPE) _txe_thread_info_get(
 80131b6:	68b8      	ldr	r0, [r7, #8]
 80131b8:	6879      	ldr	r1, [r7, #4]
        (TX_THREAD *) param_0,
        (CHAR **) param_1,
        (UINT *) extra_parameters[0],
 80131ba:	683b      	ldr	r3, [r7, #0]
 80131bc:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_thread_info_get(
 80131be:	469c      	mov	ip, r3
        (ULONG *) extra_parameters[1],
 80131c0:	683b      	ldr	r3, [r7, #0]
 80131c2:	3304      	adds	r3, #4
 80131c4:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_thread_info_get(
 80131c6:	469e      	mov	lr, r3
        (UINT *) extra_parameters[2],
 80131c8:	683b      	ldr	r3, [r7, #0]
 80131ca:	3308      	adds	r3, #8
 80131cc:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_thread_info_get(
 80131ce:	461a      	mov	r2, r3
        (UINT *) extra_parameters[3],
 80131d0:	683b      	ldr	r3, [r7, #0]
 80131d2:	330c      	adds	r3, #12
 80131d4:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_thread_info_get(
 80131d6:	461c      	mov	r4, r3
        (ULONG *) extra_parameters[4],
 80131d8:	683b      	ldr	r3, [r7, #0]
 80131da:	3310      	adds	r3, #16
 80131dc:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_thread_info_get(
 80131de:	461d      	mov	r5, r3
        (TX_THREAD **) extra_parameters[5],
 80131e0:	683b      	ldr	r3, [r7, #0]
 80131e2:	3314      	adds	r3, #20
 80131e4:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_thread_info_get(
 80131e6:	461e      	mov	r6, r3
        (TX_THREAD **) extra_parameters[6]
 80131e8:	683b      	ldr	r3, [r7, #0]
 80131ea:	3318      	adds	r3, #24
 80131ec:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_thread_info_get(
 80131ee:	9304      	str	r3, [sp, #16]
 80131f0:	9603      	str	r6, [sp, #12]
 80131f2:	9502      	str	r5, [sp, #8]
 80131f4:	9401      	str	r4, [sp, #4]
 80131f6:	9200      	str	r2, [sp, #0]
 80131f8:	4673      	mov	r3, lr
 80131fa:	4662      	mov	r2, ip
 80131fc:	f7fc f89c 	bl	800f338 <_txe_thread_info_get>
 8013200:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 8013202:	697b      	ldr	r3, [r7, #20]
}
 8013204:	4618      	mov	r0, r3
 8013206:	371c      	adds	r7, #28
 8013208:	46bd      	mov	sp, r7
 801320a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801320c <_txm_module_manager_tx_thread_interrupt_control_dispatch>:
#ifndef TXM_THREAD_INTERRUPT_CONTROL_CALL_NOT_USED
/* UINT _tx_thread_interrupt_control(
    UINT new_posture -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_thread_interrupt_control_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 801320c:	b580      	push	{r7, lr}
 801320e:	b084      	sub	sp, #16
 8013210:	af00      	add	r7, sp, #0
 8013212:	6078      	str	r0, [r7, #4]
 8013214:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_USER_MODE)
 8013216:	687b      	ldr	r3, [r7, #4]
 8013218:	68db      	ldr	r3, [r3, #12]
 801321a:	f003 0301 	and.w	r3, r3, #1
 801321e:	2b00      	cmp	r3, #0
 8013220:	d001      	beq.n	8013226 <_txm_module_manager_tx_thread_interrupt_control_dispatch+0x1a>
        return(TXM_MODULE_INVALID_PROPERTIES);
 8013222:	23f3      	movs	r3, #243	; 0xf3
 8013224:	e004      	b.n	8013230 <_txm_module_manager_tx_thread_interrupt_control_dispatch+0x24>

    return_value = (ALIGN_TYPE) _tx_thread_interrupt_control(
 8013226:	6838      	ldr	r0, [r7, #0]
 8013228:	f7ed f8c2 	bl	80003b0 <_tx_thread_interrupt_control>
 801322c:	60f8      	str	r0, [r7, #12]
        (UINT) param_0
    );
    return(return_value);
 801322e:	68fb      	ldr	r3, [r7, #12]
}
 8013230:	4618      	mov	r0, r3
 8013232:	3710      	adds	r7, #16
 8013234:	46bd      	mov	sp, r7
 8013236:	bd80      	pop	{r7, pc}

08013238 <_txm_module_manager_tx_thread_performance_info_get_dispatch>:
    ULONG *timeouts, -> extra_parameters[6]
    ULONG *wait_aborts, -> extra_parameters[7]
    TX_THREAD **last_preempted_by -> extra_parameters[8]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_thread_performance_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8013238:	b5f0      	push	{r4, r5, r6, r7, lr}
 801323a:	b091      	sub	sp, #68	; 0x44
 801323c:	af08      	add	r7, sp, #32
 801323e:	6178      	str	r0, [r7, #20]
 8013240:	6139      	str	r1, [r7, #16]
 8013242:	60fa      	str	r2, [r7, #12]
 8013244:	60bb      	str	r3, [r7, #8]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8013246:	697b      	ldr	r3, [r7, #20]
 8013248:	68db      	ldr	r3, [r3, #12]
 801324a:	f003 0302 	and.w	r3, r3, #2
 801324e:	2b00      	cmp	r3, #0
 8013250:	f000 80d7 	beq.w	8013402 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x1ca>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_THREAD)))
 8013254:	22e8      	movs	r2, #232	; 0xe8
 8013256:	6939      	ldr	r1, [r7, #16]
 8013258:	6978      	ldr	r0, [r7, #20]
 801325a:	f001 fdf5 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801325e:	4603      	mov	r3, r0
 8013260:	2b00      	cmp	r3, #0
 8013262:	d111      	bne.n	8013288 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x50>
 8013264:	693b      	ldr	r3, [r7, #16]
 8013266:	f113 0fe9 	cmn.w	r3, #233	; 0xe9
 801326a:	d812      	bhi.n	8013292 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x5a>
 801326c:	697b      	ldr	r3, [r7, #20]
 801326e:	699b      	ldr	r3, [r3, #24]
 8013270:	461a      	mov	r2, r3
 8013272:	693b      	ldr	r3, [r7, #16]
 8013274:	4293      	cmp	r3, r2
 8013276:	d30c      	bcc.n	8013292 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x5a>
 8013278:	693b      	ldr	r3, [r7, #16]
 801327a:	f103 02e8 	add.w	r2, r3, #232	; 0xe8
 801327e:	697b      	ldr	r3, [r7, #20]
 8013280:	69db      	ldr	r3, [r3, #28]
 8013282:	3301      	adds	r3, #1
 8013284:	429a      	cmp	r2, r3
 8013286:	d804      	bhi.n	8013292 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x5a>
 8013288:	693b      	ldr	r3, [r7, #16]
 801328a:	2b00      	cmp	r3, #0
 801328c:	d001      	beq.n	8013292 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x5a>
            return(TXM_MODULE_INVALID_MEMORY);
 801328e:	23f4      	movs	r3, #244	; 0xf4
 8013290:	e0ea      	b.n	8013468 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x230>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(ULONG)))
 8013292:	2204      	movs	r2, #4
 8013294:	68f9      	ldr	r1, [r7, #12]
 8013296:	6978      	ldr	r0, [r7, #20]
 8013298:	f001 fdd6 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801329c:	4603      	mov	r3, r0
 801329e:	2b00      	cmp	r3, #0
 80132a0:	d104      	bne.n	80132ac <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x74>
 80132a2:	68fb      	ldr	r3, [r7, #12]
 80132a4:	2b00      	cmp	r3, #0
 80132a6:	d001      	beq.n	80132ac <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x74>
            return(TXM_MODULE_INVALID_MEMORY);
 80132a8:	23f4      	movs	r3, #244	; 0xf4
 80132aa:	e0dd      	b.n	8013468 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x230>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[9])))
 80132ac:	68bb      	ldr	r3, [r7, #8]
 80132ae:	2224      	movs	r2, #36	; 0x24
 80132b0:	4619      	mov	r1, r3
 80132b2:	6978      	ldr	r0, [r7, #20]
 80132b4:	f001 fdc8 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80132b8:	4603      	mov	r3, r0
 80132ba:	2b00      	cmp	r3, #0
 80132bc:	d101      	bne.n	80132c2 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x8a>
            return(TXM_MODULE_INVALID_MEMORY);
 80132be:	23f4      	movs	r3, #244	; 0xf4
 80132c0:	e0d2      	b.n	8013468 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x230>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 80132c2:	68bb      	ldr	r3, [r7, #8]
 80132c4:	681b      	ldr	r3, [r3, #0]
 80132c6:	2204      	movs	r2, #4
 80132c8:	4619      	mov	r1, r3
 80132ca:	6978      	ldr	r0, [r7, #20]
 80132cc:	f001 fdbc 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80132d0:	4603      	mov	r3, r0
 80132d2:	2b00      	cmp	r3, #0
 80132d4:	d105      	bne.n	80132e2 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0xaa>
 80132d6:	68bb      	ldr	r3, [r7, #8]
 80132d8:	681b      	ldr	r3, [r3, #0]
 80132da:	2b00      	cmp	r3, #0
 80132dc:	d001      	beq.n	80132e2 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0xaa>
            return(TXM_MODULE_INVALID_MEMORY);
 80132de:	23f4      	movs	r3, #244	; 0xf4
 80132e0:	e0c2      	b.n	8013468 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x230>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 80132e2:	68bb      	ldr	r3, [r7, #8]
 80132e4:	3304      	adds	r3, #4
 80132e6:	681b      	ldr	r3, [r3, #0]
 80132e8:	2204      	movs	r2, #4
 80132ea:	4619      	mov	r1, r3
 80132ec:	6978      	ldr	r0, [r7, #20]
 80132ee:	f001 fdab 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80132f2:	4603      	mov	r3, r0
 80132f4:	2b00      	cmp	r3, #0
 80132f6:	d106      	bne.n	8013306 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0xce>
 80132f8:	68bb      	ldr	r3, [r7, #8]
 80132fa:	3304      	adds	r3, #4
 80132fc:	681b      	ldr	r3, [r3, #0]
 80132fe:	2b00      	cmp	r3, #0
 8013300:	d001      	beq.n	8013306 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0xce>
            return(TXM_MODULE_INVALID_MEMORY);
 8013302:	23f4      	movs	r3, #244	; 0xf4
 8013304:	e0b0      	b.n	8013468 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x230>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(ULONG)))
 8013306:	68bb      	ldr	r3, [r7, #8]
 8013308:	3308      	adds	r3, #8
 801330a:	681b      	ldr	r3, [r3, #0]
 801330c:	2204      	movs	r2, #4
 801330e:	4619      	mov	r1, r3
 8013310:	6978      	ldr	r0, [r7, #20]
 8013312:	f001 fd99 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013316:	4603      	mov	r3, r0
 8013318:	2b00      	cmp	r3, #0
 801331a:	d106      	bne.n	801332a <_txm_module_manager_tx_thread_performance_info_get_dispatch+0xf2>
 801331c:	68bb      	ldr	r3, [r7, #8]
 801331e:	3308      	adds	r3, #8
 8013320:	681b      	ldr	r3, [r3, #0]
 8013322:	2b00      	cmp	r3, #0
 8013324:	d001      	beq.n	801332a <_txm_module_manager_tx_thread_performance_info_get_dispatch+0xf2>
            return(TXM_MODULE_INVALID_MEMORY);
 8013326:	23f4      	movs	r3, #244	; 0xf4
 8013328:	e09e      	b.n	8013468 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x230>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[3], sizeof(ULONG)))
 801332a:	68bb      	ldr	r3, [r7, #8]
 801332c:	330c      	adds	r3, #12
 801332e:	681b      	ldr	r3, [r3, #0]
 8013330:	2204      	movs	r2, #4
 8013332:	4619      	mov	r1, r3
 8013334:	6978      	ldr	r0, [r7, #20]
 8013336:	f001 fd87 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801333a:	4603      	mov	r3, r0
 801333c:	2b00      	cmp	r3, #0
 801333e:	d106      	bne.n	801334e <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x116>
 8013340:	68bb      	ldr	r3, [r7, #8]
 8013342:	330c      	adds	r3, #12
 8013344:	681b      	ldr	r3, [r3, #0]
 8013346:	2b00      	cmp	r3, #0
 8013348:	d001      	beq.n	801334e <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x116>
            return(TXM_MODULE_INVALID_MEMORY);
 801334a:	23f4      	movs	r3, #244	; 0xf4
 801334c:	e08c      	b.n	8013468 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x230>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[4], sizeof(ULONG)))
 801334e:	68bb      	ldr	r3, [r7, #8]
 8013350:	3310      	adds	r3, #16
 8013352:	681b      	ldr	r3, [r3, #0]
 8013354:	2204      	movs	r2, #4
 8013356:	4619      	mov	r1, r3
 8013358:	6978      	ldr	r0, [r7, #20]
 801335a:	f001 fd75 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801335e:	4603      	mov	r3, r0
 8013360:	2b00      	cmp	r3, #0
 8013362:	d106      	bne.n	8013372 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x13a>
 8013364:	68bb      	ldr	r3, [r7, #8]
 8013366:	3310      	adds	r3, #16
 8013368:	681b      	ldr	r3, [r3, #0]
 801336a:	2b00      	cmp	r3, #0
 801336c:	d001      	beq.n	8013372 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x13a>
            return(TXM_MODULE_INVALID_MEMORY);
 801336e:	23f4      	movs	r3, #244	; 0xf4
 8013370:	e07a      	b.n	8013468 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x230>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[5], sizeof(ULONG)))
 8013372:	68bb      	ldr	r3, [r7, #8]
 8013374:	3314      	adds	r3, #20
 8013376:	681b      	ldr	r3, [r3, #0]
 8013378:	2204      	movs	r2, #4
 801337a:	4619      	mov	r1, r3
 801337c:	6978      	ldr	r0, [r7, #20]
 801337e:	f001 fd63 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013382:	4603      	mov	r3, r0
 8013384:	2b00      	cmp	r3, #0
 8013386:	d106      	bne.n	8013396 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x15e>
 8013388:	68bb      	ldr	r3, [r7, #8]
 801338a:	3314      	adds	r3, #20
 801338c:	681b      	ldr	r3, [r3, #0]
 801338e:	2b00      	cmp	r3, #0
 8013390:	d001      	beq.n	8013396 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x15e>
            return(TXM_MODULE_INVALID_MEMORY);
 8013392:	23f4      	movs	r3, #244	; 0xf4
 8013394:	e068      	b.n	8013468 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x230>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[6], sizeof(ULONG)))
 8013396:	68bb      	ldr	r3, [r7, #8]
 8013398:	3318      	adds	r3, #24
 801339a:	681b      	ldr	r3, [r3, #0]
 801339c:	2204      	movs	r2, #4
 801339e:	4619      	mov	r1, r3
 80133a0:	6978      	ldr	r0, [r7, #20]
 80133a2:	f001 fd51 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80133a6:	4603      	mov	r3, r0
 80133a8:	2b00      	cmp	r3, #0
 80133aa:	d106      	bne.n	80133ba <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x182>
 80133ac:	68bb      	ldr	r3, [r7, #8]
 80133ae:	3318      	adds	r3, #24
 80133b0:	681b      	ldr	r3, [r3, #0]
 80133b2:	2b00      	cmp	r3, #0
 80133b4:	d001      	beq.n	80133ba <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x182>
            return(TXM_MODULE_INVALID_MEMORY);
 80133b6:	23f4      	movs	r3, #244	; 0xf4
 80133b8:	e056      	b.n	8013468 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x230>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[7], sizeof(ULONG)))
 80133ba:	68bb      	ldr	r3, [r7, #8]
 80133bc:	331c      	adds	r3, #28
 80133be:	681b      	ldr	r3, [r3, #0]
 80133c0:	2204      	movs	r2, #4
 80133c2:	4619      	mov	r1, r3
 80133c4:	6978      	ldr	r0, [r7, #20]
 80133c6:	f001 fd3f 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80133ca:	4603      	mov	r3, r0
 80133cc:	2b00      	cmp	r3, #0
 80133ce:	d106      	bne.n	80133de <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x1a6>
 80133d0:	68bb      	ldr	r3, [r7, #8]
 80133d2:	331c      	adds	r3, #28
 80133d4:	681b      	ldr	r3, [r3, #0]
 80133d6:	2b00      	cmp	r3, #0
 80133d8:	d001      	beq.n	80133de <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x1a6>
            return(TXM_MODULE_INVALID_MEMORY);
 80133da:	23f4      	movs	r3, #244	; 0xf4
 80133dc:	e044      	b.n	8013468 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x230>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[8], sizeof(TX_THREAD *)))
 80133de:	68bb      	ldr	r3, [r7, #8]
 80133e0:	3320      	adds	r3, #32
 80133e2:	681b      	ldr	r3, [r3, #0]
 80133e4:	2204      	movs	r2, #4
 80133e6:	4619      	mov	r1, r3
 80133e8:	6978      	ldr	r0, [r7, #20]
 80133ea:	f001 fd2d 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80133ee:	4603      	mov	r3, r0
 80133f0:	2b00      	cmp	r3, #0
 80133f2:	d106      	bne.n	8013402 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x1ca>
 80133f4:	68bb      	ldr	r3, [r7, #8]
 80133f6:	3320      	adds	r3, #32
 80133f8:	681b      	ldr	r3, [r3, #0]
 80133fa:	2b00      	cmp	r3, #0
 80133fc:	d001      	beq.n	8013402 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x1ca>
            return(TXM_MODULE_INVALID_MEMORY);
 80133fe:	23f4      	movs	r3, #244	; 0xf4
 8013400:	e032      	b.n	8013468 <_txm_module_manager_tx_thread_performance_info_get_dispatch+0x230>
    }

    return_value = (ALIGN_TYPE) _tx_thread_performance_info_get(
 8013402:	6938      	ldr	r0, [r7, #16]
 8013404:	68f9      	ldr	r1, [r7, #12]
        (TX_THREAD *) param_0,
        (ULONG *) param_1,
        (ULONG *) extra_parameters[0],
 8013406:	68bb      	ldr	r3, [r7, #8]
 8013408:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_thread_performance_info_get(
 801340a:	469c      	mov	ip, r3
        (ULONG *) extra_parameters[1],
 801340c:	68bb      	ldr	r3, [r7, #8]
 801340e:	3304      	adds	r3, #4
 8013410:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_thread_performance_info_get(
 8013412:	469e      	mov	lr, r3
        (ULONG *) extra_parameters[2],
 8013414:	68bb      	ldr	r3, [r7, #8]
 8013416:	3308      	adds	r3, #8
 8013418:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_thread_performance_info_get(
 801341a:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[3],
 801341c:	68bb      	ldr	r3, [r7, #8]
 801341e:	330c      	adds	r3, #12
 8013420:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_thread_performance_info_get(
 8013422:	461c      	mov	r4, r3
        (ULONG *) extra_parameters[4],
 8013424:	68bb      	ldr	r3, [r7, #8]
 8013426:	3310      	adds	r3, #16
 8013428:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_thread_performance_info_get(
 801342a:	461d      	mov	r5, r3
        (ULONG *) extra_parameters[5],
 801342c:	68bb      	ldr	r3, [r7, #8]
 801342e:	3314      	adds	r3, #20
 8013430:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_thread_performance_info_get(
 8013432:	461e      	mov	r6, r3
        (ULONG *) extra_parameters[6],
 8013434:	68bb      	ldr	r3, [r7, #8]
 8013436:	3318      	adds	r3, #24
 8013438:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_thread_performance_info_get(
 801343a:	607b      	str	r3, [r7, #4]
        (ULONG *) extra_parameters[7],
 801343c:	68bb      	ldr	r3, [r7, #8]
 801343e:	331c      	adds	r3, #28
 8013440:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_thread_performance_info_get(
 8013442:	603b      	str	r3, [r7, #0]
        (TX_THREAD **) extra_parameters[8]
 8013444:	68bb      	ldr	r3, [r7, #8]
 8013446:	3320      	adds	r3, #32
 8013448:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_thread_performance_info_get(
 801344a:	9306      	str	r3, [sp, #24]
 801344c:	683b      	ldr	r3, [r7, #0]
 801344e:	9305      	str	r3, [sp, #20]
 8013450:	687b      	ldr	r3, [r7, #4]
 8013452:	9304      	str	r3, [sp, #16]
 8013454:	9603      	str	r6, [sp, #12]
 8013456:	9502      	str	r5, [sp, #8]
 8013458:	9401      	str	r4, [sp, #4]
 801345a:	9200      	str	r2, [sp, #0]
 801345c:	4673      	mov	r3, lr
 801345e:	4662      	mov	r2, ip
 8013460:	f7f8 fb8a 	bl	800bb78 <_tx_thread_performance_info_get>
 8013464:	61f8      	str	r0, [r7, #28]
    );
    return(return_value);
 8013466:	69fb      	ldr	r3, [r7, #28]
}
 8013468:	4618      	mov	r0, r3
 801346a:	3724      	adds	r7, #36	; 0x24
 801346c:	46bd      	mov	sp, r7
 801346e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08013470 <_txm_module_manager_tx_thread_performance_system_info_get_dispatch>:
    ULONG *wait_aborts, -> extra_parameters[6]
    ULONG *non_idle_returns, -> extra_parameters[7]
    ULONG *idle_returns -> extra_parameters[8]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_thread_performance_system_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8013470:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013472:	b091      	sub	sp, #68	; 0x44
 8013474:	af08      	add	r7, sp, #32
 8013476:	6178      	str	r0, [r7, #20]
 8013478:	6139      	str	r1, [r7, #16]
 801347a:	60fa      	str	r2, [r7, #12]
 801347c:	60bb      	str	r3, [r7, #8]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 801347e:	697b      	ldr	r3, [r7, #20]
 8013480:	68db      	ldr	r3, [r3, #12]
 8013482:	f003 0302 	and.w	r3, r3, #2
 8013486:	2b00      	cmp	r3, #0
 8013488:	f000 80c5 	beq.w	8013616 <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x1a6>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_0, sizeof(ULONG)))
 801348c:	2204      	movs	r2, #4
 801348e:	6939      	ldr	r1, [r7, #16]
 8013490:	6978      	ldr	r0, [r7, #20]
 8013492:	f001 fcd9 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013496:	4603      	mov	r3, r0
 8013498:	2b00      	cmp	r3, #0
 801349a:	d104      	bne.n	80134a6 <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x36>
 801349c:	693b      	ldr	r3, [r7, #16]
 801349e:	2b00      	cmp	r3, #0
 80134a0:	d001      	beq.n	80134a6 <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x36>
            return(TXM_MODULE_INVALID_MEMORY);
 80134a2:	23f4      	movs	r3, #244	; 0xf4
 80134a4:	e0ea      	b.n	801367c <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x20c>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(ULONG)))
 80134a6:	2204      	movs	r2, #4
 80134a8:	68f9      	ldr	r1, [r7, #12]
 80134aa:	6978      	ldr	r0, [r7, #20]
 80134ac:	f001 fccc 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80134b0:	4603      	mov	r3, r0
 80134b2:	2b00      	cmp	r3, #0
 80134b4:	d104      	bne.n	80134c0 <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x50>
 80134b6:	68fb      	ldr	r3, [r7, #12]
 80134b8:	2b00      	cmp	r3, #0
 80134ba:	d001      	beq.n	80134c0 <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x50>
            return(TXM_MODULE_INVALID_MEMORY);
 80134bc:	23f4      	movs	r3, #244	; 0xf4
 80134be:	e0dd      	b.n	801367c <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x20c>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[9])))
 80134c0:	68bb      	ldr	r3, [r7, #8]
 80134c2:	2224      	movs	r2, #36	; 0x24
 80134c4:	4619      	mov	r1, r3
 80134c6:	6978      	ldr	r0, [r7, #20]
 80134c8:	f001 fcbe 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80134cc:	4603      	mov	r3, r0
 80134ce:	2b00      	cmp	r3, #0
 80134d0:	d101      	bne.n	80134d6 <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x66>
            return(TXM_MODULE_INVALID_MEMORY);
 80134d2:	23f4      	movs	r3, #244	; 0xf4
 80134d4:	e0d2      	b.n	801367c <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x20c>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 80134d6:	68bb      	ldr	r3, [r7, #8]
 80134d8:	681b      	ldr	r3, [r3, #0]
 80134da:	2204      	movs	r2, #4
 80134dc:	4619      	mov	r1, r3
 80134de:	6978      	ldr	r0, [r7, #20]
 80134e0:	f001 fcb2 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80134e4:	4603      	mov	r3, r0
 80134e6:	2b00      	cmp	r3, #0
 80134e8:	d105      	bne.n	80134f6 <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x86>
 80134ea:	68bb      	ldr	r3, [r7, #8]
 80134ec:	681b      	ldr	r3, [r3, #0]
 80134ee:	2b00      	cmp	r3, #0
 80134f0:	d001      	beq.n	80134f6 <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x86>
            return(TXM_MODULE_INVALID_MEMORY);
 80134f2:	23f4      	movs	r3, #244	; 0xf4
 80134f4:	e0c2      	b.n	801367c <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x20c>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 80134f6:	68bb      	ldr	r3, [r7, #8]
 80134f8:	3304      	adds	r3, #4
 80134fa:	681b      	ldr	r3, [r3, #0]
 80134fc:	2204      	movs	r2, #4
 80134fe:	4619      	mov	r1, r3
 8013500:	6978      	ldr	r0, [r7, #20]
 8013502:	f001 fca1 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013506:	4603      	mov	r3, r0
 8013508:	2b00      	cmp	r3, #0
 801350a:	d106      	bne.n	801351a <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0xaa>
 801350c:	68bb      	ldr	r3, [r7, #8]
 801350e:	3304      	adds	r3, #4
 8013510:	681b      	ldr	r3, [r3, #0]
 8013512:	2b00      	cmp	r3, #0
 8013514:	d001      	beq.n	801351a <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0xaa>
            return(TXM_MODULE_INVALID_MEMORY);
 8013516:	23f4      	movs	r3, #244	; 0xf4
 8013518:	e0b0      	b.n	801367c <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x20c>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(ULONG)))
 801351a:	68bb      	ldr	r3, [r7, #8]
 801351c:	3308      	adds	r3, #8
 801351e:	681b      	ldr	r3, [r3, #0]
 8013520:	2204      	movs	r2, #4
 8013522:	4619      	mov	r1, r3
 8013524:	6978      	ldr	r0, [r7, #20]
 8013526:	f001 fc8f 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801352a:	4603      	mov	r3, r0
 801352c:	2b00      	cmp	r3, #0
 801352e:	d106      	bne.n	801353e <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0xce>
 8013530:	68bb      	ldr	r3, [r7, #8]
 8013532:	3308      	adds	r3, #8
 8013534:	681b      	ldr	r3, [r3, #0]
 8013536:	2b00      	cmp	r3, #0
 8013538:	d001      	beq.n	801353e <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0xce>
            return(TXM_MODULE_INVALID_MEMORY);
 801353a:	23f4      	movs	r3, #244	; 0xf4
 801353c:	e09e      	b.n	801367c <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x20c>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[3], sizeof(ULONG)))
 801353e:	68bb      	ldr	r3, [r7, #8]
 8013540:	330c      	adds	r3, #12
 8013542:	681b      	ldr	r3, [r3, #0]
 8013544:	2204      	movs	r2, #4
 8013546:	4619      	mov	r1, r3
 8013548:	6978      	ldr	r0, [r7, #20]
 801354a:	f001 fc7d 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801354e:	4603      	mov	r3, r0
 8013550:	2b00      	cmp	r3, #0
 8013552:	d106      	bne.n	8013562 <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0xf2>
 8013554:	68bb      	ldr	r3, [r7, #8]
 8013556:	330c      	adds	r3, #12
 8013558:	681b      	ldr	r3, [r3, #0]
 801355a:	2b00      	cmp	r3, #0
 801355c:	d001      	beq.n	8013562 <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0xf2>
            return(TXM_MODULE_INVALID_MEMORY);
 801355e:	23f4      	movs	r3, #244	; 0xf4
 8013560:	e08c      	b.n	801367c <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x20c>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[4], sizeof(ULONG)))
 8013562:	68bb      	ldr	r3, [r7, #8]
 8013564:	3310      	adds	r3, #16
 8013566:	681b      	ldr	r3, [r3, #0]
 8013568:	2204      	movs	r2, #4
 801356a:	4619      	mov	r1, r3
 801356c:	6978      	ldr	r0, [r7, #20]
 801356e:	f001 fc6b 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013572:	4603      	mov	r3, r0
 8013574:	2b00      	cmp	r3, #0
 8013576:	d106      	bne.n	8013586 <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x116>
 8013578:	68bb      	ldr	r3, [r7, #8]
 801357a:	3310      	adds	r3, #16
 801357c:	681b      	ldr	r3, [r3, #0]
 801357e:	2b00      	cmp	r3, #0
 8013580:	d001      	beq.n	8013586 <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x116>
            return(TXM_MODULE_INVALID_MEMORY);
 8013582:	23f4      	movs	r3, #244	; 0xf4
 8013584:	e07a      	b.n	801367c <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x20c>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[5], sizeof(ULONG)))
 8013586:	68bb      	ldr	r3, [r7, #8]
 8013588:	3314      	adds	r3, #20
 801358a:	681b      	ldr	r3, [r3, #0]
 801358c:	2204      	movs	r2, #4
 801358e:	4619      	mov	r1, r3
 8013590:	6978      	ldr	r0, [r7, #20]
 8013592:	f001 fc59 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013596:	4603      	mov	r3, r0
 8013598:	2b00      	cmp	r3, #0
 801359a:	d106      	bne.n	80135aa <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x13a>
 801359c:	68bb      	ldr	r3, [r7, #8]
 801359e:	3314      	adds	r3, #20
 80135a0:	681b      	ldr	r3, [r3, #0]
 80135a2:	2b00      	cmp	r3, #0
 80135a4:	d001      	beq.n	80135aa <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x13a>
            return(TXM_MODULE_INVALID_MEMORY);
 80135a6:	23f4      	movs	r3, #244	; 0xf4
 80135a8:	e068      	b.n	801367c <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x20c>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[6], sizeof(ULONG)))
 80135aa:	68bb      	ldr	r3, [r7, #8]
 80135ac:	3318      	adds	r3, #24
 80135ae:	681b      	ldr	r3, [r3, #0]
 80135b0:	2204      	movs	r2, #4
 80135b2:	4619      	mov	r1, r3
 80135b4:	6978      	ldr	r0, [r7, #20]
 80135b6:	f001 fc47 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80135ba:	4603      	mov	r3, r0
 80135bc:	2b00      	cmp	r3, #0
 80135be:	d106      	bne.n	80135ce <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x15e>
 80135c0:	68bb      	ldr	r3, [r7, #8]
 80135c2:	3318      	adds	r3, #24
 80135c4:	681b      	ldr	r3, [r3, #0]
 80135c6:	2b00      	cmp	r3, #0
 80135c8:	d001      	beq.n	80135ce <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x15e>
            return(TXM_MODULE_INVALID_MEMORY);
 80135ca:	23f4      	movs	r3, #244	; 0xf4
 80135cc:	e056      	b.n	801367c <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x20c>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[7], sizeof(ULONG)))
 80135ce:	68bb      	ldr	r3, [r7, #8]
 80135d0:	331c      	adds	r3, #28
 80135d2:	681b      	ldr	r3, [r3, #0]
 80135d4:	2204      	movs	r2, #4
 80135d6:	4619      	mov	r1, r3
 80135d8:	6978      	ldr	r0, [r7, #20]
 80135da:	f001 fc35 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80135de:	4603      	mov	r3, r0
 80135e0:	2b00      	cmp	r3, #0
 80135e2:	d106      	bne.n	80135f2 <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x182>
 80135e4:	68bb      	ldr	r3, [r7, #8]
 80135e6:	331c      	adds	r3, #28
 80135e8:	681b      	ldr	r3, [r3, #0]
 80135ea:	2b00      	cmp	r3, #0
 80135ec:	d001      	beq.n	80135f2 <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x182>
            return(TXM_MODULE_INVALID_MEMORY);
 80135ee:	23f4      	movs	r3, #244	; 0xf4
 80135f0:	e044      	b.n	801367c <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x20c>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[8], sizeof(ULONG)))
 80135f2:	68bb      	ldr	r3, [r7, #8]
 80135f4:	3320      	adds	r3, #32
 80135f6:	681b      	ldr	r3, [r3, #0]
 80135f8:	2204      	movs	r2, #4
 80135fa:	4619      	mov	r1, r3
 80135fc:	6978      	ldr	r0, [r7, #20]
 80135fe:	f001 fc23 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013602:	4603      	mov	r3, r0
 8013604:	2b00      	cmp	r3, #0
 8013606:	d106      	bne.n	8013616 <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x1a6>
 8013608:	68bb      	ldr	r3, [r7, #8]
 801360a:	3320      	adds	r3, #32
 801360c:	681b      	ldr	r3, [r3, #0]
 801360e:	2b00      	cmp	r3, #0
 8013610:	d001      	beq.n	8013616 <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x1a6>
            return(TXM_MODULE_INVALID_MEMORY);
 8013612:	23f4      	movs	r3, #244	; 0xf4
 8013614:	e032      	b.n	801367c <_txm_module_manager_tx_thread_performance_system_info_get_dispatch+0x20c>
    }

    return_value = (ALIGN_TYPE) _tx_thread_performance_system_info_get(
 8013616:	6938      	ldr	r0, [r7, #16]
 8013618:	68f9      	ldr	r1, [r7, #12]
        (ULONG *) param_0,
        (ULONG *) param_1,
        (ULONG *) extra_parameters[0],
 801361a:	68bb      	ldr	r3, [r7, #8]
 801361c:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_thread_performance_system_info_get(
 801361e:	469c      	mov	ip, r3
        (ULONG *) extra_parameters[1],
 8013620:	68bb      	ldr	r3, [r7, #8]
 8013622:	3304      	adds	r3, #4
 8013624:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_thread_performance_system_info_get(
 8013626:	469e      	mov	lr, r3
        (ULONG *) extra_parameters[2],
 8013628:	68bb      	ldr	r3, [r7, #8]
 801362a:	3308      	adds	r3, #8
 801362c:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_thread_performance_system_info_get(
 801362e:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[3],
 8013630:	68bb      	ldr	r3, [r7, #8]
 8013632:	330c      	adds	r3, #12
 8013634:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_thread_performance_system_info_get(
 8013636:	461c      	mov	r4, r3
        (ULONG *) extra_parameters[4],
 8013638:	68bb      	ldr	r3, [r7, #8]
 801363a:	3310      	adds	r3, #16
 801363c:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_thread_performance_system_info_get(
 801363e:	461d      	mov	r5, r3
        (ULONG *) extra_parameters[5],
 8013640:	68bb      	ldr	r3, [r7, #8]
 8013642:	3314      	adds	r3, #20
 8013644:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_thread_performance_system_info_get(
 8013646:	461e      	mov	r6, r3
        (ULONG *) extra_parameters[6],
 8013648:	68bb      	ldr	r3, [r7, #8]
 801364a:	3318      	adds	r3, #24
 801364c:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_thread_performance_system_info_get(
 801364e:	607b      	str	r3, [r7, #4]
        (ULONG *) extra_parameters[7],
 8013650:	68bb      	ldr	r3, [r7, #8]
 8013652:	331c      	adds	r3, #28
 8013654:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_thread_performance_system_info_get(
 8013656:	603b      	str	r3, [r7, #0]
        (ULONG *) extra_parameters[8]
 8013658:	68bb      	ldr	r3, [r7, #8]
 801365a:	3320      	adds	r3, #32
 801365c:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_thread_performance_system_info_get(
 801365e:	9306      	str	r3, [sp, #24]
 8013660:	683b      	ldr	r3, [r7, #0]
 8013662:	9305      	str	r3, [sp, #20]
 8013664:	687b      	ldr	r3, [r7, #4]
 8013666:	9304      	str	r3, [sp, #16]
 8013668:	9603      	str	r6, [sp, #12]
 801366a:	9502      	str	r5, [sp, #8]
 801366c:	9401      	str	r4, [sp, #4]
 801366e:	9200      	str	r2, [sp, #0]
 8013670:	4673      	mov	r3, lr
 8013672:	4662      	mov	r2, ip
 8013674:	f7f8 fad2 	bl	800bc1c <_tx_thread_performance_system_info_get>
 8013678:	61f8      	str	r0, [r7, #28]
    );
    return(return_value);
 801367a:	69fb      	ldr	r3, [r7, #28]
}
 801367c:	4618      	mov	r0, r3
 801367e:	3724      	adds	r7, #36	; 0x24
 8013680:	46bd      	mov	sp, r7
 8013682:	bdf0      	pop	{r4, r5, r6, r7, pc}

08013684 <_txm_module_manager_tx_thread_preemption_change_dispatch>:
    TX_THREAD *thread_ptr, -> param_0
    UINT new_threshold, -> param_1
    UINT *old_threshold -> param_2
   ); */
static ALIGN_TYPE _txm_module_manager_tx_thread_preemption_change_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE param_2)
{
 8013684:	b580      	push	{r7, lr}
 8013686:	b086      	sub	sp, #24
 8013688:	af00      	add	r7, sp, #0
 801368a:	60f8      	str	r0, [r7, #12]
 801368c:	60b9      	str	r1, [r7, #8]
 801368e:	607a      	str	r2, [r7, #4]
 8013690:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8013692:	68fb      	ldr	r3, [r7, #12]
 8013694:	68db      	ldr	r3, [r3, #12]
 8013696:	f003 0302 	and.w	r3, r3, #2
 801369a:	2b00      	cmp	r3, #0
 801369c:	d02b      	beq.n	80136f6 <_txm_module_manager_tx_thread_preemption_change_dispatch+0x72>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_THREAD)))
 801369e:	22e8      	movs	r2, #232	; 0xe8
 80136a0:	68b9      	ldr	r1, [r7, #8]
 80136a2:	68f8      	ldr	r0, [r7, #12]
 80136a4:	f001 fbd0 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80136a8:	4603      	mov	r3, r0
 80136aa:	2b00      	cmp	r3, #0
 80136ac:	d111      	bne.n	80136d2 <_txm_module_manager_tx_thread_preemption_change_dispatch+0x4e>
 80136ae:	68bb      	ldr	r3, [r7, #8]
 80136b0:	f113 0fe9 	cmn.w	r3, #233	; 0xe9
 80136b4:	d812      	bhi.n	80136dc <_txm_module_manager_tx_thread_preemption_change_dispatch+0x58>
 80136b6:	68fb      	ldr	r3, [r7, #12]
 80136b8:	699b      	ldr	r3, [r3, #24]
 80136ba:	461a      	mov	r2, r3
 80136bc:	68bb      	ldr	r3, [r7, #8]
 80136be:	4293      	cmp	r3, r2
 80136c0:	d30c      	bcc.n	80136dc <_txm_module_manager_tx_thread_preemption_change_dispatch+0x58>
 80136c2:	68bb      	ldr	r3, [r7, #8]
 80136c4:	f103 02e8 	add.w	r2, r3, #232	; 0xe8
 80136c8:	68fb      	ldr	r3, [r7, #12]
 80136ca:	69db      	ldr	r3, [r3, #28]
 80136cc:	3301      	adds	r3, #1
 80136ce:	429a      	cmp	r2, r3
 80136d0:	d804      	bhi.n	80136dc <_txm_module_manager_tx_thread_preemption_change_dispatch+0x58>
 80136d2:	68bb      	ldr	r3, [r7, #8]
 80136d4:	2b00      	cmp	r3, #0
 80136d6:	d001      	beq.n	80136dc <_txm_module_manager_tx_thread_preemption_change_dispatch+0x58>
            return(TXM_MODULE_INVALID_MEMORY);
 80136d8:	23f4      	movs	r3, #244	; 0xf4
 80136da:	e014      	b.n	8013706 <_txm_module_manager_tx_thread_preemption_change_dispatch+0x82>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_2, sizeof(UINT)))
 80136dc:	2204      	movs	r2, #4
 80136de:	6839      	ldr	r1, [r7, #0]
 80136e0:	68f8      	ldr	r0, [r7, #12]
 80136e2:	f001 fbb1 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80136e6:	4603      	mov	r3, r0
 80136e8:	2b00      	cmp	r3, #0
 80136ea:	d104      	bne.n	80136f6 <_txm_module_manager_tx_thread_preemption_change_dispatch+0x72>
 80136ec:	683b      	ldr	r3, [r7, #0]
 80136ee:	2b00      	cmp	r3, #0
 80136f0:	d001      	beq.n	80136f6 <_txm_module_manager_tx_thread_preemption_change_dispatch+0x72>
            return(TXM_MODULE_INVALID_MEMORY);
 80136f2:	23f4      	movs	r3, #244	; 0xf4
 80136f4:	e007      	b.n	8013706 <_txm_module_manager_tx_thread_preemption_change_dispatch+0x82>
    }

    return_value = (ALIGN_TYPE) _txe_thread_preemption_change(
 80136f6:	68bb      	ldr	r3, [r7, #8]
 80136f8:	683a      	ldr	r2, [r7, #0]
 80136fa:	6879      	ldr	r1, [r7, #4]
 80136fc:	4618      	mov	r0, r3
 80136fe:	f7fb fe49 	bl	800f394 <_txe_thread_preemption_change>
 8013702:	6178      	str	r0, [r7, #20]
        (TX_THREAD *) param_0,
        (UINT) param_1,
        (UINT *) param_2
    );
    return(return_value);
 8013704:	697b      	ldr	r3, [r7, #20]
}
 8013706:	4618      	mov	r0, r3
 8013708:	3718      	adds	r7, #24
 801370a:	46bd      	mov	sp, r7
 801370c:	bd80      	pop	{r7, pc}

0801370e <_txm_module_manager_tx_thread_priority_change_dispatch>:
    TX_THREAD *thread_ptr, -> param_0
    UINT new_priority, -> param_1
    UINT *old_priority -> param_2
   ); */
static ALIGN_TYPE _txm_module_manager_tx_thread_priority_change_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE param_2)
{
 801370e:	b580      	push	{r7, lr}
 8013710:	b086      	sub	sp, #24
 8013712:	af00      	add	r7, sp, #0
 8013714:	60f8      	str	r0, [r7, #12]
 8013716:	60b9      	str	r1, [r7, #8]
 8013718:	607a      	str	r2, [r7, #4]
 801371a:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 801371c:	68fb      	ldr	r3, [r7, #12]
 801371e:	68db      	ldr	r3, [r3, #12]
 8013720:	f003 0302 	and.w	r3, r3, #2
 8013724:	2b00      	cmp	r3, #0
 8013726:	d02b      	beq.n	8013780 <_txm_module_manager_tx_thread_priority_change_dispatch+0x72>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_THREAD)))
 8013728:	22e8      	movs	r2, #232	; 0xe8
 801372a:	68b9      	ldr	r1, [r7, #8]
 801372c:	68f8      	ldr	r0, [r7, #12]
 801372e:	f001 fb8b 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013732:	4603      	mov	r3, r0
 8013734:	2b00      	cmp	r3, #0
 8013736:	d111      	bne.n	801375c <_txm_module_manager_tx_thread_priority_change_dispatch+0x4e>
 8013738:	68bb      	ldr	r3, [r7, #8]
 801373a:	f113 0fe9 	cmn.w	r3, #233	; 0xe9
 801373e:	d812      	bhi.n	8013766 <_txm_module_manager_tx_thread_priority_change_dispatch+0x58>
 8013740:	68fb      	ldr	r3, [r7, #12]
 8013742:	699b      	ldr	r3, [r3, #24]
 8013744:	461a      	mov	r2, r3
 8013746:	68bb      	ldr	r3, [r7, #8]
 8013748:	4293      	cmp	r3, r2
 801374a:	d30c      	bcc.n	8013766 <_txm_module_manager_tx_thread_priority_change_dispatch+0x58>
 801374c:	68bb      	ldr	r3, [r7, #8]
 801374e:	f103 02e8 	add.w	r2, r3, #232	; 0xe8
 8013752:	68fb      	ldr	r3, [r7, #12]
 8013754:	69db      	ldr	r3, [r3, #28]
 8013756:	3301      	adds	r3, #1
 8013758:	429a      	cmp	r2, r3
 801375a:	d804      	bhi.n	8013766 <_txm_module_manager_tx_thread_priority_change_dispatch+0x58>
 801375c:	68bb      	ldr	r3, [r7, #8]
 801375e:	2b00      	cmp	r3, #0
 8013760:	d001      	beq.n	8013766 <_txm_module_manager_tx_thread_priority_change_dispatch+0x58>
            return(TXM_MODULE_INVALID_MEMORY);
 8013762:	23f4      	movs	r3, #244	; 0xf4
 8013764:	e014      	b.n	8013790 <_txm_module_manager_tx_thread_priority_change_dispatch+0x82>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_2, sizeof(UINT)))
 8013766:	2204      	movs	r2, #4
 8013768:	6839      	ldr	r1, [r7, #0]
 801376a:	68f8      	ldr	r0, [r7, #12]
 801376c:	f001 fb6c 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013770:	4603      	mov	r3, r0
 8013772:	2b00      	cmp	r3, #0
 8013774:	d104      	bne.n	8013780 <_txm_module_manager_tx_thread_priority_change_dispatch+0x72>
 8013776:	683b      	ldr	r3, [r7, #0]
 8013778:	2b00      	cmp	r3, #0
 801377a:	d001      	beq.n	8013780 <_txm_module_manager_tx_thread_priority_change_dispatch+0x72>
            return(TXM_MODULE_INVALID_MEMORY);
 801377c:	23f4      	movs	r3, #244	; 0xf4
 801377e:	e007      	b.n	8013790 <_txm_module_manager_tx_thread_priority_change_dispatch+0x82>
    }

    return_value = (ALIGN_TYPE) _txe_thread_priority_change(
 8013780:	68bb      	ldr	r3, [r7, #8]
 8013782:	683a      	ldr	r2, [r7, #0]
 8013784:	6879      	ldr	r1, [r7, #4]
 8013786:	4618      	mov	r0, r3
 8013788:	f7fb fe42 	bl	800f410 <_txe_thread_priority_change>
 801378c:	6178      	str	r0, [r7, #20]
        (TX_THREAD *) param_0,
        (UINT) param_1,
        (UINT *) param_2
    );
    return(return_value);
 801378e:	697b      	ldr	r3, [r7, #20]
}
 8013790:	4618      	mov	r0, r3
 8013792:	3718      	adds	r7, #24
 8013794:	46bd      	mov	sp, r7
 8013796:	bd80      	pop	{r7, pc}

08013798 <_txm_module_manager_tx_thread_relinquish_dispatch>:
#endif

#ifndef TXM_THREAD_RELINQUISH_CALL_NOT_USED
/* VOID _txe_thread_relinquish(); */
static ALIGN_TYPE _txm_module_manager_tx_thread_relinquish_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8013798:	b580      	push	{r7, lr}
 801379a:	b084      	sub	sp, #16
 801379c:	af00      	add	r7, sp, #0
 801379e:	60f8      	str	r0, [r7, #12]
 80137a0:	60b9      	str	r1, [r7, #8]
 80137a2:	607a      	str	r2, [r7, #4]
 80137a4:	603b      	str	r3, [r7, #0]

    _txe_thread_relinquish();
 80137a6:	f7fb fe6f 	bl	800f488 <_txe_thread_relinquish>
    return(TX_SUCCESS);
 80137aa:	2300      	movs	r3, #0
}
 80137ac:	4618      	mov	r0, r3
 80137ae:	3710      	adds	r7, #16
 80137b0:	46bd      	mov	sp, r7
 80137b2:	bd80      	pop	{r7, pc}

080137b4 <_txm_module_manager_tx_thread_reset_dispatch>:
#ifndef TXM_THREAD_RESET_CALL_NOT_USED
/* UINT _txe_thread_reset(
    TX_THREAD *thread_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_thread_reset_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 80137b4:	b580      	push	{r7, lr}
 80137b6:	b084      	sub	sp, #16
 80137b8:	af00      	add	r7, sp, #0
 80137ba:	6078      	str	r0, [r7, #4]
 80137bc:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 80137be:	687b      	ldr	r3, [r7, #4]
 80137c0:	68db      	ldr	r3, [r3, #12]
 80137c2:	f003 0302 	and.w	r3, r3, #2
 80137c6:	2b00      	cmp	r3, #0
 80137c8:	d01e      	beq.n	8013808 <_txm_module_manager_tx_thread_reset_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_THREAD)))
 80137ca:	22e8      	movs	r2, #232	; 0xe8
 80137cc:	6839      	ldr	r1, [r7, #0]
 80137ce:	6878      	ldr	r0, [r7, #4]
 80137d0:	f001 fb3a 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80137d4:	4603      	mov	r3, r0
 80137d6:	2b00      	cmp	r3, #0
 80137d8:	d111      	bne.n	80137fe <_txm_module_manager_tx_thread_reset_dispatch+0x4a>
 80137da:	683b      	ldr	r3, [r7, #0]
 80137dc:	f113 0fe9 	cmn.w	r3, #233	; 0xe9
 80137e0:	d812      	bhi.n	8013808 <_txm_module_manager_tx_thread_reset_dispatch+0x54>
 80137e2:	687b      	ldr	r3, [r7, #4]
 80137e4:	699b      	ldr	r3, [r3, #24]
 80137e6:	461a      	mov	r2, r3
 80137e8:	683b      	ldr	r3, [r7, #0]
 80137ea:	4293      	cmp	r3, r2
 80137ec:	d30c      	bcc.n	8013808 <_txm_module_manager_tx_thread_reset_dispatch+0x54>
 80137ee:	683b      	ldr	r3, [r7, #0]
 80137f0:	f103 02e8 	add.w	r2, r3, #232	; 0xe8
 80137f4:	687b      	ldr	r3, [r7, #4]
 80137f6:	69db      	ldr	r3, [r3, #28]
 80137f8:	3301      	adds	r3, #1
 80137fa:	429a      	cmp	r2, r3
 80137fc:	d804      	bhi.n	8013808 <_txm_module_manager_tx_thread_reset_dispatch+0x54>
 80137fe:	683b      	ldr	r3, [r7, #0]
 8013800:	2b00      	cmp	r3, #0
 8013802:	d001      	beq.n	8013808 <_txm_module_manager_tx_thread_reset_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 8013804:	23f4      	movs	r3, #244	; 0xf4
 8013806:	e005      	b.n	8013814 <_txm_module_manager_tx_thread_reset_dispatch+0x60>
    }

    return_value = (ALIGN_TYPE) _txm_module_manager_thread_reset(
 8013808:	683b      	ldr	r3, [r7, #0]
 801380a:	4618      	mov	r0, r3
 801380c:	f002 fd9a 	bl	8016344 <_txm_module_manager_thread_reset>
 8013810:	60f8      	str	r0, [r7, #12]
        (TX_THREAD *) param_0
    );
    return(return_value);
 8013812:	68fb      	ldr	r3, [r7, #12]
}
 8013814:	4618      	mov	r0, r3
 8013816:	3710      	adds	r7, #16
 8013818:	46bd      	mov	sp, r7
 801381a:	bd80      	pop	{r7, pc}

0801381c <_txm_module_manager_tx_thread_resume_dispatch>:
#ifndef TXM_THREAD_RESUME_CALL_NOT_USED
/* UINT _txe_thread_resume(
    TX_THREAD *thread_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_thread_resume_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 801381c:	b580      	push	{r7, lr}
 801381e:	b084      	sub	sp, #16
 8013820:	af00      	add	r7, sp, #0
 8013822:	6078      	str	r0, [r7, #4]
 8013824:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8013826:	687b      	ldr	r3, [r7, #4]
 8013828:	68db      	ldr	r3, [r3, #12]
 801382a:	f003 0302 	and.w	r3, r3, #2
 801382e:	2b00      	cmp	r3, #0
 8013830:	d01e      	beq.n	8013870 <_txm_module_manager_tx_thread_resume_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_THREAD)))
 8013832:	22e8      	movs	r2, #232	; 0xe8
 8013834:	6839      	ldr	r1, [r7, #0]
 8013836:	6878      	ldr	r0, [r7, #4]
 8013838:	f001 fb06 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801383c:	4603      	mov	r3, r0
 801383e:	2b00      	cmp	r3, #0
 8013840:	d111      	bne.n	8013866 <_txm_module_manager_tx_thread_resume_dispatch+0x4a>
 8013842:	683b      	ldr	r3, [r7, #0]
 8013844:	f113 0fe9 	cmn.w	r3, #233	; 0xe9
 8013848:	d812      	bhi.n	8013870 <_txm_module_manager_tx_thread_resume_dispatch+0x54>
 801384a:	687b      	ldr	r3, [r7, #4]
 801384c:	699b      	ldr	r3, [r3, #24]
 801384e:	461a      	mov	r2, r3
 8013850:	683b      	ldr	r3, [r7, #0]
 8013852:	4293      	cmp	r3, r2
 8013854:	d30c      	bcc.n	8013870 <_txm_module_manager_tx_thread_resume_dispatch+0x54>
 8013856:	683b      	ldr	r3, [r7, #0]
 8013858:	f103 02e8 	add.w	r2, r3, #232	; 0xe8
 801385c:	687b      	ldr	r3, [r7, #4]
 801385e:	69db      	ldr	r3, [r3, #28]
 8013860:	3301      	adds	r3, #1
 8013862:	429a      	cmp	r2, r3
 8013864:	d804      	bhi.n	8013870 <_txm_module_manager_tx_thread_resume_dispatch+0x54>
 8013866:	683b      	ldr	r3, [r7, #0]
 8013868:	2b00      	cmp	r3, #0
 801386a:	d001      	beq.n	8013870 <_txm_module_manager_tx_thread_resume_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 801386c:	23f4      	movs	r3, #244	; 0xf4
 801386e:	e005      	b.n	801387c <_txm_module_manager_tx_thread_resume_dispatch+0x60>
    }

    return_value = (ALIGN_TYPE) _txe_thread_resume(
 8013870:	683b      	ldr	r3, [r7, #0]
 8013872:	4618      	mov	r0, r3
 8013874:	f7fb fe24 	bl	800f4c0 <_txe_thread_resume>
 8013878:	60f8      	str	r0, [r7, #12]
        (TX_THREAD *) param_0
    );
    return(return_value);
 801387a:	68fb      	ldr	r3, [r7, #12]
}
 801387c:	4618      	mov	r0, r3
 801387e:	3710      	adds	r7, #16
 8013880:	46bd      	mov	sp, r7
 8013882:	bd80      	pop	{r7, pc}

08013884 <_txm_module_manager_tx_thread_sleep_dispatch>:
#ifndef TXM_THREAD_SLEEP_CALL_NOT_USED
/* UINT _tx_thread_sleep(
    ULONG timer_ticks -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_thread_sleep_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8013884:	b580      	push	{r7, lr}
 8013886:	b084      	sub	sp, #16
 8013888:	af00      	add	r7, sp, #0
 801388a:	6078      	str	r0, [r7, #4]
 801388c:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    return_value = (ALIGN_TYPE) _tx_thread_sleep(
 801388e:	6838      	ldr	r0, [r7, #0]
 8013890:	f7f8 fca2 	bl	800c1d8 <_tx_thread_sleep>
 8013894:	60f8      	str	r0, [r7, #12]
        (ULONG) param_0
    );
    return(return_value);
 8013896:	68fb      	ldr	r3, [r7, #12]
}
 8013898:	4618      	mov	r0, r3
 801389a:	3710      	adds	r7, #16
 801389c:	46bd      	mov	sp, r7
 801389e:	bd80      	pop	{r7, pc}

080138a0 <_txm_module_manager_tx_thread_stack_error_notify_dispatch>:
#ifndef TXM_THREAD_STACK_ERROR_NOTIFY_CALL_NOT_USED
/* UINT _tx_thread_stack_error_notify(
    VOID (*stack_error_handler)(TX_THREAD *thread_ptr) -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_thread_stack_error_notify_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 80138a0:	b580      	push	{r7, lr}
 80138a2:	b084      	sub	sp, #16
 80138a4:	af00      	add	r7, sp, #0
 80138a6:	6078      	str	r0, [r7, #4]
 80138a8:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_USER_MODE)
 80138aa:	687b      	ldr	r3, [r7, #4]
 80138ac:	68db      	ldr	r3, [r3, #12]
 80138ae:	f003 0301 	and.w	r3, r3, #1
 80138b2:	2b00      	cmp	r3, #0
 80138b4:	d001      	beq.n	80138ba <_txm_module_manager_tx_thread_stack_error_notify_dispatch+0x1a>
        return(TXM_MODULE_INVALID_PROPERTIES);
 80138b6:	23f3      	movs	r3, #243	; 0xf3
 80138b8:	e005      	b.n	80138c6 <_txm_module_manager_tx_thread_stack_error_notify_dispatch+0x26>

    return_value = (ALIGN_TYPE) _tx_thread_stack_error_notify(
 80138ba:	683b      	ldr	r3, [r7, #0]
 80138bc:	4618      	mov	r0, r3
 80138be:	f7fc f83f 	bl	800f940 <_tx_thread_stack_error_notify>
 80138c2:	60f8      	str	r0, [r7, #12]
        (VOID (*)(TX_THREAD *thread_ptr)) param_0
    );
    return(return_value);
 80138c4:	68fb      	ldr	r3, [r7, #12]
}
 80138c6:	4618      	mov	r0, r3
 80138c8:	3710      	adds	r7, #16
 80138ca:	46bd      	mov	sp, r7
 80138cc:	bd80      	pop	{r7, pc}

080138ce <_txm_module_manager_tx_thread_suspend_dispatch>:
#ifndef TXM_THREAD_SUSPEND_CALL_NOT_USED
/* UINT _txe_thread_suspend(
    TX_THREAD *thread_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_thread_suspend_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 80138ce:	b580      	push	{r7, lr}
 80138d0:	b084      	sub	sp, #16
 80138d2:	af00      	add	r7, sp, #0
 80138d4:	6078      	str	r0, [r7, #4]
 80138d6:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 80138d8:	687b      	ldr	r3, [r7, #4]
 80138da:	68db      	ldr	r3, [r3, #12]
 80138dc:	f003 0302 	and.w	r3, r3, #2
 80138e0:	2b00      	cmp	r3, #0
 80138e2:	d01e      	beq.n	8013922 <_txm_module_manager_tx_thread_suspend_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_THREAD)))
 80138e4:	22e8      	movs	r2, #232	; 0xe8
 80138e6:	6839      	ldr	r1, [r7, #0]
 80138e8:	6878      	ldr	r0, [r7, #4]
 80138ea:	f001 faad 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80138ee:	4603      	mov	r3, r0
 80138f0:	2b00      	cmp	r3, #0
 80138f2:	d111      	bne.n	8013918 <_txm_module_manager_tx_thread_suspend_dispatch+0x4a>
 80138f4:	683b      	ldr	r3, [r7, #0]
 80138f6:	f113 0fe9 	cmn.w	r3, #233	; 0xe9
 80138fa:	d812      	bhi.n	8013922 <_txm_module_manager_tx_thread_suspend_dispatch+0x54>
 80138fc:	687b      	ldr	r3, [r7, #4]
 80138fe:	699b      	ldr	r3, [r3, #24]
 8013900:	461a      	mov	r2, r3
 8013902:	683b      	ldr	r3, [r7, #0]
 8013904:	4293      	cmp	r3, r2
 8013906:	d30c      	bcc.n	8013922 <_txm_module_manager_tx_thread_suspend_dispatch+0x54>
 8013908:	683b      	ldr	r3, [r7, #0]
 801390a:	f103 02e8 	add.w	r2, r3, #232	; 0xe8
 801390e:	687b      	ldr	r3, [r7, #4]
 8013910:	69db      	ldr	r3, [r3, #28]
 8013912:	3301      	adds	r3, #1
 8013914:	429a      	cmp	r2, r3
 8013916:	d804      	bhi.n	8013922 <_txm_module_manager_tx_thread_suspend_dispatch+0x54>
 8013918:	683b      	ldr	r3, [r7, #0]
 801391a:	2b00      	cmp	r3, #0
 801391c:	d001      	beq.n	8013922 <_txm_module_manager_tx_thread_suspend_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 801391e:	23f4      	movs	r3, #244	; 0xf4
 8013920:	e005      	b.n	801392e <_txm_module_manager_tx_thread_suspend_dispatch+0x60>
    }

    return_value = (ALIGN_TYPE) _txe_thread_suspend(
 8013922:	683b      	ldr	r3, [r7, #0]
 8013924:	4618      	mov	r0, r3
 8013926:	f7fb fde9 	bl	800f4fc <_txe_thread_suspend>
 801392a:	60f8      	str	r0, [r7, #12]
        (TX_THREAD *) param_0
    );
    return(return_value);
 801392c:	68fb      	ldr	r3, [r7, #12]
}
 801392e:	4618      	mov	r0, r3
 8013930:	3710      	adds	r7, #16
 8013932:	46bd      	mov	sp, r7
 8013934:	bd80      	pop	{r7, pc}
	...

08013938 <_txm_module_manager_tx_thread_system_suspend_dispatch>:
#ifndef TXM_THREAD_SYSTEM_SUSPEND_CALL_NOT_USED
/* VOID _tx_thread_system_suspend(
    TX_THREAD *thread_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_thread_system_suspend_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8013938:	b580      	push	{r7, lr}
 801393a:	b08a      	sub	sp, #40	; 0x28
 801393c:	af00      	add	r7, sp, #0
 801393e:	6078      	str	r0, [r7, #4]
 8013940:	6039      	str	r1, [r7, #0]

TX_INTERRUPT_SAVE_AREA

TX_THREAD *thread_ptr;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8013942:	687b      	ldr	r3, [r7, #4]
 8013944:	68db      	ldr	r3, [r3, #12]
 8013946:	f003 0302 	and.w	r3, r3, #2
 801394a:	2b00      	cmp	r3, #0
 801394c:	d025      	beq.n	801399a <_txm_module_manager_tx_thread_system_suspend_dispatch+0x62>
    {
        /* Ensure the thread is suspending itself.  */
        if (((TX_THREAD *) param_0) != _tx_thread_current_ptr)
 801394e:	683a      	ldr	r2, [r7, #0]
 8013950:	4b2d      	ldr	r3, [pc, #180]	; (8013a08 <_txm_module_manager_tx_thread_system_suspend_dispatch+0xd0>)
 8013952:	681b      	ldr	r3, [r3, #0]
 8013954:	429a      	cmp	r2, r3
 8013956:	d001      	beq.n	801395c <_txm_module_manager_tx_thread_system_suspend_dispatch+0x24>
        {
            return(TXM_MODULE_INVALID_MEMORY);
 8013958:	23f4      	movs	r3, #244	; 0xf4
 801395a:	e050      	b.n	80139fe <_txm_module_manager_tx_thread_system_suspend_dispatch+0xc6>
        }
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_THREAD)))
 801395c:	22e8      	movs	r2, #232	; 0xe8
 801395e:	6839      	ldr	r1, [r7, #0]
 8013960:	6878      	ldr	r0, [r7, #4]
 8013962:	f001 fa71 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013966:	4603      	mov	r3, r0
 8013968:	2b00      	cmp	r3, #0
 801396a:	d111      	bne.n	8013990 <_txm_module_manager_tx_thread_system_suspend_dispatch+0x58>
 801396c:	683b      	ldr	r3, [r7, #0]
 801396e:	f113 0fe9 	cmn.w	r3, #233	; 0xe9
 8013972:	d812      	bhi.n	801399a <_txm_module_manager_tx_thread_system_suspend_dispatch+0x62>
 8013974:	687b      	ldr	r3, [r7, #4]
 8013976:	699b      	ldr	r3, [r3, #24]
 8013978:	461a      	mov	r2, r3
 801397a:	683b      	ldr	r3, [r7, #0]
 801397c:	4293      	cmp	r3, r2
 801397e:	d30c      	bcc.n	801399a <_txm_module_manager_tx_thread_system_suspend_dispatch+0x62>
 8013980:	683b      	ldr	r3, [r7, #0]
 8013982:	f103 02e8 	add.w	r2, r3, #232	; 0xe8
 8013986:	687b      	ldr	r3, [r7, #4]
 8013988:	69db      	ldr	r3, [r3, #28]
 801398a:	3301      	adds	r3, #1
 801398c:	429a      	cmp	r2, r3
 801398e:	d804      	bhi.n	801399a <_txm_module_manager_tx_thread_system_suspend_dispatch+0x62>
 8013990:	683b      	ldr	r3, [r7, #0]
 8013992:	2b00      	cmp	r3, #0
 8013994:	d001      	beq.n	801399a <_txm_module_manager_tx_thread_system_suspend_dispatch+0x62>
            return(TXM_MODULE_INVALID_MEMORY);
 8013996:	23f4      	movs	r3, #244	; 0xf4
 8013998:	e031      	b.n	80139fe <_txm_module_manager_tx_thread_system_suspend_dispatch+0xc6>
    }

    /* Get the thread pointer.  */
    thread_ptr = (TX_THREAD *) param_0;
 801399a:	683b      	ldr	r3, [r7, #0]
 801399c:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801399e:	f3ef 8310 	mrs	r3, PRIMASK
 80139a2:	60fb      	str	r3, [r7, #12]
    return(posture);
 80139a4:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 80139a6:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 80139a8:	b672      	cpsid	i
    return(int_posture);
 80139aa:	68bb      	ldr	r3, [r7, #8]

    /* Disable interrupts temporarily.  */
    TX_DISABLE
 80139ac:	623b      	str	r3, [r7, #32]

    /* Set the status to suspending, in order to indicate the suspension
       is in progress.  */
    thread_ptr -> tx_thread_state =  TX_COMPLETED;
 80139ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80139b0:	2201      	movs	r2, #1
 80139b2:	631a      	str	r2, [r3, #48]	; 0x30

    /* Thread state change.  */
    TX_THREAD_STATE_CHANGE(thread_ptr, TX_COMPLETED)

    /* Set the suspending flag. */
    thread_ptr -> tx_thread_suspending =  TX_TRUE;
 80139b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80139b6:	2201      	movs	r2, #1
 80139b8:	639a      	str	r2, [r3, #56]	; 0x38

    /* Setup for no timeout period.  */
    thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  0;
 80139ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80139bc:	2200      	movs	r2, #0
 80139be:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 80139c0:	4b12      	ldr	r3, [pc, #72]	; (8013a0c <_txm_module_manager_tx_thread_system_suspend_dispatch+0xd4>)
 80139c2:	681b      	ldr	r3, [r3, #0]
 80139c4:	3301      	adds	r3, #1
 80139c6:	4a11      	ldr	r2, [pc, #68]	; (8013a0c <_txm_module_manager_tx_thread_system_suspend_dispatch+0xd4>)
 80139c8:	6013      	str	r3, [r2, #0]
 80139ca:	6a3b      	ldr	r3, [r7, #32]
 80139cc:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80139ce:	693b      	ldr	r3, [r7, #16]
 80139d0:	f383 8810 	msr	PRIMASK, r3
}
 80139d4:	bf00      	nop
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 80139d6:	f3ef 8314 	mrs	r3, CONTROL
 80139da:	617b      	str	r3, [r7, #20]
    return(control_value);
 80139dc:	697b      	ldr	r3, [r7, #20]

    /* Restore interrupts.  */
    TX_RESTORE

    /* Perform any additional activities for tool or user purpose.  */
    TX_THREAD_COMPLETED_EXTENSION(thread_ptr);
 80139de:	61fb      	str	r3, [r7, #28]
 80139e0:	69fb      	ldr	r3, [r7, #28]
 80139e2:	f023 0304 	bic.w	r3, r3, #4
 80139e6:	61fb      	str	r3, [r7, #28]
 80139e8:	69fb      	ldr	r3, [r7, #28]
 80139ea:	61bb      	str	r3, [r7, #24]
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
 80139ec:	69bb      	ldr	r3, [r7, #24]
 80139ee:	f383 8814 	msr	CONTROL, r3
}
 80139f2:	bf00      	nop

    _tx_thread_system_suspend(
 80139f4:	683b      	ldr	r3, [r7, #0]
 80139f6:	4618      	mov	r0, r3
 80139f8:	f7f8 fe2c 	bl	800c654 <_tx_thread_system_suspend>
        (TX_THREAD *) param_0
    );
    return(TX_SUCCESS);
 80139fc:	2300      	movs	r3, #0
}
 80139fe:	4618      	mov	r0, r3
 8013a00:	3728      	adds	r7, #40	; 0x28
 8013a02:	46bd      	mov	sp, r7
 8013a04:	bd80      	pop	{r7, pc}
 8013a06:	bf00      	nop
 8013a08:	2000efb8 	.word	0x2000efb8
 8013a0c:	2000f054 	.word	0x2000f054

08013a10 <_txm_module_manager_tx_thread_terminate_dispatch>:
#ifndef TXM_THREAD_TERMINATE_CALL_NOT_USED
/* UINT _txe_thread_terminate(
    TX_THREAD *thread_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_thread_terminate_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8013a10:	b580      	push	{r7, lr}
 8013a12:	b084      	sub	sp, #16
 8013a14:	af00      	add	r7, sp, #0
 8013a16:	6078      	str	r0, [r7, #4]
 8013a18:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8013a1a:	687b      	ldr	r3, [r7, #4]
 8013a1c:	68db      	ldr	r3, [r3, #12]
 8013a1e:	f003 0302 	and.w	r3, r3, #2
 8013a22:	2b00      	cmp	r3, #0
 8013a24:	d01e      	beq.n	8013a64 <_txm_module_manager_tx_thread_terminate_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_THREAD)))
 8013a26:	22e8      	movs	r2, #232	; 0xe8
 8013a28:	6839      	ldr	r1, [r7, #0]
 8013a2a:	6878      	ldr	r0, [r7, #4]
 8013a2c:	f001 fa0c 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013a30:	4603      	mov	r3, r0
 8013a32:	2b00      	cmp	r3, #0
 8013a34:	d111      	bne.n	8013a5a <_txm_module_manager_tx_thread_terminate_dispatch+0x4a>
 8013a36:	683b      	ldr	r3, [r7, #0]
 8013a38:	f113 0fe9 	cmn.w	r3, #233	; 0xe9
 8013a3c:	d812      	bhi.n	8013a64 <_txm_module_manager_tx_thread_terminate_dispatch+0x54>
 8013a3e:	687b      	ldr	r3, [r7, #4]
 8013a40:	699b      	ldr	r3, [r3, #24]
 8013a42:	461a      	mov	r2, r3
 8013a44:	683b      	ldr	r3, [r7, #0]
 8013a46:	4293      	cmp	r3, r2
 8013a48:	d30c      	bcc.n	8013a64 <_txm_module_manager_tx_thread_terminate_dispatch+0x54>
 8013a4a:	683b      	ldr	r3, [r7, #0]
 8013a4c:	f103 02e8 	add.w	r2, r3, #232	; 0xe8
 8013a50:	687b      	ldr	r3, [r7, #4]
 8013a52:	69db      	ldr	r3, [r3, #28]
 8013a54:	3301      	adds	r3, #1
 8013a56:	429a      	cmp	r2, r3
 8013a58:	d804      	bhi.n	8013a64 <_txm_module_manager_tx_thread_terminate_dispatch+0x54>
 8013a5a:	683b      	ldr	r3, [r7, #0]
 8013a5c:	2b00      	cmp	r3, #0
 8013a5e:	d001      	beq.n	8013a64 <_txm_module_manager_tx_thread_terminate_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 8013a60:	23f4      	movs	r3, #244	; 0xf4
 8013a62:	e005      	b.n	8013a70 <_txm_module_manager_tx_thread_terminate_dispatch+0x60>
    }

    return_value = (ALIGN_TYPE) _txe_thread_terminate(
 8013a64:	683b      	ldr	r3, [r7, #0]
 8013a66:	4618      	mov	r0, r3
 8013a68:	f7fb fd66 	bl	800f538 <_txe_thread_terminate>
 8013a6c:	60f8      	str	r0, [r7, #12]
        (TX_THREAD *) param_0
    );
    return(return_value);
 8013a6e:	68fb      	ldr	r3, [r7, #12]
}
 8013a70:	4618      	mov	r0, r3
 8013a72:	3710      	adds	r7, #16
 8013a74:	46bd      	mov	sp, r7
 8013a76:	bd80      	pop	{r7, pc}

08013a78 <_txm_module_manager_tx_thread_time_slice_change_dispatch>:
    TX_THREAD *thread_ptr, -> param_0
    ULONG new_time_slice, -> param_1
    ULONG *old_time_slice -> param_2
   ); */
static ALIGN_TYPE _txm_module_manager_tx_thread_time_slice_change_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE param_2)
{
 8013a78:	b580      	push	{r7, lr}
 8013a7a:	b086      	sub	sp, #24
 8013a7c:	af00      	add	r7, sp, #0
 8013a7e:	60f8      	str	r0, [r7, #12]
 8013a80:	60b9      	str	r1, [r7, #8]
 8013a82:	607a      	str	r2, [r7, #4]
 8013a84:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8013a86:	68fb      	ldr	r3, [r7, #12]
 8013a88:	68db      	ldr	r3, [r3, #12]
 8013a8a:	f003 0302 	and.w	r3, r3, #2
 8013a8e:	2b00      	cmp	r3, #0
 8013a90:	d02b      	beq.n	8013aea <_txm_module_manager_tx_thread_time_slice_change_dispatch+0x72>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_THREAD)))
 8013a92:	22e8      	movs	r2, #232	; 0xe8
 8013a94:	68b9      	ldr	r1, [r7, #8]
 8013a96:	68f8      	ldr	r0, [r7, #12]
 8013a98:	f001 f9d6 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013a9c:	4603      	mov	r3, r0
 8013a9e:	2b00      	cmp	r3, #0
 8013aa0:	d111      	bne.n	8013ac6 <_txm_module_manager_tx_thread_time_slice_change_dispatch+0x4e>
 8013aa2:	68bb      	ldr	r3, [r7, #8]
 8013aa4:	f113 0fe9 	cmn.w	r3, #233	; 0xe9
 8013aa8:	d812      	bhi.n	8013ad0 <_txm_module_manager_tx_thread_time_slice_change_dispatch+0x58>
 8013aaa:	68fb      	ldr	r3, [r7, #12]
 8013aac:	699b      	ldr	r3, [r3, #24]
 8013aae:	461a      	mov	r2, r3
 8013ab0:	68bb      	ldr	r3, [r7, #8]
 8013ab2:	4293      	cmp	r3, r2
 8013ab4:	d30c      	bcc.n	8013ad0 <_txm_module_manager_tx_thread_time_slice_change_dispatch+0x58>
 8013ab6:	68bb      	ldr	r3, [r7, #8]
 8013ab8:	f103 02e8 	add.w	r2, r3, #232	; 0xe8
 8013abc:	68fb      	ldr	r3, [r7, #12]
 8013abe:	69db      	ldr	r3, [r3, #28]
 8013ac0:	3301      	adds	r3, #1
 8013ac2:	429a      	cmp	r2, r3
 8013ac4:	d804      	bhi.n	8013ad0 <_txm_module_manager_tx_thread_time_slice_change_dispatch+0x58>
 8013ac6:	68bb      	ldr	r3, [r7, #8]
 8013ac8:	2b00      	cmp	r3, #0
 8013aca:	d001      	beq.n	8013ad0 <_txm_module_manager_tx_thread_time_slice_change_dispatch+0x58>
            return(TXM_MODULE_INVALID_MEMORY);
 8013acc:	23f4      	movs	r3, #244	; 0xf4
 8013ace:	e014      	b.n	8013afa <_txm_module_manager_tx_thread_time_slice_change_dispatch+0x82>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_2, sizeof(ULONG)))
 8013ad0:	2204      	movs	r2, #4
 8013ad2:	6839      	ldr	r1, [r7, #0]
 8013ad4:	68f8      	ldr	r0, [r7, #12]
 8013ad6:	f001 f9b7 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013ada:	4603      	mov	r3, r0
 8013adc:	2b00      	cmp	r3, #0
 8013ade:	d104      	bne.n	8013aea <_txm_module_manager_tx_thread_time_slice_change_dispatch+0x72>
 8013ae0:	683b      	ldr	r3, [r7, #0]
 8013ae2:	2b00      	cmp	r3, #0
 8013ae4:	d001      	beq.n	8013aea <_txm_module_manager_tx_thread_time_slice_change_dispatch+0x72>
            return(TXM_MODULE_INVALID_MEMORY);
 8013ae6:	23f4      	movs	r3, #244	; 0xf4
 8013ae8:	e007      	b.n	8013afa <_txm_module_manager_tx_thread_time_slice_change_dispatch+0x82>
    }

    return_value = (ALIGN_TYPE) _txe_thread_time_slice_change(
 8013aea:	68bb      	ldr	r3, [r7, #8]
 8013aec:	683a      	ldr	r2, [r7, #0]
 8013aee:	6879      	ldr	r1, [r7, #4]
 8013af0:	4618      	mov	r0, r3
 8013af2:	f7fb fd4d 	bl	800f590 <_txe_thread_time_slice_change>
 8013af6:	6178      	str	r0, [r7, #20]
        (TX_THREAD *) param_0,
        (ULONG) param_1,
        (ULONG *) param_2
    );
    return(return_value);
 8013af8:	697b      	ldr	r3, [r7, #20]
}
 8013afa:	4618      	mov	r0, r3
 8013afc:	3718      	adds	r7, #24
 8013afe:	46bd      	mov	sp, r7
 8013b00:	bd80      	pop	{r7, pc}

08013b02 <_txm_module_manager_tx_thread_wait_abort_dispatch>:
#ifndef TXM_THREAD_WAIT_ABORT_CALL_NOT_USED
/* UINT _txe_thread_wait_abort(
    TX_THREAD *thread_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_thread_wait_abort_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8013b02:	b580      	push	{r7, lr}
 8013b04:	b084      	sub	sp, #16
 8013b06:	af00      	add	r7, sp, #0
 8013b08:	6078      	str	r0, [r7, #4]
 8013b0a:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8013b0c:	687b      	ldr	r3, [r7, #4]
 8013b0e:	68db      	ldr	r3, [r3, #12]
 8013b10:	f003 0302 	and.w	r3, r3, #2
 8013b14:	2b00      	cmp	r3, #0
 8013b16:	d01e      	beq.n	8013b56 <_txm_module_manager_tx_thread_wait_abort_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_THREAD)))
 8013b18:	22e8      	movs	r2, #232	; 0xe8
 8013b1a:	6839      	ldr	r1, [r7, #0]
 8013b1c:	6878      	ldr	r0, [r7, #4]
 8013b1e:	f001 f993 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013b22:	4603      	mov	r3, r0
 8013b24:	2b00      	cmp	r3, #0
 8013b26:	d111      	bne.n	8013b4c <_txm_module_manager_tx_thread_wait_abort_dispatch+0x4a>
 8013b28:	683b      	ldr	r3, [r7, #0]
 8013b2a:	f113 0fe9 	cmn.w	r3, #233	; 0xe9
 8013b2e:	d812      	bhi.n	8013b56 <_txm_module_manager_tx_thread_wait_abort_dispatch+0x54>
 8013b30:	687b      	ldr	r3, [r7, #4]
 8013b32:	699b      	ldr	r3, [r3, #24]
 8013b34:	461a      	mov	r2, r3
 8013b36:	683b      	ldr	r3, [r7, #0]
 8013b38:	4293      	cmp	r3, r2
 8013b3a:	d30c      	bcc.n	8013b56 <_txm_module_manager_tx_thread_wait_abort_dispatch+0x54>
 8013b3c:	683b      	ldr	r3, [r7, #0]
 8013b3e:	f103 02e8 	add.w	r2, r3, #232	; 0xe8
 8013b42:	687b      	ldr	r3, [r7, #4]
 8013b44:	69db      	ldr	r3, [r3, #28]
 8013b46:	3301      	adds	r3, #1
 8013b48:	429a      	cmp	r2, r3
 8013b4a:	d804      	bhi.n	8013b56 <_txm_module_manager_tx_thread_wait_abort_dispatch+0x54>
 8013b4c:	683b      	ldr	r3, [r7, #0]
 8013b4e:	2b00      	cmp	r3, #0
 8013b50:	d001      	beq.n	8013b56 <_txm_module_manager_tx_thread_wait_abort_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 8013b52:	23f4      	movs	r3, #244	; 0xf4
 8013b54:	e005      	b.n	8013b62 <_txm_module_manager_tx_thread_wait_abort_dispatch+0x60>
    }

    return_value = (ALIGN_TYPE) _txe_thread_wait_abort(
 8013b56:	683b      	ldr	r3, [r7, #0]
 8013b58:	4618      	mov	r0, r3
 8013b5a:	f7fb fd4f 	bl	800f5fc <_txe_thread_wait_abort>
 8013b5e:	60f8      	str	r0, [r7, #12]
        (TX_THREAD *) param_0
    );
    return(return_value);
 8013b60:	68fb      	ldr	r3, [r7, #12]
}
 8013b62:	4618      	mov	r0, r3
 8013b64:	3710      	adds	r7, #16
 8013b66:	46bd      	mov	sp, r7
 8013b68:	bd80      	pop	{r7, pc}

08013b6a <_txm_module_manager_tx_time_get_dispatch>:
#endif

#ifndef TXM_TIME_GET_CALL_NOT_USED
/* ULONG _tx_time_get(); */
static ALIGN_TYPE _txm_module_manager_tx_time_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8013b6a:	b580      	push	{r7, lr}
 8013b6c:	b086      	sub	sp, #24
 8013b6e:	af00      	add	r7, sp, #0
 8013b70:	60f8      	str	r0, [r7, #12]
 8013b72:	60b9      	str	r1, [r7, #8]
 8013b74:	607a      	str	r2, [r7, #4]
 8013b76:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    return_value = (ALIGN_TYPE) _tx_time_get();
 8013b78:	f7f9 f9c6 	bl	800cf08 <_tx_time_get>
 8013b7c:	6178      	str	r0, [r7, #20]
    return(return_value);
 8013b7e:	697b      	ldr	r3, [r7, #20]
}
 8013b80:	4618      	mov	r0, r3
 8013b82:	3718      	adds	r7, #24
 8013b84:	46bd      	mov	sp, r7
 8013b86:	bd80      	pop	{r7, pc}

08013b88 <_txm_module_manager_tx_time_set_dispatch>:
#ifndef TXM_TIME_SET_CALL_NOT_USED
/* VOID _tx_time_set(
    ULONG new_time -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_time_set_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8013b88:	b580      	push	{r7, lr}
 8013b8a:	b082      	sub	sp, #8
 8013b8c:	af00      	add	r7, sp, #0
 8013b8e:	6078      	str	r0, [r7, #4]
 8013b90:	6039      	str	r1, [r7, #0]

    _tx_time_set(
 8013b92:	6838      	ldr	r0, [r7, #0]
 8013b94:	f7f9 f9d6 	bl	800cf44 <_tx_time_set>
        (ULONG) param_0
    );
    return(TX_SUCCESS);
 8013b98:	2300      	movs	r3, #0
}
 8013b9a:	4618      	mov	r0, r3
 8013b9c:	3708      	adds	r7, #8
 8013b9e:	46bd      	mov	sp, r7
 8013ba0:	bd80      	pop	{r7, pc}

08013ba2 <_txm_module_manager_tx_timer_activate_dispatch>:
#ifndef TXM_TIMER_ACTIVATE_CALL_NOT_USED
/* UINT _txe_timer_activate(
    TX_TIMER *timer_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_timer_activate_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8013ba2:	b580      	push	{r7, lr}
 8013ba4:	b084      	sub	sp, #16
 8013ba6:	af00      	add	r7, sp, #0
 8013ba8:	6078      	str	r0, [r7, #4]
 8013baa:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8013bac:	687b      	ldr	r3, [r7, #4]
 8013bae:	68db      	ldr	r3, [r3, #12]
 8013bb0:	f003 0302 	and.w	r3, r3, #2
 8013bb4:	2b00      	cmp	r3, #0
 8013bb6:	d01e      	beq.n	8013bf6 <_txm_module_manager_tx_timer_activate_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_TIMER)))
 8013bb8:	2234      	movs	r2, #52	; 0x34
 8013bba:	6839      	ldr	r1, [r7, #0]
 8013bbc:	6878      	ldr	r0, [r7, #4]
 8013bbe:	f001 f943 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013bc2:	4603      	mov	r3, r0
 8013bc4:	2b00      	cmp	r3, #0
 8013bc6:	d111      	bne.n	8013bec <_txm_module_manager_tx_timer_activate_dispatch+0x4a>
 8013bc8:	683b      	ldr	r3, [r7, #0]
 8013bca:	f113 0f35 	cmn.w	r3, #53	; 0x35
 8013bce:	d812      	bhi.n	8013bf6 <_txm_module_manager_tx_timer_activate_dispatch+0x54>
 8013bd0:	687b      	ldr	r3, [r7, #4]
 8013bd2:	699b      	ldr	r3, [r3, #24]
 8013bd4:	461a      	mov	r2, r3
 8013bd6:	683b      	ldr	r3, [r7, #0]
 8013bd8:	4293      	cmp	r3, r2
 8013bda:	d30c      	bcc.n	8013bf6 <_txm_module_manager_tx_timer_activate_dispatch+0x54>
 8013bdc:	683b      	ldr	r3, [r7, #0]
 8013bde:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8013be2:	687b      	ldr	r3, [r7, #4]
 8013be4:	69db      	ldr	r3, [r3, #28]
 8013be6:	3301      	adds	r3, #1
 8013be8:	429a      	cmp	r2, r3
 8013bea:	d804      	bhi.n	8013bf6 <_txm_module_manager_tx_timer_activate_dispatch+0x54>
 8013bec:	683b      	ldr	r3, [r7, #0]
 8013bee:	2b00      	cmp	r3, #0
 8013bf0:	d001      	beq.n	8013bf6 <_txm_module_manager_tx_timer_activate_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 8013bf2:	23f4      	movs	r3, #244	; 0xf4
 8013bf4:	e005      	b.n	8013c02 <_txm_module_manager_tx_timer_activate_dispatch+0x60>
    }

    return_value = (ALIGN_TYPE) _txe_timer_activate(
 8013bf6:	683b      	ldr	r3, [r7, #0]
 8013bf8:	4618      	mov	r0, r3
 8013bfa:	f7fb fd1d 	bl	800f638 <_txe_timer_activate>
 8013bfe:	60f8      	str	r0, [r7, #12]
        (TX_TIMER *) param_0
    );
    return(return_value);
 8013c00:	68fb      	ldr	r3, [r7, #12]
}
 8013c02:	4618      	mov	r0, r3
 8013c04:	3710      	adds	r7, #16
 8013c06:	46bd      	mov	sp, r7
 8013c08:	bd80      	pop	{r7, pc}

08013c0a <_txm_module_manager_tx_timer_change_dispatch>:
    TX_TIMER *timer_ptr, -> param_0
    ULONG initial_ticks, -> param_1
    ULONG reschedule_ticks -> param_2
   ); */
static ALIGN_TYPE _txm_module_manager_tx_timer_change_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE param_2)
{
 8013c0a:	b580      	push	{r7, lr}
 8013c0c:	b086      	sub	sp, #24
 8013c0e:	af00      	add	r7, sp, #0
 8013c10:	60f8      	str	r0, [r7, #12]
 8013c12:	60b9      	str	r1, [r7, #8]
 8013c14:	607a      	str	r2, [r7, #4]
 8013c16:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8013c18:	68fb      	ldr	r3, [r7, #12]
 8013c1a:	68db      	ldr	r3, [r3, #12]
 8013c1c:	f003 0302 	and.w	r3, r3, #2
 8013c20:	2b00      	cmp	r3, #0
 8013c22:	d01e      	beq.n	8013c62 <_txm_module_manager_tx_timer_change_dispatch+0x58>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_TIMER)))
 8013c24:	2234      	movs	r2, #52	; 0x34
 8013c26:	68b9      	ldr	r1, [r7, #8]
 8013c28:	68f8      	ldr	r0, [r7, #12]
 8013c2a:	f001 f90d 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013c2e:	4603      	mov	r3, r0
 8013c30:	2b00      	cmp	r3, #0
 8013c32:	d111      	bne.n	8013c58 <_txm_module_manager_tx_timer_change_dispatch+0x4e>
 8013c34:	68bb      	ldr	r3, [r7, #8]
 8013c36:	f113 0f35 	cmn.w	r3, #53	; 0x35
 8013c3a:	d812      	bhi.n	8013c62 <_txm_module_manager_tx_timer_change_dispatch+0x58>
 8013c3c:	68fb      	ldr	r3, [r7, #12]
 8013c3e:	699b      	ldr	r3, [r3, #24]
 8013c40:	461a      	mov	r2, r3
 8013c42:	68bb      	ldr	r3, [r7, #8]
 8013c44:	4293      	cmp	r3, r2
 8013c46:	d30c      	bcc.n	8013c62 <_txm_module_manager_tx_timer_change_dispatch+0x58>
 8013c48:	68bb      	ldr	r3, [r7, #8]
 8013c4a:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8013c4e:	68fb      	ldr	r3, [r7, #12]
 8013c50:	69db      	ldr	r3, [r3, #28]
 8013c52:	3301      	adds	r3, #1
 8013c54:	429a      	cmp	r2, r3
 8013c56:	d804      	bhi.n	8013c62 <_txm_module_manager_tx_timer_change_dispatch+0x58>
 8013c58:	68bb      	ldr	r3, [r7, #8]
 8013c5a:	2b00      	cmp	r3, #0
 8013c5c:	d001      	beq.n	8013c62 <_txm_module_manager_tx_timer_change_dispatch+0x58>
            return(TXM_MODULE_INVALID_MEMORY);
 8013c5e:	23f4      	movs	r3, #244	; 0xf4
 8013c60:	e007      	b.n	8013c72 <_txm_module_manager_tx_timer_change_dispatch+0x68>
    }

    return_value = (ALIGN_TYPE) _txe_timer_change(
 8013c62:	68bb      	ldr	r3, [r7, #8]
 8013c64:	683a      	ldr	r2, [r7, #0]
 8013c66:	6879      	ldr	r1, [r7, #4]
 8013c68:	4618      	mov	r0, r3
 8013c6a:	f7fb fd03 	bl	800f674 <_txe_timer_change>
 8013c6e:	6178      	str	r0, [r7, #20]
        (TX_TIMER *) param_0,
        (ULONG) param_1,
        (ULONG) param_2
    );
    return(return_value);
 8013c70:	697b      	ldr	r3, [r7, #20]
}
 8013c72:	4618      	mov	r0, r3
 8013c74:	3718      	adds	r7, #24
 8013c76:	46bd      	mov	sp, r7
 8013c78:	bd80      	pop	{r7, pc}
	...

08013c7c <_txm_module_manager_tx_timer_create_dispatch>:
    ULONG reschedule_ticks, -> extra_parameters[3]
    UINT auto_activate, -> extra_parameters[4]
    UINT timer_control_block_size -> extra_parameters[5]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_timer_create_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8013c7c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013c7e:	b08d      	sub	sp, #52	; 0x34
 8013c80:	af04      	add	r7, sp, #16
 8013c82:	60f8      	str	r0, [r7, #12]
 8013c84:	60b9      	str	r1, [r7, #8]
 8013c86:	607a      	str	r2, [r7, #4]
 8013c88:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;
TX_TIMER *timer_ptr;
VOID (*expiration_function)(ULONG);

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8013c8a:	68fb      	ldr	r3, [r7, #12]
 8013c8c:	68db      	ldr	r3, [r3, #12]
 8013c8e:	f003 0302 	and.w	r3, r3, #2
 8013c92:	2b00      	cmp	r3, #0
 8013c94:	d04b      	beq.n	8013d2e <_txm_module_manager_tx_timer_create_dispatch+0xb2>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_CREATION(module_instance, param_0, sizeof(TX_TIMER)))
 8013c96:	4b43      	ldr	r3, [pc, #268]	; (8013da4 <_txm_module_manager_tx_timer_create_dispatch+0x128>)
 8013c98:	681b      	ldr	r3, [r3, #0]
 8013c9a:	2b01      	cmp	r3, #1
 8013c9c:	d119      	bne.n	8013cd2 <_txm_module_manager_tx_timer_create_dispatch+0x56>
 8013c9e:	68bb      	ldr	r3, [r7, #8]
 8013ca0:	f113 0f35 	cmn.w	r3, #53	; 0x35
 8013ca4:	d815      	bhi.n	8013cd2 <_txm_module_manager_tx_timer_create_dispatch+0x56>
 8013ca6:	4b40      	ldr	r3, [pc, #256]	; (8013da8 <_txm_module_manager_tx_timer_create_dispatch+0x12c>)
 8013ca8:	699b      	ldr	r3, [r3, #24]
 8013caa:	3310      	adds	r3, #16
 8013cac:	68ba      	ldr	r2, [r7, #8]
 8013cae:	429a      	cmp	r2, r3
 8013cb0:	d30f      	bcc.n	8013cd2 <_txm_module_manager_tx_timer_create_dispatch+0x56>
 8013cb2:	68bb      	ldr	r3, [r7, #8]
 8013cb4:	3334      	adds	r3, #52	; 0x34
 8013cb6:	4a3c      	ldr	r2, [pc, #240]	; (8013da8 <_txm_module_manager_tx_timer_create_dispatch+0x12c>)
 8013cb8:	6991      	ldr	r1, [r2, #24]
 8013cba:	4a3b      	ldr	r2, [pc, #236]	; (8013da8 <_txm_module_manager_tx_timer_create_dispatch+0x12c>)
 8013cbc:	69d2      	ldr	r2, [r2, #28]
 8013cbe:	440a      	add	r2, r1
 8013cc0:	4293      	cmp	r3, r2
 8013cc2:	d806      	bhi.n	8013cd2 <_txm_module_manager_tx_timer_create_dispatch+0x56>
 8013cc4:	2134      	movs	r1, #52	; 0x34
 8013cc6:	68b8      	ldr	r0, [r7, #8]
 8013cc8:	f002 fce6 	bl	8016698 <_txm_module_manager_object_size_check>
 8013ccc:	4603      	mov	r3, r0
 8013cce:	2b00      	cmp	r3, #0
 8013cd0:	d004      	beq.n	8013cdc <_txm_module_manager_tx_timer_create_dispatch+0x60>
 8013cd2:	68bb      	ldr	r3, [r7, #8]
 8013cd4:	2b00      	cmp	r3, #0
 8013cd6:	d001      	beq.n	8013cdc <_txm_module_manager_tx_timer_create_dispatch+0x60>
            return(TXM_MODULE_INVALID_MEMORY);
 8013cd8:	23f4      	movs	r3, #244	; 0xf4
 8013cda:	e05f      	b.n	8013d9c <_txm_module_manager_tx_timer_create_dispatch+0x120>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_DEREFERENCE_STRING(module_instance, param_1))
 8013cdc:	2201      	movs	r2, #1
 8013cde:	6879      	ldr	r1, [r7, #4]
 8013ce0:	68f8      	ldr	r0, [r7, #12]
 8013ce2:	f001 f8b1 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013ce6:	4603      	mov	r3, r0
 8013ce8:	2b00      	cmp	r3, #0
 8013cea:	d115      	bne.n	8013d18 <_txm_module_manager_tx_timer_create_dispatch+0x9c>
 8013cec:	687b      	ldr	r3, [r7, #4]
 8013cee:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8013cf2:	d00c      	beq.n	8013d0e <_txm_module_manager_tx_timer_create_dispatch+0x92>
 8013cf4:	68fb      	ldr	r3, [r7, #12]
 8013cf6:	699b      	ldr	r3, [r3, #24]
 8013cf8:	461a      	mov	r2, r3
 8013cfa:	687b      	ldr	r3, [r7, #4]
 8013cfc:	4293      	cmp	r3, r2
 8013cfe:	d306      	bcc.n	8013d0e <_txm_module_manager_tx_timer_create_dispatch+0x92>
 8013d00:	687b      	ldr	r3, [r7, #4]
 8013d02:	1c5a      	adds	r2, r3, #1
 8013d04:	68fb      	ldr	r3, [r7, #12]
 8013d06:	69db      	ldr	r3, [r3, #28]
 8013d08:	3301      	adds	r3, #1
 8013d0a:	429a      	cmp	r2, r3
 8013d0c:	d904      	bls.n	8013d18 <_txm_module_manager_tx_timer_create_dispatch+0x9c>
 8013d0e:	687b      	ldr	r3, [r7, #4]
 8013d10:	2b00      	cmp	r3, #0
 8013d12:	d001      	beq.n	8013d18 <_txm_module_manager_tx_timer_create_dispatch+0x9c>
            return(TXM_MODULE_INVALID_MEMORY);
 8013d14:	23f4      	movs	r3, #244	; 0xf4
 8013d16:	e041      	b.n	8013d9c <_txm_module_manager_tx_timer_create_dispatch+0x120>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[6])))
 8013d18:	683b      	ldr	r3, [r7, #0]
 8013d1a:	2218      	movs	r2, #24
 8013d1c:	4619      	mov	r1, r3
 8013d1e:	68f8      	ldr	r0, [r7, #12]
 8013d20:	f001 f892 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013d24:	4603      	mov	r3, r0
 8013d26:	2b00      	cmp	r3, #0
 8013d28:	d101      	bne.n	8013d2e <_txm_module_manager_tx_timer_create_dispatch+0xb2>
            return(TXM_MODULE_INVALID_MEMORY);
 8013d2a:	23f4      	movs	r3, #244	; 0xf4
 8013d2c:	e036      	b.n	8013d9c <_txm_module_manager_tx_timer_create_dispatch+0x120>
    }

    /* Is it a disable request?  */
    if ((void *) extra_parameters[0] == TX_NULL)
 8013d2e:	683b      	ldr	r3, [r7, #0]
 8013d30:	681b      	ldr	r3, [r3, #0]
 8013d32:	2b00      	cmp	r3, #0
 8013d34:	d102      	bne.n	8013d3c <_txm_module_manager_tx_timer_create_dispatch+0xc0>
    {

        /* Clear the callback.  */
        expiration_function = (VOID (*)(ULONG)) TX_NULL;
 8013d36:	2300      	movs	r3, #0
 8013d38:	61fb      	str	r3, [r7, #28]
 8013d3a:	e001      	b.n	8013d40 <_txm_module_manager_tx_timer_create_dispatch+0xc4>
    }
    else
    {

        /* Set trampoline callback.  */
        expiration_function = _txm_module_manager_timer_notify_trampoline;
 8013d3c:	4b1b      	ldr	r3, [pc, #108]	; (8013dac <_txm_module_manager_tx_timer_create_dispatch+0x130>)
 8013d3e:	61fb      	str	r3, [r7, #28]
    }

    return_value = (ALIGN_TYPE) _txe_timer_create(
 8013d40:	68bc      	ldr	r4, [r7, #8]
 8013d42:	687d      	ldr	r5, [r7, #4]
        (TX_TIMER *) param_0,
        (CHAR *) param_1,
        (VOID (*)(ULONG)) expiration_function,
        (ULONG) extra_parameters[1],
 8013d44:	683b      	ldr	r3, [r7, #0]
 8013d46:	3304      	adds	r3, #4
    return_value = (ALIGN_TYPE) _txe_timer_create(
 8013d48:	681e      	ldr	r6, [r3, #0]
        (ULONG) extra_parameters[2],
 8013d4a:	683b      	ldr	r3, [r7, #0]
 8013d4c:	3308      	adds	r3, #8
    return_value = (ALIGN_TYPE) _txe_timer_create(
 8013d4e:	681b      	ldr	r3, [r3, #0]
        (ULONG) extra_parameters[3],
 8013d50:	683a      	ldr	r2, [r7, #0]
 8013d52:	320c      	adds	r2, #12
    return_value = (ALIGN_TYPE) _txe_timer_create(
 8013d54:	6812      	ldr	r2, [r2, #0]
        (UINT) extra_parameters[4],
 8013d56:	6839      	ldr	r1, [r7, #0]
 8013d58:	3110      	adds	r1, #16
    return_value = (ALIGN_TYPE) _txe_timer_create(
 8013d5a:	6809      	ldr	r1, [r1, #0]
        (UINT) extra_parameters[5]
 8013d5c:	6838      	ldr	r0, [r7, #0]
 8013d5e:	3014      	adds	r0, #20
    return_value = (ALIGN_TYPE) _txe_timer_create(
 8013d60:	6800      	ldr	r0, [r0, #0]
 8013d62:	9003      	str	r0, [sp, #12]
 8013d64:	9102      	str	r1, [sp, #8]
 8013d66:	9201      	str	r2, [sp, #4]
 8013d68:	9300      	str	r3, [sp, #0]
 8013d6a:	4633      	mov	r3, r6
 8013d6c:	69fa      	ldr	r2, [r7, #28]
 8013d6e:	4629      	mov	r1, r5
 8013d70:	4620      	mov	r0, r4
 8013d72:	f7fb fcb5 	bl	800f6e0 <_txe_timer_create>
 8013d76:	61b8      	str	r0, [r7, #24]
    );

    if (return_value == TX_SUCCESS)
 8013d78:	69bb      	ldr	r3, [r7, #24]
 8013d7a:	2b00      	cmp	r3, #0
 8013d7c:	d10d      	bne.n	8013d9a <_txm_module_manager_tx_timer_create_dispatch+0x11e>
    {

        /* Get the object pointer.  */
        timer_ptr = (TX_TIMER *) param_0;
 8013d7e:	68bb      	ldr	r3, [r7, #8]
 8013d80:	617b      	str	r3, [r7, #20]

        /* Setup trampoline values.  */
        if ((void *) extra_parameters[0] != TX_NULL)
 8013d82:	683b      	ldr	r3, [r7, #0]
 8013d84:	681b      	ldr	r3, [r3, #0]
 8013d86:	2b00      	cmp	r3, #0
 8013d88:	d007      	beq.n	8013d9a <_txm_module_manager_tx_timer_create_dispatch+0x11e>
        {

            timer_ptr -> tx_timer_module_instance = (VOID *) module_instance;
 8013d8a:	697b      	ldr	r3, [r7, #20]
 8013d8c:	68fa      	ldr	r2, [r7, #12]
 8013d8e:	62da      	str	r2, [r3, #44]	; 0x2c
            timer_ptr -> tx_timer_module_expiration_function = (VOID (*)(ULONG)) extra_parameters[0];
 8013d90:	683b      	ldr	r3, [r7, #0]
 8013d92:	681b      	ldr	r3, [r3, #0]
 8013d94:	461a      	mov	r2, r3
 8013d96:	697b      	ldr	r3, [r7, #20]
 8013d98:	631a      	str	r2, [r3, #48]	; 0x30
        }
    }
    return(return_value);
 8013d9a:	69bb      	ldr	r3, [r7, #24]
}
 8013d9c:	4618      	mov	r0, r3
 8013d9e:	3724      	adds	r7, #36	; 0x24
 8013da0:	46bd      	mov	sp, r7
 8013da2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013da4:	2000f670 	.word	0x2000f670
 8013da8:	2000f63c 	.word	0x2000f63c
 8013dac:	08016419 	.word	0x08016419

08013db0 <_txm_module_manager_tx_timer_deactivate_dispatch>:
#ifndef TXM_TIMER_DEACTIVATE_CALL_NOT_USED
/* UINT _txe_timer_deactivate(
    TX_TIMER *timer_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_timer_deactivate_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8013db0:	b580      	push	{r7, lr}
 8013db2:	b084      	sub	sp, #16
 8013db4:	af00      	add	r7, sp, #0
 8013db6:	6078      	str	r0, [r7, #4]
 8013db8:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8013dba:	687b      	ldr	r3, [r7, #4]
 8013dbc:	68db      	ldr	r3, [r3, #12]
 8013dbe:	f003 0302 	and.w	r3, r3, #2
 8013dc2:	2b00      	cmp	r3, #0
 8013dc4:	d01e      	beq.n	8013e04 <_txm_module_manager_tx_timer_deactivate_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_TIMER)))
 8013dc6:	2234      	movs	r2, #52	; 0x34
 8013dc8:	6839      	ldr	r1, [r7, #0]
 8013dca:	6878      	ldr	r0, [r7, #4]
 8013dcc:	f001 f83c 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013dd0:	4603      	mov	r3, r0
 8013dd2:	2b00      	cmp	r3, #0
 8013dd4:	d111      	bne.n	8013dfa <_txm_module_manager_tx_timer_deactivate_dispatch+0x4a>
 8013dd6:	683b      	ldr	r3, [r7, #0]
 8013dd8:	f113 0f35 	cmn.w	r3, #53	; 0x35
 8013ddc:	d812      	bhi.n	8013e04 <_txm_module_manager_tx_timer_deactivate_dispatch+0x54>
 8013dde:	687b      	ldr	r3, [r7, #4]
 8013de0:	699b      	ldr	r3, [r3, #24]
 8013de2:	461a      	mov	r2, r3
 8013de4:	683b      	ldr	r3, [r7, #0]
 8013de6:	4293      	cmp	r3, r2
 8013de8:	d30c      	bcc.n	8013e04 <_txm_module_manager_tx_timer_deactivate_dispatch+0x54>
 8013dea:	683b      	ldr	r3, [r7, #0]
 8013dec:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8013df0:	687b      	ldr	r3, [r7, #4]
 8013df2:	69db      	ldr	r3, [r3, #28]
 8013df4:	3301      	adds	r3, #1
 8013df6:	429a      	cmp	r2, r3
 8013df8:	d804      	bhi.n	8013e04 <_txm_module_manager_tx_timer_deactivate_dispatch+0x54>
 8013dfa:	683b      	ldr	r3, [r7, #0]
 8013dfc:	2b00      	cmp	r3, #0
 8013dfe:	d001      	beq.n	8013e04 <_txm_module_manager_tx_timer_deactivate_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 8013e00:	23f4      	movs	r3, #244	; 0xf4
 8013e02:	e005      	b.n	8013e10 <_txm_module_manager_tx_timer_deactivate_dispatch+0x60>
    }

    return_value = (ALIGN_TYPE) _txe_timer_deactivate(
 8013e04:	683b      	ldr	r3, [r7, #0]
 8013e06:	4618      	mov	r0, r3
 8013e08:	f7fb fd16 	bl	800f838 <_txe_timer_deactivate>
 8013e0c:	60f8      	str	r0, [r7, #12]
        (TX_TIMER *) param_0
    );
    return(return_value);
 8013e0e:	68fb      	ldr	r3, [r7, #12]
}
 8013e10:	4618      	mov	r0, r3
 8013e12:	3710      	adds	r7, #16
 8013e14:	46bd      	mov	sp, r7
 8013e16:	bd80      	pop	{r7, pc}

08013e18 <_txm_module_manager_tx_timer_delete_dispatch>:
#ifndef TXM_TIMER_DELETE_CALL_NOT_USED
/* UINT _txe_timer_delete(
    TX_TIMER *timer_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_timer_delete_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8013e18:	b580      	push	{r7, lr}
 8013e1a:	b084      	sub	sp, #16
 8013e1c:	af00      	add	r7, sp, #0
 8013e1e:	6078      	str	r0, [r7, #4]
 8013e20:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8013e22:	687b      	ldr	r3, [r7, #4]
 8013e24:	68db      	ldr	r3, [r3, #12]
 8013e26:	f003 0302 	and.w	r3, r3, #2
 8013e2a:	2b00      	cmp	r3, #0
 8013e2c:	d01e      	beq.n	8013e6c <_txm_module_manager_tx_timer_delete_dispatch+0x54>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_TIMER)))
 8013e2e:	2234      	movs	r2, #52	; 0x34
 8013e30:	6839      	ldr	r1, [r7, #0]
 8013e32:	6878      	ldr	r0, [r7, #4]
 8013e34:	f001 f808 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013e38:	4603      	mov	r3, r0
 8013e3a:	2b00      	cmp	r3, #0
 8013e3c:	d111      	bne.n	8013e62 <_txm_module_manager_tx_timer_delete_dispatch+0x4a>
 8013e3e:	683b      	ldr	r3, [r7, #0]
 8013e40:	f113 0f35 	cmn.w	r3, #53	; 0x35
 8013e44:	d812      	bhi.n	8013e6c <_txm_module_manager_tx_timer_delete_dispatch+0x54>
 8013e46:	687b      	ldr	r3, [r7, #4]
 8013e48:	699b      	ldr	r3, [r3, #24]
 8013e4a:	461a      	mov	r2, r3
 8013e4c:	683b      	ldr	r3, [r7, #0]
 8013e4e:	4293      	cmp	r3, r2
 8013e50:	d30c      	bcc.n	8013e6c <_txm_module_manager_tx_timer_delete_dispatch+0x54>
 8013e52:	683b      	ldr	r3, [r7, #0]
 8013e54:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8013e58:	687b      	ldr	r3, [r7, #4]
 8013e5a:	69db      	ldr	r3, [r3, #28]
 8013e5c:	3301      	adds	r3, #1
 8013e5e:	429a      	cmp	r2, r3
 8013e60:	d804      	bhi.n	8013e6c <_txm_module_manager_tx_timer_delete_dispatch+0x54>
 8013e62:	683b      	ldr	r3, [r7, #0]
 8013e64:	2b00      	cmp	r3, #0
 8013e66:	d001      	beq.n	8013e6c <_txm_module_manager_tx_timer_delete_dispatch+0x54>
            return(TXM_MODULE_INVALID_MEMORY);
 8013e68:	23f4      	movs	r3, #244	; 0xf4
 8013e6a:	e00d      	b.n	8013e88 <_txm_module_manager_tx_timer_delete_dispatch+0x70>
    }

    return_value = (ALIGN_TYPE) _txe_timer_delete(
 8013e6c:	683b      	ldr	r3, [r7, #0]
 8013e6e:	4618      	mov	r0, r3
 8013e70:	f7fb fd00 	bl	800f874 <_txe_timer_delete>
 8013e74:	60f8      	str	r0, [r7, #12]
        (TX_TIMER *) param_0
    );

    /* Deallocate object memory.  */
    if (return_value == TX_SUCCESS)
 8013e76:	68fb      	ldr	r3, [r7, #12]
 8013e78:	2b00      	cmp	r3, #0
 8013e7a:	d104      	bne.n	8013e86 <_txm_module_manager_tx_timer_delete_dispatch+0x6e>
    {
        return_value = _txm_module_manager_object_deallocate((VOID *) param_0);
 8013e7c:	683b      	ldr	r3, [r7, #0]
 8013e7e:	4618      	mov	r0, r3
 8013e80:	f001 f898 	bl	8014fb4 <_txm_module_manager_object_deallocate>
 8013e84:	60f8      	str	r0, [r7, #12]
    }
    return(return_value);
 8013e86:	68fb      	ldr	r3, [r7, #12]
}
 8013e88:	4618      	mov	r0, r3
 8013e8a:	3710      	adds	r7, #16
 8013e8c:	46bd      	mov	sp, r7
 8013e8e:	bd80      	pop	{r7, pc}

08013e90 <_txm_module_manager_tx_timer_info_get_dispatch>:
    ULONG *remaining_ticks, -> extra_parameters[1]
    ULONG *reschedule_ticks, -> extra_parameters[2]
    TX_TIMER **next_timer -> extra_parameters[3]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_timer_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8013e90:	b5b0      	push	{r4, r5, r7, lr}
 8013e92:	b088      	sub	sp, #32
 8013e94:	af02      	add	r7, sp, #8
 8013e96:	60f8      	str	r0, [r7, #12]
 8013e98:	60b9      	str	r1, [r7, #8]
 8013e9a:	607a      	str	r2, [r7, #4]
 8013e9c:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8013e9e:	68fb      	ldr	r3, [r7, #12]
 8013ea0:	68db      	ldr	r3, [r3, #12]
 8013ea2:	f003 0302 	and.w	r3, r3, #2
 8013ea6:	2b00      	cmp	r3, #0
 8013ea8:	d07c      	beq.n	8013fa4 <_txm_module_manager_tx_timer_info_get_dispatch+0x114>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_TIMER)))
 8013eaa:	2234      	movs	r2, #52	; 0x34
 8013eac:	68b9      	ldr	r1, [r7, #8]
 8013eae:	68f8      	ldr	r0, [r7, #12]
 8013eb0:	f000 ffca 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013eb4:	4603      	mov	r3, r0
 8013eb6:	2b00      	cmp	r3, #0
 8013eb8:	d111      	bne.n	8013ede <_txm_module_manager_tx_timer_info_get_dispatch+0x4e>
 8013eba:	68bb      	ldr	r3, [r7, #8]
 8013ebc:	f113 0f35 	cmn.w	r3, #53	; 0x35
 8013ec0:	d812      	bhi.n	8013ee8 <_txm_module_manager_tx_timer_info_get_dispatch+0x58>
 8013ec2:	68fb      	ldr	r3, [r7, #12]
 8013ec4:	699b      	ldr	r3, [r3, #24]
 8013ec6:	461a      	mov	r2, r3
 8013ec8:	68bb      	ldr	r3, [r7, #8]
 8013eca:	4293      	cmp	r3, r2
 8013ecc:	d30c      	bcc.n	8013ee8 <_txm_module_manager_tx_timer_info_get_dispatch+0x58>
 8013ece:	68bb      	ldr	r3, [r7, #8]
 8013ed0:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8013ed4:	68fb      	ldr	r3, [r7, #12]
 8013ed6:	69db      	ldr	r3, [r3, #28]
 8013ed8:	3301      	adds	r3, #1
 8013eda:	429a      	cmp	r2, r3
 8013edc:	d804      	bhi.n	8013ee8 <_txm_module_manager_tx_timer_info_get_dispatch+0x58>
 8013ede:	68bb      	ldr	r3, [r7, #8]
 8013ee0:	2b00      	cmp	r3, #0
 8013ee2:	d001      	beq.n	8013ee8 <_txm_module_manager_tx_timer_info_get_dispatch+0x58>
            return(TXM_MODULE_INVALID_MEMORY);
 8013ee4:	23f4      	movs	r3, #244	; 0xf4
 8013ee6:	e075      	b.n	8013fd4 <_txm_module_manager_tx_timer_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(CHAR *)))
 8013ee8:	2204      	movs	r2, #4
 8013eea:	6879      	ldr	r1, [r7, #4]
 8013eec:	68f8      	ldr	r0, [r7, #12]
 8013eee:	f000 ffab 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013ef2:	4603      	mov	r3, r0
 8013ef4:	2b00      	cmp	r3, #0
 8013ef6:	d104      	bne.n	8013f02 <_txm_module_manager_tx_timer_info_get_dispatch+0x72>
 8013ef8:	687b      	ldr	r3, [r7, #4]
 8013efa:	2b00      	cmp	r3, #0
 8013efc:	d001      	beq.n	8013f02 <_txm_module_manager_tx_timer_info_get_dispatch+0x72>
            return(TXM_MODULE_INVALID_MEMORY);
 8013efe:	23f4      	movs	r3, #244	; 0xf4
 8013f00:	e068      	b.n	8013fd4 <_txm_module_manager_tx_timer_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[4])))
 8013f02:	683b      	ldr	r3, [r7, #0]
 8013f04:	2210      	movs	r2, #16
 8013f06:	4619      	mov	r1, r3
 8013f08:	68f8      	ldr	r0, [r7, #12]
 8013f0a:	f000 ff9d 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013f0e:	4603      	mov	r3, r0
 8013f10:	2b00      	cmp	r3, #0
 8013f12:	d101      	bne.n	8013f18 <_txm_module_manager_tx_timer_info_get_dispatch+0x88>
            return(TXM_MODULE_INVALID_MEMORY);
 8013f14:	23f4      	movs	r3, #244	; 0xf4
 8013f16:	e05d      	b.n	8013fd4 <_txm_module_manager_tx_timer_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(UINT)))
 8013f18:	683b      	ldr	r3, [r7, #0]
 8013f1a:	681b      	ldr	r3, [r3, #0]
 8013f1c:	2204      	movs	r2, #4
 8013f1e:	4619      	mov	r1, r3
 8013f20:	68f8      	ldr	r0, [r7, #12]
 8013f22:	f000 ff91 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013f26:	4603      	mov	r3, r0
 8013f28:	2b00      	cmp	r3, #0
 8013f2a:	d105      	bne.n	8013f38 <_txm_module_manager_tx_timer_info_get_dispatch+0xa8>
 8013f2c:	683b      	ldr	r3, [r7, #0]
 8013f2e:	681b      	ldr	r3, [r3, #0]
 8013f30:	2b00      	cmp	r3, #0
 8013f32:	d001      	beq.n	8013f38 <_txm_module_manager_tx_timer_info_get_dispatch+0xa8>
            return(TXM_MODULE_INVALID_MEMORY);
 8013f34:	23f4      	movs	r3, #244	; 0xf4
 8013f36:	e04d      	b.n	8013fd4 <_txm_module_manager_tx_timer_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 8013f38:	683b      	ldr	r3, [r7, #0]
 8013f3a:	3304      	adds	r3, #4
 8013f3c:	681b      	ldr	r3, [r3, #0]
 8013f3e:	2204      	movs	r2, #4
 8013f40:	4619      	mov	r1, r3
 8013f42:	68f8      	ldr	r0, [r7, #12]
 8013f44:	f000 ff80 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013f48:	4603      	mov	r3, r0
 8013f4a:	2b00      	cmp	r3, #0
 8013f4c:	d106      	bne.n	8013f5c <_txm_module_manager_tx_timer_info_get_dispatch+0xcc>
 8013f4e:	683b      	ldr	r3, [r7, #0]
 8013f50:	3304      	adds	r3, #4
 8013f52:	681b      	ldr	r3, [r3, #0]
 8013f54:	2b00      	cmp	r3, #0
 8013f56:	d001      	beq.n	8013f5c <_txm_module_manager_tx_timer_info_get_dispatch+0xcc>
            return(TXM_MODULE_INVALID_MEMORY);
 8013f58:	23f4      	movs	r3, #244	; 0xf4
 8013f5a:	e03b      	b.n	8013fd4 <_txm_module_manager_tx_timer_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(ULONG)))
 8013f5c:	683b      	ldr	r3, [r7, #0]
 8013f5e:	3308      	adds	r3, #8
 8013f60:	681b      	ldr	r3, [r3, #0]
 8013f62:	2204      	movs	r2, #4
 8013f64:	4619      	mov	r1, r3
 8013f66:	68f8      	ldr	r0, [r7, #12]
 8013f68:	f000 ff6e 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013f6c:	4603      	mov	r3, r0
 8013f6e:	2b00      	cmp	r3, #0
 8013f70:	d106      	bne.n	8013f80 <_txm_module_manager_tx_timer_info_get_dispatch+0xf0>
 8013f72:	683b      	ldr	r3, [r7, #0]
 8013f74:	3308      	adds	r3, #8
 8013f76:	681b      	ldr	r3, [r3, #0]
 8013f78:	2b00      	cmp	r3, #0
 8013f7a:	d001      	beq.n	8013f80 <_txm_module_manager_tx_timer_info_get_dispatch+0xf0>
            return(TXM_MODULE_INVALID_MEMORY);
 8013f7c:	23f4      	movs	r3, #244	; 0xf4
 8013f7e:	e029      	b.n	8013fd4 <_txm_module_manager_tx_timer_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[3], sizeof(TX_TIMER *)))
 8013f80:	683b      	ldr	r3, [r7, #0]
 8013f82:	330c      	adds	r3, #12
 8013f84:	681b      	ldr	r3, [r3, #0]
 8013f86:	2204      	movs	r2, #4
 8013f88:	4619      	mov	r1, r3
 8013f8a:	68f8      	ldr	r0, [r7, #12]
 8013f8c:	f000 ff5c 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8013f90:	4603      	mov	r3, r0
 8013f92:	2b00      	cmp	r3, #0
 8013f94:	d106      	bne.n	8013fa4 <_txm_module_manager_tx_timer_info_get_dispatch+0x114>
 8013f96:	683b      	ldr	r3, [r7, #0]
 8013f98:	330c      	adds	r3, #12
 8013f9a:	681b      	ldr	r3, [r3, #0]
 8013f9c:	2b00      	cmp	r3, #0
 8013f9e:	d001      	beq.n	8013fa4 <_txm_module_manager_tx_timer_info_get_dispatch+0x114>
            return(TXM_MODULE_INVALID_MEMORY);
 8013fa0:	23f4      	movs	r3, #244	; 0xf4
 8013fa2:	e017      	b.n	8013fd4 <_txm_module_manager_tx_timer_info_get_dispatch+0x144>
    }

    return_value = (ALIGN_TYPE) _txe_timer_info_get(
 8013fa4:	68b8      	ldr	r0, [r7, #8]
 8013fa6:	6879      	ldr	r1, [r7, #4]
        (TX_TIMER *) param_0,
        (CHAR **) param_1,
        (UINT *) extra_parameters[0],
 8013fa8:	683b      	ldr	r3, [r7, #0]
 8013faa:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_timer_info_get(
 8013fac:	461c      	mov	r4, r3
        (ULONG *) extra_parameters[1],
 8013fae:	683b      	ldr	r3, [r7, #0]
 8013fb0:	3304      	adds	r3, #4
 8013fb2:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_timer_info_get(
 8013fb4:	461d      	mov	r5, r3
        (ULONG *) extra_parameters[2],
 8013fb6:	683b      	ldr	r3, [r7, #0]
 8013fb8:	3308      	adds	r3, #8
 8013fba:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_timer_info_get(
 8013fbc:	461a      	mov	r2, r3
        (TX_TIMER **) extra_parameters[3]
 8013fbe:	683b      	ldr	r3, [r7, #0]
 8013fc0:	330c      	adds	r3, #12
 8013fc2:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txe_timer_info_get(
 8013fc4:	9301      	str	r3, [sp, #4]
 8013fc6:	9200      	str	r2, [sp, #0]
 8013fc8:	462b      	mov	r3, r5
 8013fca:	4622      	mov	r2, r4
 8013fcc:	f7fb fc90 	bl	800f8f0 <_txe_timer_info_get>
 8013fd0:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 8013fd2:	697b      	ldr	r3, [r7, #20]
}
 8013fd4:	4618      	mov	r0, r3
 8013fd6:	3718      	adds	r7, #24
 8013fd8:	46bd      	mov	sp, r7
 8013fda:	bdb0      	pop	{r4, r5, r7, pc}

08013fdc <_txm_module_manager_tx_timer_performance_info_get_dispatch>:
    ULONG *deactivates, -> extra_parameters[1]
    ULONG *expirations, -> extra_parameters[2]
    ULONG *expiration_adjusts -> extra_parameters[3]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_timer_performance_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8013fdc:	b5b0      	push	{r4, r5, r7, lr}
 8013fde:	b088      	sub	sp, #32
 8013fe0:	af02      	add	r7, sp, #8
 8013fe2:	60f8      	str	r0, [r7, #12]
 8013fe4:	60b9      	str	r1, [r7, #8]
 8013fe6:	607a      	str	r2, [r7, #4]
 8013fe8:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8013fea:	68fb      	ldr	r3, [r7, #12]
 8013fec:	68db      	ldr	r3, [r3, #12]
 8013fee:	f003 0302 	and.w	r3, r3, #2
 8013ff2:	2b00      	cmp	r3, #0
 8013ff4:	d07c      	beq.n	80140f0 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0x114>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_TIMER)))
 8013ff6:	2234      	movs	r2, #52	; 0x34
 8013ff8:	68b9      	ldr	r1, [r7, #8]
 8013ffa:	68f8      	ldr	r0, [r7, #12]
 8013ffc:	f000 ff24 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8014000:	4603      	mov	r3, r0
 8014002:	2b00      	cmp	r3, #0
 8014004:	d111      	bne.n	801402a <_txm_module_manager_tx_timer_performance_info_get_dispatch+0x4e>
 8014006:	68bb      	ldr	r3, [r7, #8]
 8014008:	f113 0f35 	cmn.w	r3, #53	; 0x35
 801400c:	d812      	bhi.n	8014034 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0x58>
 801400e:	68fb      	ldr	r3, [r7, #12]
 8014010:	699b      	ldr	r3, [r3, #24]
 8014012:	461a      	mov	r2, r3
 8014014:	68bb      	ldr	r3, [r7, #8]
 8014016:	4293      	cmp	r3, r2
 8014018:	d30c      	bcc.n	8014034 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0x58>
 801401a:	68bb      	ldr	r3, [r7, #8]
 801401c:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8014020:	68fb      	ldr	r3, [r7, #12]
 8014022:	69db      	ldr	r3, [r3, #28]
 8014024:	3301      	adds	r3, #1
 8014026:	429a      	cmp	r2, r3
 8014028:	d804      	bhi.n	8014034 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0x58>
 801402a:	68bb      	ldr	r3, [r7, #8]
 801402c:	2b00      	cmp	r3, #0
 801402e:	d001      	beq.n	8014034 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0x58>
            return(TXM_MODULE_INVALID_MEMORY);
 8014030:	23f4      	movs	r3, #244	; 0xf4
 8014032:	e075      	b.n	8014120 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(ULONG)))
 8014034:	2204      	movs	r2, #4
 8014036:	6879      	ldr	r1, [r7, #4]
 8014038:	68f8      	ldr	r0, [r7, #12]
 801403a:	f000 ff05 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801403e:	4603      	mov	r3, r0
 8014040:	2b00      	cmp	r3, #0
 8014042:	d104      	bne.n	801404e <_txm_module_manager_tx_timer_performance_info_get_dispatch+0x72>
 8014044:	687b      	ldr	r3, [r7, #4]
 8014046:	2b00      	cmp	r3, #0
 8014048:	d001      	beq.n	801404e <_txm_module_manager_tx_timer_performance_info_get_dispatch+0x72>
            return(TXM_MODULE_INVALID_MEMORY);
 801404a:	23f4      	movs	r3, #244	; 0xf4
 801404c:	e068      	b.n	8014120 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[4])))
 801404e:	683b      	ldr	r3, [r7, #0]
 8014050:	2210      	movs	r2, #16
 8014052:	4619      	mov	r1, r3
 8014054:	68f8      	ldr	r0, [r7, #12]
 8014056:	f000 fef7 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801405a:	4603      	mov	r3, r0
 801405c:	2b00      	cmp	r3, #0
 801405e:	d101      	bne.n	8014064 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0x88>
            return(TXM_MODULE_INVALID_MEMORY);
 8014060:	23f4      	movs	r3, #244	; 0xf4
 8014062:	e05d      	b.n	8014120 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 8014064:	683b      	ldr	r3, [r7, #0]
 8014066:	681b      	ldr	r3, [r3, #0]
 8014068:	2204      	movs	r2, #4
 801406a:	4619      	mov	r1, r3
 801406c:	68f8      	ldr	r0, [r7, #12]
 801406e:	f000 feeb 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8014072:	4603      	mov	r3, r0
 8014074:	2b00      	cmp	r3, #0
 8014076:	d105      	bne.n	8014084 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0xa8>
 8014078:	683b      	ldr	r3, [r7, #0]
 801407a:	681b      	ldr	r3, [r3, #0]
 801407c:	2b00      	cmp	r3, #0
 801407e:	d001      	beq.n	8014084 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0xa8>
            return(TXM_MODULE_INVALID_MEMORY);
 8014080:	23f4      	movs	r3, #244	; 0xf4
 8014082:	e04d      	b.n	8014120 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 8014084:	683b      	ldr	r3, [r7, #0]
 8014086:	3304      	adds	r3, #4
 8014088:	681b      	ldr	r3, [r3, #0]
 801408a:	2204      	movs	r2, #4
 801408c:	4619      	mov	r1, r3
 801408e:	68f8      	ldr	r0, [r7, #12]
 8014090:	f000 feda 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8014094:	4603      	mov	r3, r0
 8014096:	2b00      	cmp	r3, #0
 8014098:	d106      	bne.n	80140a8 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0xcc>
 801409a:	683b      	ldr	r3, [r7, #0]
 801409c:	3304      	adds	r3, #4
 801409e:	681b      	ldr	r3, [r3, #0]
 80140a0:	2b00      	cmp	r3, #0
 80140a2:	d001      	beq.n	80140a8 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0xcc>
            return(TXM_MODULE_INVALID_MEMORY);
 80140a4:	23f4      	movs	r3, #244	; 0xf4
 80140a6:	e03b      	b.n	8014120 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(ULONG)))
 80140a8:	683b      	ldr	r3, [r7, #0]
 80140aa:	3308      	adds	r3, #8
 80140ac:	681b      	ldr	r3, [r3, #0]
 80140ae:	2204      	movs	r2, #4
 80140b0:	4619      	mov	r1, r3
 80140b2:	68f8      	ldr	r0, [r7, #12]
 80140b4:	f000 fec8 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80140b8:	4603      	mov	r3, r0
 80140ba:	2b00      	cmp	r3, #0
 80140bc:	d106      	bne.n	80140cc <_txm_module_manager_tx_timer_performance_info_get_dispatch+0xf0>
 80140be:	683b      	ldr	r3, [r7, #0]
 80140c0:	3308      	adds	r3, #8
 80140c2:	681b      	ldr	r3, [r3, #0]
 80140c4:	2b00      	cmp	r3, #0
 80140c6:	d001      	beq.n	80140cc <_txm_module_manager_tx_timer_performance_info_get_dispatch+0xf0>
            return(TXM_MODULE_INVALID_MEMORY);
 80140c8:	23f4      	movs	r3, #244	; 0xf4
 80140ca:	e029      	b.n	8014120 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0x144>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[3], sizeof(ULONG)))
 80140cc:	683b      	ldr	r3, [r7, #0]
 80140ce:	330c      	adds	r3, #12
 80140d0:	681b      	ldr	r3, [r3, #0]
 80140d2:	2204      	movs	r2, #4
 80140d4:	4619      	mov	r1, r3
 80140d6:	68f8      	ldr	r0, [r7, #12]
 80140d8:	f000 feb6 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80140dc:	4603      	mov	r3, r0
 80140de:	2b00      	cmp	r3, #0
 80140e0:	d106      	bne.n	80140f0 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0x114>
 80140e2:	683b      	ldr	r3, [r7, #0]
 80140e4:	330c      	adds	r3, #12
 80140e6:	681b      	ldr	r3, [r3, #0]
 80140e8:	2b00      	cmp	r3, #0
 80140ea:	d001      	beq.n	80140f0 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0x114>
            return(TXM_MODULE_INVALID_MEMORY);
 80140ec:	23f4      	movs	r3, #244	; 0xf4
 80140ee:	e017      	b.n	8014120 <_txm_module_manager_tx_timer_performance_info_get_dispatch+0x144>
    }

    return_value = (ALIGN_TYPE) _tx_timer_performance_info_get(
 80140f0:	68b8      	ldr	r0, [r7, #8]
 80140f2:	6879      	ldr	r1, [r7, #4]
        (TX_TIMER *) param_0,
        (ULONG *) param_1,
        (ULONG *) extra_parameters[0],
 80140f4:	683b      	ldr	r3, [r7, #0]
 80140f6:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_timer_performance_info_get(
 80140f8:	461c      	mov	r4, r3
        (ULONG *) extra_parameters[1],
 80140fa:	683b      	ldr	r3, [r7, #0]
 80140fc:	3304      	adds	r3, #4
 80140fe:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_timer_performance_info_get(
 8014100:	461d      	mov	r5, r3
        (ULONG *) extra_parameters[2],
 8014102:	683b      	ldr	r3, [r7, #0]
 8014104:	3308      	adds	r3, #8
 8014106:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_timer_performance_info_get(
 8014108:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[3]
 801410a:	683b      	ldr	r3, [r7, #0]
 801410c:	330c      	adds	r3, #12
 801410e:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_timer_performance_info_get(
 8014110:	9301      	str	r3, [sp, #4]
 8014112:	9200      	str	r2, [sp, #0]
 8014114:	462b      	mov	r3, r5
 8014116:	4622      	mov	r2, r4
 8014118:	f7f9 fa1e 	bl	800d558 <_tx_timer_performance_info_get>
 801411c:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 801411e:	697b      	ldr	r3, [r7, #20]
}
 8014120:	4618      	mov	r0, r3
 8014122:	3718      	adds	r7, #24
 8014124:	46bd      	mov	sp, r7
 8014126:	bdb0      	pop	{r4, r5, r7, pc}

08014128 <_txm_module_manager_tx_timer_performance_system_info_get_dispatch>:
    ULONG *deactivates, -> extra_parameters[0]
    ULONG *expirations, -> extra_parameters[1]
    ULONG *expiration_adjusts -> extra_parameters[2]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_timer_performance_system_info_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8014128:	b590      	push	{r4, r7, lr}
 801412a:	b089      	sub	sp, #36	; 0x24
 801412c:	af02      	add	r7, sp, #8
 801412e:	60f8      	str	r0, [r7, #12]
 8014130:	60b9      	str	r1, [r7, #8]
 8014132:	607a      	str	r2, [r7, #4]
 8014134:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8014136:	68fb      	ldr	r3, [r7, #12]
 8014138:	68db      	ldr	r3, [r3, #12]
 801413a:	f003 0302 	and.w	r3, r3, #2
 801413e:	2b00      	cmp	r3, #0
 8014140:	d058      	beq.n	80141f4 <_txm_module_manager_tx_timer_performance_system_info_get_dispatch+0xcc>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_0, sizeof(ULONG)))
 8014142:	2204      	movs	r2, #4
 8014144:	68b9      	ldr	r1, [r7, #8]
 8014146:	68f8      	ldr	r0, [r7, #12]
 8014148:	f000 fe7e 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801414c:	4603      	mov	r3, r0
 801414e:	2b00      	cmp	r3, #0
 8014150:	d104      	bne.n	801415c <_txm_module_manager_tx_timer_performance_system_info_get_dispatch+0x34>
 8014152:	68bb      	ldr	r3, [r7, #8]
 8014154:	2b00      	cmp	r3, #0
 8014156:	d001      	beq.n	801415c <_txm_module_manager_tx_timer_performance_system_info_get_dispatch+0x34>
            return(TXM_MODULE_INVALID_MEMORY);
 8014158:	23f4      	movs	r3, #244	; 0xf4
 801415a:	e05d      	b.n	8014218 <_txm_module_manager_tx_timer_performance_system_info_get_dispatch+0xf0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_1, sizeof(ULONG)))
 801415c:	2204      	movs	r2, #4
 801415e:	6879      	ldr	r1, [r7, #4]
 8014160:	68f8      	ldr	r0, [r7, #12]
 8014162:	f000 fe71 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8014166:	4603      	mov	r3, r0
 8014168:	2b00      	cmp	r3, #0
 801416a:	d104      	bne.n	8014176 <_txm_module_manager_tx_timer_performance_system_info_get_dispatch+0x4e>
 801416c:	687b      	ldr	r3, [r7, #4]
 801416e:	2b00      	cmp	r3, #0
 8014170:	d001      	beq.n	8014176 <_txm_module_manager_tx_timer_performance_system_info_get_dispatch+0x4e>
            return(TXM_MODULE_INVALID_MEMORY);
 8014172:	23f4      	movs	r3, #244	; 0xf4
 8014174:	e050      	b.n	8014218 <_txm_module_manager_tx_timer_performance_system_info_get_dispatch+0xf0>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[3])))
 8014176:	683b      	ldr	r3, [r7, #0]
 8014178:	220c      	movs	r2, #12
 801417a:	4619      	mov	r1, r3
 801417c:	68f8      	ldr	r0, [r7, #12]
 801417e:	f000 fe63 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8014182:	4603      	mov	r3, r0
 8014184:	2b00      	cmp	r3, #0
 8014186:	d101      	bne.n	801418c <_txm_module_manager_tx_timer_performance_system_info_get_dispatch+0x64>
            return(TXM_MODULE_INVALID_MEMORY);
 8014188:	23f4      	movs	r3, #244	; 0xf4
 801418a:	e045      	b.n	8014218 <_txm_module_manager_tx_timer_performance_system_info_get_dispatch+0xf0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[0], sizeof(ULONG)))
 801418c:	683b      	ldr	r3, [r7, #0]
 801418e:	681b      	ldr	r3, [r3, #0]
 8014190:	2204      	movs	r2, #4
 8014192:	4619      	mov	r1, r3
 8014194:	68f8      	ldr	r0, [r7, #12]
 8014196:	f000 fe57 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801419a:	4603      	mov	r3, r0
 801419c:	2b00      	cmp	r3, #0
 801419e:	d105      	bne.n	80141ac <_txm_module_manager_tx_timer_performance_system_info_get_dispatch+0x84>
 80141a0:	683b      	ldr	r3, [r7, #0]
 80141a2:	681b      	ldr	r3, [r3, #0]
 80141a4:	2b00      	cmp	r3, #0
 80141a6:	d001      	beq.n	80141ac <_txm_module_manager_tx_timer_performance_system_info_get_dispatch+0x84>
            return(TXM_MODULE_INVALID_MEMORY);
 80141a8:	23f4      	movs	r3, #244	; 0xf4
 80141aa:	e035      	b.n	8014218 <_txm_module_manager_tx_timer_performance_system_info_get_dispatch+0xf0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(ULONG)))
 80141ac:	683b      	ldr	r3, [r7, #0]
 80141ae:	3304      	adds	r3, #4
 80141b0:	681b      	ldr	r3, [r3, #0]
 80141b2:	2204      	movs	r2, #4
 80141b4:	4619      	mov	r1, r3
 80141b6:	68f8      	ldr	r0, [r7, #12]
 80141b8:	f000 fe46 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80141bc:	4603      	mov	r3, r0
 80141be:	2b00      	cmp	r3, #0
 80141c0:	d106      	bne.n	80141d0 <_txm_module_manager_tx_timer_performance_system_info_get_dispatch+0xa8>
 80141c2:	683b      	ldr	r3, [r7, #0]
 80141c4:	3304      	adds	r3, #4
 80141c6:	681b      	ldr	r3, [r3, #0]
 80141c8:	2b00      	cmp	r3, #0
 80141ca:	d001      	beq.n	80141d0 <_txm_module_manager_tx_timer_performance_system_info_get_dispatch+0xa8>
            return(TXM_MODULE_INVALID_MEMORY);
 80141cc:	23f4      	movs	r3, #244	; 0xf4
 80141ce:	e023      	b.n	8014218 <_txm_module_manager_tx_timer_performance_system_info_get_dispatch+0xf0>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[2], sizeof(ULONG)))
 80141d0:	683b      	ldr	r3, [r7, #0]
 80141d2:	3308      	adds	r3, #8
 80141d4:	681b      	ldr	r3, [r3, #0]
 80141d6:	2204      	movs	r2, #4
 80141d8:	4619      	mov	r1, r3
 80141da:	68f8      	ldr	r0, [r7, #12]
 80141dc:	f000 fe34 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80141e0:	4603      	mov	r3, r0
 80141e2:	2b00      	cmp	r3, #0
 80141e4:	d106      	bne.n	80141f4 <_txm_module_manager_tx_timer_performance_system_info_get_dispatch+0xcc>
 80141e6:	683b      	ldr	r3, [r7, #0]
 80141e8:	3308      	adds	r3, #8
 80141ea:	681b      	ldr	r3, [r3, #0]
 80141ec:	2b00      	cmp	r3, #0
 80141ee:	d001      	beq.n	80141f4 <_txm_module_manager_tx_timer_performance_system_info_get_dispatch+0xcc>
            return(TXM_MODULE_INVALID_MEMORY);
 80141f0:	23f4      	movs	r3, #244	; 0xf4
 80141f2:	e011      	b.n	8014218 <_txm_module_manager_tx_timer_performance_system_info_get_dispatch+0xf0>
    }

    return_value = (ALIGN_TYPE) _tx_timer_performance_system_info_get(
 80141f4:	68b8      	ldr	r0, [r7, #8]
 80141f6:	6879      	ldr	r1, [r7, #4]
        (ULONG *) param_0,
        (ULONG *) param_1,
        (ULONG *) extra_parameters[0],
 80141f8:	683b      	ldr	r3, [r7, #0]
 80141fa:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_timer_performance_system_info_get(
 80141fc:	461a      	mov	r2, r3
        (ULONG *) extra_parameters[1],
 80141fe:	683b      	ldr	r3, [r7, #0]
 8014200:	3304      	adds	r3, #4
 8014202:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_timer_performance_system_info_get(
 8014204:	461c      	mov	r4, r3
        (ULONG *) extra_parameters[2]
 8014206:	683b      	ldr	r3, [r7, #0]
 8014208:	3308      	adds	r3, #8
 801420a:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _tx_timer_performance_system_info_get(
 801420c:	9300      	str	r3, [sp, #0]
 801420e:	4623      	mov	r3, r4
 8014210:	f7f9 f9d6 	bl	800d5c0 <_tx_timer_performance_system_info_get>
 8014214:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 8014216:	697b      	ldr	r3, [r7, #20]
}
 8014218:	4618      	mov	r0, r3
 801421a:	371c      	adds	r7, #28
 801421c:	46bd      	mov	sp, r7
 801421e:	bd90      	pop	{r4, r7, pc}

08014220 <_txm_module_manager_tx_trace_buffer_full_notify_dispatch>:
#ifndef TXM_TRACE_BUFFER_FULL_NOTIFY_CALL_NOT_USED
/* UINT _tx_trace_buffer_full_notify(
    VOID (*full_buffer_callback)(VOID *buffer) -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_trace_buffer_full_notify_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8014220:	b580      	push	{r7, lr}
 8014222:	b084      	sub	sp, #16
 8014224:	af00      	add	r7, sp, #0
 8014226:	6078      	str	r0, [r7, #4]
 8014228:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    return_value = (ALIGN_TYPE) _tx_trace_buffer_full_notify(
 801422a:	683b      	ldr	r3, [r7, #0]
 801422c:	4618      	mov	r0, r3
 801422e:	f7f9 fb8d 	bl	800d94c <_tx_trace_buffer_full_notify>
 8014232:	60f8      	str	r0, [r7, #12]
        (VOID (*)(VOID *buffer)) param_0
    );
    return(return_value);
 8014234:	68fb      	ldr	r3, [r7, #12]
}
 8014236:	4618      	mov	r0, r3
 8014238:	3710      	adds	r7, #16
 801423a:	46bd      	mov	sp, r7
 801423c:	bd80      	pop	{r7, pc}

0801423e <_txm_module_manager_tx_trace_disable_dispatch>:
#endif

#ifndef TXM_TRACE_DISABLE_CALL_NOT_USED
/* UINT _tx_trace_disable(); */
static ALIGN_TYPE _txm_module_manager_tx_trace_disable_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 801423e:	b580      	push	{r7, lr}
 8014240:	b086      	sub	sp, #24
 8014242:	af00      	add	r7, sp, #0
 8014244:	60f8      	str	r0, [r7, #12]
 8014246:	60b9      	str	r1, [r7, #8]
 8014248:	607a      	str	r2, [r7, #4]
 801424a:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_USER_MODE)
 801424c:	68fb      	ldr	r3, [r7, #12]
 801424e:	68db      	ldr	r3, [r3, #12]
 8014250:	f003 0301 	and.w	r3, r3, #1
 8014254:	2b00      	cmp	r3, #0
 8014256:	d001      	beq.n	801425c <_txm_module_manager_tx_trace_disable_dispatch+0x1e>
        return(TXM_MODULE_INVALID_PROPERTIES);
 8014258:	23f3      	movs	r3, #243	; 0xf3
 801425a:	e003      	b.n	8014264 <_txm_module_manager_tx_trace_disable_dispatch+0x26>

    return_value = (ALIGN_TYPE) _tx_trace_disable();
 801425c:	f7f9 fb89 	bl	800d972 <_tx_trace_disable>
 8014260:	6178      	str	r0, [r7, #20]
    return(return_value);
 8014262:	697b      	ldr	r3, [r7, #20]
}
 8014264:	4618      	mov	r0, r3
 8014266:	3718      	adds	r7, #24
 8014268:	46bd      	mov	sp, r7
 801426a:	bd80      	pop	{r7, pc}

0801426c <_txm_module_manager_tx_trace_enable_dispatch>:
    VOID *trace_buffer_start, -> param_0
    ULONG trace_buffer_size, -> param_1
    ULONG registry_entries -> param_2
   ); */
static ALIGN_TYPE _txm_module_manager_tx_trace_enable_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE param_2)
{
 801426c:	b580      	push	{r7, lr}
 801426e:	b086      	sub	sp, #24
 8014270:	af00      	add	r7, sp, #0
 8014272:	60f8      	str	r0, [r7, #12]
 8014274:	60b9      	str	r1, [r7, #8]
 8014276:	607a      	str	r2, [r7, #4]
 8014278:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_USER_MODE)
 801427a:	68fb      	ldr	r3, [r7, #12]
 801427c:	68db      	ldr	r3, [r3, #12]
 801427e:	f003 0301 	and.w	r3, r3, #1
 8014282:	2b00      	cmp	r3, #0
 8014284:	d001      	beq.n	801428a <_txm_module_manager_tx_trace_enable_dispatch+0x1e>
        return(TXM_MODULE_INVALID_PROPERTIES);
 8014286:	23f3      	movs	r3, #243	; 0xf3
 8014288:	e007      	b.n	801429a <_txm_module_manager_tx_trace_enable_dispatch+0x2e>

    return_value = (ALIGN_TYPE) _tx_trace_enable(
 801428a:	68bb      	ldr	r3, [r7, #8]
 801428c:	683a      	ldr	r2, [r7, #0]
 801428e:	6879      	ldr	r1, [r7, #4]
 8014290:	4618      	mov	r0, r3
 8014292:	f7f9 fb76 	bl	800d982 <_tx_trace_enable>
 8014296:	6178      	str	r0, [r7, #20]
        (VOID *) param_0,
        (ULONG) param_1,
        (ULONG) param_2
    );
    return(return_value);
 8014298:	697b      	ldr	r3, [r7, #20]
}
 801429a:	4618      	mov	r0, r3
 801429c:	3718      	adds	r7, #24
 801429e:	46bd      	mov	sp, r7
 80142a0:	bd80      	pop	{r7, pc}

080142a2 <_txm_module_manager_tx_trace_event_filter_dispatch>:
#ifndef TXM_TRACE_EVENT_FILTER_CALL_NOT_USED
/* UINT _tx_trace_event_filter(
    ULONG event_filter_bits -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_trace_event_filter_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 80142a2:	b580      	push	{r7, lr}
 80142a4:	b084      	sub	sp, #16
 80142a6:	af00      	add	r7, sp, #0
 80142a8:	6078      	str	r0, [r7, #4]
 80142aa:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    return_value = (ALIGN_TYPE) _tx_trace_event_filter(
 80142ac:	6838      	ldr	r0, [r7, #0]
 80142ae:	f7f9 fb89 	bl	800d9c4 <_tx_trace_event_filter>
 80142b2:	60f8      	str	r0, [r7, #12]
        (ULONG) param_0
    );
    return(return_value);
 80142b4:	68fb      	ldr	r3, [r7, #12]
}
 80142b6:	4618      	mov	r0, r3
 80142b8:	3710      	adds	r7, #16
 80142ba:	46bd      	mov	sp, r7
 80142bc:	bd80      	pop	{r7, pc}

080142be <_txm_module_manager_tx_trace_event_unfilter_dispatch>:
#ifndef TXM_TRACE_EVENT_UNFILTER_CALL_NOT_USED
/* UINT _tx_trace_event_unfilter(
    ULONG event_unfilter_bits -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_trace_event_unfilter_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 80142be:	b580      	push	{r7, lr}
 80142c0:	b084      	sub	sp, #16
 80142c2:	af00      	add	r7, sp, #0
 80142c4:	6078      	str	r0, [r7, #4]
 80142c6:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    return_value = (ALIGN_TYPE) _tx_trace_event_unfilter(
 80142c8:	6838      	ldr	r0, [r7, #0]
 80142ca:	f7f9 fb8e 	bl	800d9ea <_tx_trace_event_unfilter>
 80142ce:	60f8      	str	r0, [r7, #12]
        (ULONG) param_0
    );
    return(return_value);
 80142d0:	68fb      	ldr	r3, [r7, #12]
}
 80142d2:	4618      	mov	r0, r3
 80142d4:	3710      	adds	r7, #16
 80142d6:	46bd      	mov	sp, r7
 80142d8:	bd80      	pop	{r7, pc}

080142da <_txm_module_manager_tx_trace_interrupt_control_dispatch>:
#ifndef TXM_TRACE_INTERRUPT_CONTROL_CALL_NOT_USED
/* UINT _tx_trace_interrupt_control(
    UINT new_posture -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_trace_interrupt_control_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 80142da:	b580      	push	{r7, lr}
 80142dc:	b084      	sub	sp, #16
 80142de:	af00      	add	r7, sp, #0
 80142e0:	6078      	str	r0, [r7, #4]
 80142e2:	6039      	str	r1, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_USER_MODE)
 80142e4:	687b      	ldr	r3, [r7, #4]
 80142e6:	68db      	ldr	r3, [r3, #12]
 80142e8:	f003 0301 	and.w	r3, r3, #1
 80142ec:	2b00      	cmp	r3, #0
 80142ee:	d001      	beq.n	80142f4 <_txm_module_manager_tx_trace_interrupt_control_dispatch+0x1a>
        return(TXM_MODULE_INVALID_PROPERTIES);
 80142f0:	23f3      	movs	r3, #243	; 0xf3
 80142f2:	e004      	b.n	80142fe <_txm_module_manager_tx_trace_interrupt_control_dispatch+0x24>

    return_value = (ALIGN_TYPE) _tx_trace_interrupt_control(
 80142f4:	6838      	ldr	r0, [r7, #0]
 80142f6:	f7f9 fb8b 	bl	800da10 <_tx_trace_interrupt_control>
 80142fa:	60f8      	str	r0, [r7, #12]
        (UINT) param_0
    );
    return(return_value);
 80142fc:	68fb      	ldr	r3, [r7, #12]
}
 80142fe:	4618      	mov	r0, r3
 8014300:	3710      	adds	r7, #16
 8014302:	46bd      	mov	sp, r7
 8014304:	bd80      	pop	{r7, pc}

08014306 <_txm_module_manager_tx_trace_isr_enter_insert_dispatch>:
#ifndef TXM_TRACE_ISR_ENTER_INSERT_CALL_NOT_USED
/* VOID _tx_trace_isr_enter_insert(
    ULONG isr_id -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_trace_isr_enter_insert_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8014306:	b580      	push	{r7, lr}
 8014308:	b082      	sub	sp, #8
 801430a:	af00      	add	r7, sp, #0
 801430c:	6078      	str	r0, [r7, #4]
 801430e:	6039      	str	r1, [r7, #0]

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_USER_MODE)
 8014310:	687b      	ldr	r3, [r7, #4]
 8014312:	68db      	ldr	r3, [r3, #12]
 8014314:	f003 0301 	and.w	r3, r3, #1
 8014318:	2b00      	cmp	r3, #0
 801431a:	d001      	beq.n	8014320 <_txm_module_manager_tx_trace_isr_enter_insert_dispatch+0x1a>
        return(TXM_MODULE_INVALID_PROPERTIES);
 801431c:	23f3      	movs	r3, #243	; 0xf3
 801431e:	e003      	b.n	8014328 <_txm_module_manager_tx_trace_isr_enter_insert_dispatch+0x22>

    _tx_trace_isr_enter_insert(
 8014320:	6838      	ldr	r0, [r7, #0]
 8014322:	f7f9 fb82 	bl	800da2a <_tx_trace_isr_enter_insert>
        (ULONG) param_0
    );
    return(TX_SUCCESS);
 8014326:	2300      	movs	r3, #0
}
 8014328:	4618      	mov	r0, r3
 801432a:	3708      	adds	r7, #8
 801432c:	46bd      	mov	sp, r7
 801432e:	bd80      	pop	{r7, pc}

08014330 <_txm_module_manager_tx_trace_isr_exit_insert_dispatch>:
#ifndef TXM_TRACE_ISR_EXIT_INSERT_CALL_NOT_USED
/* VOID _tx_trace_isr_exit_insert(
    ULONG isr_id -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_tx_trace_isr_exit_insert_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 8014330:	b580      	push	{r7, lr}
 8014332:	b082      	sub	sp, #8
 8014334:	af00      	add	r7, sp, #0
 8014336:	6078      	str	r0, [r7, #4]
 8014338:	6039      	str	r1, [r7, #0]

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_USER_MODE)
 801433a:	687b      	ldr	r3, [r7, #4]
 801433c:	68db      	ldr	r3, [r3, #12]
 801433e:	f003 0301 	and.w	r3, r3, #1
 8014342:	2b00      	cmp	r3, #0
 8014344:	d001      	beq.n	801434a <_txm_module_manager_tx_trace_isr_exit_insert_dispatch+0x1a>
        return(TXM_MODULE_INVALID_PROPERTIES);
 8014346:	23f3      	movs	r3, #243	; 0xf3
 8014348:	e003      	b.n	8014352 <_txm_module_manager_tx_trace_isr_exit_insert_dispatch+0x22>

    _tx_trace_isr_exit_insert(
 801434a:	6838      	ldr	r0, [r7, #0]
 801434c:	f7f9 fb88 	bl	800da60 <_tx_trace_isr_exit_insert>
        (ULONG) param_0
    );
    return(TX_SUCCESS);
 8014350:	2300      	movs	r3, #0
}
 8014352:	4618      	mov	r0, r3
 8014354:	3708      	adds	r7, #8
 8014356:	46bd      	mov	sp, r7
 8014358:	bd80      	pop	{r7, pc}

0801435a <_txm_module_manager_tx_trace_user_event_insert_dispatch>:
    ULONG info_field_2, -> extra_parameters[0]
    ULONG info_field_3, -> extra_parameters[1]
    ULONG info_field_4 -> extra_parameters[2]
   ); */
static ALIGN_TYPE _txm_module_manager_tx_trace_user_event_insert_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 801435a:	b580      	push	{r7, lr}
 801435c:	b088      	sub	sp, #32
 801435e:	af02      	add	r7, sp, #8
 8014360:	60f8      	str	r0, [r7, #12]
 8014362:	60b9      	str	r1, [r7, #8]
 8014364:	607a      	str	r2, [r7, #4]
 8014366:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8014368:	68fb      	ldr	r3, [r7, #12]
 801436a:	68db      	ldr	r3, [r3, #12]
 801436c:	f003 0302 	and.w	r3, r3, #2
 8014370:	2b00      	cmp	r3, #0
 8014372:	d00a      	beq.n	801438a <_txm_module_manager_tx_trace_user_event_insert_dispatch+0x30>
    {
        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[3])))
 8014374:	683b      	ldr	r3, [r7, #0]
 8014376:	220c      	movs	r2, #12
 8014378:	4619      	mov	r1, r3
 801437a:	68f8      	ldr	r0, [r7, #12]
 801437c:	f000 fd64 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8014380:	4603      	mov	r3, r0
 8014382:	2b00      	cmp	r3, #0
 8014384:	d101      	bne.n	801438a <_txm_module_manager_tx_trace_user_event_insert_dispatch+0x30>
            return(TXM_MODULE_INVALID_MEMORY);
 8014386:	23f4      	movs	r3, #244	; 0xf4
 8014388:	e00f      	b.n	80143aa <_txm_module_manager_tx_trace_user_event_insert_dispatch+0x50>
    }

    return_value = (ALIGN_TYPE) _tx_trace_user_event_insert(
 801438a:	683b      	ldr	r3, [r7, #0]
 801438c:	681a      	ldr	r2, [r3, #0]
        (ULONG) param_0,
        (ULONG) param_1,
        (ULONG) extra_parameters[0],
        (ULONG) extra_parameters[1],
 801438e:	683b      	ldr	r3, [r7, #0]
 8014390:	3304      	adds	r3, #4
    return_value = (ALIGN_TYPE) _tx_trace_user_event_insert(
 8014392:	6819      	ldr	r1, [r3, #0]
        (ULONG) extra_parameters[2]
 8014394:	683b      	ldr	r3, [r7, #0]
 8014396:	3308      	adds	r3, #8
    return_value = (ALIGN_TYPE) _tx_trace_user_event_insert(
 8014398:	681b      	ldr	r3, [r3, #0]
 801439a:	9300      	str	r3, [sp, #0]
 801439c:	460b      	mov	r3, r1
 801439e:	6879      	ldr	r1, [r7, #4]
 80143a0:	68b8      	ldr	r0, [r7, #8]
 80143a2:	f7f9 fb78 	bl	800da96 <_tx_trace_user_event_insert>
 80143a6:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 80143a8:	697b      	ldr	r3, [r7, #20]
}
 80143aa:	4618      	mov	r0, r3
 80143ac:	3718      	adds	r7, #24
 80143ae:	46bd      	mov	sp, r7
 80143b0:	bd80      	pop	{r7, pc}

080143b2 <_txm_module_manager_txm_module_object_allocate_dispatch>:
/* UINT _txm_module_object_allocate(
    VOID **object_ptr, -> param_0
    ULONG object_size -> param_1
   ); */
static ALIGN_TYPE _txm_module_manager_txm_module_object_allocate_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1)
{
 80143b2:	b580      	push	{r7, lr}
 80143b4:	b086      	sub	sp, #24
 80143b6:	af00      	add	r7, sp, #0
 80143b8:	60f8      	str	r0, [r7, #12]
 80143ba:	60b9      	str	r1, [r7, #8]
 80143bc:	607a      	str	r2, [r7, #4]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 80143be:	68fb      	ldr	r3, [r7, #12]
 80143c0:	68db      	ldr	r3, [r3, #12]
 80143c2:	f003 0302 	and.w	r3, r3, #2
 80143c6:	2b00      	cmp	r3, #0
 80143c8:	d00c      	beq.n	80143e4 <_txm_module_manager_txm_module_object_allocate_dispatch+0x32>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_0, sizeof(VOID *)))
 80143ca:	2204      	movs	r2, #4
 80143cc:	68b9      	ldr	r1, [r7, #8]
 80143ce:	68f8      	ldr	r0, [r7, #12]
 80143d0:	f000 fd3a 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80143d4:	4603      	mov	r3, r0
 80143d6:	2b00      	cmp	r3, #0
 80143d8:	d104      	bne.n	80143e4 <_txm_module_manager_txm_module_object_allocate_dispatch+0x32>
 80143da:	68bb      	ldr	r3, [r7, #8]
 80143dc:	2b00      	cmp	r3, #0
 80143de:	d001      	beq.n	80143e4 <_txm_module_manager_txm_module_object_allocate_dispatch+0x32>
            return(TXM_MODULE_INVALID_MEMORY);
 80143e0:	23f4      	movs	r3, #244	; 0xf4
 80143e2:	e007      	b.n	80143f4 <_txm_module_manager_txm_module_object_allocate_dispatch+0x42>
    }

    return_value = (ALIGN_TYPE) _txm_module_manager_object_allocate(
 80143e4:	68bb      	ldr	r3, [r7, #8]
 80143e6:	68fa      	ldr	r2, [r7, #12]
 80143e8:	6879      	ldr	r1, [r7, #4]
 80143ea:	4618      	mov	r0, r3
 80143ec:	f000 fd7a 	bl	8014ee4 <_txm_module_manager_object_allocate>
 80143f0:	6178      	str	r0, [r7, #20]
        (VOID **) param_0,
        (ULONG) param_1,
        module_instance
    );
    return(return_value);
 80143f2:	697b      	ldr	r3, [r7, #20]
}
 80143f4:	4618      	mov	r0, r3
 80143f6:	3718      	adds	r7, #24
 80143f8:	46bd      	mov	sp, r7
 80143fa:	bd80      	pop	{r7, pc}

080143fc <_txm_module_manager_txm_module_object_deallocate_dispatch>:
#ifndef TXM_MODULE_OBJECT_DEALLOCATE_CALL_NOT_USED
/* UINT _txm_module_object_deallocate(
    VOID *object_ptr -> param_0
   ); */
static ALIGN_TYPE _txm_module_manager_txm_module_object_deallocate_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0)
{
 80143fc:	b580      	push	{r7, lr}
 80143fe:	b086      	sub	sp, #24
 8014400:	af00      	add	r7, sp, #0
 8014402:	6078      	str	r0, [r7, #4]
 8014404:	6039      	str	r1, [r7, #0]
ALIGN_TYPE return_value;
TXM_MODULE_ALLOCATED_OBJECT *object_ptr;
ALIGN_TYPE object_end;
ALIGN_TYPE object_pool_end;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8014406:	687b      	ldr	r3, [r7, #4]
 8014408:	68db      	ldr	r3, [r3, #12]
 801440a:	f003 0302 	and.w	r3, r3, #2
 801440e:	2b00      	cmp	r3, #0
 8014410:	d024      	beq.n	801445c <_txm_module_manager_txm_module_object_deallocate_dispatch+0x60>
    {
        /* Is the object pool created?  */
        if (_txm_module_manager_object_pool_created == TX_TRUE)
 8014412:	4b17      	ldr	r3, [pc, #92]	; (8014470 <_txm_module_manager_txm_module_object_deallocate_dispatch+0x74>)
 8014414:	681b      	ldr	r3, [r3, #0]
 8014416:	2b01      	cmp	r3, #1
 8014418:	d120      	bne.n	801445c <_txm_module_manager_txm_module_object_deallocate_dispatch+0x60>
        {

            /* Get the module allocated object.  */
            object_ptr =  ((TXM_MODULE_ALLOCATED_OBJECT *) param_0) - 1;
 801441a:	683b      	ldr	r3, [r7, #0]
 801441c:	3b10      	subs	r3, #16
 801441e:	617b      	str	r3, [r7, #20]

            /* Get the end address of the object pool.  */
            object_pool_end = (ALIGN_TYPE) (_txm_module_manager_object_pool.tx_byte_pool_start + _txm_module_manager_object_pool.tx_byte_pool_size);
 8014420:	4b14      	ldr	r3, [pc, #80]	; (8014474 <_txm_module_manager_txm_module_object_deallocate_dispatch+0x78>)
 8014422:	699a      	ldr	r2, [r3, #24]
 8014424:	4b13      	ldr	r3, [pc, #76]	; (8014474 <_txm_module_manager_txm_module_object_deallocate_dispatch+0x78>)
 8014426:	69db      	ldr	r3, [r3, #28]
 8014428:	4413      	add	r3, r2
 801442a:	613b      	str	r3, [r7, #16]

            /* Check that the pointer is in the object pool.  */
            if ((ALIGN_TYPE) object_ptr < (ALIGN_TYPE) _txm_module_manager_object_pool.tx_byte_pool_start ||
 801442c:	4b11      	ldr	r3, [pc, #68]	; (8014474 <_txm_module_manager_txm_module_object_deallocate_dispatch+0x78>)
 801442e:	699b      	ldr	r3, [r3, #24]
 8014430:	461a      	mov	r2, r3
 8014432:	697b      	ldr	r3, [r7, #20]
 8014434:	429a      	cmp	r2, r3
 8014436:	d803      	bhi.n	8014440 <_txm_module_manager_txm_module_object_deallocate_dispatch+0x44>
                (ALIGN_TYPE) object_ptr >= (ALIGN_TYPE) object_pool_end)
 8014438:	697b      	ldr	r3, [r7, #20]
            if ((ALIGN_TYPE) object_ptr < (ALIGN_TYPE) _txm_module_manager_object_pool.tx_byte_pool_start ||
 801443a:	693a      	ldr	r2, [r7, #16]
 801443c:	429a      	cmp	r2, r3
 801443e:	d801      	bhi.n	8014444 <_txm_module_manager_txm_module_object_deallocate_dispatch+0x48>
            {
                /* Pointer is outside of the object pool.  */
                return(TXM_MODULE_INVALID_MEMORY);
 8014440:	23f4      	movs	r3, #244	; 0xf4
 8014442:	e011      	b.n	8014468 <_txm_module_manager_txm_module_object_deallocate_dispatch+0x6c>
            }

            /* Get the end addresses of the object.  */
            object_end = ((ALIGN_TYPE) object_ptr) + sizeof(TXM_MODULE_ALLOCATED_OBJECT) + object_ptr -> txm_module_object_size;
 8014444:	697b      	ldr	r3, [r7, #20]
 8014446:	68da      	ldr	r2, [r3, #12]
 8014448:	697b      	ldr	r3, [r7, #20]
 801444a:	4413      	add	r3, r2
 801444c:	3310      	adds	r3, #16
 801444e:	60fb      	str	r3, [r7, #12]

            /* Check that the object is in the object pool.  */
            if (object_end >= object_pool_end)
 8014450:	68fa      	ldr	r2, [r7, #12]
 8014452:	693b      	ldr	r3, [r7, #16]
 8014454:	429a      	cmp	r2, r3
 8014456:	d301      	bcc.n	801445c <_txm_module_manager_txm_module_object_deallocate_dispatch+0x60>
            {
                /* Object is outside of the object pool.  */
                return(TXM_MODULE_INVALID_MEMORY);
 8014458:	23f4      	movs	r3, #244	; 0xf4
 801445a:	e005      	b.n	8014468 <_txm_module_manager_txm_module_object_deallocate_dispatch+0x6c>
            }
        }
    }

    return_value = (ALIGN_TYPE) _txm_module_manager_object_deallocate(
 801445c:	683b      	ldr	r3, [r7, #0]
 801445e:	4618      	mov	r0, r3
 8014460:	f000 fda8 	bl	8014fb4 <_txm_module_manager_object_deallocate>
 8014464:	60b8      	str	r0, [r7, #8]
        (VOID *) param_0
    );
    return(return_value);
 8014466:	68bb      	ldr	r3, [r7, #8]
}
 8014468:	4618      	mov	r0, r3
 801446a:	3718      	adds	r7, #24
 801446c:	46bd      	mov	sp, r7
 801446e:	bd80      	pop	{r7, pc}
 8014470:	2000f670 	.word	0x2000f670
 8014474:	2000f63c 	.word	0x2000f63c

08014478 <_txm_module_manager_txm_module_object_pointer_get_dispatch>:
    UINT object_type, -> param_0
    CHAR *name, -> param_1
    VOID **object_ptr -> param_2
   ); */
static ALIGN_TYPE _txm_module_manager_txm_module_object_pointer_get_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE param_2)
{
 8014478:	b580      	push	{r7, lr}
 801447a:	b086      	sub	sp, #24
 801447c:	af00      	add	r7, sp, #0
 801447e:	60f8      	str	r0, [r7, #12]
 8014480:	60b9      	str	r1, [r7, #8]
 8014482:	607a      	str	r2, [r7, #4]
 8014484:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8014486:	68fb      	ldr	r3, [r7, #12]
 8014488:	68db      	ldr	r3, [r3, #12]
 801448a:	f003 0302 	and.w	r3, r3, #2
 801448e:	2b00      	cmp	r3, #0
 8014490:	d02a      	beq.n	80144e8 <_txm_module_manager_txm_module_object_pointer_get_dispatch+0x70>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_DEREFERENCE_STRING(module_instance, param_1))
 8014492:	2201      	movs	r2, #1
 8014494:	6879      	ldr	r1, [r7, #4]
 8014496:	68f8      	ldr	r0, [r7, #12]
 8014498:	f000 fcd6 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801449c:	4603      	mov	r3, r0
 801449e:	2b00      	cmp	r3, #0
 80144a0:	d115      	bne.n	80144ce <_txm_module_manager_txm_module_object_pointer_get_dispatch+0x56>
 80144a2:	687b      	ldr	r3, [r7, #4]
 80144a4:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80144a8:	d00c      	beq.n	80144c4 <_txm_module_manager_txm_module_object_pointer_get_dispatch+0x4c>
 80144aa:	68fb      	ldr	r3, [r7, #12]
 80144ac:	699b      	ldr	r3, [r3, #24]
 80144ae:	461a      	mov	r2, r3
 80144b0:	687b      	ldr	r3, [r7, #4]
 80144b2:	4293      	cmp	r3, r2
 80144b4:	d306      	bcc.n	80144c4 <_txm_module_manager_txm_module_object_pointer_get_dispatch+0x4c>
 80144b6:	687b      	ldr	r3, [r7, #4]
 80144b8:	1c5a      	adds	r2, r3, #1
 80144ba:	68fb      	ldr	r3, [r7, #12]
 80144bc:	69db      	ldr	r3, [r3, #28]
 80144be:	3301      	adds	r3, #1
 80144c0:	429a      	cmp	r2, r3
 80144c2:	d904      	bls.n	80144ce <_txm_module_manager_txm_module_object_pointer_get_dispatch+0x56>
 80144c4:	687b      	ldr	r3, [r7, #4]
 80144c6:	2b00      	cmp	r3, #0
 80144c8:	d001      	beq.n	80144ce <_txm_module_manager_txm_module_object_pointer_get_dispatch+0x56>
            return(TXM_MODULE_INVALID_MEMORY);
 80144ca:	23f4      	movs	r3, #244	; 0xf4
 80144cc:	e014      	b.n	80144f8 <_txm_module_manager_txm_module_object_pointer_get_dispatch+0x80>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, param_2, sizeof(VOID *)))
 80144ce:	2204      	movs	r2, #4
 80144d0:	6839      	ldr	r1, [r7, #0]
 80144d2:	68f8      	ldr	r0, [r7, #12]
 80144d4:	f000 fcb8 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80144d8:	4603      	mov	r3, r0
 80144da:	2b00      	cmp	r3, #0
 80144dc:	d104      	bne.n	80144e8 <_txm_module_manager_txm_module_object_pointer_get_dispatch+0x70>
 80144de:	683b      	ldr	r3, [r7, #0]
 80144e0:	2b00      	cmp	r3, #0
 80144e2:	d001      	beq.n	80144e8 <_txm_module_manager_txm_module_object_pointer_get_dispatch+0x70>
            return(TXM_MODULE_INVALID_MEMORY);
 80144e4:	23f4      	movs	r3, #244	; 0xf4
 80144e6:	e007      	b.n	80144f8 <_txm_module_manager_txm_module_object_pointer_get_dispatch+0x80>
    }

    return_value = (ALIGN_TYPE) _txm_module_manager_object_pointer_get(
 80144e8:	687b      	ldr	r3, [r7, #4]
 80144ea:	683a      	ldr	r2, [r7, #0]
 80144ec:	4619      	mov	r1, r3
 80144ee:	68b8      	ldr	r0, [r7, #8]
 80144f0:	f000 fdc6 	bl	8015080 <_txm_module_manager_object_pointer_get>
 80144f4:	6178      	str	r0, [r7, #20]
        (UINT) param_0,
        (CHAR *) param_1,
        (VOID **) param_2
    );
    return(return_value);
 80144f6:	697b      	ldr	r3, [r7, #20]
}
 80144f8:	4618      	mov	r0, r3
 80144fa:	3718      	adds	r7, #24
 80144fc:	46bd      	mov	sp, r7
 80144fe:	bd80      	pop	{r7, pc}

08014500 <_txm_module_manager_txm_module_object_pointer_get_extended_dispatch>:
    CHAR *name, -> param_1
    UINT name_length, -> extra_parameters[0]
    VOID **object_ptr -> extra_parameters[1]
   ); */
static ALIGN_TYPE _txm_module_manager_txm_module_object_pointer_get_extended_dispatch(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE *extra_parameters)
{
 8014500:	b580      	push	{r7, lr}
 8014502:	b086      	sub	sp, #24
 8014504:	af00      	add	r7, sp, #0
 8014506:	60f8      	str	r0, [r7, #12]
 8014508:	60b9      	str	r1, [r7, #8]
 801450a:	607a      	str	r2, [r7, #4]
 801450c:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value;

    if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 801450e:	68fb      	ldr	r3, [r7, #12]
 8014510:	68db      	ldr	r3, [r3, #12]
 8014512:	f003 0302 	and.w	r3, r3, #2
 8014516:	2b00      	cmp	r3, #0
 8014518:	d03a      	beq.n	8014590 <_txm_module_manager_txm_module_object_pointer_get_extended_dispatch+0x90>
    {
        if (!TXM_MODULE_MANAGER_PARAM_CHECK_DEREFERENCE_STRING(module_instance, param_1))
 801451a:	2201      	movs	r2, #1
 801451c:	6879      	ldr	r1, [r7, #4]
 801451e:	68f8      	ldr	r0, [r7, #12]
 8014520:	f000 fc92 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8014524:	4603      	mov	r3, r0
 8014526:	2b00      	cmp	r3, #0
 8014528:	d115      	bne.n	8014556 <_txm_module_manager_txm_module_object_pointer_get_extended_dispatch+0x56>
 801452a:	687b      	ldr	r3, [r7, #4]
 801452c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8014530:	d00c      	beq.n	801454c <_txm_module_manager_txm_module_object_pointer_get_extended_dispatch+0x4c>
 8014532:	68fb      	ldr	r3, [r7, #12]
 8014534:	699b      	ldr	r3, [r3, #24]
 8014536:	461a      	mov	r2, r3
 8014538:	687b      	ldr	r3, [r7, #4]
 801453a:	4293      	cmp	r3, r2
 801453c:	d306      	bcc.n	801454c <_txm_module_manager_txm_module_object_pointer_get_extended_dispatch+0x4c>
 801453e:	687b      	ldr	r3, [r7, #4]
 8014540:	1c5a      	adds	r2, r3, #1
 8014542:	68fb      	ldr	r3, [r7, #12]
 8014544:	69db      	ldr	r3, [r3, #28]
 8014546:	3301      	adds	r3, #1
 8014548:	429a      	cmp	r2, r3
 801454a:	d904      	bls.n	8014556 <_txm_module_manager_txm_module_object_pointer_get_extended_dispatch+0x56>
 801454c:	687b      	ldr	r3, [r7, #4]
 801454e:	2b00      	cmp	r3, #0
 8014550:	d001      	beq.n	8014556 <_txm_module_manager_txm_module_object_pointer_get_extended_dispatch+0x56>
            return(TXM_MODULE_INVALID_MEMORY);
 8014552:	23f4      	movs	r3, #244	; 0xf4
 8014554:	e027      	b.n	80145a6 <_txm_module_manager_txm_module_object_pointer_get_extended_dispatch+0xa6>

        if (!TXM_MODULE_MANAGER_ENSURE_INSIDE_MODULE_DATA(module_instance, (ALIGN_TYPE)extra_parameters, sizeof(ALIGN_TYPE[2])))
 8014556:	683b      	ldr	r3, [r7, #0]
 8014558:	2208      	movs	r2, #8
 801455a:	4619      	mov	r1, r3
 801455c:	68f8      	ldr	r0, [r7, #12]
 801455e:	f000 fc73 	bl	8014e48 <_txm_module_manager_inside_data_check>
 8014562:	4603      	mov	r3, r0
 8014564:	2b00      	cmp	r3, #0
 8014566:	d101      	bne.n	801456c <_txm_module_manager_txm_module_object_pointer_get_extended_dispatch+0x6c>
            return(TXM_MODULE_INVALID_MEMORY);
 8014568:	23f4      	movs	r3, #244	; 0xf4
 801456a:	e01c      	b.n	80145a6 <_txm_module_manager_txm_module_object_pointer_get_extended_dispatch+0xa6>

        if (!TXM_MODULE_MANAGER_PARAM_CHECK_BUFFER_WRITE(module_instance, extra_parameters[1], sizeof(VOID *)))
 801456c:	683b      	ldr	r3, [r7, #0]
 801456e:	3304      	adds	r3, #4
 8014570:	681b      	ldr	r3, [r3, #0]
 8014572:	2204      	movs	r2, #4
 8014574:	4619      	mov	r1, r3
 8014576:	68f8      	ldr	r0, [r7, #12]
 8014578:	f000 fc66 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801457c:	4603      	mov	r3, r0
 801457e:	2b00      	cmp	r3, #0
 8014580:	d106      	bne.n	8014590 <_txm_module_manager_txm_module_object_pointer_get_extended_dispatch+0x90>
 8014582:	683b      	ldr	r3, [r7, #0]
 8014584:	3304      	adds	r3, #4
 8014586:	681b      	ldr	r3, [r3, #0]
 8014588:	2b00      	cmp	r3, #0
 801458a:	d001      	beq.n	8014590 <_txm_module_manager_txm_module_object_pointer_get_extended_dispatch+0x90>
            return(TXM_MODULE_INVALID_MEMORY);
 801458c:	23f4      	movs	r3, #244	; 0xf4
 801458e:	e00a      	b.n	80145a6 <_txm_module_manager_txm_module_object_pointer_get_extended_dispatch+0xa6>
    }

    return_value = (ALIGN_TYPE) _txm_module_manager_object_pointer_get_extended(
 8014590:	6879      	ldr	r1, [r7, #4]
 8014592:	683b      	ldr	r3, [r7, #0]
 8014594:	681a      	ldr	r2, [r3, #0]
        (UINT) param_0,
        (CHAR *) param_1,
        (UINT) extra_parameters[0],
        (VOID **) extra_parameters[1]
 8014596:	683b      	ldr	r3, [r7, #0]
 8014598:	3304      	adds	r3, #4
 801459a:	681b      	ldr	r3, [r3, #0]
    return_value = (ALIGN_TYPE) _txm_module_manager_object_pointer_get_extended(
 801459c:	68b8      	ldr	r0, [r7, #8]
 801459e:	f000 fd83 	bl	80150a8 <_txm_module_manager_object_pointer_get_extended>
 80145a2:	6178      	str	r0, [r7, #20]
    );
    return(return_value);
 80145a4:	697b      	ldr	r3, [r7, #20]
}
 80145a6:	4618      	mov	r0, r3
 80145a8:	3718      	adds	r7, #24
 80145aa:	46bd      	mov	sp, r7
 80145ac:	bd80      	pop	{r7, pc}
	...

080145b0 <_txm_module_manager_kernel_dispatch>:
/*                                            CALL_NOT_USED option,       */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
ALIGN_TYPE _txm_module_manager_kernel_dispatch(ULONG kernel_request, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE param_2)
{
 80145b0:	b580      	push	{r7, lr}
 80145b2:	b088      	sub	sp, #32
 80145b4:	af02      	add	r7, sp, #8
 80145b6:	60f8      	str	r0, [r7, #12]
 80145b8:	60b9      	str	r1, [r7, #8]
 80145ba:	607a      	str	r2, [r7, #4]
 80145bc:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value = TX_NOT_AVAILABLE;
 80145be:	231d      	movs	r3, #29
 80145c0:	617b      	str	r3, [r7, #20]
TXM_MODULE_INSTANCE *module_instance;


    /* Get the module instance.  */
    module_instance = _tx_thread_current_ptr -> tx_thread_module_instance_ptr;
 80145c2:	4bba      	ldr	r3, [pc, #744]	; (80148ac <_txm_module_manager_kernel_dispatch+0x2fc>)
 80145c4:	681b      	ldr	r3, [r3, #0]
 80145c6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80145ca:	613b      	str	r3, [r7, #16]

    /* Sanity-check for a valid module instance.  */
    if (module_instance == TX_NULL)
 80145cc:	693b      	ldr	r3, [r7, #16]
 80145ce:	2b00      	cmp	r3, #0
 80145d0:	d101      	bne.n	80145d6 <_txm_module_manager_kernel_dispatch+0x26>
    {
        /* Just return!  */
        return(TXM_MODULE_INVALID);
 80145d2:	23f2      	movs	r3, #242	; 0xf2
 80145d4:	e398      	b.n	8014d08 <_txm_module_manager_kernel_dispatch+0x758>
    }

    switch (kernel_request)
 80145d6:	68fb      	ldr	r3, [r7, #12]
 80145d8:	3b01      	subs	r3, #1
 80145da:	2b5f      	cmp	r3, #95	; 0x5f
 80145dc:	f200 8374 	bhi.w	8014cc8 <_txm_module_manager_kernel_dispatch+0x718>
 80145e0:	a201      	add	r2, pc, #4	; (adr r2, 80145e8 <_txm_module_manager_kernel_dispatch+0x38>)
 80145e2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80145e6:	bf00      	nop
 80145e8:	08014769 	.word	0x08014769
 80145ec:	08014779 	.word	0x08014779
 80145f0:	08014789 	.word	0x08014789
 80145f4:	08014795 	.word	0x08014795
 80145f8:	080147a5 	.word	0x080147a5
 80145fc:	080147b5 	.word	0x080147b5
 8014600:	080147c5 	.word	0x080147c5
 8014604:	080147d1 	.word	0x080147d1
 8014608:	080147dd 	.word	0x080147dd
 801460c:	080147ed 	.word	0x080147ed
 8014610:	080147fd 	.word	0x080147fd
 8014614:	08014809 	.word	0x08014809
 8014618:	08014819 	.word	0x08014819
 801461c:	08014829 	.word	0x08014829
 8014620:	08014839 	.word	0x08014839
 8014624:	08014845 	.word	0x08014845
 8014628:	08014851 	.word	0x08014851
 801462c:	08014861 	.word	0x08014861
 8014630:	0801486d 	.word	0x0801486d
 8014634:	0801487d 	.word	0x0801487d
 8014638:	0801488d 	.word	0x0801488d
 801463c:	0801489d 	.word	0x0801489d
 8014640:	080148b1 	.word	0x080148b1
 8014644:	080148c1 	.word	0x080148c1
 8014648:	08014abb 	.word	0x08014abb
 801464c:	080148cf 	.word	0x080148cf
 8014650:	080148df 	.word	0x080148df
 8014654:	080148eb 	.word	0x080148eb
 8014658:	080148f9 	.word	0x080148f9
 801465c:	08014909 	.word	0x08014909
 8014660:	08014919 	.word	0x08014919
 8014664:	08014929 	.word	0x08014929
 8014668:	08014935 	.word	0x08014935
 801466c:	08014941 	.word	0x08014941
 8014670:	08014951 	.word	0x08014951
 8014674:	0801495d 	.word	0x0801495d
 8014678:	08014969 	.word	0x08014969
 801467c:	08014979 	.word	0x08014979
 8014680:	08014989 	.word	0x08014989
 8014684:	08014999 	.word	0x08014999
 8014688:	080149a9 	.word	0x080149a9
 801468c:	080149b5 	.word	0x080149b5
 8014690:	080149c5 	.word	0x080149c5
 8014694:	080149d5 	.word	0x080149d5
 8014698:	080149e3 	.word	0x080149e3
 801469c:	080149f1 	.word	0x080149f1
 80146a0:	08014a01 	.word	0x08014a01
 80146a4:	08014a0d 	.word	0x08014a0d
 80146a8:	08014a1b 	.word	0x08014a1b
 80146ac:	08014a2b 	.word	0x08014a2b
 80146b0:	08014a3b 	.word	0x08014a3b
 80146b4:	08014a4b 	.word	0x08014a4b
 80146b8:	08014a57 	.word	0x08014a57
 80146bc:	08014a63 	.word	0x08014a63
 80146c0:	08014a71 	.word	0x08014a71
 80146c4:	08014a81 	.word	0x08014a81
 80146c8:	08014a8d 	.word	0x08014a8d
 80146cc:	08014a9b 	.word	0x08014a9b
 80146d0:	08014aab 	.word	0x08014aab
 80146d4:	08014ac7 	.word	0x08014ac7
 80146d8:	08014ad7 	.word	0x08014ad7
 80146dc:	08014ae7 	.word	0x08014ae7
 80146e0:	08014af7 	.word	0x08014af7
 80146e4:	08014b07 	.word	0x08014b07
 80146e8:	08014b17 	.word	0x08014b17
 80146ec:	08014b23 	.word	0x08014b23
 80146f0:	08014b2f 	.word	0x08014b2f
 80146f4:	08014b3b 	.word	0x08014b3b
 80146f8:	08014b47 	.word	0x08014b47
 80146fc:	08014b5f 	.word	0x08014b5f
 8014700:	08014b6b 	.word	0x08014b6b
 8014704:	08014b7b 	.word	0x08014b7b
 8014708:	08014b87 	.word	0x08014b87
 801470c:	08014b97 	.word	0x08014b97
 8014710:	08014ba3 	.word	0x08014ba3
 8014714:	08014baf 	.word	0x08014baf
 8014718:	08014bbf 	.word	0x08014bbf
 801471c:	08014bcf 	.word	0x08014bcf
 8014720:	08014bdb 	.word	0x08014bdb
 8014724:	08014be7 	.word	0x08014be7
 8014728:	08014bf7 	.word	0x08014bf7
 801472c:	08014c07 	.word	0x08014c07
 8014730:	08014c33 	.word	0x08014c33
 8014734:	08014c43 	.word	0x08014c43
 8014738:	08014c4f 	.word	0x08014c4f
 801473c:	08014c23 	.word	0x08014c23
 8014740:	08014c5b 	.word	0x08014c5b
 8014744:	08014c67 	.word	0x08014c67
 8014748:	08014c73 	.word	0x08014c73
 801474c:	08014c17 	.word	0x08014c17
 8014750:	08014c7f 	.word	0x08014c7f
 8014754:	08014b53 	.word	0x08014b53
 8014758:	08014ca9 	.word	0x08014ca9
 801475c:	08014cb9 	.word	0x08014cb9
 8014760:	08014c8f 	.word	0x08014c8f
 8014764:	08014c9d 	.word	0x08014c9d
    {
    #ifndef TXM_BLOCK_ALLOCATE_CALL_NOT_USED
    case TXM_BLOCK_ALLOCATE_CALL:
    {
        return_value = _txm_module_manager_tx_block_allocate_dispatch(module_instance, param_0, param_1, param_2);
 8014768:	683b      	ldr	r3, [r7, #0]
 801476a:	687a      	ldr	r2, [r7, #4]
 801476c:	68b9      	ldr	r1, [r7, #8]
 801476e:	6938      	ldr	r0, [r7, #16]
 8014770:	f7fb fdae 	bl	80102d0 <_txm_module_manager_tx_block_allocate_dispatch>
 8014774:	6178      	str	r0, [r7, #20]
        break;
 8014776:	e2c6      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_BLOCK_POOL_CREATE_CALL_NOT_USED
    case TXM_BLOCK_POOL_CREATE_CALL:
    {
        return_value = _txm_module_manager_tx_block_pool_create_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014778:	683b      	ldr	r3, [r7, #0]
 801477a:	687a      	ldr	r2, [r7, #4]
 801477c:	68b9      	ldr	r1, [r7, #8]
 801477e:	6938      	ldr	r0, [r7, #16]
 8014780:	f7fb fdec 	bl	801035c <_txm_module_manager_tx_block_pool_create_dispatch>
 8014784:	6178      	str	r0, [r7, #20]
        break;
 8014786:	e2be      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_BLOCK_POOL_DELETE_CALL_NOT_USED
    case TXM_BLOCK_POOL_DELETE_CALL:
    {
        return_value = _txm_module_manager_tx_block_pool_delete_dispatch(module_instance, param_0);
 8014788:	68b9      	ldr	r1, [r7, #8]
 801478a:	6938      	ldr	r0, [r7, #16]
 801478c:	f7fb fe72 	bl	8010474 <_txm_module_manager_tx_block_pool_delete_dispatch>
 8014790:	6178      	str	r0, [r7, #20]
        break;
 8014792:	e2b8      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_BLOCK_POOL_INFO_GET_CALL_NOT_USED
    case TXM_BLOCK_POOL_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_block_pool_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014794:	683b      	ldr	r3, [r7, #0]
 8014796:	687a      	ldr	r2, [r7, #4]
 8014798:	68b9      	ldr	r1, [r7, #8]
 801479a:	6938      	ldr	r0, [r7, #16]
 801479c:	f7fb fea6 	bl	80104ec <_txm_module_manager_tx_block_pool_info_get_dispatch>
 80147a0:	6178      	str	r0, [r7, #20]
        break;
 80147a2:	e2b0      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_BLOCK_POOL_PERFORMANCE_INFO_GET_CALL_NOT_USED
    case TXM_BLOCK_POOL_PERFORMANCE_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_block_pool_performance_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 80147a4:	683b      	ldr	r3, [r7, #0]
 80147a6:	687a      	ldr	r2, [r7, #4]
 80147a8:	68b9      	ldr	r1, [r7, #8]
 80147aa:	6938      	ldr	r0, [r7, #16]
 80147ac:	f7fb ff5c 	bl	8010668 <_txm_module_manager_tx_block_pool_performance_info_get_dispatch>
 80147b0:	6178      	str	r0, [r7, #20]
        break;
 80147b2:	e2a8      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_BLOCK_POOL_PERFORMANCE_SYSTEM_INFO_GET_CALL_NOT_USED
    case TXM_BLOCK_POOL_PERFORMANCE_SYSTEM_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_block_pool_performance_system_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 80147b4:	683b      	ldr	r3, [r7, #0]
 80147b6:	687a      	ldr	r2, [r7, #4]
 80147b8:	68b9      	ldr	r1, [r7, #8]
 80147ba:	6938      	ldr	r0, [r7, #16]
 80147bc:	f7fb ffe2 	bl	8010784 <_txm_module_manager_tx_block_pool_performance_system_info_get_dispatch>
 80147c0:	6178      	str	r0, [r7, #20]
        break;
 80147c2:	e2a0      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_BLOCK_POOL_PRIORITIZE_CALL_NOT_USED
    case TXM_BLOCK_POOL_PRIORITIZE_CALL:
    {
        return_value = _txm_module_manager_tx_block_pool_prioritize_dispatch(module_instance, param_0);
 80147c4:	68b9      	ldr	r1, [r7, #8]
 80147c6:	6938      	ldr	r0, [r7, #16]
 80147c8:	f7fc f840 	bl	801084c <_txm_module_manager_tx_block_pool_prioritize_dispatch>
 80147cc:	6178      	str	r0, [r7, #20]
        break;
 80147ce:	e29a      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_BLOCK_RELEASE_CALL_NOT_USED
    case TXM_BLOCK_RELEASE_CALL:
    {
        return_value = _txm_module_manager_tx_block_release_dispatch(module_instance, param_0);
 80147d0:	68b9      	ldr	r1, [r7, #8]
 80147d2:	6938      	ldr	r0, [r7, #16]
 80147d4:	f7fc f86e 	bl	80108b4 <_txm_module_manager_tx_block_release_dispatch>
 80147d8:	6178      	str	r0, [r7, #20]
        break;
 80147da:	e294      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_BYTE_ALLOCATE_CALL_NOT_USED
    case TXM_BYTE_ALLOCATE_CALL:
    {
        return_value = _txm_module_manager_tx_byte_allocate_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 80147dc:	683b      	ldr	r3, [r7, #0]
 80147de:	687a      	ldr	r2, [r7, #4]
 80147e0:	68b9      	ldr	r1, [r7, #8]
 80147e2:	6938      	ldr	r0, [r7, #16]
 80147e4:	f7fc f88f 	bl	8010906 <_txm_module_manager_tx_byte_allocate_dispatch>
 80147e8:	6178      	str	r0, [r7, #20]
        break;
 80147ea:	e28c      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_BYTE_POOL_CREATE_CALL_NOT_USED
    case TXM_BYTE_POOL_CREATE_CALL:
    {
        return_value = _txm_module_manager_tx_byte_pool_create_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 80147ec:	683b      	ldr	r3, [r7, #0]
 80147ee:	687a      	ldr	r2, [r7, #4]
 80147f0:	68b9      	ldr	r1, [r7, #8]
 80147f2:	6938      	ldr	r0, [r7, #16]
 80147f4:	f7fc f8da 	bl	80109ac <_txm_module_manager_tx_byte_pool_create_dispatch>
 80147f8:	6178      	str	r0, [r7, #20]
        break;
 80147fa:	e284      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_BYTE_POOL_DELETE_CALL_NOT_USED
    case TXM_BYTE_POOL_DELETE_CALL:
    {
        return_value = _txm_module_manager_tx_byte_pool_delete_dispatch(module_instance, param_0);
 80147fc:	68b9      	ldr	r1, [r7, #8]
 80147fe:	6938      	ldr	r0, [r7, #16]
 8014800:	f7fc f95a 	bl	8010ab8 <_txm_module_manager_tx_byte_pool_delete_dispatch>
 8014804:	6178      	str	r0, [r7, #20]
        break;
 8014806:	e27e      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_BYTE_POOL_INFO_GET_CALL_NOT_USED
    case TXM_BYTE_POOL_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_byte_pool_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014808:	683b      	ldr	r3, [r7, #0]
 801480a:	687a      	ldr	r2, [r7, #4]
 801480c:	68b9      	ldr	r1, [r7, #8]
 801480e:	6938      	ldr	r0, [r7, #16]
 8014810:	f7fc f98e 	bl	8010b30 <_txm_module_manager_tx_byte_pool_info_get_dispatch>
 8014814:	6178      	str	r0, [r7, #20]
        break;
 8014816:	e276      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_BYTE_POOL_PERFORMANCE_INFO_GET_CALL_NOT_USED
    case TXM_BYTE_POOL_PERFORMANCE_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_byte_pool_performance_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014818:	683b      	ldr	r3, [r7, #0]
 801481a:	687a      	ldr	r2, [r7, #4]
 801481c:	68b9      	ldr	r1, [r7, #8]
 801481e:	6938      	ldr	r0, [r7, #16]
 8014820:	f7fc fa44 	bl	8010cac <_txm_module_manager_tx_byte_pool_performance_info_get_dispatch>
 8014824:	6178      	str	r0, [r7, #20]
        break;
 8014826:	e26e      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_BYTE_POOL_PERFORMANCE_SYSTEM_INFO_GET_CALL_NOT_USED
    case TXM_BYTE_POOL_PERFORMANCE_SYSTEM_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014828:	683b      	ldr	r3, [r7, #0]
 801482a:	687a      	ldr	r2, [r7, #4]
 801482c:	68b9      	ldr	r1, [r7, #8]
 801482e:	6938      	ldr	r0, [r7, #16]
 8014830:	f7fc fb11 	bl	8010e56 <_txm_module_manager_tx_byte_pool_performance_system_info_get_dispatch>
 8014834:	6178      	str	r0, [r7, #20]
        break;
 8014836:	e266      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_BYTE_POOL_PRIORITIZE_CALL_NOT_USED
    case TXM_BYTE_POOL_PRIORITIZE_CALL:
    {
        return_value = _txm_module_manager_tx_byte_pool_prioritize_dispatch(module_instance, param_0);
 8014838:	68b9      	ldr	r1, [r7, #8]
 801483a:	6938      	ldr	r0, [r7, #16]
 801483c:	f7fc fbb6 	bl	8010fac <_txm_module_manager_tx_byte_pool_prioritize_dispatch>
 8014840:	6178      	str	r0, [r7, #20]
        break;
 8014842:	e260      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_BYTE_RELEASE_CALL_NOT_USED
    case TXM_BYTE_RELEASE_CALL:
    {
        return_value = _txm_module_manager_tx_byte_release_dispatch(module_instance, param_0);
 8014844:	68b9      	ldr	r1, [r7, #8]
 8014846:	6938      	ldr	r0, [r7, #16]
 8014848:	f7fc fbe4 	bl	8011014 <_txm_module_manager_tx_byte_release_dispatch>
 801484c:	6178      	str	r0, [r7, #20]
        break;
 801484e:	e25a      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_EVENT_FLAGS_CREATE_CALL_NOT_USED
    case TXM_EVENT_FLAGS_CREATE_CALL:
    {
        return_value = _txm_module_manager_tx_event_flags_create_dispatch(module_instance, param_0, param_1, param_2);
 8014850:	683b      	ldr	r3, [r7, #0]
 8014852:	687a      	ldr	r2, [r7, #4]
 8014854:	68b9      	ldr	r1, [r7, #8]
 8014856:	6938      	ldr	r0, [r7, #16]
 8014858:	f7fc fc06 	bl	8011068 <_txm_module_manager_tx_event_flags_create_dispatch>
 801485c:	6178      	str	r0, [r7, #20]
        break;
 801485e:	e252      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_EVENT_FLAGS_DELETE_CALL_NOT_USED
    case TXM_EVENT_FLAGS_DELETE_CALL:
    {
        return_value = _txm_module_manager_tx_event_flags_delete_dispatch(module_instance, param_0);
 8014860:	68b9      	ldr	r1, [r7, #8]
 8014862:	6938      	ldr	r0, [r7, #16]
 8014864:	f7fc fc5e 	bl	8011124 <_txm_module_manager_tx_event_flags_delete_dispatch>
 8014868:	6178      	str	r0, [r7, #20]
        break;
 801486a:	e24c      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_EVENT_FLAGS_GET_CALL_NOT_USED
    case TXM_EVENT_FLAGS_GET_CALL:
    {
        return_value = _txm_module_manager_tx_event_flags_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 801486c:	683b      	ldr	r3, [r7, #0]
 801486e:	687a      	ldr	r2, [r7, #4]
 8014870:	68b9      	ldr	r1, [r7, #8]
 8014872:	6938      	ldr	r0, [r7, #16]
 8014874:	f7fc fc92 	bl	801119c <_txm_module_manager_tx_event_flags_get_dispatch>
 8014878:	6178      	str	r0, [r7, #20]
        break;
 801487a:	e244      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_EVENT_FLAGS_INFO_GET_CALL_NOT_USED
    case TXM_EVENT_FLAGS_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_event_flags_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 801487c:	683b      	ldr	r3, [r7, #0]
 801487e:	687a      	ldr	r2, [r7, #4]
 8014880:	68b9      	ldr	r1, [r7, #8]
 8014882:	6938      	ldr	r0, [r7, #16]
 8014884:	f7fc fce8 	bl	8011258 <_txm_module_manager_tx_event_flags_info_get_dispatch>
 8014888:	6178      	str	r0, [r7, #20]
        break;
 801488a:	e23c      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_EVENT_FLAGS_PERFORMANCE_INFO_GET_CALL_NOT_USED
    case TXM_EVENT_FLAGS_PERFORMANCE_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_event_flags_performance_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 801488c:	683b      	ldr	r3, [r7, #0]
 801488e:	687a      	ldr	r2, [r7, #4]
 8014890:	68b9      	ldr	r1, [r7, #8]
 8014892:	6938      	ldr	r0, [r7, #16]
 8014894:	f7fc fd86 	bl	80113a4 <_txm_module_manager_tx_event_flags_performance_info_get_dispatch>
 8014898:	6178      	str	r0, [r7, #20]
        break;
 801489a:	e234      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_EVENT_FLAGS_PERFORMANCE_SYSTEM_INFO_GET_CALL_NOT_USED
    case TXM_EVENT_FLAGS_PERFORMANCE_SYSTEM_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_event_flags_performance_system_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 801489c:	683b      	ldr	r3, [r7, #0]
 801489e:	687a      	ldr	r2, [r7, #4]
 80148a0:	68b9      	ldr	r1, [r7, #8]
 80148a2:	6938      	ldr	r0, [r7, #16]
 80148a4:	f7fc fe0c 	bl	80114c0 <_txm_module_manager_tx_event_flags_performance_system_info_get_dispatch>
 80148a8:	6178      	str	r0, [r7, #20]
        break;
 80148aa:	e22c      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
 80148ac:	2000efb8 	.word	0x2000efb8
    #endif

    #ifndef TXM_EVENT_FLAGS_SET_CALL_NOT_USED
    case TXM_EVENT_FLAGS_SET_CALL:
    {
        return_value = _txm_module_manager_tx_event_flags_set_dispatch(module_instance, param_0, param_1, param_2);
 80148b0:	683b      	ldr	r3, [r7, #0]
 80148b2:	687a      	ldr	r2, [r7, #4]
 80148b4:	68b9      	ldr	r1, [r7, #8]
 80148b6:	6938      	ldr	r0, [r7, #16]
 80148b8:	f7fc fe66 	bl	8011588 <_txm_module_manager_tx_event_flags_set_dispatch>
 80148bc:	6178      	str	r0, [r7, #20]
        break;
 80148be:	e222      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_EVENT_FLAGS_SET_NOTIFY_CALL_NOT_USED
    case TXM_EVENT_FLAGS_SET_NOTIFY_CALL:
    {
        return_value = _txm_module_manager_tx_event_flags_set_notify_dispatch(module_instance, param_0, param_1);
 80148c0:	687a      	ldr	r2, [r7, #4]
 80148c2:	68b9      	ldr	r1, [r7, #8]
 80148c4:	6938      	ldr	r0, [r7, #16]
 80148c6:	f7fc fe97 	bl	80115f8 <_txm_module_manager_tx_event_flags_set_notify_dispatch>
 80148ca:	6178      	str	r0, [r7, #20]
        break;
 80148cc:	e21b      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_MUTEX_CREATE_CALL_NOT_USED
    case TXM_MUTEX_CREATE_CALL:
    {
        return_value = _txm_module_manager_tx_mutex_create_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 80148ce:	683b      	ldr	r3, [r7, #0]
 80148d0:	687a      	ldr	r2, [r7, #4]
 80148d2:	68b9      	ldr	r1, [r7, #8]
 80148d4:	6938      	ldr	r0, [r7, #16]
 80148d6:	f7fc fee3 	bl	80116a0 <_txm_module_manager_tx_mutex_create_dispatch>
 80148da:	6178      	str	r0, [r7, #20]
        break;
 80148dc:	e213      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_MUTEX_DELETE_CALL_NOT_USED
    case TXM_MUTEX_DELETE_CALL:
    {
        return_value = _txm_module_manager_tx_mutex_delete_dispatch(module_instance, param_0);
 80148de:	68b9      	ldr	r1, [r7, #8]
 80148e0:	6938      	ldr	r0, [r7, #16]
 80148e2:	f7fc ff49 	bl	8011778 <_txm_module_manager_tx_mutex_delete_dispatch>
 80148e6:	6178      	str	r0, [r7, #20]
        break;
 80148e8:	e20d      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_MUTEX_GET_CALL_NOT_USED
    case TXM_MUTEX_GET_CALL:
    {
        return_value = _txm_module_manager_tx_mutex_get_dispatch(module_instance, param_0, param_1);
 80148ea:	687a      	ldr	r2, [r7, #4]
 80148ec:	68b9      	ldr	r1, [r7, #8]
 80148ee:	6938      	ldr	r0, [r7, #16]
 80148f0:	f7fc ff7e 	bl	80117f0 <_txm_module_manager_tx_mutex_get_dispatch>
 80148f4:	6178      	str	r0, [r7, #20]
        break;
 80148f6:	e206      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_MUTEX_INFO_GET_CALL_NOT_USED
    case TXM_MUTEX_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_mutex_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 80148f8:	683b      	ldr	r3, [r7, #0]
 80148fa:	687a      	ldr	r2, [r7, #4]
 80148fc:	68b9      	ldr	r1, [r7, #8]
 80148fe:	6938      	ldr	r0, [r7, #16]
 8014900:	f7fc ffac 	bl	801185c <_txm_module_manager_tx_mutex_info_get_dispatch>
 8014904:	6178      	str	r0, [r7, #20]
        break;
 8014906:	e1fe      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_MUTEX_PERFORMANCE_INFO_GET_CALL_NOT_USED
    case TXM_MUTEX_PERFORMANCE_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_mutex_performance_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014908:	683b      	ldr	r3, [r7, #0]
 801490a:	687a      	ldr	r2, [r7, #4]
 801490c:	68b9      	ldr	r1, [r7, #8]
 801490e:	6938      	ldr	r0, [r7, #16]
 8014910:	f7fd f862 	bl	80119d8 <_txm_module_manager_tx_mutex_performance_info_get_dispatch>
 8014914:	6178      	str	r0, [r7, #20]
        break;
 8014916:	e1f6      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_MUTEX_PERFORMANCE_SYSTEM_INFO_GET_CALL_NOT_USED
    case TXM_MUTEX_PERFORMANCE_SYSTEM_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_mutex_performance_system_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014918:	683b      	ldr	r3, [r7, #0]
 801491a:	687a      	ldr	r2, [r7, #4]
 801491c:	68b9      	ldr	r1, [r7, #8]
 801491e:	6938      	ldr	r0, [r7, #16]
 8014920:	f7fd f918 	bl	8011b54 <_txm_module_manager_tx_mutex_performance_system_info_get_dispatch>
 8014924:	6178      	str	r0, [r7, #20]
        break;
 8014926:	e1ee      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_MUTEX_PRIORITIZE_CALL_NOT_USED
    case TXM_MUTEX_PRIORITIZE_CALL:
    {
        return_value = _txm_module_manager_tx_mutex_prioritize_dispatch(module_instance, param_0);
 8014928:	68b9      	ldr	r1, [r7, #8]
 801492a:	6938      	ldr	r0, [r7, #16]
 801492c:	f7fd f9a6 	bl	8011c7c <_txm_module_manager_tx_mutex_prioritize_dispatch>
 8014930:	6178      	str	r0, [r7, #20]
        break;
 8014932:	e1e8      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_MUTEX_PUT_CALL_NOT_USED
    case TXM_MUTEX_PUT_CALL:
    {
        return_value = _txm_module_manager_tx_mutex_put_dispatch(module_instance, param_0);
 8014934:	68b9      	ldr	r1, [r7, #8]
 8014936:	6938      	ldr	r0, [r7, #16]
 8014938:	f7fd f9d4 	bl	8011ce4 <_txm_module_manager_tx_mutex_put_dispatch>
 801493c:	6178      	str	r0, [r7, #20]
        break;
 801493e:	e1e2      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_QUEUE_CREATE_CALL_NOT_USED
    case TXM_QUEUE_CREATE_CALL:
    {
        return_value = _txm_module_manager_tx_queue_create_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014940:	683b      	ldr	r3, [r7, #0]
 8014942:	687a      	ldr	r2, [r7, #4]
 8014944:	68b9      	ldr	r1, [r7, #8]
 8014946:	6938      	ldr	r0, [r7, #16]
 8014948:	f7fd fa00 	bl	8011d4c <_txm_module_manager_tx_queue_create_dispatch>
 801494c:	6178      	str	r0, [r7, #20]
        break;
 801494e:	e1da      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_QUEUE_DELETE_CALL_NOT_USED
    case TXM_QUEUE_DELETE_CALL:
    {
        return_value = _txm_module_manager_tx_queue_delete_dispatch(module_instance, param_0);
 8014950:	68b9      	ldr	r1, [r7, #8]
 8014952:	6938      	ldr	r0, [r7, #16]
 8014954:	f7fd fa86 	bl	8011e64 <_txm_module_manager_tx_queue_delete_dispatch>
 8014958:	6178      	str	r0, [r7, #20]
        break;
 801495a:	e1d4      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_QUEUE_FLUSH_CALL_NOT_USED
    case TXM_QUEUE_FLUSH_CALL:
    {
        return_value = _txm_module_manager_tx_queue_flush_dispatch(module_instance, param_0);
 801495c:	68b9      	ldr	r1, [r7, #8]
 801495e:	6938      	ldr	r0, [r7, #16]
 8014960:	f7fd fabc 	bl	8011edc <_txm_module_manager_tx_queue_flush_dispatch>
 8014964:	6178      	str	r0, [r7, #20]
        break;
 8014966:	e1ce      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_QUEUE_FRONT_SEND_CALL_NOT_USED
    case TXM_QUEUE_FRONT_SEND_CALL:
    {
        return_value = _txm_module_manager_tx_queue_front_send_dispatch(module_instance, param_0, param_1, param_2);
 8014968:	683b      	ldr	r3, [r7, #0]
 801496a:	687a      	ldr	r2, [r7, #4]
 801496c:	68b9      	ldr	r1, [r7, #8]
 801496e:	6938      	ldr	r0, [r7, #16]
 8014970:	f7fd fae8 	bl	8011f44 <_txm_module_manager_tx_queue_front_send_dispatch>
 8014974:	6178      	str	r0, [r7, #20]
        break;
 8014976:	e1c6      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_QUEUE_INFO_GET_CALL_NOT_USED
    case TXM_QUEUE_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_queue_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014978:	683b      	ldr	r3, [r7, #0]
 801497a:	687a      	ldr	r2, [r7, #4]
 801497c:	68b9      	ldr	r1, [r7, #8]
 801497e:	6938      	ldr	r0, [r7, #16]
 8014980:	f7fd fb3f 	bl	8012002 <_txm_module_manager_tx_queue_info_get_dispatch>
 8014984:	6178      	str	r0, [r7, #20]
        break;
 8014986:	e1be      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_QUEUE_PERFORMANCE_INFO_GET_CALL_NOT_USED
    case TXM_QUEUE_PERFORMANCE_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_queue_performance_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014988:	683b      	ldr	r3, [r7, #0]
 801498a:	687a      	ldr	r2, [r7, #4]
 801498c:	68b9      	ldr	r1, [r7, #8]
 801498e:	6938      	ldr	r0, [r7, #16]
 8014990:	f7fd fbf5 	bl	801217e <_txm_module_manager_tx_queue_performance_info_get_dispatch>
 8014994:	6178      	str	r0, [r7, #20]
        break;
 8014996:	e1b6      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_QUEUE_PERFORMANCE_SYSTEM_INFO_GET_CALL_NOT_USED
    case TXM_QUEUE_PERFORMANCE_SYSTEM_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_queue_performance_system_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014998:	683b      	ldr	r3, [r7, #0]
 801499a:	687a      	ldr	r2, [r7, #4]
 801499c:	68b9      	ldr	r1, [r7, #8]
 801499e:	6938      	ldr	r0, [r7, #16]
 80149a0:	f7fd fcab 	bl	80122fa <_txm_module_manager_tx_queue_performance_system_info_get_dispatch>
 80149a4:	6178      	str	r0, [r7, #20]
        break;
 80149a6:	e1ae      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_QUEUE_PRIORITIZE_CALL_NOT_USED
    case TXM_QUEUE_PRIORITIZE_CALL:
    {
        return_value = _txm_module_manager_tx_queue_prioritize_dispatch(module_instance, param_0);
 80149a8:	68b9      	ldr	r1, [r7, #8]
 80149aa:	6938      	ldr	r0, [r7, #16]
 80149ac:	f7fd fd39 	bl	8012422 <_txm_module_manager_tx_queue_prioritize_dispatch>
 80149b0:	6178      	str	r0, [r7, #20]
        break;
 80149b2:	e1a8      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_QUEUE_RECEIVE_CALL_NOT_USED
    case TXM_QUEUE_RECEIVE_CALL:
    {
        return_value = _txm_module_manager_tx_queue_receive_dispatch(module_instance, param_0, param_1, param_2);
 80149b4:	683b      	ldr	r3, [r7, #0]
 80149b6:	687a      	ldr	r2, [r7, #4]
 80149b8:	68b9      	ldr	r1, [r7, #8]
 80149ba:	6938      	ldr	r0, [r7, #16]
 80149bc:	f7fd fd65 	bl	801248a <_txm_module_manager_tx_queue_receive_dispatch>
 80149c0:	6178      	str	r0, [r7, #20]
        break;
 80149c2:	e1a0      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif
    
    #ifndef TXM_QUEUE_SEND_CALL_NOT_USED
    case TXM_QUEUE_SEND_CALL:
    {
        return_value = _txm_module_manager_tx_queue_send_dispatch(module_instance, param_0, param_1, param_2);
 80149c4:	683b      	ldr	r3, [r7, #0]
 80149c6:	687a      	ldr	r2, [r7, #4]
 80149c8:	68b9      	ldr	r1, [r7, #8]
 80149ca:	6938      	ldr	r0, [r7, #16]
 80149cc:	f7fd fda7 	bl	801251e <_txm_module_manager_tx_queue_send_dispatch>
 80149d0:	6178      	str	r0, [r7, #20]
        break;
 80149d2:	e198      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_QUEUE_SEND_NOTIFY_CALL_NOT_USED
    case TXM_QUEUE_SEND_NOTIFY_CALL:
    {
        return_value = _txm_module_manager_tx_queue_send_notify_dispatch(module_instance, param_0, param_1);
 80149d4:	687a      	ldr	r2, [r7, #4]
 80149d6:	68b9      	ldr	r1, [r7, #8]
 80149d8:	6938      	ldr	r0, [r7, #16]
 80149da:	f7fd fe03 	bl	80125e4 <_txm_module_manager_tx_queue_send_notify_dispatch>
 80149de:	6178      	str	r0, [r7, #20]
        break;
 80149e0:	e191      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_SEMAPHORE_CEILING_PUT_CALL_NOT_USED
    case TXM_SEMAPHORE_CEILING_PUT_CALL:
    {
        return_value = _txm_module_manager_tx_semaphore_ceiling_put_dispatch(module_instance, param_0, param_1);
 80149e2:	687a      	ldr	r2, [r7, #4]
 80149e4:	68b9      	ldr	r1, [r7, #8]
 80149e6:	6938      	ldr	r0, [r7, #16]
 80149e8:	f7fd fe50 	bl	801268c <_txm_module_manager_tx_semaphore_ceiling_put_dispatch>
 80149ec:	6178      	str	r0, [r7, #20]
        break;
 80149ee:	e18a      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_SEMAPHORE_CREATE_CALL_NOT_USED
    case TXM_SEMAPHORE_CREATE_CALL:
    {
        return_value = _txm_module_manager_tx_semaphore_create_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 80149f0:	683b      	ldr	r3, [r7, #0]
 80149f2:	687a      	ldr	r2, [r7, #4]
 80149f4:	68b9      	ldr	r1, [r7, #8]
 80149f6:	6938      	ldr	r0, [r7, #16]
 80149f8:	f7fd fe7e 	bl	80126f8 <_txm_module_manager_tx_semaphore_create_dispatch>
 80149fc:	6178      	str	r0, [r7, #20]
        break;
 80149fe:	e182      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_SEMAPHORE_DELETE_CALL_NOT_USED
    case TXM_SEMAPHORE_DELETE_CALL:
    {
        return_value = _txm_module_manager_tx_semaphore_delete_dispatch(module_instance, param_0);
 8014a00:	68b9      	ldr	r1, [r7, #8]
 8014a02:	6938      	ldr	r0, [r7, #16]
 8014a04:	f7fd fee4 	bl	80127d0 <_txm_module_manager_tx_semaphore_delete_dispatch>
 8014a08:	6178      	str	r0, [r7, #20]
        break;
 8014a0a:	e17c      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_SEMAPHORE_GET_CALL_NOT_USED
    case TXM_SEMAPHORE_GET_CALL:
    {
        return_value = _txm_module_manager_tx_semaphore_get_dispatch(module_instance, param_0, param_1);
 8014a0c:	687a      	ldr	r2, [r7, #4]
 8014a0e:	68b9      	ldr	r1, [r7, #8]
 8014a10:	6938      	ldr	r0, [r7, #16]
 8014a12:	f7fd ff19 	bl	8012848 <_txm_module_manager_tx_semaphore_get_dispatch>
 8014a16:	6178      	str	r0, [r7, #20]
        break;
 8014a18:	e175      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_SEMAPHORE_INFO_GET_CALL_NOT_USED
    case TXM_SEMAPHORE_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_semaphore_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014a1a:	683b      	ldr	r3, [r7, #0]
 8014a1c:	687a      	ldr	r2, [r7, #4]
 8014a1e:	68b9      	ldr	r1, [r7, #8]
 8014a20:	6938      	ldr	r0, [r7, #16]
 8014a22:	f7fd ff47 	bl	80128b4 <_txm_module_manager_tx_semaphore_info_get_dispatch>
 8014a26:	6178      	str	r0, [r7, #20]
        break;
 8014a28:	e16d      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_SEMAPHORE_PERFORMANCE_INFO_GET_CALL_NOT_USED
    case TXM_SEMAPHORE_PERFORMANCE_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_semaphore_performance_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014a2a:	683b      	ldr	r3, [r7, #0]
 8014a2c:	687a      	ldr	r2, [r7, #4]
 8014a2e:	68b9      	ldr	r1, [r7, #8]
 8014a30:	6938      	ldr	r0, [r7, #16]
 8014a32:	f7fd ffe5 	bl	8012a00 <_txm_module_manager_tx_semaphore_performance_info_get_dispatch>
 8014a36:	6178      	str	r0, [r7, #20]
        break;
 8014a38:	e165      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_SEMAPHORE_PERFORMANCE_SYSTEM_INFO_GET_CALL_NOT_USED
    case TXM_SEMAPHORE_PERFORMANCE_SYSTEM_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_semaphore_performance_system_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014a3a:	683b      	ldr	r3, [r7, #0]
 8014a3c:	687a      	ldr	r2, [r7, #4]
 8014a3e:	68b9      	ldr	r1, [r7, #8]
 8014a40:	6938      	ldr	r0, [r7, #16]
 8014a42:	f7fe f86b 	bl	8012b1c <_txm_module_manager_tx_semaphore_performance_system_info_get_dispatch>
 8014a46:	6178      	str	r0, [r7, #20]
        break;
 8014a48:	e15d      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_SEMAPHORE_PRIORITIZE_CALL_NOT_USED
    case TXM_SEMAPHORE_PRIORITIZE_CALL:
    {
        return_value = _txm_module_manager_tx_semaphore_prioritize_dispatch(module_instance, param_0);
 8014a4a:	68b9      	ldr	r1, [r7, #8]
 8014a4c:	6938      	ldr	r0, [r7, #16]
 8014a4e:	f7fe f8c9 	bl	8012be4 <_txm_module_manager_tx_semaphore_prioritize_dispatch>
 8014a52:	6178      	str	r0, [r7, #20]
        break;
 8014a54:	e157      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_SEMAPHORE_PUT_CALL_NOT_USED
    case TXM_SEMAPHORE_PUT_CALL:
    {
        return_value = _txm_module_manager_tx_semaphore_put_dispatch(module_instance, param_0);
 8014a56:	68b9      	ldr	r1, [r7, #8]
 8014a58:	6938      	ldr	r0, [r7, #16]
 8014a5a:	f7fe f8f7 	bl	8012c4c <_txm_module_manager_tx_semaphore_put_dispatch>
 8014a5e:	6178      	str	r0, [r7, #20]
        break;
 8014a60:	e151      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_SEMAPHORE_PUT_NOTIFY_CALL_NOT_USED
    case TXM_SEMAPHORE_PUT_NOTIFY_CALL:
    {
        return_value = _txm_module_manager_tx_semaphore_put_notify_dispatch(module_instance, param_0, param_1);
 8014a62:	687a      	ldr	r2, [r7, #4]
 8014a64:	68b9      	ldr	r1, [r7, #8]
 8014a66:	6938      	ldr	r0, [r7, #16]
 8014a68:	f7fe f924 	bl	8012cb4 <_txm_module_manager_tx_semaphore_put_notify_dispatch>
 8014a6c:	6178      	str	r0, [r7, #20]
        break;
 8014a6e:	e14a      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_CREATE_CALL_NOT_USED
    case TXM_THREAD_CREATE_CALL:
    {
        return_value = _txm_module_manager_tx_thread_create_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014a70:	683b      	ldr	r3, [r7, #0]
 8014a72:	687a      	ldr	r2, [r7, #4]
 8014a74:	68b9      	ldr	r1, [r7, #8]
 8014a76:	6938      	ldr	r0, [r7, #16]
 8014a78:	f7fe f970 	bl	8012d5c <_txm_module_manager_tx_thread_create_dispatch>
 8014a7c:	6178      	str	r0, [r7, #20]
        break;
 8014a7e:	e142      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_DELETE_CALL_NOT_USED
    case TXM_THREAD_DELETE_CALL:
    {
        return_value = _txm_module_manager_tx_thread_delete_dispatch(module_instance, param_0);
 8014a80:	68b9      	ldr	r1, [r7, #8]
 8014a82:	6938      	ldr	r0, [r7, #16]
 8014a84:	f7fe fa2c 	bl	8012ee0 <_txm_module_manager_tx_thread_delete_dispatch>
 8014a88:	6178      	str	r0, [r7, #20]
        break;
 8014a8a:	e13c      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_ENTRY_EXIT_NOTIFY_CALL_NOT_USED
    case TXM_THREAD_ENTRY_EXIT_NOTIFY_CALL:
    {
        return_value = _txm_module_manager_tx_thread_entry_exit_notify_dispatch(module_instance, param_0, param_1);
 8014a8c:	687a      	ldr	r2, [r7, #4]
 8014a8e:	68b9      	ldr	r1, [r7, #8]
 8014a90:	6938      	ldr	r0, [r7, #16]
 8014a92:	f7fe fa61 	bl	8012f58 <_txm_module_manager_tx_thread_entry_exit_notify_dispatch>
 8014a96:	6178      	str	r0, [r7, #20]
        break;
 8014a98:	e135      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_IDENTIFY_CALL_NOT_USED
    case TXM_THREAD_IDENTIFY_CALL:
    {
        return_value = _txm_module_manager_tx_thread_identify_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014a9a:	683b      	ldr	r3, [r7, #0]
 8014a9c:	687a      	ldr	r2, [r7, #4]
 8014a9e:	68b9      	ldr	r1, [r7, #8]
 8014aa0:	6938      	ldr	r0, [r7, #16]
 8014aa2:	f7fe fab7 	bl	8013014 <_txm_module_manager_tx_thread_identify_dispatch>
 8014aa6:	6178      	str	r0, [r7, #20]
        break;
 8014aa8:	e12d      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_INFO_GET_CALL_NOT_USED
    case TXM_THREAD_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_thread_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014aaa:	683b      	ldr	r3, [r7, #0]
 8014aac:	687a      	ldr	r2, [r7, #4]
 8014aae:	68b9      	ldr	r1, [r7, #8]
 8014ab0:	6938      	ldr	r0, [r7, #16]
 8014ab2:	f7fe fabf 	bl	8013034 <_txm_module_manager_tx_thread_info_get_dispatch>
 8014ab6:	6178      	str	r0, [r7, #20]
        break;
 8014ab8:	e125      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_INTERRUPT_CONTROL_CALL_NOT_USED
    case TXM_THREAD_INTERRUPT_CONTROL_CALL:
    {
        return_value = _txm_module_manager_tx_thread_interrupt_control_dispatch(module_instance, param_0);
 8014aba:	68b9      	ldr	r1, [r7, #8]
 8014abc:	6938      	ldr	r0, [r7, #16]
 8014abe:	f7fe fba5 	bl	801320c <_txm_module_manager_tx_thread_interrupt_control_dispatch>
 8014ac2:	6178      	str	r0, [r7, #20]
        break;
 8014ac4:	e11f      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_PERFORMANCE_INFO_GET_CALL_NOT_USED
    case TXM_THREAD_PERFORMANCE_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_thread_performance_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014ac6:	683b      	ldr	r3, [r7, #0]
 8014ac8:	687a      	ldr	r2, [r7, #4]
 8014aca:	68b9      	ldr	r1, [r7, #8]
 8014acc:	6938      	ldr	r0, [r7, #16]
 8014ace:	f7fe fbb3 	bl	8013238 <_txm_module_manager_tx_thread_performance_info_get_dispatch>
 8014ad2:	6178      	str	r0, [r7, #20]
        break;
 8014ad4:	e117      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_PERFORMANCE_SYSTEM_INFO_GET_CALL_NOT_USED
    case TXM_THREAD_PERFORMANCE_SYSTEM_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_thread_performance_system_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014ad6:	683b      	ldr	r3, [r7, #0]
 8014ad8:	687a      	ldr	r2, [r7, #4]
 8014ada:	68b9      	ldr	r1, [r7, #8]
 8014adc:	6938      	ldr	r0, [r7, #16]
 8014ade:	f7fe fcc7 	bl	8013470 <_txm_module_manager_tx_thread_performance_system_info_get_dispatch>
 8014ae2:	6178      	str	r0, [r7, #20]
        break;
 8014ae4:	e10f      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_PREEMPTION_CHANGE_CALL_NOT_USED
    case TXM_THREAD_PREEMPTION_CHANGE_CALL:
    {
        return_value = _txm_module_manager_tx_thread_preemption_change_dispatch(module_instance, param_0, param_1, param_2);
 8014ae6:	683b      	ldr	r3, [r7, #0]
 8014ae8:	687a      	ldr	r2, [r7, #4]
 8014aea:	68b9      	ldr	r1, [r7, #8]
 8014aec:	6938      	ldr	r0, [r7, #16]
 8014aee:	f7fe fdc9 	bl	8013684 <_txm_module_manager_tx_thread_preemption_change_dispatch>
 8014af2:	6178      	str	r0, [r7, #20]
        break;
 8014af4:	e107      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_PRIORITY_CHANGE_CALL_NOT_USED
    case TXM_THREAD_PRIORITY_CHANGE_CALL:
    {
        return_value = _txm_module_manager_tx_thread_priority_change_dispatch(module_instance, param_0, param_1, param_2);
 8014af6:	683b      	ldr	r3, [r7, #0]
 8014af8:	687a      	ldr	r2, [r7, #4]
 8014afa:	68b9      	ldr	r1, [r7, #8]
 8014afc:	6938      	ldr	r0, [r7, #16]
 8014afe:	f7fe fe06 	bl	801370e <_txm_module_manager_tx_thread_priority_change_dispatch>
 8014b02:	6178      	str	r0, [r7, #20]
        break;
 8014b04:	e0ff      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_RELINQUISH_CALL_NOT_USED
    case TXM_THREAD_RELINQUISH_CALL:
    {
        return_value = _txm_module_manager_tx_thread_relinquish_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014b06:	683b      	ldr	r3, [r7, #0]
 8014b08:	687a      	ldr	r2, [r7, #4]
 8014b0a:	68b9      	ldr	r1, [r7, #8]
 8014b0c:	6938      	ldr	r0, [r7, #16]
 8014b0e:	f7fe fe43 	bl	8013798 <_txm_module_manager_tx_thread_relinquish_dispatch>
 8014b12:	6178      	str	r0, [r7, #20]
        break;
 8014b14:	e0f7      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_RESET_CALL_NOT_USED
    case TXM_THREAD_RESET_CALL:
    {
        return_value = _txm_module_manager_tx_thread_reset_dispatch(module_instance, param_0);
 8014b16:	68b9      	ldr	r1, [r7, #8]
 8014b18:	6938      	ldr	r0, [r7, #16]
 8014b1a:	f7fe fe4b 	bl	80137b4 <_txm_module_manager_tx_thread_reset_dispatch>
 8014b1e:	6178      	str	r0, [r7, #20]
        break;
 8014b20:	e0f1      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_RESUME_CALL_NOT_USED
    case TXM_THREAD_RESUME_CALL:
    {
        return_value = _txm_module_manager_tx_thread_resume_dispatch(module_instance, param_0);
 8014b22:	68b9      	ldr	r1, [r7, #8]
 8014b24:	6938      	ldr	r0, [r7, #16]
 8014b26:	f7fe fe79 	bl	801381c <_txm_module_manager_tx_thread_resume_dispatch>
 8014b2a:	6178      	str	r0, [r7, #20]
        break;
 8014b2c:	e0eb      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_SLEEP_CALL_NOT_USED
    case TXM_THREAD_SLEEP_CALL:
    {
        return_value = _txm_module_manager_tx_thread_sleep_dispatch(module_instance, param_0);
 8014b2e:	68b9      	ldr	r1, [r7, #8]
 8014b30:	6938      	ldr	r0, [r7, #16]
 8014b32:	f7fe fea7 	bl	8013884 <_txm_module_manager_tx_thread_sleep_dispatch>
 8014b36:	6178      	str	r0, [r7, #20]
        break;
 8014b38:	e0e5      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_STACK_ERROR_NOTIFY_CALL_NOT_USED
    case TXM_THREAD_STACK_ERROR_NOTIFY_CALL:
    {
        return_value = _txm_module_manager_tx_thread_stack_error_notify_dispatch(module_instance, param_0);
 8014b3a:	68b9      	ldr	r1, [r7, #8]
 8014b3c:	6938      	ldr	r0, [r7, #16]
 8014b3e:	f7fe feaf 	bl	80138a0 <_txm_module_manager_tx_thread_stack_error_notify_dispatch>
 8014b42:	6178      	str	r0, [r7, #20]
        break;
 8014b44:	e0df      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_SUSPEND_CALL_NOT_USED
    case TXM_THREAD_SUSPEND_CALL:
    {
        return_value = _txm_module_manager_tx_thread_suspend_dispatch(module_instance, param_0);
 8014b46:	68b9      	ldr	r1, [r7, #8]
 8014b48:	6938      	ldr	r0, [r7, #16]
 8014b4a:	f7fe fec0 	bl	80138ce <_txm_module_manager_tx_thread_suspend_dispatch>
 8014b4e:	6178      	str	r0, [r7, #20]
        break;
 8014b50:	e0d9      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_SYSTEM_SUSPEND_CALL_NOT_USED
    case TXM_THREAD_SYSTEM_SUSPEND_CALL:
    {
        return_value = _txm_module_manager_tx_thread_system_suspend_dispatch(module_instance, param_0);
 8014b52:	68b9      	ldr	r1, [r7, #8]
 8014b54:	6938      	ldr	r0, [r7, #16]
 8014b56:	f7fe feef 	bl	8013938 <_txm_module_manager_tx_thread_system_suspend_dispatch>
 8014b5a:	6178      	str	r0, [r7, #20]
        break;
 8014b5c:	e0d3      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_TERMINATE_CALL_NOT_USED
    case TXM_THREAD_TERMINATE_CALL:
    {
        return_value = _txm_module_manager_tx_thread_terminate_dispatch(module_instance, param_0);
 8014b5e:	68b9      	ldr	r1, [r7, #8]
 8014b60:	6938      	ldr	r0, [r7, #16]
 8014b62:	f7fe ff55 	bl	8013a10 <_txm_module_manager_tx_thread_terminate_dispatch>
 8014b66:	6178      	str	r0, [r7, #20]
        break;
 8014b68:	e0cd      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_TIME_SLICE_CHANGE_CALL_NOT_USED
    case TXM_THREAD_TIME_SLICE_CHANGE_CALL:
    {
        return_value = _txm_module_manager_tx_thread_time_slice_change_dispatch(module_instance, param_0, param_1, param_2);
 8014b6a:	683b      	ldr	r3, [r7, #0]
 8014b6c:	687a      	ldr	r2, [r7, #4]
 8014b6e:	68b9      	ldr	r1, [r7, #8]
 8014b70:	6938      	ldr	r0, [r7, #16]
 8014b72:	f7fe ff81 	bl	8013a78 <_txm_module_manager_tx_thread_time_slice_change_dispatch>
 8014b76:	6178      	str	r0, [r7, #20]
        break;
 8014b78:	e0c5      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_THREAD_WAIT_ABORT_CALL_NOT_USED
    case TXM_THREAD_WAIT_ABORT_CALL:
    {
        return_value = _txm_module_manager_tx_thread_wait_abort_dispatch(module_instance, param_0);
 8014b7a:	68b9      	ldr	r1, [r7, #8]
 8014b7c:	6938      	ldr	r0, [r7, #16]
 8014b7e:	f7fe ffc0 	bl	8013b02 <_txm_module_manager_tx_thread_wait_abort_dispatch>
 8014b82:	6178      	str	r0, [r7, #20]
        break;
 8014b84:	e0bf      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TIME_GET_CALL_NOT_USED
    case TXM_TIME_GET_CALL:
    {
        return_value = _txm_module_manager_tx_time_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014b86:	683b      	ldr	r3, [r7, #0]
 8014b88:	687a      	ldr	r2, [r7, #4]
 8014b8a:	68b9      	ldr	r1, [r7, #8]
 8014b8c:	6938      	ldr	r0, [r7, #16]
 8014b8e:	f7fe ffec 	bl	8013b6a <_txm_module_manager_tx_time_get_dispatch>
 8014b92:	6178      	str	r0, [r7, #20]
        break;
 8014b94:	e0b7      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TIME_SET_CALL_NOT_USED
    case TXM_TIME_SET_CALL:
    {
        return_value = _txm_module_manager_tx_time_set_dispatch(module_instance, param_0);
 8014b96:	68b9      	ldr	r1, [r7, #8]
 8014b98:	6938      	ldr	r0, [r7, #16]
 8014b9a:	f7fe fff5 	bl	8013b88 <_txm_module_manager_tx_time_set_dispatch>
 8014b9e:	6178      	str	r0, [r7, #20]
        break;
 8014ba0:	e0b1      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TIMER_ACTIVATE_CALL_NOT_USED
    case TXM_TIMER_ACTIVATE_CALL:
    {
        return_value = _txm_module_manager_tx_timer_activate_dispatch(module_instance, param_0);
 8014ba2:	68b9      	ldr	r1, [r7, #8]
 8014ba4:	6938      	ldr	r0, [r7, #16]
 8014ba6:	f7fe fffc 	bl	8013ba2 <_txm_module_manager_tx_timer_activate_dispatch>
 8014baa:	6178      	str	r0, [r7, #20]
        break;
 8014bac:	e0ab      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TIMER_CHANGE_CALL_NOT_USED
    case TXM_TIMER_CHANGE_CALL:
    {
        return_value = _txm_module_manager_tx_timer_change_dispatch(module_instance, param_0, param_1, param_2);
 8014bae:	683b      	ldr	r3, [r7, #0]
 8014bb0:	687a      	ldr	r2, [r7, #4]
 8014bb2:	68b9      	ldr	r1, [r7, #8]
 8014bb4:	6938      	ldr	r0, [r7, #16]
 8014bb6:	f7ff f828 	bl	8013c0a <_txm_module_manager_tx_timer_change_dispatch>
 8014bba:	6178      	str	r0, [r7, #20]
        break;
 8014bbc:	e0a3      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TIMER_CREATE_CALL_NOT_USED
    case TXM_TIMER_CREATE_CALL:
    {
        return_value = _txm_module_manager_tx_timer_create_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014bbe:	683b      	ldr	r3, [r7, #0]
 8014bc0:	687a      	ldr	r2, [r7, #4]
 8014bc2:	68b9      	ldr	r1, [r7, #8]
 8014bc4:	6938      	ldr	r0, [r7, #16]
 8014bc6:	f7ff f859 	bl	8013c7c <_txm_module_manager_tx_timer_create_dispatch>
 8014bca:	6178      	str	r0, [r7, #20]
        break;
 8014bcc:	e09b      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TIMER_DEACTIVATE_CALL_NOT_USED
    case TXM_TIMER_DEACTIVATE_CALL:
    {
        return_value = _txm_module_manager_tx_timer_deactivate_dispatch(module_instance, param_0);
 8014bce:	68b9      	ldr	r1, [r7, #8]
 8014bd0:	6938      	ldr	r0, [r7, #16]
 8014bd2:	f7ff f8ed 	bl	8013db0 <_txm_module_manager_tx_timer_deactivate_dispatch>
 8014bd6:	6178      	str	r0, [r7, #20]
        break;
 8014bd8:	e095      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TIMER_DELETE_CALL_NOT_USED
    case TXM_TIMER_DELETE_CALL:
    {
        return_value = _txm_module_manager_tx_timer_delete_dispatch(module_instance, param_0);
 8014bda:	68b9      	ldr	r1, [r7, #8]
 8014bdc:	6938      	ldr	r0, [r7, #16]
 8014bde:	f7ff f91b 	bl	8013e18 <_txm_module_manager_tx_timer_delete_dispatch>
 8014be2:	6178      	str	r0, [r7, #20]
        break;
 8014be4:	e08f      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TIMER_INFO_GET_CALL_NOT_USED
    case TXM_TIMER_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_timer_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014be6:	683b      	ldr	r3, [r7, #0]
 8014be8:	687a      	ldr	r2, [r7, #4]
 8014bea:	68b9      	ldr	r1, [r7, #8]
 8014bec:	6938      	ldr	r0, [r7, #16]
 8014bee:	f7ff f94f 	bl	8013e90 <_txm_module_manager_tx_timer_info_get_dispatch>
 8014bf2:	6178      	str	r0, [r7, #20]
        break;
 8014bf4:	e087      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TIMER_PERFORMANCE_INFO_GET_CALL_NOT_USED
    case TXM_TIMER_PERFORMANCE_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_timer_performance_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014bf6:	683b      	ldr	r3, [r7, #0]
 8014bf8:	687a      	ldr	r2, [r7, #4]
 8014bfa:	68b9      	ldr	r1, [r7, #8]
 8014bfc:	6938      	ldr	r0, [r7, #16]
 8014bfe:	f7ff f9ed 	bl	8013fdc <_txm_module_manager_tx_timer_performance_info_get_dispatch>
 8014c02:	6178      	str	r0, [r7, #20]
        break;
 8014c04:	e07f      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TIMER_PERFORMANCE_SYSTEM_INFO_GET_CALL_NOT_USED
    case TXM_TIMER_PERFORMANCE_SYSTEM_INFO_GET_CALL:
    {
        return_value = _txm_module_manager_tx_timer_performance_system_info_get_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014c06:	683b      	ldr	r3, [r7, #0]
 8014c08:	687a      	ldr	r2, [r7, #4]
 8014c0a:	68b9      	ldr	r1, [r7, #8]
 8014c0c:	6938      	ldr	r0, [r7, #16]
 8014c0e:	f7ff fa8b 	bl	8014128 <_txm_module_manager_tx_timer_performance_system_info_get_dispatch>
 8014c12:	6178      	str	r0, [r7, #20]
        break;
 8014c14:	e077      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TRACE_BUFFER_FULL_NOTIFY_CALL_NOT_USED
    case TXM_TRACE_BUFFER_FULL_NOTIFY_CALL:
    {
        return_value = _txm_module_manager_tx_trace_buffer_full_notify_dispatch(module_instance, param_0);
 8014c16:	68b9      	ldr	r1, [r7, #8]
 8014c18:	6938      	ldr	r0, [r7, #16]
 8014c1a:	f7ff fb01 	bl	8014220 <_txm_module_manager_tx_trace_buffer_full_notify_dispatch>
 8014c1e:	6178      	str	r0, [r7, #20]
        break;
 8014c20:	e071      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TRACE_DISABLE_CALL_NOT_USED
    case TXM_TRACE_DISABLE_CALL:
    {
        return_value = _txm_module_manager_tx_trace_disable_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014c22:	683b      	ldr	r3, [r7, #0]
 8014c24:	687a      	ldr	r2, [r7, #4]
 8014c26:	68b9      	ldr	r1, [r7, #8]
 8014c28:	6938      	ldr	r0, [r7, #16]
 8014c2a:	f7ff fb08 	bl	801423e <_txm_module_manager_tx_trace_disable_dispatch>
 8014c2e:	6178      	str	r0, [r7, #20]
        break;
 8014c30:	e069      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TRACE_ENABLE_CALL_NOT_USED
    case TXM_TRACE_ENABLE_CALL:
    {
        return_value = _txm_module_manager_tx_trace_enable_dispatch(module_instance, param_0, param_1, param_2);
 8014c32:	683b      	ldr	r3, [r7, #0]
 8014c34:	687a      	ldr	r2, [r7, #4]
 8014c36:	68b9      	ldr	r1, [r7, #8]
 8014c38:	6938      	ldr	r0, [r7, #16]
 8014c3a:	f7ff fb17 	bl	801426c <_txm_module_manager_tx_trace_enable_dispatch>
 8014c3e:	6178      	str	r0, [r7, #20]
        break;
 8014c40:	e061      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TRACE_EVENT_FILTER_CALL_NOT_USED
    case TXM_TRACE_EVENT_FILTER_CALL:
    {
        return_value = _txm_module_manager_tx_trace_event_filter_dispatch(module_instance, param_0);
 8014c42:	68b9      	ldr	r1, [r7, #8]
 8014c44:	6938      	ldr	r0, [r7, #16]
 8014c46:	f7ff fb2c 	bl	80142a2 <_txm_module_manager_tx_trace_event_filter_dispatch>
 8014c4a:	6178      	str	r0, [r7, #20]
        break;
 8014c4c:	e05b      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TRACE_EVENT_UNFILTER_CALL_NOT_USED
    case TXM_TRACE_EVENT_UNFILTER_CALL:
    {
        return_value = _txm_module_manager_tx_trace_event_unfilter_dispatch(module_instance, param_0);
 8014c4e:	68b9      	ldr	r1, [r7, #8]
 8014c50:	6938      	ldr	r0, [r7, #16]
 8014c52:	f7ff fb34 	bl	80142be <_txm_module_manager_tx_trace_event_unfilter_dispatch>
 8014c56:	6178      	str	r0, [r7, #20]
        break;
 8014c58:	e055      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TRACE_INTERRUPT_CONTROL_CALL_NOT_USED
    case TXM_TRACE_INTERRUPT_CONTROL_CALL:
    {
        return_value = _txm_module_manager_tx_trace_interrupt_control_dispatch(module_instance, param_0);
 8014c5a:	68b9      	ldr	r1, [r7, #8]
 8014c5c:	6938      	ldr	r0, [r7, #16]
 8014c5e:	f7ff fb3c 	bl	80142da <_txm_module_manager_tx_trace_interrupt_control_dispatch>
 8014c62:	6178      	str	r0, [r7, #20]
        break;
 8014c64:	e04f      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TRACE_ISR_ENTER_INSERT_CALL_NOT_USED
    case TXM_TRACE_ISR_ENTER_INSERT_CALL:
    {
        return_value = _txm_module_manager_tx_trace_isr_enter_insert_dispatch(module_instance, param_0);
 8014c66:	68b9      	ldr	r1, [r7, #8]
 8014c68:	6938      	ldr	r0, [r7, #16]
 8014c6a:	f7ff fb4c 	bl	8014306 <_txm_module_manager_tx_trace_isr_enter_insert_dispatch>
 8014c6e:	6178      	str	r0, [r7, #20]
        break;
 8014c70:	e049      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TRACE_ISR_EXIT_INSERT_CALL_NOT_USED
    case TXM_TRACE_ISR_EXIT_INSERT_CALL:
    {
        return_value = _txm_module_manager_tx_trace_isr_exit_insert_dispatch(module_instance, param_0);
 8014c72:	68b9      	ldr	r1, [r7, #8]
 8014c74:	6938      	ldr	r0, [r7, #16]
 8014c76:	f7ff fb5b 	bl	8014330 <_txm_module_manager_tx_trace_isr_exit_insert_dispatch>
 8014c7a:	6178      	str	r0, [r7, #20]
        break;
 8014c7c:	e043      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_TRACE_USER_EVENT_INSERT_CALL_NOT_USED
    case TXM_TRACE_USER_EVENT_INSERT_CALL:
    {
        return_value = _txm_module_manager_tx_trace_user_event_insert_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014c7e:	683b      	ldr	r3, [r7, #0]
 8014c80:	687a      	ldr	r2, [r7, #4]
 8014c82:	68b9      	ldr	r1, [r7, #8]
 8014c84:	6938      	ldr	r0, [r7, #16]
 8014c86:	f7ff fb68 	bl	801435a <_txm_module_manager_tx_trace_user_event_insert_dispatch>
 8014c8a:	6178      	str	r0, [r7, #20]
        break;
 8014c8c:	e03b      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_MODULE_OBJECT_ALLOCATE_CALL_NOT_USED
    case TXM_MODULE_OBJECT_ALLOCATE_CALL:
    {
        return_value = _txm_module_manager_txm_module_object_allocate_dispatch(module_instance, param_0, param_1);
 8014c8e:	687a      	ldr	r2, [r7, #4]
 8014c90:	68b9      	ldr	r1, [r7, #8]
 8014c92:	6938      	ldr	r0, [r7, #16]
 8014c94:	f7ff fb8d 	bl	80143b2 <_txm_module_manager_txm_module_object_allocate_dispatch>
 8014c98:	6178      	str	r0, [r7, #20]
        break;
 8014c9a:	e034      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_MODULE_OBJECT_DEALLOCATE_CALL_NOT_USED
    case TXM_MODULE_OBJECT_DEALLOCATE_CALL:
    {
        return_value = _txm_module_manager_txm_module_object_deallocate_dispatch(module_instance, param_0);
 8014c9c:	68b9      	ldr	r1, [r7, #8]
 8014c9e:	6938      	ldr	r0, [r7, #16]
 8014ca0:	f7ff fbac 	bl	80143fc <_txm_module_manager_txm_module_object_deallocate_dispatch>
 8014ca4:	6178      	str	r0, [r7, #20]
        break;
 8014ca6:	e02e      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_MODULE_OBJECT_POINTER_GET_CALL_NOT_USED
    case TXM_MODULE_OBJECT_POINTER_GET_CALL:
    {
        return_value = _txm_module_manager_txm_module_object_pointer_get_dispatch(module_instance, param_0, param_1, param_2);
 8014ca8:	683b      	ldr	r3, [r7, #0]
 8014caa:	687a      	ldr	r2, [r7, #4]
 8014cac:	68b9      	ldr	r1, [r7, #8]
 8014cae:	6938      	ldr	r0, [r7, #16]
 8014cb0:	f7ff fbe2 	bl	8014478 <_txm_module_manager_txm_module_object_pointer_get_dispatch>
 8014cb4:	6178      	str	r0, [r7, #20]
        break;
 8014cb6:	e026      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>
    #endif

    #ifndef TXM_MODULE_OBJECT_POINTER_GET_EXTENDED_CALL_NOT_USED
    case TXM_MODULE_OBJECT_POINTER_GET_EXTENDED_CALL:
    {
        return_value = _txm_module_manager_txm_module_object_pointer_get_extended_dispatch(module_instance, param_0, param_1, (ALIGN_TYPE *) param_2);
 8014cb8:	683b      	ldr	r3, [r7, #0]
 8014cba:	687a      	ldr	r2, [r7, #4]
 8014cbc:	68b9      	ldr	r1, [r7, #8]
 8014cbe:	6938      	ldr	r0, [r7, #16]
 8014cc0:	f7ff fc1e 	bl	8014500 <_txm_module_manager_txm_module_object_pointer_get_extended_dispatch>
 8014cc4:	6178      	str	r0, [r7, #20]
        break;
 8014cc6:	e01e      	b.n	8014d06 <_txm_module_manager_kernel_dispatch+0x756>

    default:
    {
#ifdef TXM_MODULE_PORT_DISPATCH
        /* Is this a port-specific request? */
        if ((kernel_request >= TXM_MODULE_PORT_EXTENSION_API_ID_START) && (kernel_request <= TXM_MODULE_PORT_EXTENSION_API_ID_END))
 8014cc8:	68fb      	ldr	r3, [r7, #12]
 8014cca:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8014cce:	d30c      	bcc.n	8014cea <_txm_module_manager_kernel_dispatch+0x73a>
 8014cd0:	68fb      	ldr	r3, [r7, #12]
 8014cd2:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8014cd6:	d208      	bcs.n	8014cea <_txm_module_manager_kernel_dispatch+0x73a>
        {
            /* Yes, call the port-specific dispatcher. */
            return_value = (ALIGN_TYPE) _txm_module_manager_port_dispatch(module_instance, kernel_request, param_0, param_1, param_2);
 8014cd8:	683b      	ldr	r3, [r7, #0]
 8014cda:	9300      	str	r3, [sp, #0]
 8014cdc:	687b      	ldr	r3, [r7, #4]
 8014cde:	68ba      	ldr	r2, [r7, #8]
 8014ce0:	68f9      	ldr	r1, [r7, #12]
 8014ce2:	6938      	ldr	r0, [r7, #16]
 8014ce4:	f000 fbbc 	bl	8015460 <_txm_module_manager_port_dispatch>
 8014ce8:	6178      	str	r0, [r7, #20]
        }
#endif

        #ifndef TXM_MODULE_APPLICATION_REQUEST_CALL_NOT_USED
        /* Determine if an application request is present.  */
        if (kernel_request >= TXM_APPLICATION_REQUEST_ID_BASE)
 8014cea:	68fb      	ldr	r3, [r7, #12]
 8014cec:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8014cf0:	d308      	bcc.n	8014d04 <_txm_module_manager_kernel_dispatch+0x754>
        {
            /* Yes, call the module manager function that the application defines in order to
               support application-specific requests.  */
            return_value =  (ALIGN_TYPE)  _txm_module_manager_application_request(kernel_request-TXM_APPLICATION_REQUEST_ID_BASE, param_0, param_1, param_2);
 8014cf2:	68fb      	ldr	r3, [r7, #12]
 8014cf4:	f5a3 3080 	sub.w	r0, r3, #65536	; 0x10000
 8014cf8:	683b      	ldr	r3, [r7, #0]
 8014cfa:	687a      	ldr	r2, [r7, #4]
 8014cfc:	68b9      	ldr	r1, [r7, #8]
 8014cfe:	f7fa fe75 	bl	800f9ec <_txm_module_manager_application_request>
 8014d02:	6178      	str	r0, [r7, #20]
            return_value =  _txm_module_manager_usbx_dispatch(module_instance, kernel_request, param_0, param_1, param_2);
        }
#endif

        /* Unhandled kernel request, return an error!  */
        break;
 8014d04:	bf00      	nop
    }
    }

    return(return_value);
 8014d06:	697b      	ldr	r3, [r7, #20]
}
 8014d08:	4618      	mov	r0, r3
 8014d0a:	3718      	adds	r7, #24
 8014d0c:	46bd      	mov	sp, r7
 8014d0e:	bd80      	pop	{r7, pc}

08014d10 <_txm_module_manager_memory_fault_handler>:
/*                                                                        */
/*  03-02-2021      Scott Larson            Initial Version 6.1.5         */
/*                                                                        */
/**************************************************************************/
VOID  _txm_module_manager_memory_fault_handler(VOID)
{
 8014d10:	b580      	push	{r7, lr}
 8014d12:	b082      	sub	sp, #8
 8014d14:	af00      	add	r7, sp, #0

TXM_MODULE_INSTANCE     *module_instance_ptr;
TX_THREAD               *thread_ptr;

    /* Pickup the current thread.  */
    thread_ptr =  _tx_thread_current_ptr;
 8014d16:	4b0f      	ldr	r3, [pc, #60]	; (8014d54 <_txm_module_manager_memory_fault_handler+0x44>)
 8014d18:	681b      	ldr	r3, [r3, #0]
 8014d1a:	603b      	str	r3, [r7, #0]

    /* Initialize the module instance pointer to NULL.  */
    module_instance_ptr =  TX_NULL;
 8014d1c:	2300      	movs	r3, #0
 8014d1e:	607b      	str	r3, [r7, #4]
    
    /* Is there a thread?  */
    if (thread_ptr)
 8014d20:	683b      	ldr	r3, [r7, #0]
 8014d22:	2b00      	cmp	r3, #0
 8014d24:	d008      	beq.n	8014d38 <_txm_module_manager_memory_fault_handler+0x28>
    {
        /* Pickup the module instance.  */
        module_instance_ptr =  thread_ptr -> tx_thread_module_instance_ptr;
 8014d26:	683b      	ldr	r3, [r7, #0]
 8014d28:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8014d2c:	607b      	str	r3, [r7, #4]

        /* Terminate the current thread.  */
        _tx_thread_terminate(_tx_thread_current_ptr);
 8014d2e:	4b09      	ldr	r3, [pc, #36]	; (8014d54 <_txm_module_manager_memory_fault_handler+0x44>)
 8014d30:	681b      	ldr	r3, [r3, #0]
 8014d32:	4618      	mov	r0, r3
 8014d34:	f7f7 fe1e 	bl	800c974 <_tx_thread_terminate>
    }
    
    /* Determine if there is a user memory fault notification callback.  */
    if (_txm_module_manager_fault_notify)
 8014d38:	4b07      	ldr	r3, [pc, #28]	; (8014d58 <_txm_module_manager_memory_fault_handler+0x48>)
 8014d3a:	681b      	ldr	r3, [r3, #0]
 8014d3c:	2b00      	cmp	r3, #0
 8014d3e:	d004      	beq.n	8014d4a <_txm_module_manager_memory_fault_handler+0x3a>
    {
        /* Yes, call the user's notification memory fault callback.  */
        (_txm_module_manager_fault_notify)(thread_ptr, module_instance_ptr);
 8014d40:	4b05      	ldr	r3, [pc, #20]	; (8014d58 <_txm_module_manager_memory_fault_handler+0x48>)
 8014d42:	681b      	ldr	r3, [r3, #0]
 8014d44:	6879      	ldr	r1, [r7, #4]
 8014d46:	6838      	ldr	r0, [r7, #0]
 8014d48:	4798      	blx	r3
    }
}
 8014d4a:	bf00      	nop
 8014d4c:	3708      	adds	r7, #8
 8014d4e:	46bd      	mov	sp, r7
 8014d50:	bd80      	pop	{r7, pc}
 8014d52:	bf00      	nop
 8014d54:	2000efb8 	.word	0x2000efb8
 8014d58:	2000f6bc 	.word	0x2000f6bc

08014d5c <_txm_module_manager_memory_fault_notify>:
/*                                                                        */
/*  03-02-2021      Scott Larson            Initial Version 6.1.5         */
/*                                                                        */
/**************************************************************************/
UINT  _txm_module_manager_memory_fault_notify(VOID (*notify_function)(TX_THREAD *, TXM_MODULE_INSTANCE *))
{
 8014d5c:	b480      	push	{r7}
 8014d5e:	b083      	sub	sp, #12
 8014d60:	af00      	add	r7, sp, #0
 8014d62:	6078      	str	r0, [r7, #4]
    /* Setup notification function.  */
    _txm_module_manager_fault_notify =  notify_function;
 8014d64:	4a04      	ldr	r2, [pc, #16]	; (8014d78 <_txm_module_manager_memory_fault_notify+0x1c>)
 8014d66:	687b      	ldr	r3, [r7, #4]
 8014d68:	6013      	str	r3, [r2, #0]
    
    /* Return success.  */
    return(TX_SUCCESS);
 8014d6a:	2300      	movs	r3, #0
}
 8014d6c:	4618      	mov	r0, r3
 8014d6e:	370c      	adds	r7, #12
 8014d70:	46bd      	mov	sp, r7
 8014d72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014d76:	4770      	bx	lr
 8014d78:	2000f6bc 	.word	0x2000f6bc

08014d7c <_txm_module_manager_mm_register_setup>:
/*                                            for overflow,               */
/*                                            resulting 6.1.6             */
/*                                                                        */
/**************************************************************************/
VOID  _txm_module_manager_mm_register_setup(TXM_MODULE_INSTANCE *module_instance)
{
 8014d7c:	b480      	push	{r7}
 8014d7e:	b087      	sub	sp, #28
 8014d80:	af00      	add	r7, sp, #0
 8014d82:	6078      	str	r0, [r7, #4]
ULONG   callback_stack_size;

    /* Setup MPU region for kernel mode entry.  */
    /* Set base address register to user mode entry function address, which is guaranteed to be at least 32-byte aligned.
       Mask address to proper range, inner shareable, read only. */
    module_instance -> txm_module_instance_mpu_registers[TXM_MODULE_MPU_KERNEL_ENTRY_INDEX].txm_module_mpu_region_base_address = ((ULONG) _txm_module_manager_user_mode_entry & 0xFFFFFFE0) | TXM_MODULE_ATTRIBUTE_INNER_SHAREABLE | TXM_MODULE_ATTRIBUTE_READ_ONLY;
 8014d84:	4b2f      	ldr	r3, [pc, #188]	; (8014e44 <_txm_module_manager_mm_register_setup+0xc8>)
 8014d86:	f023 031f 	bic.w	r3, r3, #31
 8014d8a:	f043 021e 	orr.w	r2, r3, #30
 8014d8e:	687b      	ldr	r3, [r7, #4]
 8014d90:	665a      	str	r2, [r3, #100]	; 0x64
    /* Set the limit address, attribute index, and enable bit.  */
    module_instance -> txm_module_instance_mpu_registers[TXM_MODULE_MPU_KERNEL_ENTRY_INDEX].txm_module_mpu_region_limit_address = ((ULONG) _txm_module_manager_user_mode_entry & 0xFFFFFFE0) | TXM_MODULE_ATTRIBUTE_INDEX | TXM_MODULE_ATTRIBUTE_REGION_ENABLE;
 8014d92:	4b2c      	ldr	r3, [pc, #176]	; (8014e44 <_txm_module_manager_mm_register_setup+0xc8>)
 8014d94:	f023 031f 	bic.w	r3, r3, #31
 8014d98:	f043 0201 	orr.w	r2, r3, #1
 8014d9c:	687b      	ldr	r3, [r7, #4]
 8014d9e:	669a      	str	r2, [r3, #104]	; 0x68


    /* Setup MPU region for module code protection.  */
    /* Set base address register to module code address, which should be at least 32-byte aligned.
       Mask address to proper range, inner shareable, read only. */
    module_instance -> txm_module_instance_mpu_registers[TXM_MODULE_MPU_CODE_INDEX].txm_module_mpu_region_base_address = ((ULONG) module_instance -> txm_module_instance_code_start & 0xFFFFFFE0) | TXM_MODULE_ATTRIBUTE_INNER_SHAREABLE | TXM_MODULE_ATTRIBUTE_READ_ONLY;
 8014da0:	687b      	ldr	r3, [r7, #4]
 8014da2:	699b      	ldr	r3, [r3, #24]
 8014da4:	f023 031f 	bic.w	r3, r3, #31
 8014da8:	f043 021e 	orr.w	r2, r3, #30
 8014dac:	687b      	ldr	r3, [r7, #4]
 8014dae:	66da      	str	r2, [r3, #108]	; 0x6c
    /* Set the limit address (code start + code size-1), attribute index, and enable bit.  */
    module_instance -> txm_module_instance_mpu_registers[TXM_MODULE_MPU_CODE_INDEX].txm_module_mpu_region_limit_address = (((ULONG) module_instance -> txm_module_instance_code_start + module_instance -> txm_module_instance_preamble_ptr -> txm_module_preamble_code_size - 1) & 0xFFFFFFE0) | TXM_MODULE_ATTRIBUTE_INDEX | TXM_MODULE_ATTRIBUTE_REGION_ENABLE;
 8014db0:	687b      	ldr	r3, [r7, #4]
 8014db2:	699b      	ldr	r3, [r3, #24]
 8014db4:	461a      	mov	r2, r3
 8014db6:	687b      	ldr	r3, [r7, #4]
 8014db8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8014dba:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014dbc:	4413      	add	r3, r2
 8014dbe:	3b01      	subs	r3, #1
 8014dc0:	f023 031f 	bic.w	r3, r3, #31
 8014dc4:	f043 0201 	orr.w	r2, r3, #1
 8014dc8:	687b      	ldr	r3, [r7, #4]
 8014dca:	671a      	str	r2, [r3, #112]	; 0x70


    /* Setup MPU region for module data protection.  */
    /* Set base address register to module data address, which should be at least 32-byte aligned.
       Mask address to proper range, inner shareable, read write, execute never. */
    module_instance -> txm_module_instance_mpu_registers[TXM_MODULE_MPU_DATA_INDEX].txm_module_mpu_region_base_address = ((ULONG) module_instance -> txm_module_instance_data_start & 0xFFFFFFE0) | TXM_MODULE_ATTRIBUTE_INNER_SHAREABLE | TXM_MODULE_ATTRIBUTE_READ_WRITE | TXM_MODULE_ATTRIBUTE_EXECUTE_NEVER;
 8014dcc:	687b      	ldr	r3, [r7, #4]
 8014dce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8014dd0:	f023 031f 	bic.w	r3, r3, #31
 8014dd4:	f043 021b 	orr.w	r2, r3, #27
 8014dd8:	687b      	ldr	r3, [r7, #4]
 8014dda:	675a      	str	r2, [r3, #116]	; 0x74
    /* Adjust the size of the module elements to be aligned to the default alignment. We do this
       so that when we partition the allocated memory, we can simply place these regions right beside
       each other without having to align their pointers. Note this only works when they all have
       the same alignment.  */
    
    data_size =             module_instance -> txm_module_instance_preamble_ptr -> txm_module_preamble_data_size;
 8014ddc:	687b      	ldr	r3, [r7, #4]
 8014dde:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8014de0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8014de2:	617b      	str	r3, [r7, #20]
    start_stop_stack_size = module_instance -> txm_module_instance_preamble_ptr -> txm_module_preamble_start_stop_stack_size;
 8014de4:	687b      	ldr	r3, [r7, #4]
 8014de6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8014de8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014dea:	613b      	str	r3, [r7, #16]
    callback_stack_size =   module_instance -> txm_module_instance_preamble_ptr -> txm_module_preamble_callback_stack_size;
 8014dec:	687b      	ldr	r3, [r7, #4]
 8014dee:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8014df0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8014df2:	60fb      	str	r3, [r7, #12]
    
    data_size =              ((data_size + TXM_MODULE_DATA_ALIGNMENT - 1)/TXM_MODULE_DATA_ALIGNMENT) * TXM_MODULE_DATA_ALIGNMENT;
 8014df4:	697b      	ldr	r3, [r7, #20]
 8014df6:	3307      	adds	r3, #7
 8014df8:	f023 0307 	bic.w	r3, r3, #7
 8014dfc:	617b      	str	r3, [r7, #20]
    start_stop_stack_size =  ((start_stop_stack_size + TXM_MODULE_DATA_ALIGNMENT - 1)/TXM_MODULE_DATA_ALIGNMENT) * TXM_MODULE_DATA_ALIGNMENT;
 8014dfe:	693b      	ldr	r3, [r7, #16]
 8014e00:	3307      	adds	r3, #7
 8014e02:	f023 0307 	bic.w	r3, r3, #7
 8014e06:	613b      	str	r3, [r7, #16]
    callback_stack_size =    ((callback_stack_size + TXM_MODULE_DATA_ALIGNMENT - 1)/TXM_MODULE_DATA_ALIGNMENT) * TXM_MODULE_DATA_ALIGNMENT;
 8014e08:	68fb      	ldr	r3, [r7, #12]
 8014e0a:	3307      	adds	r3, #7
 8014e0c:	f023 0307 	bic.w	r3, r3, #7
 8014e10:	60fb      	str	r3, [r7, #12]

    /* Update the data size to include thread stacks.  */
    data_size = data_size + start_stop_stack_size + callback_stack_size;
 8014e12:	697a      	ldr	r2, [r7, #20]
 8014e14:	693b      	ldr	r3, [r7, #16]
 8014e16:	4413      	add	r3, r2
 8014e18:	68fa      	ldr	r2, [r7, #12]
 8014e1a:	4413      	add	r3, r2
 8014e1c:	617b      	str	r3, [r7, #20]
    
    /* Set the limit address (data start + data size-1), attribute index, and enable bit.  */
    module_instance -> txm_module_instance_mpu_registers[TXM_MODULE_MPU_DATA_INDEX].txm_module_mpu_region_limit_address = (((ULONG) module_instance -> txm_module_instance_data_start + data_size - 1) & 0xFFFFFFE0) | TXM_MODULE_ATTRIBUTE_INDEX | TXM_MODULE_ATTRIBUTE_REGION_ENABLE;
 8014e1e:	687b      	ldr	r3, [r7, #4]
 8014e20:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8014e22:	461a      	mov	r2, r3
 8014e24:	697b      	ldr	r3, [r7, #20]
 8014e26:	4413      	add	r3, r2
 8014e28:	3b01      	subs	r3, #1
 8014e2a:	f023 031f 	bic.w	r3, r3, #31
 8014e2e:	f043 0201 	orr.w	r2, r3, #1
 8014e32:	687b      	ldr	r3, [r7, #4]
 8014e34:	679a      	str	r2, [r3, #120]	; 0x78
    /* End of module data protection.  */
    
    /* Remaining MPU entries are disabled for now and can be used for shared memory. */
}
 8014e36:	bf00      	nop
 8014e38:	371c      	adds	r7, #28
 8014e3a:	46bd      	mov	sp, r7
 8014e3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014e40:	4770      	bx	lr
 8014e42:	bf00      	nop
 8014e44:	080006e1 	.word	0x080006e1

08014e48 <_txm_module_manager_inside_data_check>:
/*  04-02-2021      Scott Larson            Modified comments,            */
/*                                            resulting in version 6.1.6  */
/*                                                                        */
/**************************************************************************/
UINT _txm_module_manager_inside_data_check(TXM_MODULE_INSTANCE *module_instance, ALIGN_TYPE obj_ptr, UINT obj_size)
{
 8014e48:	b480      	push	{r7}
 8014e4a:	b089      	sub	sp, #36	; 0x24
 8014e4c:	af00      	add	r7, sp, #0
 8014e4e:	60f8      	str	r0, [r7, #12]
 8014e50:	60b9      	str	r1, [r7, #8]
 8014e52:	607a      	str	r2, [r7, #4]
UINT num_shared_memory_mpu_entries;
ALIGN_TYPE shared_memory_address_start;
ALIGN_TYPE shared_memory_address_end;

    /* Check for overflow. */
    if ((obj_ptr) > ((obj_ptr) + (obj_size)))
 8014e54:	68ba      	ldr	r2, [r7, #8]
 8014e56:	687b      	ldr	r3, [r7, #4]
 8014e58:	4413      	add	r3, r2
 8014e5a:	68ba      	ldr	r2, [r7, #8]
 8014e5c:	429a      	cmp	r2, r3
 8014e5e:	d901      	bls.n	8014e64 <_txm_module_manager_inside_data_check+0x1c>
    {
        return(TX_FALSE);
 8014e60:	2300      	movs	r3, #0
 8014e62:	e039      	b.n	8014ed8 <_txm_module_manager_inside_data_check+0x90>
    }
    
    /* Check if the object is inside the module data.  */
    if ((obj_ptr >= (ALIGN_TYPE) module_instance -> txm_module_instance_data_start) &&
 8014e64:	68fb      	ldr	r3, [r7, #12]
 8014e66:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8014e68:	461a      	mov	r2, r3
 8014e6a:	68bb      	ldr	r3, [r7, #8]
 8014e6c:	4293      	cmp	r3, r2
 8014e6e:	d309      	bcc.n	8014e84 <_txm_module_manager_inside_data_check+0x3c>
        ((obj_ptr + obj_size) <= ((ALIGN_TYPE) module_instance -> txm_module_instance_data_end + 1)))
 8014e70:	68ba      	ldr	r2, [r7, #8]
 8014e72:	687b      	ldr	r3, [r7, #4]
 8014e74:	441a      	add	r2, r3
 8014e76:	68fb      	ldr	r3, [r7, #12]
 8014e78:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014e7a:	3301      	adds	r3, #1
    if ((obj_ptr >= (ALIGN_TYPE) module_instance -> txm_module_instance_data_start) &&
 8014e7c:	429a      	cmp	r2, r3
 8014e7e:	d801      	bhi.n	8014e84 <_txm_module_manager_inside_data_check+0x3c>
    {
        return(TX_TRUE);
 8014e80:	2301      	movs	r3, #1
 8014e82:	e029      	b.n	8014ed8 <_txm_module_manager_inside_data_check+0x90>
    }

    /* Check if the object is inside the shared memory.  */
    num_shared_memory_mpu_entries = module_instance -> txm_module_instance_shared_memory_count;
 8014e84:	68fb      	ldr	r3, [r7, #12]
 8014e86:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 8014e8a:	61bb      	str	r3, [r7, #24]
    for (shared_memory_index = 0; shared_memory_index < num_shared_memory_mpu_entries; shared_memory_index++)
 8014e8c:	2300      	movs	r3, #0
 8014e8e:	61fb      	str	r3, [r7, #28]
 8014e90:	e01d      	b.n	8014ece <_txm_module_manager_inside_data_check+0x86>
    {

        shared_memory_address_start = (ALIGN_TYPE) module_instance -> txm_module_instance_shared_memory_address[shared_memory_index];
 8014e92:	68fb      	ldr	r3, [r7, #12]
 8014e94:	69fa      	ldr	r2, [r7, #28]
 8014e96:	322a      	adds	r2, #42	; 0x2a
 8014e98:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8014e9c:	617b      	str	r3, [r7, #20]
        shared_memory_address_end = shared_memory_address_start + module_instance -> txm_module_instance_shared_memory_length[shared_memory_index];
 8014e9e:	68fa      	ldr	r2, [r7, #12]
 8014ea0:	69fb      	ldr	r3, [r7, #28]
 8014ea2:	332e      	adds	r3, #46	; 0x2e
 8014ea4:	009b      	lsls	r3, r3, #2
 8014ea6:	4413      	add	r3, r2
 8014ea8:	685b      	ldr	r3, [r3, #4]
 8014eaa:	697a      	ldr	r2, [r7, #20]
 8014eac:	4413      	add	r3, r2
 8014eae:	613b      	str	r3, [r7, #16]

        if ((obj_ptr >= (ALIGN_TYPE) shared_memory_address_start) &&
 8014eb0:	68ba      	ldr	r2, [r7, #8]
 8014eb2:	697b      	ldr	r3, [r7, #20]
 8014eb4:	429a      	cmp	r2, r3
 8014eb6:	d307      	bcc.n	8014ec8 <_txm_module_manager_inside_data_check+0x80>
            ((obj_ptr + obj_size) <= (ALIGN_TYPE) shared_memory_address_end))
 8014eb8:	68ba      	ldr	r2, [r7, #8]
 8014eba:	687b      	ldr	r3, [r7, #4]
 8014ebc:	4413      	add	r3, r2
        if ((obj_ptr >= (ALIGN_TYPE) shared_memory_address_start) &&
 8014ebe:	693a      	ldr	r2, [r7, #16]
 8014ec0:	429a      	cmp	r2, r3
 8014ec2:	d301      	bcc.n	8014ec8 <_txm_module_manager_inside_data_check+0x80>
        {
            return(TX_TRUE);
 8014ec4:	2301      	movs	r3, #1
 8014ec6:	e007      	b.n	8014ed8 <_txm_module_manager_inside_data_check+0x90>
    for (shared_memory_index = 0; shared_memory_index < num_shared_memory_mpu_entries; shared_memory_index++)
 8014ec8:	69fb      	ldr	r3, [r7, #28]
 8014eca:	3301      	adds	r3, #1
 8014ecc:	61fb      	str	r3, [r7, #28]
 8014ece:	69fa      	ldr	r2, [r7, #28]
 8014ed0:	69bb      	ldr	r3, [r7, #24]
 8014ed2:	429a      	cmp	r2, r3
 8014ed4:	d3dd      	bcc.n	8014e92 <_txm_module_manager_inside_data_check+0x4a>
        }
    }

    return(TX_FALSE);
 8014ed6:	2300      	movs	r3, #0
}
 8014ed8:	4618      	mov	r0, r3
 8014eda:	3724      	adds	r7, #36	; 0x24
 8014edc:	46bd      	mov	sp, r7
 8014ede:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014ee2:	4770      	bx	lr

08014ee4 <_txm_module_manager_object_allocate>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
UINT _txm_module_manager_object_allocate(VOID **object_ptr_ptr, ULONG object_size, TXM_MODULE_INSTANCE *module_instance)
{
 8014ee4:	b580      	push	{r7, lr}
 8014ee6:	b088      	sub	sp, #32
 8014ee8:	af00      	add	r7, sp, #0
 8014eea:	60f8      	str	r0, [r7, #12]
 8014eec:	60b9      	str	r1, [r7, #8]
 8014eee:	607a      	str	r2, [r7, #4]
TXM_MODULE_ALLOCATED_OBJECT *object_ptr;
UINT                        return_value;


    /* Ensure the object pointer pointer is valid. */
    if (object_ptr_ptr == (VOID **) TX_NULL)
 8014ef0:	68fb      	ldr	r3, [r7, #12]
 8014ef2:	2b00      	cmp	r3, #0
 8014ef4:	d101      	bne.n	8014efa <_txm_module_manager_object_allocate+0x16>
    {

        /* The object pointer pointer is invalid, return an error.  */
        return(TXM_MODULE_INVALID_MEMORY);
 8014ef6:	23f4      	movs	r3, #244	; 0xf4
 8014ef8:	e052      	b.n	8014fa0 <_txm_module_manager_object_allocate+0xbc>
    }

    /* Initialize the return pointer to NULL.  */
    *((VOID **) object_ptr_ptr) =  TX_NULL;
 8014efa:	68fb      	ldr	r3, [r7, #12]
 8014efc:	2200      	movs	r2, #0
 8014efe:	601a      	str	r2, [r3, #0]

    /* Get module manager protection mutex.  */
    _txe_mutex_get(&_txm_module_manager_mutex, TX_WAIT_FOREVER);
 8014f00:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8014f04:	4828      	ldr	r0, [pc, #160]	; (8014fa8 <_txm_module_manager_object_allocate+0xc4>)
 8014f06:	f7f9 fbeb 	bl	800e6e0 <_txe_mutex_get>

    /* Determine if an object pool was created.  */
    if (_txm_module_manager_object_pool_created)
 8014f0a:	4b28      	ldr	r3, [pc, #160]	; (8014fac <_txm_module_manager_object_allocate+0xc8>)
 8014f0c:	681b      	ldr	r3, [r3, #0]
 8014f0e:	2b00      	cmp	r3, #0
 8014f10:	d040      	beq.n	8014f94 <_txm_module_manager_object_allocate+0xb0>

    TXM_MODULE_ALLOCATED_OBJECT   *next_object, *previous_object;

        /* Allocate the object requested by the module - adding an extra ULONG in order to
           store the module instance pointer.  */
        return_value =  (ULONG)  _txe_byte_allocate(&_txm_module_manager_object_pool, (VOID **) &object_ptr,
 8014f12:	68bb      	ldr	r3, [r7, #8]
 8014f14:	f103 0210 	add.w	r2, r3, #16
 8014f18:	f107 0110 	add.w	r1, r7, #16
 8014f1c:	2300      	movs	r3, #0
 8014f1e:	4824      	ldr	r0, [pc, #144]	; (8014fb0 <_txm_module_manager_object_allocate+0xcc>)
 8014f20:	f7f8 ff90 	bl	800de44 <_txe_byte_allocate>
 8014f24:	61f8      	str	r0, [r7, #28]
            (ULONG) (object_size + sizeof(TXM_MODULE_ALLOCATED_OBJECT)), TX_NO_WAIT);

        /* Determine if the request was successful.  */
        if (return_value == TX_SUCCESS)
 8014f26:	69fb      	ldr	r3, [r7, #28]
 8014f28:	2b00      	cmp	r3, #0
 8014f2a:	d135      	bne.n	8014f98 <_txm_module_manager_object_allocate+0xb4>
        {
            /* Yes, now store the module instance in the allocated memory block.  */

            /* Link the allocated memory to the module instance.  */
            if (module_instance -> txm_module_instance_object_list_count++ == 0)
 8014f2c:	687b      	ldr	r3, [r7, #4]
 8014f2e:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
 8014f32:	1c59      	adds	r1, r3, #1
 8014f34:	687a      	ldr	r2, [r7, #4]
 8014f36:	f8c2 14a0 	str.w	r1, [r2, #1184]	; 0x4a0
 8014f3a:	2b00      	cmp	r3, #0
 8014f3c:	d10a      	bne.n	8014f54 <_txm_module_manager_object_allocate+0x70>
            {
                /* The allocated object list is empty.  Add object to empty list.  */
                module_instance -> txm_module_instance_object_list_head =  object_ptr;
 8014f3e:	693a      	ldr	r2, [r7, #16]
 8014f40:	687b      	ldr	r3, [r7, #4]
 8014f42:	f8c3 249c 	str.w	r2, [r3, #1180]	; 0x49c
                object_ptr -> txm_module_allocated_object_next =           object_ptr;
 8014f46:	693b      	ldr	r3, [r7, #16]
 8014f48:	693a      	ldr	r2, [r7, #16]
 8014f4a:	605a      	str	r2, [r3, #4]
                object_ptr -> txm_module_allocated_object_previous =       object_ptr;
 8014f4c:	693b      	ldr	r3, [r7, #16]
 8014f4e:	693a      	ldr	r2, [r7, #16]
 8014f50:	609a      	str	r2, [r3, #8]
 8014f52:	e012      	b.n	8014f7a <_txm_module_manager_object_allocate+0x96>
            }
            else
            {
                /* This list is not NULL, add to the end of the list.  */
                next_object =      module_instance -> txm_module_instance_object_list_head;
 8014f54:	687b      	ldr	r3, [r7, #4]
 8014f56:	f8d3 349c 	ldr.w	r3, [r3, #1180]	; 0x49c
 8014f5a:	61bb      	str	r3, [r7, #24]
                previous_object =  next_object -> txm_module_allocated_object_previous;
 8014f5c:	69bb      	ldr	r3, [r7, #24]
 8014f5e:	689b      	ldr	r3, [r3, #8]
 8014f60:	617b      	str	r3, [r7, #20]

                /* Place the new object in the list.  */
                next_object -> txm_module_allocated_object_previous =  object_ptr;
 8014f62:	693a      	ldr	r2, [r7, #16]
 8014f64:	69bb      	ldr	r3, [r7, #24]
 8014f66:	609a      	str	r2, [r3, #8]
                previous_object -> txm_module_allocated_object_next =  object_ptr;
 8014f68:	693a      	ldr	r2, [r7, #16]
 8014f6a:	697b      	ldr	r3, [r7, #20]
 8014f6c:	605a      	str	r2, [r3, #4]

                /* Setup this object's allocated links.  */
                object_ptr -> txm_module_allocated_object_previous =  previous_object;
 8014f6e:	693b      	ldr	r3, [r7, #16]
 8014f70:	697a      	ldr	r2, [r7, #20]
 8014f72:	609a      	str	r2, [r3, #8]
                object_ptr -> txm_module_allocated_object_next =      next_object;
 8014f74:	693b      	ldr	r3, [r7, #16]
 8014f76:	69ba      	ldr	r2, [r7, #24]
 8014f78:	605a      	str	r2, [r3, #4]
            }

            /* Setup the module instance pointer in the allocated object.  */
            object_ptr -> txm_module_allocated_object_module_instance =  module_instance;
 8014f7a:	693b      	ldr	r3, [r7, #16]
 8014f7c:	687a      	ldr	r2, [r7, #4]
 8014f7e:	601a      	str	r2, [r3, #0]

            /* Set the object size. */
            object_ptr -> txm_module_object_size =  object_size;
 8014f80:	693b      	ldr	r3, [r7, #16]
 8014f82:	68ba      	ldr	r2, [r7, #8]
 8014f84:	60da      	str	r2, [r3, #12]

            /* Move the object pointer forward. This is what the module is given. */
            object_ptr++;
 8014f86:	693b      	ldr	r3, [r7, #16]
 8014f88:	3310      	adds	r3, #16
 8014f8a:	613b      	str	r3, [r7, #16]

            /* Return this pointer to the application.  */
            *((VOID **) object_ptr_ptr) =  object_ptr;
 8014f8c:	693a      	ldr	r2, [r7, #16]
 8014f8e:	68fb      	ldr	r3, [r7, #12]
 8014f90:	601a      	str	r2, [r3, #0]
 8014f92:	e001      	b.n	8014f98 <_txm_module_manager_object_allocate+0xb4>
        }
    }
    else
    {
        /* Set return value to not enabled.  */
        return_value =  TX_NOT_AVAILABLE;
 8014f94:	231d      	movs	r3, #29
 8014f96:	61fb      	str	r3, [r7, #28]
    }

    /* Release the protection mutex.  */
    _txe_mutex_put(&_txm_module_manager_mutex);
 8014f98:	4803      	ldr	r0, [pc, #12]	; (8014fa8 <_txm_module_manager_object_allocate+0xc4>)
 8014f9a:	f7f9 fc43 	bl	800e824 <_txe_mutex_put>

    return(return_value);
 8014f9e:	69fb      	ldr	r3, [r7, #28]
}
 8014fa0:	4618      	mov	r0, r3
 8014fa2:	3720      	adds	r7, #32
 8014fa4:	46bd      	mov	sp, r7
 8014fa6:	bd80      	pop	{r7, pc}
 8014fa8:	2000f674 	.word	0x2000f674
 8014fac:	2000f670 	.word	0x2000f670
 8014fb0:	2000f63c 	.word	0x2000f63c

08014fb4 <_txm_module_manager_object_deallocate>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
UINT  _txm_module_manager_object_deallocate(VOID *object_ptr)
{
 8014fb4:	b580      	push	{r7, lr}
 8014fb6:	b088      	sub	sp, #32
 8014fb8:	af00      	add	r7, sp, #0
 8014fba:	6078      	str	r0, [r7, #4]
TXM_MODULE_INSTANCE         *module_instance;
TXM_MODULE_ALLOCATED_OBJECT *module_allocated_object_ptr;
UINT                        return_value;

    /* Get module manager protection mutex.  */
    _txe_mutex_get(&_txm_module_manager_mutex, TX_WAIT_FOREVER);
 8014fbc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8014fc0:	482c      	ldr	r0, [pc, #176]	; (8015074 <_txm_module_manager_object_deallocate+0xc0>)
 8014fc2:	f7f9 fb8d 	bl	800e6e0 <_txe_mutex_get>

    /* Determine if an object pool was created.  */
    if (_txm_module_manager_object_pool_created)
 8014fc6:	4b2c      	ldr	r3, [pc, #176]	; (8015078 <_txm_module_manager_object_deallocate+0xc4>)
 8014fc8:	681b      	ldr	r3, [r3, #0]
 8014fca:	2b00      	cmp	r3, #0
 8014fcc:	d047      	beq.n	801505e <_txm_module_manager_object_deallocate+0xaa>
    {

    TXM_MODULE_ALLOCATED_OBJECT   *next_object, *previous_object;

        /* Pickup module instance pointer.  */
        module_instance =  _tx_thread_current_ptr -> tx_thread_module_instance_ptr;
 8014fce:	4b2b      	ldr	r3, [pc, #172]	; (801507c <_txm_module_manager_object_deallocate+0xc8>)
 8014fd0:	681b      	ldr	r3, [r3, #0]
 8014fd2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8014fd6:	61bb      	str	r3, [r7, #24]

        /* Setup the memory pointer.  */
        module_allocated_object_ptr =  (TXM_MODULE_ALLOCATED_OBJECT *) object_ptr;
 8014fd8:	687b      	ldr	r3, [r7, #4]
 8014fda:	617b      	str	r3, [r7, #20]

        /* Position the object pointer backwards to position back to the module manager information.  */
        previous_object =  module_allocated_object_ptr--;
 8014fdc:	697b      	ldr	r3, [r7, #20]
 8014fde:	f1a3 0210 	sub.w	r2, r3, #16
 8014fe2:	617a      	str	r2, [r7, #20]
 8014fe4:	613b      	str	r3, [r7, #16]

        /* Make sure the object is valid.  */
        if ((module_allocated_object_ptr == TX_NULL) || (module_allocated_object_ptr -> txm_module_allocated_object_module_instance != module_instance) || (module_instance -> txm_module_instance_object_list_count == 0))
 8014fe6:	697b      	ldr	r3, [r7, #20]
 8014fe8:	2b00      	cmp	r3, #0
 8014fea:	d009      	beq.n	8015000 <_txm_module_manager_object_deallocate+0x4c>
 8014fec:	697b      	ldr	r3, [r7, #20]
 8014fee:	681b      	ldr	r3, [r3, #0]
 8014ff0:	69ba      	ldr	r2, [r7, #24]
 8014ff2:	429a      	cmp	r2, r3
 8014ff4:	d104      	bne.n	8015000 <_txm_module_manager_object_deallocate+0x4c>
 8014ff6:	69bb      	ldr	r3, [r7, #24]
 8014ff8:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
 8014ffc:	2b00      	cmp	r3, #0
 8014ffe:	d102      	bne.n	8015006 <_txm_module_manager_object_deallocate+0x52>
        {
            /* Set return value to invalid pointer.  */
            return_value =  TX_PTR_ERROR;
 8015000:	2303      	movs	r3, #3
 8015002:	61fb      	str	r3, [r7, #28]
 8015004:	e02d      	b.n	8015062 <_txm_module_manager_object_deallocate+0xae>
        }
        else
        {

            /* Unlink the node.  */
            if ((--module_instance -> txm_module_instance_object_list_count) == 0)
 8015006:	69bb      	ldr	r3, [r7, #24]
 8015008:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
 801500c:	1e5a      	subs	r2, r3, #1
 801500e:	69bb      	ldr	r3, [r7, #24]
 8015010:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
 8015014:	69bb      	ldr	r3, [r7, #24]
 8015016:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
 801501a:	2b00      	cmp	r3, #0
 801501c:	d104      	bne.n	8015028 <_txm_module_manager_object_deallocate+0x74>
            {
                /* Only allocated object, just set the allocated list to NULL.  */
                module_instance -> txm_module_instance_object_list_head =  TX_NULL;
 801501e:	69bb      	ldr	r3, [r7, #24]
 8015020:	2200      	movs	r2, #0
 8015022:	f8c3 249c 	str.w	r2, [r3, #1180]	; 0x49c
 8015026:	e015      	b.n	8015054 <_txm_module_manager_object_deallocate+0xa0>
            }
            else
            {
                /* Otherwise, not the only allocated object, link-up the neighbors.  */
                next_object =                                           module_allocated_object_ptr -> txm_module_allocated_object_next;
 8015028:	697b      	ldr	r3, [r7, #20]
 801502a:	685b      	ldr	r3, [r3, #4]
 801502c:	60fb      	str	r3, [r7, #12]
                previous_object =                                       module_allocated_object_ptr -> txm_module_allocated_object_previous;
 801502e:	697b      	ldr	r3, [r7, #20]
 8015030:	689b      	ldr	r3, [r3, #8]
 8015032:	613b      	str	r3, [r7, #16]
                next_object -> txm_module_allocated_object_previous =   previous_object;
 8015034:	68fb      	ldr	r3, [r7, #12]
 8015036:	693a      	ldr	r2, [r7, #16]
 8015038:	609a      	str	r2, [r3, #8]
                previous_object -> txm_module_allocated_object_next =   next_object;
 801503a:	693b      	ldr	r3, [r7, #16]
 801503c:	68fa      	ldr	r2, [r7, #12]
 801503e:	605a      	str	r2, [r3, #4]

                /* See if we have to update the allocated object list head pointer.  */
                if (module_instance -> txm_module_instance_object_list_head == module_allocated_object_ptr)
 8015040:	69bb      	ldr	r3, [r7, #24]
 8015042:	f8d3 349c 	ldr.w	r3, [r3, #1180]	; 0x49c
 8015046:	697a      	ldr	r2, [r7, #20]
 8015048:	429a      	cmp	r2, r3
 801504a:	d103      	bne.n	8015054 <_txm_module_manager_object_deallocate+0xa0>
                {
                    /* Yes, move the head pointer to the next link. */
                    module_instance -> txm_module_instance_object_list_head =  next_object;
 801504c:	69bb      	ldr	r3, [r7, #24]
 801504e:	68fa      	ldr	r2, [r7, #12]
 8015050:	f8c3 249c 	str.w	r2, [r3, #1180]	; 0x49c
                }
            }

            /* Release the object memory.  */
            return_value =  (ULONG)  _txe_byte_release((VOID *) module_allocated_object_ptr);
 8015054:	6978      	ldr	r0, [r7, #20]
 8015056:	f7f9 f88f 	bl	800e178 <_txe_byte_release>
 801505a:	61f8      	str	r0, [r7, #28]
 801505c:	e001      	b.n	8015062 <_txm_module_manager_object_deallocate+0xae>
        }
    }
    else
    {
        /* Set return value to not enabled.  */
        return_value =  TX_NOT_AVAILABLE;
 801505e:	231d      	movs	r3, #29
 8015060:	61fb      	str	r3, [r7, #28]
    }

    /* Release the protection mutex.  */
    _txe_mutex_put(&_txm_module_manager_mutex);
 8015062:	4804      	ldr	r0, [pc, #16]	; (8015074 <_txm_module_manager_object_deallocate+0xc0>)
 8015064:	f7f9 fbde 	bl	800e824 <_txe_mutex_put>

    return(return_value);
 8015068:	69fb      	ldr	r3, [r7, #28]
}
 801506a:	4618      	mov	r0, r3
 801506c:	3720      	adds	r7, #32
 801506e:	46bd      	mov	sp, r7
 8015070:	bd80      	pop	{r7, pc}
 8015072:	bf00      	nop
 8015074:	2000f674 	.word	0x2000f674
 8015078:	2000f670 	.word	0x2000f670
 801507c:	2000efb8 	.word	0x2000efb8

08015080 <_txm_module_manager_object_pointer_get>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
UINT  _txm_module_manager_object_pointer_get(UINT object_type, CHAR *name, VOID **object_ptr)
{
 8015080:	b580      	push	{r7, lr}
 8015082:	b086      	sub	sp, #24
 8015084:	af00      	add	r7, sp, #0
 8015086:	60f8      	str	r0, [r7, #12]
 8015088:	60b9      	str	r1, [r7, #8]
 801508a:	607a      	str	r2, [r7, #4]

UINT    status;

    /* Call the secure version of this function with the maximum length
       possible since none was passed.  */
    status =  _txm_module_manager_object_pointer_get_extended(object_type, name, TXM_MODULE_MANAGER_UTIL_MAX_VALUE_OF_TYPE_UNSIGNED(UINT), object_ptr);
 801508c:	687b      	ldr	r3, [r7, #4]
 801508e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8015092:	68b9      	ldr	r1, [r7, #8]
 8015094:	68f8      	ldr	r0, [r7, #12]
 8015096:	f000 f807 	bl	80150a8 <_txm_module_manager_object_pointer_get_extended>
 801509a:	6178      	str	r0, [r7, #20]
    return(status);
 801509c:	697b      	ldr	r3, [r7, #20]
}
 801509e:	4618      	mov	r0, r3
 80150a0:	3718      	adds	r7, #24
 80150a2:	46bd      	mov	sp, r7
 80150a4:	bd80      	pop	{r7, pc}
	...

080150a8 <_txm_module_manager_object_pointer_get_extended>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
UINT  _txm_module_manager_object_pointer_get_extended(UINT object_type, CHAR *search_name, UINT search_name_length, VOID **object_ptr)
{
 80150a8:	b580      	push	{r7, lr}
 80150aa:	b096      	sub	sp, #88	; 0x58
 80150ac:	af00      	add	r7, sp, #0
 80150ae:	60f8      	str	r0, [r7, #12]
 80150b0:	60b9      	str	r1, [r7, #8]
 80150b2:	607a      	str	r2, [r7, #4]
 80150b4:	603b      	str	r3, [r7, #0]
UINT                    status;
TXM_MODULE_INSTANCE     *module_instance;


    /* Determine if the name or object pointer are NULL.  */
    if ((search_name == TX_NULL) || (object_ptr == TX_NULL))
 80150b6:	68bb      	ldr	r3, [r7, #8]
 80150b8:	2b00      	cmp	r3, #0
 80150ba:	d002      	beq.n	80150c2 <_txm_module_manager_object_pointer_get_extended+0x1a>
 80150bc:	683b      	ldr	r3, [r7, #0]
 80150be:	2b00      	cmp	r3, #0
 80150c0:	d101      	bne.n	80150c6 <_txm_module_manager_object_pointer_get_extended+0x1e>
    {

        /* Return error!  */
        return(TX_PTR_ERROR);
 80150c2:	2303      	movs	r3, #3
 80150c4:	e1a3      	b.n	801540e <_txm_module_manager_object_pointer_get_extended+0x366>
    }

    /* Default status to not found.  */
    status =  TX_NO_INSTANCE;
 80150c6:	230d      	movs	r3, #13
 80150c8:	633b      	str	r3, [r7, #48]	; 0x30

    /* Set the return value to NULL.  */
    *object_ptr =  TX_NULL;
 80150ca:	683b      	ldr	r3, [r7, #0]
 80150cc:	2200      	movs	r2, #0
 80150ce:	601a      	str	r2, [r3, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80150d0:	f3ef 8310 	mrs	r3, PRIMASK
 80150d4:	623b      	str	r3, [r7, #32]
    return(posture);
 80150d6:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 80150d8:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 80150da:	b672      	cpsid	i
    return(int_posture);
 80150dc:	69fb      	ldr	r3, [r7, #28]

    /* Disable interrupts.  */
    TX_DISABLE
 80150de:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Temporarily disable preemption.  This will keep other threads from creating and deleting threads.  */
    _tx_thread_preempt_disable++;
 80150e0:	4b8f      	ldr	r3, [pc, #572]	; (8015320 <_txm_module_manager_object_pointer_get_extended+0x278>)
 80150e2:	681b      	ldr	r3, [r3, #0]
 80150e4:	3301      	adds	r3, #1
 80150e6:	4a8e      	ldr	r2, [pc, #568]	; (8015320 <_txm_module_manager_object_pointer_get_extended+0x278>)
 80150e8:	6013      	str	r3, [r2, #0]
 80150ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80150ec:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80150ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80150f0:	f383 8810 	msr	PRIMASK, r3
}
 80150f4:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Process relative to the object type.  */
    switch(object_type)
 80150f6:	68fb      	ldr	r3, [r7, #12]
 80150f8:	3b01      	subs	r3, #1
 80150fa:	2b07      	cmp	r3, #7
 80150fc:	f200 816e 	bhi.w	80153dc <_txm_module_manager_object_pointer_get_extended+0x334>
 8015100:	a201      	add	r2, pc, #4	; (adr r2, 8015108 <_txm_module_manager_object_pointer_get_extended+0x60>)
 8015102:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8015106:	bf00      	nop
 8015108:	080152cf 	.word	0x080152cf
 801510c:	08015375 	.word	0x08015375
 8015110:	080151fd 	.word	0x080151fd
 8015114:	08015289 	.word	0x08015289
 8015118:	080151b7 	.word	0x080151b7
 801511c:	08015243 	.word	0x08015243
 8015120:	08015129 	.word	0x08015129
 8015124:	08015171 	.word	0x08015171
    /* Determine if a thread object is requested.  */
    case TXM_THREAD_OBJECT:
    {

        /* Loop to find the first matching thread.  */
        i = 0;
 8015128:	2300      	movs	r3, #0
 801512a:	637b      	str	r3, [r7, #52]	; 0x34
        thread_ptr =  _tx_thread_created_ptr;
 801512c:	4b7d      	ldr	r3, [pc, #500]	; (8015324 <_txm_module_manager_object_pointer_get_extended+0x27c>)
 801512e:	681b      	ldr	r3, [r3, #0]
 8015130:	657b      	str	r3, [r7, #84]	; 0x54
        while (i < _tx_thread_created_count)
 8015132:	e017      	b.n	8015164 <_txm_module_manager_object_pointer_get_extended+0xbc>
        {

            /* Do we have a match?  */
            if (_txm_module_manager_object_name_compare(search_name, search_name_length, thread_ptr -> tx_thread_name))
 8015134:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8015136:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015138:	461a      	mov	r2, r3
 801513a:	6879      	ldr	r1, [r7, #4]
 801513c:	68b8      	ldr	r0, [r7, #8]
 801513e:	f001 fac4 	bl	80166ca <_txm_module_manager_object_name_compare>
 8015142:	4603      	mov	r3, r0
 8015144:	2b00      	cmp	r3, #0
 8015146:	d006      	beq.n	8015156 <_txm_module_manager_object_pointer_get_extended+0xae>
            {

                /* Yes, we found it - return the necessary info!  */
                *object_ptr =  (VOID *) thread_ptr;
 8015148:	683b      	ldr	r3, [r7, #0]
 801514a:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801514c:	601a      	str	r2, [r3, #0]

                /* Set the the status to success!  */
                status =  TX_SUCCESS;
 801514e:	2300      	movs	r3, #0
 8015150:	633b      	str	r3, [r7, #48]	; 0x30
                break;
 8015152:	bf00      	nop
            i++;

            /* Move to next thread.  */
            thread_ptr =  thread_ptr -> tx_thread_created_next;
        }
        break;
 8015154:	e145      	b.n	80153e2 <_txm_module_manager_object_pointer_get_extended+0x33a>
            i++;
 8015156:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8015158:	3301      	adds	r3, #1
 801515a:	637b      	str	r3, [r7, #52]	; 0x34
            thread_ptr =  thread_ptr -> tx_thread_created_next;
 801515c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801515e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8015162:	657b      	str	r3, [r7, #84]	; 0x54
        while (i < _tx_thread_created_count)
 8015164:	4b70      	ldr	r3, [pc, #448]	; (8015328 <_txm_module_manager_object_pointer_get_extended+0x280>)
 8015166:	681b      	ldr	r3, [r3, #0]
 8015168:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801516a:	429a      	cmp	r2, r3
 801516c:	d3e2      	bcc.n	8015134 <_txm_module_manager_object_pointer_get_extended+0x8c>
        break;
 801516e:	e138      	b.n	80153e2 <_txm_module_manager_object_pointer_get_extended+0x33a>
    /* Determine if a timer object is requested.  */
    case TXM_TIMER_OBJECT:
    {

        /* Loop to find the first matching timer.  */
        i = 0;
 8015170:	2300      	movs	r3, #0
 8015172:	637b      	str	r3, [r7, #52]	; 0x34
        timer_ptr =  _tx_timer_created_ptr;
 8015174:	4b6d      	ldr	r3, [pc, #436]	; (801532c <_txm_module_manager_object_pointer_get_extended+0x284>)
 8015176:	681b      	ldr	r3, [r3, #0]
 8015178:	653b      	str	r3, [r7, #80]	; 0x50
        while (i < _tx_timer_created_count)
 801517a:	e016      	b.n	80151aa <_txm_module_manager_object_pointer_get_extended+0x102>
        {

            /* Do we have a match?  */
            if (_txm_module_manager_object_name_compare(search_name, search_name_length, timer_ptr -> tx_timer_name))
 801517c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801517e:	685b      	ldr	r3, [r3, #4]
 8015180:	461a      	mov	r2, r3
 8015182:	6879      	ldr	r1, [r7, #4]
 8015184:	68b8      	ldr	r0, [r7, #8]
 8015186:	f001 faa0 	bl	80166ca <_txm_module_manager_object_name_compare>
 801518a:	4603      	mov	r3, r0
 801518c:	2b00      	cmp	r3, #0
 801518e:	d006      	beq.n	801519e <_txm_module_manager_object_pointer_get_extended+0xf6>
            {

                /* Yes, we found it - return the necessary info!  */
                *object_ptr =  (VOID *) timer_ptr;
 8015190:	683b      	ldr	r3, [r7, #0]
 8015192:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8015194:	601a      	str	r2, [r3, #0]

                /* Set the the status to success!  */
                status =  TX_SUCCESS;
 8015196:	2300      	movs	r3, #0
 8015198:	633b      	str	r3, [r7, #48]	; 0x30
                break;
 801519a:	bf00      	nop
            i++;

            /* Move to next timer.  */
            timer_ptr =  timer_ptr -> tx_timer_created_next;
        }
        break;
 801519c:	e121      	b.n	80153e2 <_txm_module_manager_object_pointer_get_extended+0x33a>
            i++;
 801519e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80151a0:	3301      	adds	r3, #1
 80151a2:	637b      	str	r3, [r7, #52]	; 0x34
            timer_ptr =  timer_ptr -> tx_timer_created_next;
 80151a4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80151a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80151a8:	653b      	str	r3, [r7, #80]	; 0x50
        while (i < _tx_timer_created_count)
 80151aa:	4b61      	ldr	r3, [pc, #388]	; (8015330 <_txm_module_manager_object_pointer_get_extended+0x288>)
 80151ac:	681b      	ldr	r3, [r3, #0]
 80151ae:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80151b0:	429a      	cmp	r2, r3
 80151b2:	d3e3      	bcc.n	801517c <_txm_module_manager_object_pointer_get_extended+0xd4>
        break;
 80151b4:	e115      	b.n	80153e2 <_txm_module_manager_object_pointer_get_extended+0x33a>
    /* Determine if a queue object is requested.  */
    case TXM_QUEUE_OBJECT:
    {

        /* Loop to find the first matching queue.  */
        i = 0;
 80151b6:	2300      	movs	r3, #0
 80151b8:	637b      	str	r3, [r7, #52]	; 0x34
        queue_ptr =  _tx_queue_created_ptr;
 80151ba:	4b5e      	ldr	r3, [pc, #376]	; (8015334 <_txm_module_manager_object_pointer_get_extended+0x28c>)
 80151bc:	681b      	ldr	r3, [r3, #0]
 80151be:	64fb      	str	r3, [r7, #76]	; 0x4c
        while (i < _tx_queue_created_count)
 80151c0:	e016      	b.n	80151f0 <_txm_module_manager_object_pointer_get_extended+0x148>
        {

            /* Do we have a match?  */
            if (_txm_module_manager_object_name_compare(search_name, search_name_length, queue_ptr -> tx_queue_name))
 80151c2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80151c4:	685b      	ldr	r3, [r3, #4]
 80151c6:	461a      	mov	r2, r3
 80151c8:	6879      	ldr	r1, [r7, #4]
 80151ca:	68b8      	ldr	r0, [r7, #8]
 80151cc:	f001 fa7d 	bl	80166ca <_txm_module_manager_object_name_compare>
 80151d0:	4603      	mov	r3, r0
 80151d2:	2b00      	cmp	r3, #0
 80151d4:	d006      	beq.n	80151e4 <_txm_module_manager_object_pointer_get_extended+0x13c>
            {

                /* Yes, we found it - return the necessary info!  */
                *object_ptr =  (VOID *) queue_ptr;
 80151d6:	683b      	ldr	r3, [r7, #0]
 80151d8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80151da:	601a      	str	r2, [r3, #0]

                /* Set the the status to success!  */
                status =  TX_SUCCESS;
 80151dc:	2300      	movs	r3, #0
 80151de:	633b      	str	r3, [r7, #48]	; 0x30
                break;
 80151e0:	bf00      	nop
            i++;

            /* Move to next queue.  */
            queue_ptr =  queue_ptr -> tx_queue_created_next;
        }
        break;
 80151e2:	e0fe      	b.n	80153e2 <_txm_module_manager_object_pointer_get_extended+0x33a>
            i++;
 80151e4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80151e6:	3301      	adds	r3, #1
 80151e8:	637b      	str	r3, [r7, #52]	; 0x34
            queue_ptr =  queue_ptr -> tx_queue_created_next;
 80151ea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80151ec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80151ee:	64fb      	str	r3, [r7, #76]	; 0x4c
        while (i < _tx_queue_created_count)
 80151f0:	4b51      	ldr	r3, [pc, #324]	; (8015338 <_txm_module_manager_object_pointer_get_extended+0x290>)
 80151f2:	681b      	ldr	r3, [r3, #0]
 80151f4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80151f6:	429a      	cmp	r2, r3
 80151f8:	d3e3      	bcc.n	80151c2 <_txm_module_manager_object_pointer_get_extended+0x11a>
        break;
 80151fa:	e0f2      	b.n	80153e2 <_txm_module_manager_object_pointer_get_extended+0x33a>
    /* Determine if a event flags object is requested.  */
    case TXM_EVENT_FLAGS_OBJECT:
    {

        /* Loop to find the first matching event flags group.  */
        i = 0;
 80151fc:	2300      	movs	r3, #0
 80151fe:	637b      	str	r3, [r7, #52]	; 0x34
        events_ptr =  _tx_event_flags_created_ptr;
 8015200:	4b4e      	ldr	r3, [pc, #312]	; (801533c <_txm_module_manager_object_pointer_get_extended+0x294>)
 8015202:	681b      	ldr	r3, [r3, #0]
 8015204:	64bb      	str	r3, [r7, #72]	; 0x48
        while (i < _tx_event_flags_created_count)
 8015206:	e016      	b.n	8015236 <_txm_module_manager_object_pointer_get_extended+0x18e>
        {

            /* Do we have a match?  */
            if (_txm_module_manager_object_name_compare(search_name, search_name_length, events_ptr -> tx_event_flags_group_name))
 8015208:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801520a:	685b      	ldr	r3, [r3, #4]
 801520c:	461a      	mov	r2, r3
 801520e:	6879      	ldr	r1, [r7, #4]
 8015210:	68b8      	ldr	r0, [r7, #8]
 8015212:	f001 fa5a 	bl	80166ca <_txm_module_manager_object_name_compare>
 8015216:	4603      	mov	r3, r0
 8015218:	2b00      	cmp	r3, #0
 801521a:	d006      	beq.n	801522a <_txm_module_manager_object_pointer_get_extended+0x182>
            {

                /* Yes, we found it - return the necessary info!  */
                *object_ptr =  (VOID *) events_ptr;
 801521c:	683b      	ldr	r3, [r7, #0]
 801521e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8015220:	601a      	str	r2, [r3, #0]

                /* Set the the status to success!  */
                status =  TX_SUCCESS;
 8015222:	2300      	movs	r3, #0
 8015224:	633b      	str	r3, [r7, #48]	; 0x30
                break;
 8015226:	bf00      	nop
            i++;

            /* Move to next event flags group.  */
            events_ptr =  events_ptr -> tx_event_flags_group_created_next;
        }
        break;
 8015228:	e0db      	b.n	80153e2 <_txm_module_manager_object_pointer_get_extended+0x33a>
            i++;
 801522a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801522c:	3301      	adds	r3, #1
 801522e:	637b      	str	r3, [r7, #52]	; 0x34
            events_ptr =  events_ptr -> tx_event_flags_group_created_next;
 8015230:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8015232:	699b      	ldr	r3, [r3, #24]
 8015234:	64bb      	str	r3, [r7, #72]	; 0x48
        while (i < _tx_event_flags_created_count)
 8015236:	4b42      	ldr	r3, [pc, #264]	; (8015340 <_txm_module_manager_object_pointer_get_extended+0x298>)
 8015238:	681b      	ldr	r3, [r3, #0]
 801523a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801523c:	429a      	cmp	r2, r3
 801523e:	d3e3      	bcc.n	8015208 <_txm_module_manager_object_pointer_get_extended+0x160>
        break;
 8015240:	e0cf      	b.n	80153e2 <_txm_module_manager_object_pointer_get_extended+0x33a>
    /* Determine if a semaphore object is requested.  */
    case TXM_SEMAPHORE_OBJECT:
    {

        /* Loop to find the first matching semaphore.  */
        i = 0;
 8015242:	2300      	movs	r3, #0
 8015244:	637b      	str	r3, [r7, #52]	; 0x34
        semaphore_ptr =  _tx_semaphore_created_ptr;
 8015246:	4b3f      	ldr	r3, [pc, #252]	; (8015344 <_txm_module_manager_object_pointer_get_extended+0x29c>)
 8015248:	681b      	ldr	r3, [r3, #0]
 801524a:	647b      	str	r3, [r7, #68]	; 0x44
        while (i < _tx_semaphore_created_count)
 801524c:	e016      	b.n	801527c <_txm_module_manager_object_pointer_get_extended+0x1d4>
        {

            /* Do we have a match?  */
            if (_txm_module_manager_object_name_compare(search_name, search_name_length, semaphore_ptr -> tx_semaphore_name))
 801524e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8015250:	685b      	ldr	r3, [r3, #4]
 8015252:	461a      	mov	r2, r3
 8015254:	6879      	ldr	r1, [r7, #4]
 8015256:	68b8      	ldr	r0, [r7, #8]
 8015258:	f001 fa37 	bl	80166ca <_txm_module_manager_object_name_compare>
 801525c:	4603      	mov	r3, r0
 801525e:	2b00      	cmp	r3, #0
 8015260:	d006      	beq.n	8015270 <_txm_module_manager_object_pointer_get_extended+0x1c8>
            {

                /* Yes, we found it - return the necessary info!  */
                *object_ptr =  (VOID *) semaphore_ptr;
 8015262:	683b      	ldr	r3, [r7, #0]
 8015264:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8015266:	601a      	str	r2, [r3, #0]

                /* Set the the status to success!  */
                status =  TX_SUCCESS;
 8015268:	2300      	movs	r3, #0
 801526a:	633b      	str	r3, [r7, #48]	; 0x30
                break;
 801526c:	bf00      	nop
            i++;

            /* Move to next semaphore.  */
            semaphore_ptr =  semaphore_ptr -> tx_semaphore_created_next;
        }
        break;
 801526e:	e0b8      	b.n	80153e2 <_txm_module_manager_object_pointer_get_extended+0x33a>
            i++;
 8015270:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8015272:	3301      	adds	r3, #1
 8015274:	637b      	str	r3, [r7, #52]	; 0x34
            semaphore_ptr =  semaphore_ptr -> tx_semaphore_created_next;
 8015276:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8015278:	695b      	ldr	r3, [r3, #20]
 801527a:	647b      	str	r3, [r7, #68]	; 0x44
        while (i < _tx_semaphore_created_count)
 801527c:	4b32      	ldr	r3, [pc, #200]	; (8015348 <_txm_module_manager_object_pointer_get_extended+0x2a0>)
 801527e:	681b      	ldr	r3, [r3, #0]
 8015280:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8015282:	429a      	cmp	r2, r3
 8015284:	d3e3      	bcc.n	801524e <_txm_module_manager_object_pointer_get_extended+0x1a6>
        break;
 8015286:	e0ac      	b.n	80153e2 <_txm_module_manager_object_pointer_get_extended+0x33a>
    /* Determine if a mutex object is requested.  */
    case TXM_MUTEX_OBJECT:
    {

        /* Loop to find the first matching mutex.  */
        i = 0;
 8015288:	2300      	movs	r3, #0
 801528a:	637b      	str	r3, [r7, #52]	; 0x34
        mutex_ptr =  _tx_mutex_created_ptr;
 801528c:	4b2f      	ldr	r3, [pc, #188]	; (801534c <_txm_module_manager_object_pointer_get_extended+0x2a4>)
 801528e:	681b      	ldr	r3, [r3, #0]
 8015290:	643b      	str	r3, [r7, #64]	; 0x40
        while (i < _tx_mutex_created_count)
 8015292:	e016      	b.n	80152c2 <_txm_module_manager_object_pointer_get_extended+0x21a>
        {

            /* Do we have a match?  */
            if (_txm_module_manager_object_name_compare(search_name, search_name_length, mutex_ptr -> tx_mutex_name))
 8015294:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015296:	685b      	ldr	r3, [r3, #4]
 8015298:	461a      	mov	r2, r3
 801529a:	6879      	ldr	r1, [r7, #4]
 801529c:	68b8      	ldr	r0, [r7, #8]
 801529e:	f001 fa14 	bl	80166ca <_txm_module_manager_object_name_compare>
 80152a2:	4603      	mov	r3, r0
 80152a4:	2b00      	cmp	r3, #0
 80152a6:	d006      	beq.n	80152b6 <_txm_module_manager_object_pointer_get_extended+0x20e>
            {

                /* Yes, we found it - return the necessary info!  */
                *object_ptr =  (VOID *) mutex_ptr;
 80152a8:	683b      	ldr	r3, [r7, #0]
 80152aa:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80152ac:	601a      	str	r2, [r3, #0]

                /* Set the the status to success!  */
                status =  TX_SUCCESS;
 80152ae:	2300      	movs	r3, #0
 80152b0:	633b      	str	r3, [r7, #48]	; 0x30
                break;
 80152b2:	bf00      	nop
            i++;

            /* Move to next mutex.  */
            mutex_ptr =  mutex_ptr -> tx_mutex_created_next;
        }
        break;
 80152b4:	e095      	b.n	80153e2 <_txm_module_manager_object_pointer_get_extended+0x33a>
            i++;
 80152b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80152b8:	3301      	adds	r3, #1
 80152ba:	637b      	str	r3, [r7, #52]	; 0x34
            mutex_ptr =  mutex_ptr -> tx_mutex_created_next;
 80152bc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80152be:	6a1b      	ldr	r3, [r3, #32]
 80152c0:	643b      	str	r3, [r7, #64]	; 0x40
        while (i < _tx_mutex_created_count)
 80152c2:	4b23      	ldr	r3, [pc, #140]	; (8015350 <_txm_module_manager_object_pointer_get_extended+0x2a8>)
 80152c4:	681b      	ldr	r3, [r3, #0]
 80152c6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80152c8:	429a      	cmp	r2, r3
 80152ca:	d3e3      	bcc.n	8015294 <_txm_module_manager_object_pointer_get_extended+0x1ec>
        break;
 80152cc:	e089      	b.n	80153e2 <_txm_module_manager_object_pointer_get_extended+0x33a>
    /* Determine if a block pool object is requested.  */
    case TXM_BLOCK_POOL_OBJECT:
    {

        /* Get the module instance.  */
        module_instance =  _tx_thread_current_ptr -> tx_thread_module_instance_ptr;
 80152ce:	4b21      	ldr	r3, [pc, #132]	; (8015354 <_txm_module_manager_object_pointer_get_extended+0x2ac>)
 80152d0:	681b      	ldr	r3, [r3, #0]
 80152d2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80152d6:	62bb      	str	r3, [r7, #40]	; 0x28

        /* Is a module making this request?  */
        if (module_instance != TX_NULL)
 80152d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80152da:	2b00      	cmp	r3, #0
 80152dc:	d008      	beq.n	80152f0 <_txm_module_manager_object_pointer_get_extended+0x248>
        {

            /* Is memory protection enabled?  */
            if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 80152de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80152e0:	68db      	ldr	r3, [r3, #12]
 80152e2:	f003 0302 	and.w	r3, r3, #2
 80152e6:	2b00      	cmp	r3, #0
 80152e8:	d002      	beq.n	80152f0 <_txm_module_manager_object_pointer_get_extended+0x248>
            {

                /* Modules with memory protection can only access block pools they created.  */
                status =  TXM_MODULE_INVALID;
 80152ea:	23f2      	movs	r3, #242	; 0xf2
 80152ec:	633b      	str	r3, [r7, #48]	; 0x30
                break;
 80152ee:	e078      	b.n	80153e2 <_txm_module_manager_object_pointer_get_extended+0x33a>
            }
        }

        /* Loop to find the first matching block pool.  */
        i = 0;
 80152f0:	2300      	movs	r3, #0
 80152f2:	637b      	str	r3, [r7, #52]	; 0x34
        block_pool_ptr =  _tx_block_pool_created_ptr;
 80152f4:	4b18      	ldr	r3, [pc, #96]	; (8015358 <_txm_module_manager_object_pointer_get_extended+0x2b0>)
 80152f6:	681b      	ldr	r3, [r3, #0]
 80152f8:	63fb      	str	r3, [r7, #60]	; 0x3c
        while (i < _tx_block_pool_created_count)
 80152fa:	e035      	b.n	8015368 <_txm_module_manager_object_pointer_get_extended+0x2c0>
        {

            /* Do we have a match?  */
            if (_txm_module_manager_object_name_compare(search_name, search_name_length, block_pool_ptr -> tx_block_pool_name))
 80152fc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80152fe:	685b      	ldr	r3, [r3, #4]
 8015300:	461a      	mov	r2, r3
 8015302:	6879      	ldr	r1, [r7, #4]
 8015304:	68b8      	ldr	r0, [r7, #8]
 8015306:	f001 f9e0 	bl	80166ca <_txm_module_manager_object_name_compare>
 801530a:	4603      	mov	r3, r0
 801530c:	2b00      	cmp	r3, #0
 801530e:	d025      	beq.n	801535c <_txm_module_manager_object_pointer_get_extended+0x2b4>
            {

                /* Yes, we found it - return the necessary info!  */
                *object_ptr =  (VOID *) block_pool_ptr;
 8015310:	683b      	ldr	r3, [r7, #0]
 8015312:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8015314:	601a      	str	r2, [r3, #0]

                /* Set the the status to success!  */
                status =  TX_SUCCESS;
 8015316:	2300      	movs	r3, #0
 8015318:	633b      	str	r3, [r7, #48]	; 0x30
                break;
 801531a:	bf00      	nop
            i++;

            /* Move to next block pool.  */
            block_pool_ptr =  block_pool_ptr -> tx_block_pool_created_next;
        }
        break;
 801531c:	e061      	b.n	80153e2 <_txm_module_manager_object_pointer_get_extended+0x33a>
 801531e:	bf00      	nop
 8015320:	2000f054 	.word	0x2000f054
 8015324:	2000efc0 	.word	0x2000efc0
 8015328:	2000efc4 	.word	0x2000efc4
 801532c:	2000f0fc 	.word	0x2000f0fc
 8015330:	2000f100 	.word	0x2000f100
 8015334:	2000ef88 	.word	0x2000ef88
 8015338:	2000ef8c 	.word	0x2000ef8c
 801533c:	2000ef90 	.word	0x2000ef90
 8015340:	2000ef94 	.word	0x2000ef94
 8015344:	2000ef80 	.word	0x2000ef80
 8015348:	2000ef84 	.word	0x2000ef84
 801534c:	2000ef98 	.word	0x2000ef98
 8015350:	2000ef9c 	.word	0x2000ef9c
 8015354:	2000efb8 	.word	0x2000efb8
 8015358:	2000efa0 	.word	0x2000efa0
            i++;
 801535c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801535e:	3301      	adds	r3, #1
 8015360:	637b      	str	r3, [r7, #52]	; 0x34
            block_pool_ptr =  block_pool_ptr -> tx_block_pool_created_next;
 8015362:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015364:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015366:	63fb      	str	r3, [r7, #60]	; 0x3c
        while (i < _tx_block_pool_created_count)
 8015368:	4b2b      	ldr	r3, [pc, #172]	; (8015418 <_txm_module_manager_object_pointer_get_extended+0x370>)
 801536a:	681b      	ldr	r3, [r3, #0]
 801536c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801536e:	429a      	cmp	r2, r3
 8015370:	d3c4      	bcc.n	80152fc <_txm_module_manager_object_pointer_get_extended+0x254>
        break;
 8015372:	e036      	b.n	80153e2 <_txm_module_manager_object_pointer_get_extended+0x33a>
    /* Determine if a byte pool object is requested.  */
    case TXM_BYTE_POOL_OBJECT:
    {

        /* Get the module instance.  */
        module_instance =  _tx_thread_current_ptr -> tx_thread_module_instance_ptr;
 8015374:	4b29      	ldr	r3, [pc, #164]	; (801541c <_txm_module_manager_object_pointer_get_extended+0x374>)
 8015376:	681b      	ldr	r3, [r3, #0]
 8015378:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 801537c:	62bb      	str	r3, [r7, #40]	; 0x28

        /* Is a module making this request?  */
        if (module_instance != TX_NULL)
 801537e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015380:	2b00      	cmp	r3, #0
 8015382:	d008      	beq.n	8015396 <_txm_module_manager_object_pointer_get_extended+0x2ee>
        {

            /* Is memory protection enabled?  */
            if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8015384:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015386:	68db      	ldr	r3, [r3, #12]
 8015388:	f003 0302 	and.w	r3, r3, #2
 801538c:	2b00      	cmp	r3, #0
 801538e:	d002      	beq.n	8015396 <_txm_module_manager_object_pointer_get_extended+0x2ee>
            {

                /* Modules with memory protection can only access block pools they created.  */
                status =  TXM_MODULE_INVALID;
 8015390:	23f2      	movs	r3, #242	; 0xf2
 8015392:	633b      	str	r3, [r7, #48]	; 0x30
                break;
 8015394:	e025      	b.n	80153e2 <_txm_module_manager_object_pointer_get_extended+0x33a>
            }
        }

        /* Loop to find the first matching byte pool.  */
        i = 0;
 8015396:	2300      	movs	r3, #0
 8015398:	637b      	str	r3, [r7, #52]	; 0x34
        byte_pool_ptr =  _tx_byte_pool_created_ptr;
 801539a:	4b21      	ldr	r3, [pc, #132]	; (8015420 <_txm_module_manager_object_pointer_get_extended+0x378>)
 801539c:	681b      	ldr	r3, [r3, #0]
 801539e:	63bb      	str	r3, [r7, #56]	; 0x38
        while (i < _tx_byte_pool_created_count)
 80153a0:	e016      	b.n	80153d0 <_txm_module_manager_object_pointer_get_extended+0x328>
        {

            /* Do we have a match?  */
            if (_txm_module_manager_object_name_compare(search_name, search_name_length, byte_pool_ptr -> tx_byte_pool_name))
 80153a2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80153a4:	685b      	ldr	r3, [r3, #4]
 80153a6:	461a      	mov	r2, r3
 80153a8:	6879      	ldr	r1, [r7, #4]
 80153aa:	68b8      	ldr	r0, [r7, #8]
 80153ac:	f001 f98d 	bl	80166ca <_txm_module_manager_object_name_compare>
 80153b0:	4603      	mov	r3, r0
 80153b2:	2b00      	cmp	r3, #0
 80153b4:	d006      	beq.n	80153c4 <_txm_module_manager_object_pointer_get_extended+0x31c>
            {

                /* Yes, we found it - return the necessary info!  */
                *object_ptr =  (VOID *) byte_pool_ptr;
 80153b6:	683b      	ldr	r3, [r7, #0]
 80153b8:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80153ba:	601a      	str	r2, [r3, #0]

                /* Set the the status to success!  */
                status =  TX_SUCCESS;
 80153bc:	2300      	movs	r3, #0
 80153be:	633b      	str	r3, [r7, #48]	; 0x30
                break;
 80153c0:	bf00      	nop
            i++;

            /* Move to next byte pool.  */
            byte_pool_ptr =  byte_pool_ptr -> tx_byte_pool_created_next;
        }
        break;
 80153c2:	e00e      	b.n	80153e2 <_txm_module_manager_object_pointer_get_extended+0x33a>
            i++;
 80153c4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80153c6:	3301      	adds	r3, #1
 80153c8:	637b      	str	r3, [r7, #52]	; 0x34
            byte_pool_ptr =  byte_pool_ptr -> tx_byte_pool_created_next;
 80153ca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80153cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80153ce:	63bb      	str	r3, [r7, #56]	; 0x38
        while (i < _tx_byte_pool_created_count)
 80153d0:	4b14      	ldr	r3, [pc, #80]	; (8015424 <_txm_module_manager_object_pointer_get_extended+0x37c>)
 80153d2:	681b      	ldr	r3, [r3, #0]
 80153d4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80153d6:	429a      	cmp	r2, r3
 80153d8:	d3e3      	bcc.n	80153a2 <_txm_module_manager_object_pointer_get_extended+0x2fa>
        break;
 80153da:	e002      	b.n	80153e2 <_txm_module_manager_object_pointer_get_extended+0x33a>
    }

    default:

        /* Invalid object ID.  */
        status =  TX_OPTION_ERROR;
 80153dc:	2308      	movs	r3, #8
 80153de:	633b      	str	r3, [r7, #48]	; 0x30
            /* Call the USBX object get function.  */
            status =  _txm_module_manager_usbx_object_pointer_get(object_type, search_name, search_name_length, object_ptr);
        }
#endif

        break;
 80153e0:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80153e2:	f3ef 8310 	mrs	r3, PRIMASK
 80153e6:	617b      	str	r3, [r7, #20]
    return(posture);
 80153e8:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 80153ea:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 80153ec:	b672      	cpsid	i
    return(int_posture);
 80153ee:	693b      	ldr	r3, [r7, #16]
    }

    /* Disable interrupts.  */
    TX_DISABLE
 80153f0:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Enable preemption again.  */
    _tx_thread_preempt_disable--;
 80153f2:	4b0d      	ldr	r3, [pc, #52]	; (8015428 <_txm_module_manager_object_pointer_get_extended+0x380>)
 80153f4:	681b      	ldr	r3, [r3, #0]
 80153f6:	3b01      	subs	r3, #1
 80153f8:	4a0b      	ldr	r2, [pc, #44]	; (8015428 <_txm_module_manager_object_pointer_get_extended+0x380>)
 80153fa:	6013      	str	r3, [r2, #0]
 80153fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80153fe:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015400:	69bb      	ldr	r3, [r7, #24]
 8015402:	f383 8810 	msr	PRIMASK, r3
}
 8015406:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 8015408:	f7f6 ffd6 	bl	800c3b8 <_tx_thread_system_preempt_check>

    /* Return success.  */
    return(status);
 801540c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
}
 801540e:	4618      	mov	r0, r3
 8015410:	3758      	adds	r7, #88	; 0x58
 8015412:	46bd      	mov	sp, r7
 8015414:	bd80      	pop	{r7, pc}
 8015416:	bf00      	nop
 8015418:	2000efa4 	.word	0x2000efa4
 801541c:	2000efb8 	.word	0x2000efb8
 8015420:	2000efa8 	.word	0x2000efa8
 8015424:	2000efac 	.word	0x2000efac
 8015428:	2000f054 	.word	0x2000f054

0801542c <_txm_module_manager_object_pool_create>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
UINT  _txm_module_manager_object_pool_create(VOID *object_memory, ULONG object_memory_size)
{
 801542c:	b580      	push	{r7, lr}
 801542e:	b082      	sub	sp, #8
 8015430:	af00      	add	r7, sp, #0
 8015432:	6078      	str	r0, [r7, #4]
 8015434:	6039      	str	r1, [r7, #0]

    /* Create a byte pool for allocating RAM areas for modules.  */
    _tx_byte_pool_create(&_txm_module_manager_object_pool, "Module Manager Object Pool", object_memory, object_memory_size);
 8015436:	683b      	ldr	r3, [r7, #0]
 8015438:	687a      	ldr	r2, [r7, #4]
 801543a:	4906      	ldr	r1, [pc, #24]	; (8015454 <_txm_module_manager_object_pool_create+0x28>)
 801543c:	4806      	ldr	r0, [pc, #24]	; (8015458 <_txm_module_manager_object_pool_create+0x2c>)
 801543e:	f7f2 fba3 	bl	8007b88 <_tx_byte_pool_create>

    /* Indicate the module manager object pool has been created.  */
    _txm_module_manager_object_pool_created =  TX_TRUE;
 8015442:	4b06      	ldr	r3, [pc, #24]	; (801545c <_txm_module_manager_object_pool_create+0x30>)
 8015444:	2201      	movs	r2, #1
 8015446:	601a      	str	r2, [r3, #0]

    /* Return success.  */
    return(TX_SUCCESS);
 8015448:	2300      	movs	r3, #0
}
 801544a:	4618      	mov	r0, r3
 801544c:	3708      	adds	r7, #8
 801544e:	46bd      	mov	sp, r7
 8015450:	bd80      	pop	{r7, pc}
 8015452:	bf00      	nop
 8015454:	08017a10 	.word	0x08017a10
 8015458:	2000f63c 	.word	0x2000f63c
 801545c:	2000f670 	.word	0x2000f670

08015460 <_txm_module_manager_port_dispatch>:
/*                                                                        */
/*  03-02-2021      Scott Larson            Initial Version 6.1.5         */
/*                                                                        */
/**************************************************************************/
ALIGN_TYPE _txm_module_manager_port_dispatch(TXM_MODULE_INSTANCE *module_instance, ULONG kernel_request, ALIGN_TYPE param_0, ALIGN_TYPE param_1, ALIGN_TYPE param_2)
{
 8015460:	b580      	push	{r7, lr}
 8015462:	b086      	sub	sp, #24
 8015464:	af00      	add	r7, sp, #0
 8015466:	60f8      	str	r0, [r7, #12]
 8015468:	60b9      	str	r1, [r7, #8]
 801546a:	607a      	str	r2, [r7, #4]
 801546c:	603b      	str	r3, [r7, #0]

ALIGN_TYPE return_value = TX_NOT_AVAILABLE;
 801546e:	231d      	movs	r3, #29
 8015470:	617b      	str	r3, [r7, #20]

    switch(kernel_request)
 8015472:	68bb      	ldr	r3, [r7, #8]
 8015474:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8015478:	d005      	beq.n	8015486 <_txm_module_manager_port_dispatch+0x26>
 801547a:	68bb      	ldr	r3, [r7, #8]
 801547c:	f240 12f5 	movw	r2, #501	; 0x1f5
 8015480:	4293      	cmp	r3, r2
 8015482:	d02c      	beq.n	80154de <_txm_module_manager_port_dispatch+0x7e>
        }
        
        default:
        {
            /* Unhandled kernel request, return an error!  */
            break;
 8015484:	e056      	b.n	8015534 <_txm_module_manager_port_dispatch+0xd4>
            if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 8015486:	68fb      	ldr	r3, [r7, #12]
 8015488:	68db      	ldr	r3, [r3, #12]
 801548a:	f003 0302 	and.w	r3, r3, #2
 801548e:	2b00      	cmp	r3, #0
 8015490:	d01e      	beq.n	80154d0 <_txm_module_manager_port_dispatch+0x70>
                if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_THREAD)))
 8015492:	22e8      	movs	r2, #232	; 0xe8
 8015494:	6879      	ldr	r1, [r7, #4]
 8015496:	68f8      	ldr	r0, [r7, #12]
 8015498:	f7ff fcd6 	bl	8014e48 <_txm_module_manager_inside_data_check>
 801549c:	4603      	mov	r3, r0
 801549e:	2b00      	cmp	r3, #0
 80154a0:	d111      	bne.n	80154c6 <_txm_module_manager_port_dispatch+0x66>
 80154a2:	687b      	ldr	r3, [r7, #4]
 80154a4:	f113 0fe9 	cmn.w	r3, #233	; 0xe9
 80154a8:	d812      	bhi.n	80154d0 <_txm_module_manager_port_dispatch+0x70>
 80154aa:	68fb      	ldr	r3, [r7, #12]
 80154ac:	699b      	ldr	r3, [r3, #24]
 80154ae:	461a      	mov	r2, r3
 80154b0:	687b      	ldr	r3, [r7, #4]
 80154b2:	4293      	cmp	r3, r2
 80154b4:	d30c      	bcc.n	80154d0 <_txm_module_manager_port_dispatch+0x70>
 80154b6:	687b      	ldr	r3, [r7, #4]
 80154b8:	f103 02e8 	add.w	r2, r3, #232	; 0xe8
 80154bc:	68fb      	ldr	r3, [r7, #12]
 80154be:	69db      	ldr	r3, [r3, #28]
 80154c0:	3301      	adds	r3, #1
 80154c2:	429a      	cmp	r2, r3
 80154c4:	d804      	bhi.n	80154d0 <_txm_module_manager_port_dispatch+0x70>
 80154c6:	687b      	ldr	r3, [r7, #4]
 80154c8:	2b00      	cmp	r3, #0
 80154ca:	d001      	beq.n	80154d0 <_txm_module_manager_port_dispatch+0x70>
                    return(TXM_MODULE_INVALID_MEMORY);
 80154cc:	23f4      	movs	r3, #244	; 0xf4
 80154ce:	e032      	b.n	8015536 <_txm_module_manager_port_dispatch+0xd6>
            return_value = (ALIGN_TYPE) _txe_thread_secure_stack_allocate(
 80154d0:	687b      	ldr	r3, [r7, #4]
 80154d2:	6839      	ldr	r1, [r7, #0]
 80154d4:	4618      	mov	r0, r3
 80154d6:	f7fa fa51 	bl	800f97c <_txe_thread_secure_stack_allocate>
 80154da:	6178      	str	r0, [r7, #20]
            break;
 80154dc:	e02a      	b.n	8015534 <_txm_module_manager_port_dispatch+0xd4>
            if (module_instance -> txm_module_instance_property_flags & TXM_MODULE_MEMORY_PROTECTION)
 80154de:	68fb      	ldr	r3, [r7, #12]
 80154e0:	68db      	ldr	r3, [r3, #12]
 80154e2:	f003 0302 	and.w	r3, r3, #2
 80154e6:	2b00      	cmp	r3, #0
 80154e8:	d01e      	beq.n	8015528 <_txm_module_manager_port_dispatch+0xc8>
                if (!TXM_MODULE_MANAGER_PARAM_CHECK_OBJECT_FOR_USE(module_instance, param_0, sizeof(TX_THREAD)))
 80154ea:	22e8      	movs	r2, #232	; 0xe8
 80154ec:	6879      	ldr	r1, [r7, #4]
 80154ee:	68f8      	ldr	r0, [r7, #12]
 80154f0:	f7ff fcaa 	bl	8014e48 <_txm_module_manager_inside_data_check>
 80154f4:	4603      	mov	r3, r0
 80154f6:	2b00      	cmp	r3, #0
 80154f8:	d111      	bne.n	801551e <_txm_module_manager_port_dispatch+0xbe>
 80154fa:	687b      	ldr	r3, [r7, #4]
 80154fc:	f113 0fe9 	cmn.w	r3, #233	; 0xe9
 8015500:	d812      	bhi.n	8015528 <_txm_module_manager_port_dispatch+0xc8>
 8015502:	68fb      	ldr	r3, [r7, #12]
 8015504:	699b      	ldr	r3, [r3, #24]
 8015506:	461a      	mov	r2, r3
 8015508:	687b      	ldr	r3, [r7, #4]
 801550a:	4293      	cmp	r3, r2
 801550c:	d30c      	bcc.n	8015528 <_txm_module_manager_port_dispatch+0xc8>
 801550e:	687b      	ldr	r3, [r7, #4]
 8015510:	f103 02e8 	add.w	r2, r3, #232	; 0xe8
 8015514:	68fb      	ldr	r3, [r7, #12]
 8015516:	69db      	ldr	r3, [r3, #28]
 8015518:	3301      	adds	r3, #1
 801551a:	429a      	cmp	r2, r3
 801551c:	d804      	bhi.n	8015528 <_txm_module_manager_port_dispatch+0xc8>
 801551e:	687b      	ldr	r3, [r7, #4]
 8015520:	2b00      	cmp	r3, #0
 8015522:	d001      	beq.n	8015528 <_txm_module_manager_port_dispatch+0xc8>
                    return(TXM_MODULE_INVALID_MEMORY);
 8015524:	23f4      	movs	r3, #244	; 0xf4
 8015526:	e006      	b.n	8015536 <_txm_module_manager_port_dispatch+0xd6>
            return_value = (ALIGN_TYPE) _txe_thread_secure_stack_free(
 8015528:	687b      	ldr	r3, [r7, #4]
 801552a:	4618      	mov	r0, r3
 801552c:	f7fa fa32 	bl	800f994 <_txe_thread_secure_stack_free>
 8015530:	6178      	str	r0, [r7, #20]
            break;
 8015532:	bf00      	nop
        }
    }
    
    return(return_value);
 8015534:	697b      	ldr	r3, [r7, #20]
}
 8015536:	4618      	mov	r0, r3
 8015538:	3718      	adds	r7, #24
 801553a:	46bd      	mov	sp, r7
 801553c:	bd80      	pop	{r7, pc}
	...

08015540 <_txm_module_manager_properties_get>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
UINT  _txm_module_manager_properties_get(TXM_MODULE_INSTANCE *module_instance, ULONG *module_properties_ptr)
{
 8015540:	b480      	push	{r7}
 8015542:	b083      	sub	sp, #12
 8015544:	af00      	add	r7, sp, #0
 8015546:	6078      	str	r0, [r7, #4]
 8015548:	6039      	str	r1, [r7, #0]

    /* Determine if the module manager has not been initialized yet.  */
    if (_txm_module_manager_ready != TX_TRUE)
 801554a:	4b11      	ldr	r3, [pc, #68]	; (8015590 <_txm_module_manager_properties_get+0x50>)
 801554c:	681b      	ldr	r3, [r3, #0]
 801554e:	2b01      	cmp	r3, #1
 8015550:	d001      	beq.n	8015556 <_txm_module_manager_properties_get+0x16>
    {

        /* Module manager has not been initialized.  */
        return(TX_NOT_AVAILABLE);
 8015552:	231d      	movs	r3, #29
 8015554:	e015      	b.n	8015582 <_txm_module_manager_properties_get+0x42>
    }

    /* Determine if the module is valid.  */
    if (module_instance == TX_NULL)
 8015556:	687b      	ldr	r3, [r7, #4]
 8015558:	2b00      	cmp	r3, #0
 801555a:	d101      	bne.n	8015560 <_txm_module_manager_properties_get+0x20>
    {

        /* Invalid module pointer.  */
        return(TX_PTR_ERROR);
 801555c:	2303      	movs	r3, #3
 801555e:	e010      	b.n	8015582 <_txm_module_manager_properties_get+0x42>
    }

    /* Check the module ID.  */
    if (module_instance -> txm_module_instance_id != TXM_MODULE_ID)
 8015560:	687b      	ldr	r3, [r7, #4]
 8015562:	681b      	ldr	r3, [r3, #0]
 8015564:	4a0b      	ldr	r2, [pc, #44]	; (8015594 <_txm_module_manager_properties_get+0x54>)
 8015566:	4293      	cmp	r3, r2
 8015568:	d001      	beq.n	801556e <_txm_module_manager_properties_get+0x2e>
    {

        /* Invalid module pointer.  */
        return(TX_PTR_ERROR);
 801556a:	2303      	movs	r3, #3
 801556c:	e009      	b.n	8015582 <_txm_module_manager_properties_get+0x42>
    }

    /* Check for non-null buffer.  */
    if (module_properties_ptr == TX_NULL)
 801556e:	683b      	ldr	r3, [r7, #0]
 8015570:	2b00      	cmp	r3, #0
 8015572:	d101      	bne.n	8015578 <_txm_module_manager_properties_get+0x38>
    {

        /* Invalid buffer pointer.  */
        return(TX_PTR_ERROR);
 8015574:	2303      	movs	r3, #3
 8015576:	e004      	b.n	8015582 <_txm_module_manager_properties_get+0x42>
    }

    /* Simply return the property bitmap.  */
    *module_properties_ptr =  module_instance -> txm_module_instance_property_flags;
 8015578:	687b      	ldr	r3, [r7, #4]
 801557a:	68da      	ldr	r2, [r3, #12]
 801557c:	683b      	ldr	r3, [r7, #0]
 801557e:	601a      	str	r2, [r3, #0]

    /* Return success.  */
    return(TX_SUCCESS);
 8015580:	2300      	movs	r3, #0
}
 8015582:	4618      	mov	r0, r3
 8015584:	370c      	adds	r7, #12
 8015586:	46bd      	mov	sp, r7
 8015588:	f85d 7b04 	ldr.w	r7, [sp], #4
 801558c:	4770      	bx	lr
 801558e:	bf00      	nop
 8015590:	2000f6b0 	.word	0x2000f6b0
 8015594:	4d4f4455 	.word	0x4d4f4455

08015598 <_txm_module_manager_queue_notify_trampoline>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
VOID  _txm_module_manager_queue_notify_trampoline(TX_QUEUE *queue_ptr)
{
 8015598:	b580      	push	{r7, lr}
 801559a:	b096      	sub	sp, #88	; 0x58
 801559c:	af00      	add	r7, sp, #0
 801559e:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80155a0:	f3ef 8310 	mrs	r3, PRIMASK
 80155a4:	64bb      	str	r3, [r7, #72]	; 0x48
    return(posture);
 80155a6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    int_posture = __get_interrupt_posture();
 80155a8:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("CPSID i" : : : "memory");
 80155aa:	b672      	cpsid	i
    return(int_posture);
 80155ac:	6c7b      	ldr	r3, [r7, #68]	; 0x44


    /* We now know the callback is for a module.  */

    /* Disable interrupts.  */
    TX_DISABLE
 80155ae:	657b      	str	r3, [r7, #84]	; 0x54

    /* Pickup the module instance pointer.  */
    module_instance =  (TXM_MODULE_INSTANCE *) queue_ptr -> tx_queue_module_instance;
 80155b0:	687b      	ldr	r3, [r7, #4]
 80155b2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80155b4:	653b      	str	r3, [r7, #80]	; 0x50

    /* Determine if this module is still valid.  */
    if ((module_instance) && (module_instance -> txm_module_instance_id == TXM_MODULE_ID) &&
 80155b6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80155b8:	2b00      	cmp	r3, #0
 80155ba:	d034      	beq.n	8015626 <_txm_module_manager_queue_notify_trampoline+0x8e>
 80155bc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80155be:	681b      	ldr	r3, [r3, #0]
 80155c0:	4a20      	ldr	r2, [pc, #128]	; (8015644 <_txm_module_manager_queue_notify_trampoline+0xac>)
 80155c2:	4293      	cmp	r3, r2
 80155c4:	d12f      	bne.n	8015626 <_txm_module_manager_queue_notify_trampoline+0x8e>
        (module_instance -> txm_module_instance_state == TXM_MODULE_STARTED))
 80155c6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80155c8:	689b      	ldr	r3, [r3, #8]
    if ((module_instance) && (module_instance -> txm_module_instance_id == TXM_MODULE_ID) &&
 80155ca:	2b02      	cmp	r3, #2
 80155cc:	d12b      	bne.n	8015626 <_txm_module_manager_queue_notify_trampoline+0x8e>
    {

        /* Yes, the module is still valid.  */

        /* Pickup the module's callback message queue.  */
        module_callback_queue =  &(module_instance -> txm_module_instance_callback_request_queue);
 80155ce:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80155d0:	f503 7328 	add.w	r3, r3, #672	; 0x2a0
 80155d4:	64fb      	str	r3, [r7, #76]	; 0x4c

        /* Build the queue notification message.  */
        callback_message.txm_module_callback_message_type =                  TXM_QUEUE_SEND_CALLBACK;
 80155d6:	2302      	movs	r3, #2
 80155d8:	60bb      	str	r3, [r7, #8]
        callback_message.txm_module_callback_message_activation_count =      1;
 80155da:	2301      	movs	r3, #1
 80155dc:	60fb      	str	r3, [r7, #12]
        callback_message.txm_module_callback_message_application_function =  (VOID (*)(VOID)) queue_ptr -> tx_queue_send_module_notify;
 80155de:	687b      	ldr	r3, [r7, #4]
 80155e0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80155e2:	613b      	str	r3, [r7, #16]
        callback_message.txm_module_callback_message_param_1 =               (ALIGN_TYPE) queue_ptr;
 80155e4:	687b      	ldr	r3, [r7, #4]
 80155e6:	617b      	str	r3, [r7, #20]
        callback_message.txm_module_callback_message_param_2 =               0;
 80155e8:	2300      	movs	r3, #0
 80155ea:	61bb      	str	r3, [r7, #24]
        callback_message.txm_module_callback_message_param_3 =               0;
 80155ec:	2300      	movs	r3, #0
 80155ee:	61fb      	str	r3, [r7, #28]
        callback_message.txm_module_callback_message_param_4 =               0;
 80155f0:	2300      	movs	r3, #0
 80155f2:	623b      	str	r3, [r7, #32]
        callback_message.txm_module_callback_message_param_5 =               0;
 80155f4:	2300      	movs	r3, #0
 80155f6:	627b      	str	r3, [r7, #36]	; 0x24
        callback_message.txm_module_callback_message_param_6 =               0;
 80155f8:	2300      	movs	r3, #0
 80155fa:	62bb      	str	r3, [r7, #40]	; 0x28
        callback_message.txm_module_callback_message_param_7 =               0;
 80155fc:	2300      	movs	r3, #0
 80155fe:	62fb      	str	r3, [r7, #44]	; 0x2c
        callback_message.txm_module_callback_message_param_8 =               0;
 8015600:	2300      	movs	r3, #0
 8015602:	633b      	str	r3, [r7, #48]	; 0x30
        callback_message.txm_module_callback_message_reserved1 =             0;
 8015604:	2300      	movs	r3, #0
 8015606:	637b      	str	r3, [r7, #52]	; 0x34
        callback_message.txm_module_callback_message_reserved2 =             0;
 8015608:	2300      	movs	r3, #0
 801560a:	63bb      	str	r3, [r7, #56]	; 0x38
 801560c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801560e:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015610:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015612:	f383 8810 	msr	PRIMASK, r3
}
 8015616:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE

        /* Call the general processing that will place the callback on the
           module's callback request queue.  */
        _txm_module_manager_callback_request(module_callback_queue, &callback_message);
 8015618:	f107 0308 	add.w	r3, r7, #8
 801561c:	4619      	mov	r1, r3
 801561e:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8015620:	f7fa f9f2 	bl	800fa08 <_txm_module_manager_callback_request>
 8015624:	e00a      	b.n	801563c <_txm_module_manager_queue_notify_trampoline+0xa4>
    {

        /* Module no longer valid.  */

        /* Error, increment the error counter and return.  */
        _txm_module_manager_callback_error_count++;
 8015626:	4b08      	ldr	r3, [pc, #32]	; (8015648 <_txm_module_manager_queue_notify_trampoline+0xb0>)
 8015628:	681b      	ldr	r3, [r3, #0]
 801562a:	3301      	adds	r3, #1
 801562c:	4a06      	ldr	r2, [pc, #24]	; (8015648 <_txm_module_manager_queue_notify_trampoline+0xb0>)
 801562e:	6013      	str	r3, [r2, #0]
 8015630:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8015632:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015634:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015636:	f383 8810 	msr	PRIMASK, r3
}
 801563a:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
    }
}
 801563c:	bf00      	nop
 801563e:	3758      	adds	r7, #88	; 0x58
 8015640:	46bd      	mov	sp, r7
 8015642:	bd80      	pop	{r7, pc}
 8015644:	4d4f4455 	.word	0x4d4f4455
 8015648:	2000f6b8 	.word	0x2000f6b8

0801564c <_txm_module_manager_semaphore_notify_trampoline>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
VOID  _txm_module_manager_semaphore_notify_trampoline(TX_SEMAPHORE *semaphore_ptr)
{
 801564c:	b580      	push	{r7, lr}
 801564e:	b096      	sub	sp, #88	; 0x58
 8015650:	af00      	add	r7, sp, #0
 8015652:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8015654:	f3ef 8310 	mrs	r3, PRIMASK
 8015658:	64bb      	str	r3, [r7, #72]	; 0x48
    return(posture);
 801565a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    int_posture = __get_interrupt_posture();
 801565c:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("CPSID i" : : : "memory");
 801565e:	b672      	cpsid	i
    return(int_posture);
 8015660:	6c7b      	ldr	r3, [r7, #68]	; 0x44


    /* We now know the callback is for a module.  */

    /* Disable interrupts.  */
    TX_DISABLE
 8015662:	657b      	str	r3, [r7, #84]	; 0x54

    /* Pickup the module instance pointer.  */
    module_instance =  (TXM_MODULE_INSTANCE *) semaphore_ptr -> tx_semaphore_module_instance;
 8015664:	687b      	ldr	r3, [r7, #4]
 8015666:	6a1b      	ldr	r3, [r3, #32]
 8015668:	653b      	str	r3, [r7, #80]	; 0x50

    /* Determine if this module is still valid.  */
    if ((module_instance) && (module_instance -> txm_module_instance_id == TXM_MODULE_ID) &&
 801566a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801566c:	2b00      	cmp	r3, #0
 801566e:	d034      	beq.n	80156da <_txm_module_manager_semaphore_notify_trampoline+0x8e>
 8015670:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015672:	681b      	ldr	r3, [r3, #0]
 8015674:	4a20      	ldr	r2, [pc, #128]	; (80156f8 <_txm_module_manager_semaphore_notify_trampoline+0xac>)
 8015676:	4293      	cmp	r3, r2
 8015678:	d12f      	bne.n	80156da <_txm_module_manager_semaphore_notify_trampoline+0x8e>
        (module_instance -> txm_module_instance_state == TXM_MODULE_STARTED))
 801567a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801567c:	689b      	ldr	r3, [r3, #8]
    if ((module_instance) && (module_instance -> txm_module_instance_id == TXM_MODULE_ID) &&
 801567e:	2b02      	cmp	r3, #2
 8015680:	d12b      	bne.n	80156da <_txm_module_manager_semaphore_notify_trampoline+0x8e>
    {

        /* Yes, the module is still valid.  */

        /* Pickup the module's callback message queue.  */
        module_callback_queue =  &(module_instance -> txm_module_instance_callback_request_queue);
 8015682:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015684:	f503 7328 	add.w	r3, r3, #672	; 0x2a0
 8015688:	64fb      	str	r3, [r7, #76]	; 0x4c

        /* Build the queue notification message.  */
        callback_message.txm_module_callback_message_type =                  TXM_SEMAPHORE_PUT_CALLBACK;
 801568a:	2303      	movs	r3, #3
 801568c:	60bb      	str	r3, [r7, #8]
        callback_message.txm_module_callback_message_activation_count =      1;
 801568e:	2301      	movs	r3, #1
 8015690:	60fb      	str	r3, [r7, #12]
        callback_message.txm_module_callback_message_application_function =  (VOID (*)(VOID)) semaphore_ptr -> tx_semaphore_put_module_notify;
 8015692:	687b      	ldr	r3, [r7, #4]
 8015694:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8015696:	613b      	str	r3, [r7, #16]
        callback_message.txm_module_callback_message_param_1 =               (ALIGN_TYPE) semaphore_ptr;
 8015698:	687b      	ldr	r3, [r7, #4]
 801569a:	617b      	str	r3, [r7, #20]
        callback_message.txm_module_callback_message_param_2 =               0;
 801569c:	2300      	movs	r3, #0
 801569e:	61bb      	str	r3, [r7, #24]
        callback_message.txm_module_callback_message_param_3 =               0;
 80156a0:	2300      	movs	r3, #0
 80156a2:	61fb      	str	r3, [r7, #28]
        callback_message.txm_module_callback_message_param_4 =               0;
 80156a4:	2300      	movs	r3, #0
 80156a6:	623b      	str	r3, [r7, #32]
        callback_message.txm_module_callback_message_param_5 =               0;
 80156a8:	2300      	movs	r3, #0
 80156aa:	627b      	str	r3, [r7, #36]	; 0x24
        callback_message.txm_module_callback_message_param_6 =               0;
 80156ac:	2300      	movs	r3, #0
 80156ae:	62bb      	str	r3, [r7, #40]	; 0x28
        callback_message.txm_module_callback_message_param_7 =               0;
 80156b0:	2300      	movs	r3, #0
 80156b2:	62fb      	str	r3, [r7, #44]	; 0x2c
        callback_message.txm_module_callback_message_param_8 =               0;
 80156b4:	2300      	movs	r3, #0
 80156b6:	633b      	str	r3, [r7, #48]	; 0x30
        callback_message.txm_module_callback_message_reserved1 =             0;
 80156b8:	2300      	movs	r3, #0
 80156ba:	637b      	str	r3, [r7, #52]	; 0x34
        callback_message.txm_module_callback_message_reserved2 =             0;
 80156bc:	2300      	movs	r3, #0
 80156be:	63bb      	str	r3, [r7, #56]	; 0x38
 80156c0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80156c2:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80156c4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80156c6:	f383 8810 	msr	PRIMASK, r3
}
 80156ca:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE

        /* Call the general processing that will place the callback on the
           module's callback request queue.  */
        _txm_module_manager_callback_request(module_callback_queue, &callback_message);
 80156cc:	f107 0308 	add.w	r3, r7, #8
 80156d0:	4619      	mov	r1, r3
 80156d2:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 80156d4:	f7fa f998 	bl	800fa08 <_txm_module_manager_callback_request>
 80156d8:	e00a      	b.n	80156f0 <_txm_module_manager_semaphore_notify_trampoline+0xa4>
    {

        /* Module no longer valid.  */

        /* Error, increment the error counter and return.  */
        _txm_module_manager_callback_error_count++;
 80156da:	4b08      	ldr	r3, [pc, #32]	; (80156fc <_txm_module_manager_semaphore_notify_trampoline+0xb0>)
 80156dc:	681b      	ldr	r3, [r3, #0]
 80156de:	3301      	adds	r3, #1
 80156e0:	4a06      	ldr	r2, [pc, #24]	; (80156fc <_txm_module_manager_semaphore_notify_trampoline+0xb0>)
 80156e2:	6013      	str	r3, [r2, #0]
 80156e4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80156e6:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80156e8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80156ea:	f383 8810 	msr	PRIMASK, r3
}
 80156ee:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
    }
}
 80156f0:	bf00      	nop
 80156f2:	3758      	adds	r7, #88	; 0x58
 80156f4:	46bd      	mov	sp, r7
 80156f6:	bd80      	pop	{r7, pc}
 80156f8:	4d4f4455 	.word	0x4d4f4455
 80156fc:	2000f6b8 	.word	0x2000f6b8

08015700 <_txm_module_manager_start>:
/*  12-31-2020      Scott Larson            Modified comment(s),          */
/*                                            resulting in version 6.1.3  */
/*                                                                        */
/**************************************************************************/
UINT  _txm_module_manager_start(TXM_MODULE_INSTANCE *module_instance)
{
 8015700:	b5f0      	push	{r4, r5, r6, r7, lr}
 8015702:	b091      	sub	sp, #68	; 0x44
 8015704:	af0a      	add	r7, sp, #40	; 0x28
 8015706:	60f8      	str	r0, [r7, #12]

UINT    status;


    /* Determine if the module manager has not been initialized yet.  */
    if (_txm_module_manager_ready != TX_TRUE)
 8015708:	4b6e      	ldr	r3, [pc, #440]	; (80158c4 <_txm_module_manager_start+0x1c4>)
 801570a:	681b      	ldr	r3, [r3, #0]
 801570c:	2b01      	cmp	r3, #1
 801570e:	d001      	beq.n	8015714 <_txm_module_manager_start+0x14>
    {

        /* Module manager has not been initialized.  */
        return(TX_NOT_AVAILABLE);
 8015710:	231d      	movs	r3, #29
 8015712:	e0d3      	b.n	80158bc <_txm_module_manager_start+0x1bc>
    }

    /* Determine if the module is valid.  */
    if (module_instance == TX_NULL)
 8015714:	68fb      	ldr	r3, [r7, #12]
 8015716:	2b00      	cmp	r3, #0
 8015718:	d101      	bne.n	801571e <_txm_module_manager_start+0x1e>
    {

        /* Invalid module pointer.  */
        return(TX_PTR_ERROR);
 801571a:	2303      	movs	r3, #3
 801571c:	e0ce      	b.n	80158bc <_txm_module_manager_start+0x1bc>
    }

    /* Get module manager protection mutex.  */
    _tx_mutex_get(&_txm_module_manager_mutex, TX_WAIT_FOREVER);
 801571e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8015722:	4869      	ldr	r0, [pc, #420]	; (80158c8 <_txm_module_manager_start+0x1c8>)
 8015724:	f7f3 fe60 	bl	80093e8 <_tx_mutex_get>

    /* Determine if the module instance is valid.  */
    if (module_instance -> txm_module_instance_id != TXM_MODULE_ID)
 8015728:	68fb      	ldr	r3, [r7, #12]
 801572a:	681b      	ldr	r3, [r3, #0]
 801572c:	4a67      	ldr	r2, [pc, #412]	; (80158cc <_txm_module_manager_start+0x1cc>)
 801572e:	4293      	cmp	r3, r2
 8015730:	d004      	beq.n	801573c <_txm_module_manager_start+0x3c>
    {

        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 8015732:	4865      	ldr	r0, [pc, #404]	; (80158c8 <_txm_module_manager_start+0x1c8>)
 8015734:	f7f4 f992 	bl	8009a5c <_tx_mutex_put>

        /* Invalid module pointer.  */
        return(TX_PTR_ERROR);
 8015738:	2303      	movs	r3, #3
 801573a:	e0bf      	b.n	80158bc <_txm_module_manager_start+0x1bc>
    }

    /* Determine if the module instance is in the loaded state.  */
    if ((module_instance -> txm_module_instance_state != TXM_MODULE_LOADED) && (module_instance -> txm_module_instance_state != TXM_MODULE_STOPPED))
 801573c:	68fb      	ldr	r3, [r7, #12]
 801573e:	689b      	ldr	r3, [r3, #8]
 8015740:	2b01      	cmp	r3, #1
 8015742:	d008      	beq.n	8015756 <_txm_module_manager_start+0x56>
 8015744:	68fb      	ldr	r3, [r7, #12]
 8015746:	689b      	ldr	r3, [r3, #8]
 8015748:	2b04      	cmp	r3, #4
 801574a:	d004      	beq.n	8015756 <_txm_module_manager_start+0x56>
    {

        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 801574c:	485e      	ldr	r0, [pc, #376]	; (80158c8 <_txm_module_manager_start+0x1c8>)
 801574e:	f7f4 f985 	bl	8009a5c <_tx_mutex_put>

        /* Return error if the module is not ready.  */
        return(TX_START_ERROR);
 8015752:	2310      	movs	r3, #16
 8015754:	e0b2      	b.n	80158bc <_txm_module_manager_start+0x1bc>
    }

    /* Check the priorities of the start/stop and callback request threads. */
    if (module_instance -> txm_module_instance_start_stop_priority < module_instance -> txm_module_instance_maximum_priority ||
 8015756:	68fb      	ldr	r3, [r7, #12]
 8015758:	f8d3 2488 	ldr.w	r2, [r3, #1160]	; 0x488
 801575c:	68fb      	ldr	r3, [r7, #12]
 801575e:	f8d3 3498 	ldr.w	r3, [r3, #1176]	; 0x498
 8015762:	429a      	cmp	r2, r3
 8015764:	d307      	bcc.n	8015776 <_txm_module_manager_start+0x76>
        module_instance -> txm_module_instance_callback_priority < module_instance -> txm_module_instance_maximum_priority)
 8015766:	68fb      	ldr	r3, [r7, #12]
 8015768:	f8d3 2490 	ldr.w	r2, [r3, #1168]	; 0x490
 801576c:	68fb      	ldr	r3, [r7, #12]
 801576e:	f8d3 3498 	ldr.w	r3, [r3, #1176]	; 0x498
    if (module_instance -> txm_module_instance_start_stop_priority < module_instance -> txm_module_instance_maximum_priority ||
 8015772:	429a      	cmp	r2, r3
 8015774:	d204      	bcs.n	8015780 <_txm_module_manager_start+0x80>
    {

        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 8015776:	4854      	ldr	r0, [pc, #336]	; (80158c8 <_txm_module_manager_start+0x1c8>)
 8015778:	f7f4 f970 	bl	8009a5c <_tx_mutex_put>

        /* At least one thread has an invalid priority.  */
        return(TX_PRIORITY_ERROR);
 801577c:	230f      	movs	r3, #15
 801577e:	e09d      	b.n	80158bc <_txm_module_manager_start+0x1bc>
    }

    /* Create the module's callback request queue.  */
    status = _tx_queue_create(&(module_instance -> txm_module_instance_callback_request_queue), "Module Callback Request Queue", (sizeof(TXM_MODULE_CALLBACK_MESSAGE)/sizeof(ULONG)),
 8015780:	68fb      	ldr	r3, [r7, #12]
 8015782:	f503 7028 	add.w	r0, r3, #672	; 0x2a0
                              module_instance -> txm_module_instance_callback_request_queue_area, sizeof(module_instance -> txm_module_instance_callback_request_queue_area));
 8015786:	68fb      	ldr	r3, [r7, #12]
 8015788:	f503 7339 	add.w	r3, r3, #740	; 0x2e4
    status = _tx_queue_create(&(module_instance -> txm_module_instance_callback_request_queue), "Module Callback Request Queue", (sizeof(TXM_MODULE_CALLBACK_MESSAGE)/sizeof(ULONG)),
 801578c:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 8015790:	9200      	str	r2, [sp, #0]
 8015792:	220d      	movs	r2, #13
 8015794:	494e      	ldr	r1, [pc, #312]	; (80158d0 <_txm_module_manager_start+0x1d0>)
 8015796:	f7f4 fc0b 	bl	8009fb0 <_tx_queue_create>
 801579a:	6178      	str	r0, [r7, #20]

    /* Determine if there was an error.  */
    if (status)
 801579c:	697b      	ldr	r3, [r7, #20]
 801579e:	2b00      	cmp	r3, #0
 80157a0:	d004      	beq.n	80157ac <_txm_module_manager_start+0xac>
    {

        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 80157a2:	4849      	ldr	r0, [pc, #292]	; (80158c8 <_txm_module_manager_start+0x1c8>)
 80157a4:	f7f4 f95a 	bl	8009a5c <_tx_mutex_put>

        /* Return error if the module is not ready.  */
        return(TX_START_ERROR);
 80157a8:	2310      	movs	r3, #16
 80157aa:	e087      	b.n	80158bc <_txm_module_manager_start+0x1bc>
    }

    /* Create the module start thread.  */
    status =  _txm_module_manager_thread_create(&(module_instance -> txm_module_instance_start_stop_thread),
 80157ac:	68fb      	ldr	r3, [r7, #12]
 80157ae:	f103 06d0 	add.w	r6, r3, #208	; 0xd0
                                                "Module Start Thread",
                                                module_instance -> txm_module_instance_shell_entry_function,
 80157b2:	68fb      	ldr	r3, [r7, #12]
 80157b4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80157b6:	60bb      	str	r3, [r7, #8]
    status =  _txm_module_manager_thread_create(&(module_instance -> txm_module_instance_start_stop_thread),
 80157b8:	68fb      	ldr	r3, [r7, #12]
 80157ba:	6d99      	ldr	r1, [r3, #88]	; 0x58
 80157bc:	6079      	str	r1, [r7, #4]
 80157be:	68fb      	ldr	r3, [r7, #12]
 80157c0:	f8d3 3494 	ldr.w	r3, [r3, #1172]	; 0x494
 80157c4:	68fa      	ldr	r2, [r7, #12]
 80157c6:	6c12      	ldr	r2, [r2, #64]	; 0x40
 80157c8:	68f9      	ldr	r1, [r7, #12]
 80157ca:	f8d1 1484 	ldr.w	r1, [r1, #1156]	; 0x484
                                                module_instance -> txm_module_instance_start_thread_entry,
                                                module_instance -> txm_module_instance_application_module_id,
                                                module_instance -> txm_module_instance_start_stop_stack_start_address,
                                                module_instance -> txm_module_instance_start_stop_stack_size,
                                                (UINT) module_instance -> txm_module_instance_start_stop_priority,
 80157ce:	68f8      	ldr	r0, [r7, #12]
 80157d0:	f8d0 0488 	ldr.w	r0, [r0, #1160]	; 0x488
                                                (UINT) module_instance -> txm_module_instance_start_stop_priority,
 80157d4:	68fc      	ldr	r4, [r7, #12]
 80157d6:	f8d4 4488 	ldr.w	r4, [r4, #1160]	; 0x488
    status =  _txm_module_manager_thread_create(&(module_instance -> txm_module_instance_start_stop_thread),
 80157da:	68fd      	ldr	r5, [r7, #12]
 80157dc:	9508      	str	r5, [sp, #32]
 80157de:	25e8      	movs	r5, #232	; 0xe8
 80157e0:	9507      	str	r5, [sp, #28]
 80157e2:	2500      	movs	r5, #0
 80157e4:	9506      	str	r5, [sp, #24]
 80157e6:	2504      	movs	r5, #4
 80157e8:	9505      	str	r5, [sp, #20]
 80157ea:	9404      	str	r4, [sp, #16]
 80157ec:	9003      	str	r0, [sp, #12]
 80157ee:	9102      	str	r1, [sp, #8]
 80157f0:	9201      	str	r2, [sp, #4]
 80157f2:	9300      	str	r3, [sp, #0]
 80157f4:	687b      	ldr	r3, [r7, #4]
 80157f6:	68ba      	ldr	r2, [r7, #8]
 80157f8:	4936      	ldr	r1, [pc, #216]	; (80158d4 <_txm_module_manager_start+0x1d4>)
 80157fa:	4630      	mov	r0, r6
 80157fc:	f000 fad0 	bl	8015da0 <_txm_module_manager_thread_create>
 8015800:	6178      	str	r0, [r7, #20]
                                                TX_DONT_START,
                                                sizeof(TX_THREAD),
                                                module_instance);

    /* Determine if the thread create was successful.  */
    if (status != TX_SUCCESS)
 8015802:	697b      	ldr	r3, [r7, #20]
 8015804:	2b00      	cmp	r3, #0
 8015806:	d00a      	beq.n	801581e <_txm_module_manager_start+0x11e>
    {

        /* Delete the callback notification queue.  */
        _tx_queue_delete(&(module_instance -> txm_module_instance_callback_request_queue));
 8015808:	68fb      	ldr	r3, [r7, #12]
 801580a:	f503 7328 	add.w	r3, r3, #672	; 0x2a0
 801580e:	4618      	mov	r0, r3
 8015810:	f7f4 fc42 	bl	800a098 <_tx_queue_delete>

        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 8015814:	482c      	ldr	r0, [pc, #176]	; (80158c8 <_txm_module_manager_start+0x1c8>)
 8015816:	f7f4 f921 	bl	8009a5c <_tx_mutex_put>

        /* Return the error status.  */
        return(status);
 801581a:	697b      	ldr	r3, [r7, #20]
 801581c:	e04e      	b.n	80158bc <_txm_module_manager_start+0x1bc>
    }

    /* Create the module callback thread.  */
    status =  _txm_module_manager_thread_create(&(module_instance -> txm_module_instance_callback_request_thread),
 801581e:	68fb      	ldr	r3, [r7, #12]
 8015820:	f503 76dc 	add.w	r6, r3, #440	; 0x1b8
                                                "Module Callback Request Thread",
                                                module_instance -> txm_module_instance_shell_entry_function,
 8015824:	68fb      	ldr	r3, [r7, #12]
 8015826:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8015828:	60bb      	str	r3, [r7, #8]
    status =  _txm_module_manager_thread_create(&(module_instance -> txm_module_instance_callback_request_thread),
 801582a:	68fb      	ldr	r3, [r7, #12]
 801582c:	6e19      	ldr	r1, [r3, #96]	; 0x60
 801582e:	6079      	str	r1, [r7, #4]
 8015830:	68fb      	ldr	r3, [r7, #12]
 8015832:	f8d3 3494 	ldr.w	r3, [r3, #1172]	; 0x494
 8015836:	68fa      	ldr	r2, [r7, #12]
 8015838:	6c92      	ldr	r2, [r2, #72]	; 0x48
 801583a:	68f9      	ldr	r1, [r7, #12]
 801583c:	f8d1 148c 	ldr.w	r1, [r1, #1164]	; 0x48c
                                                module_instance -> txm_module_instance_callback_request_thread_entry,
                                                module_instance -> txm_module_instance_application_module_id,
                                                module_instance -> txm_module_instance_callback_stack_start_address,
                                                module_instance -> txm_module_instance_callback_stack_size,
                                                (UINT) module_instance -> txm_module_instance_callback_priority,
 8015840:	68f8      	ldr	r0, [r7, #12]
 8015842:	f8d0 0490 	ldr.w	r0, [r0, #1168]	; 0x490
                                                (UINT) module_instance -> txm_module_instance_callback_priority,
 8015846:	68fc      	ldr	r4, [r7, #12]
 8015848:	f8d4 4490 	ldr.w	r4, [r4, #1168]	; 0x490
    status =  _txm_module_manager_thread_create(&(module_instance -> txm_module_instance_callback_request_thread),
 801584c:	68fd      	ldr	r5, [r7, #12]
 801584e:	9508      	str	r5, [sp, #32]
 8015850:	25e8      	movs	r5, #232	; 0xe8
 8015852:	9507      	str	r5, [sp, #28]
 8015854:	2500      	movs	r5, #0
 8015856:	9506      	str	r5, [sp, #24]
 8015858:	2500      	movs	r5, #0
 801585a:	9505      	str	r5, [sp, #20]
 801585c:	9404      	str	r4, [sp, #16]
 801585e:	9003      	str	r0, [sp, #12]
 8015860:	9102      	str	r1, [sp, #8]
 8015862:	9201      	str	r2, [sp, #4]
 8015864:	9300      	str	r3, [sp, #0]
 8015866:	687b      	ldr	r3, [r7, #4]
 8015868:	68ba      	ldr	r2, [r7, #8]
 801586a:	491b      	ldr	r1, [pc, #108]	; (80158d8 <_txm_module_manager_start+0x1d8>)
 801586c:	4630      	mov	r0, r6
 801586e:	f000 fa97 	bl	8015da0 <_txm_module_manager_thread_create>
 8015872:	6178      	str	r0, [r7, #20]
                                                TX_DONT_START,
                                                sizeof(TX_THREAD),
                                                module_instance);

    /* Determine if the thread create was successful.  */
    if (status != TX_SUCCESS)
 8015874:	697b      	ldr	r3, [r7, #20]
 8015876:	2b00      	cmp	r3, #0
 8015878:	d014      	beq.n	80158a4 <_txm_module_manager_start+0x1a4>
    {

        /* Terminate the start thread.  */
        _tx_thread_terminate(&(module_instance -> txm_module_instance_start_stop_thread));
 801587a:	68fb      	ldr	r3, [r7, #12]
 801587c:	33d0      	adds	r3, #208	; 0xd0
 801587e:	4618      	mov	r0, r3
 8015880:	f7f7 f878 	bl	800c974 <_tx_thread_terminate>

        /* Delete the start thread.  */
        _tx_thread_delete(&(module_instance -> txm_module_instance_start_stop_thread));
 8015884:	68fb      	ldr	r3, [r7, #12]
 8015886:	33d0      	adds	r3, #208	; 0xd0
 8015888:	4618      	mov	r0, r3
 801588a:	f7f6 f847 	bl	800b91c <_tx_thread_delete>

        /* Delete the callback notification queue.  */
        _tx_queue_delete(&(module_instance -> txm_module_instance_callback_request_queue));
 801588e:	68fb      	ldr	r3, [r7, #12]
 8015890:	f503 7328 	add.w	r3, r3, #672	; 0x2a0
 8015894:	4618      	mov	r0, r3
 8015896:	f7f4 fbff 	bl	800a098 <_tx_queue_delete>

        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 801589a:	480b      	ldr	r0, [pc, #44]	; (80158c8 <_txm_module_manager_start+0x1c8>)
 801589c:	f7f4 f8de 	bl	8009a5c <_tx_mutex_put>

        /* Return the error status.  */
        return(status);
 80158a0:	697b      	ldr	r3, [r7, #20]
 80158a2:	e00b      	b.n	80158bc <_txm_module_manager_start+0x1bc>
    }


    /* Set the module state to started.  */
    module_instance -> txm_module_instance_state =  TXM_MODULE_STARTED;
 80158a4:	68fb      	ldr	r3, [r7, #12]
 80158a6:	2202      	movs	r2, #2
 80158a8:	609a      	str	r2, [r3, #8]

    /* Release the protection mutex.  */
    _tx_mutex_put(&_txm_module_manager_mutex);
 80158aa:	4807      	ldr	r0, [pc, #28]	; (80158c8 <_txm_module_manager_start+0x1c8>)
 80158ac:	f7f4 f8d6 	bl	8009a5c <_tx_mutex_put>

    /* Resume the module's start thread.  */
    _tx_thread_resume(&(module_instance -> txm_module_instance_start_stop_thread));
 80158b0:	68fb      	ldr	r3, [r7, #12]
 80158b2:	33d0      	adds	r3, #208	; 0xd0
 80158b4:	4618      	mov	r0, r3
 80158b6:	f7f6 fbbf 	bl	800c038 <_tx_thread_resume>

    /* Return success.  */
    return(TX_SUCCESS);
 80158ba:	2300      	movs	r3, #0
}
 80158bc:	4618      	mov	r0, r3
 80158be:	371c      	adds	r7, #28
 80158c0:	46bd      	mov	sp, r7
 80158c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80158c4:	2000f6b0 	.word	0x2000f6b0
 80158c8:	2000f674 	.word	0x2000f674
 80158cc:	4d4f4455 	.word	0x4d4f4455
 80158d0:	08017a2c 	.word	0x08017a2c
 80158d4:	08017a4c 	.word	0x08017a4c
 80158d8:	08017a60 	.word	0x08017a60

080158dc <_txm_module_manager_stop>:
/*                                            object delete underflow,    */
/*                                            resulting in version 6.1.5  */
/*                                                                        */
/**************************************************************************/
UINT  _txm_module_manager_stop(TXM_MODULE_INSTANCE *module_instance)
{
 80158dc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80158de:	b0ab      	sub	sp, #172	; 0xac
 80158e0:	af0a      	add	r7, sp, #40	; 0x28
 80158e2:	60f8      	str	r0, [r7, #12]
ULONG                           i;
TXM_MODULE_ALLOCATED_OBJECT     *object_ptr;


    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 80158e4:	4b85      	ldr	r3, [pc, #532]	; (8015afc <_txm_module_manager_stop+0x220>)
 80158e6:	681b      	ldr	r3, [r3, #0]
 80158e8:	67fb      	str	r3, [r7, #124]	; 0x7c

    /* Determine if this is a legal request.  */

    /* Is there a current thread?  */
    if (thread_ptr == TX_NULL)
 80158ea:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80158ec:	2b00      	cmp	r3, #0
 80158ee:	d101      	bne.n	80158f4 <_txm_module_manager_stop+0x18>
    {

        /* Illegal caller of this service.  */
        return(TX_CALLER_ERROR);
 80158f0:	2313      	movs	r3, #19
 80158f2:	e232      	b.n	8015d5a <_txm_module_manager_stop+0x47e>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80158f4:	f3ef 8305 	mrs	r3, IPSR
 80158f8:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(ipsr_value);
 80158fa:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    }

    /* Is the caller an ISR or Initialization?  */
    if (TX_THREAD_GET_SYSTEM_STATE() != 0)
 80158fc:	4b80      	ldr	r3, [pc, #512]	; (8015b00 <_txm_module_manager_stop+0x224>)
 80158fe:	681b      	ldr	r3, [r3, #0]
 8015900:	4313      	orrs	r3, r2
 8015902:	2b00      	cmp	r3, #0
 8015904:	d001      	beq.n	801590a <_txm_module_manager_stop+0x2e>
    {

        /* Illegal caller of this service.  */
        return(TX_CALLER_ERROR);
 8015906:	2313      	movs	r3, #19
 8015908:	e227      	b.n	8015d5a <_txm_module_manager_stop+0x47e>
    }

#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Check for invalid caller of this function.  First check for a calling thread.  */
    if (thread_ptr == &_tx_timer_thread)
 801590a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 801590c:	4a7d      	ldr	r2, [pc, #500]	; (8015b04 <_txm_module_manager_stop+0x228>)
 801590e:	4293      	cmp	r3, r2
 8015910:	d101      	bne.n	8015916 <_txm_module_manager_stop+0x3a>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        return(TX_CALLER_ERROR);
 8015912:	2313      	movs	r3, #19
 8015914:	e221      	b.n	8015d5a <_txm_module_manager_stop+0x47e>
    }
#endif

    /* Determine if the module manager has not been initialized yet.  */
    if (_txm_module_manager_ready != TX_TRUE)
 8015916:	4b7c      	ldr	r3, [pc, #496]	; (8015b08 <_txm_module_manager_stop+0x22c>)
 8015918:	681b      	ldr	r3, [r3, #0]
 801591a:	2b01      	cmp	r3, #1
 801591c:	d001      	beq.n	8015922 <_txm_module_manager_stop+0x46>
    {

        /* Module manager has not been initialized.  */
        return(TX_NOT_AVAILABLE);
 801591e:	231d      	movs	r3, #29
 8015920:	e21b      	b.n	8015d5a <_txm_module_manager_stop+0x47e>
    }

    /* Determine if the module is valid.  */
    if (module_instance == TX_NULL)
 8015922:	68fb      	ldr	r3, [r7, #12]
 8015924:	2b00      	cmp	r3, #0
 8015926:	d101      	bne.n	801592c <_txm_module_manager_stop+0x50>
    {

        /* Invalid module pointer.  */
        return(TX_PTR_ERROR);
 8015928:	2303      	movs	r3, #3
 801592a:	e216      	b.n	8015d5a <_txm_module_manager_stop+0x47e>
    }

    /* Get module manager protection mutex.  */
    _tx_mutex_get(&_txm_module_manager_mutex, TX_WAIT_FOREVER);
 801592c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8015930:	4876      	ldr	r0, [pc, #472]	; (8015b0c <_txm_module_manager_stop+0x230>)
 8015932:	f7f3 fd59 	bl	80093e8 <_tx_mutex_get>

    /* Determine if the module instance is valid.  */
    if (module_instance -> txm_module_instance_id != TXM_MODULE_ID)
 8015936:	68fb      	ldr	r3, [r7, #12]
 8015938:	681b      	ldr	r3, [r3, #0]
 801593a:	4a75      	ldr	r2, [pc, #468]	; (8015b10 <_txm_module_manager_stop+0x234>)
 801593c:	4293      	cmp	r3, r2
 801593e:	d004      	beq.n	801594a <_txm_module_manager_stop+0x6e>
    {

        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 8015940:	4872      	ldr	r0, [pc, #456]	; (8015b0c <_txm_module_manager_stop+0x230>)
 8015942:	f7f4 f88b 	bl	8009a5c <_tx_mutex_put>

        /* Invalid module pointer.  */
        return(TX_PTR_ERROR);
 8015946:	2303      	movs	r3, #3
 8015948:	e207      	b.n	8015d5a <_txm_module_manager_stop+0x47e>
    }

    /* Determine if the module instance is in the loaded state.  */
    if (module_instance -> txm_module_instance_state != TXM_MODULE_STARTED)
 801594a:	68fb      	ldr	r3, [r7, #12]
 801594c:	689b      	ldr	r3, [r3, #8]
 801594e:	2b02      	cmp	r3, #2
 8015950:	d004      	beq.n	801595c <_txm_module_manager_stop+0x80>
    {

        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 8015952:	486e      	ldr	r0, [pc, #440]	; (8015b0c <_txm_module_manager_stop+0x230>)
 8015954:	f7f4 f882 	bl	8009a5c <_tx_mutex_put>

        /* Return error if the module is not ready.  */
        return(TX_START_ERROR);
 8015958:	2310      	movs	r3, #16
 801595a:	e1fe      	b.n	8015d5a <_txm_module_manager_stop+0x47e>
    }

    /* Set the module state to indicate the module is stopping.  */
    module_instance -> txm_module_instance_state =  TXM_MODULE_STOPPING;
 801595c:	68fb      	ldr	r3, [r7, #12]
 801595e:	2203      	movs	r2, #3
 8015960:	609a      	str	r2, [r3, #8]

    /* This thread was previously used as the start thread. So first, make sure it is terminated and deleted before doing anything else.  */
    _tx_thread_terminate(&(module_instance -> txm_module_instance_start_stop_thread));
 8015962:	68fb      	ldr	r3, [r7, #12]
 8015964:	33d0      	adds	r3, #208	; 0xd0
 8015966:	4618      	mov	r0, r3
 8015968:	f7f7 f804 	bl	800c974 <_tx_thread_terminate>
    _tx_thread_delete(&(module_instance -> txm_module_instance_start_stop_thread));
 801596c:	68fb      	ldr	r3, [r7, #12]
 801596e:	33d0      	adds	r3, #208	; 0xd0
 8015970:	4618      	mov	r0, r3
 8015972:	f7f5 ffd3 	bl	800b91c <_tx_thread_delete>

    /* Determine if there is a module stop function.  */
    if (module_instance -> txm_module_instance_stop_thread_entry)
 8015976:	68fb      	ldr	r3, [r7, #12]
 8015978:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 801597a:	2b00      	cmp	r3, #0
 801597c:	d044      	beq.n	8015a08 <_txm_module_manager_stop+0x12c>
    {

        /* Yes, there is a stop function.  Build a thread for executing the module stop function.  */

        /* Create the module stop thread.  */
        _txm_module_manager_thread_create(&(module_instance -> txm_module_instance_start_stop_thread),
 801597e:	68fb      	ldr	r3, [r7, #12]
 8015980:	f103 06d0 	add.w	r6, r3, #208	; 0xd0
                                          "Module Stop Thread",
                                          module_instance -> txm_module_instance_shell_entry_function,
 8015984:	68fb      	ldr	r3, [r7, #12]
 8015986:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8015988:	60bb      	str	r3, [r7, #8]
        _txm_module_manager_thread_create(&(module_instance -> txm_module_instance_start_stop_thread),
 801598a:	68fb      	ldr	r3, [r7, #12]
 801598c:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 801598e:	6079      	str	r1, [r7, #4]
 8015990:	68fb      	ldr	r3, [r7, #12]
 8015992:	f8d3 3494 	ldr.w	r3, [r3, #1172]	; 0x494
 8015996:	68fa      	ldr	r2, [r7, #12]
 8015998:	6c12      	ldr	r2, [r2, #64]	; 0x40
 801599a:	68f9      	ldr	r1, [r7, #12]
 801599c:	f8d1 1484 	ldr.w	r1, [r1, #1156]	; 0x484
                                          module_instance -> txm_module_instance_stop_thread_entry,
                                          module_instance -> txm_module_instance_application_module_id,
                                          module_instance -> txm_module_instance_start_stop_stack_start_address,
                                          module_instance -> txm_module_instance_start_stop_stack_size,
                                          (UINT) module_instance -> txm_module_instance_start_stop_priority,
 80159a0:	68f8      	ldr	r0, [r7, #12]
 80159a2:	f8d0 0488 	ldr.w	r0, [r0, #1160]	; 0x488
                                          (UINT) module_instance -> txm_module_instance_start_stop_priority,
 80159a6:	68fc      	ldr	r4, [r7, #12]
 80159a8:	f8d4 4488 	ldr.w	r4, [r4, #1160]	; 0x488
        _txm_module_manager_thread_create(&(module_instance -> txm_module_instance_start_stop_thread),
 80159ac:	68fd      	ldr	r5, [r7, #12]
 80159ae:	9508      	str	r5, [sp, #32]
 80159b0:	25e8      	movs	r5, #232	; 0xe8
 80159b2:	9507      	str	r5, [sp, #28]
 80159b4:	2501      	movs	r5, #1
 80159b6:	9506      	str	r5, [sp, #24]
 80159b8:	2504      	movs	r5, #4
 80159ba:	9505      	str	r5, [sp, #20]
 80159bc:	9404      	str	r4, [sp, #16]
 80159be:	9003      	str	r0, [sp, #12]
 80159c0:	9102      	str	r1, [sp, #8]
 80159c2:	9201      	str	r2, [sp, #4]
 80159c4:	9300      	str	r3, [sp, #0]
 80159c6:	687b      	ldr	r3, [r7, #4]
 80159c8:	68ba      	ldr	r2, [r7, #8]
 80159ca:	4952      	ldr	r1, [pc, #328]	; (8015b14 <_txm_module_manager_stop+0x238>)
 80159cc:	4630      	mov	r0, r6
 80159ce:	f000 f9e7 	bl	8015da0 <_txm_module_manager_thread_create>
                                          TX_AUTO_START,
                                          sizeof(TX_THREAD),
                                          module_instance);

        /* Wait for the stop thread to complete.  */
        i =  0;
 80159d2:	2300      	movs	r3, #0
 80159d4:	65fb      	str	r3, [r7, #92]	; 0x5c
        while ((i < TXM_MODULE_TIMEOUT) && (module_instance -> txm_module_instance_start_stop_thread.tx_thread_state != TX_COMPLETED))
 80159d6:	e005      	b.n	80159e4 <_txm_module_manager_stop+0x108>
        {

            /* Sleep to let the module stop thread run.  */
            _tx_thread_sleep(1);
 80159d8:	2001      	movs	r0, #1
 80159da:	f7f6 fbfd 	bl	800c1d8 <_tx_thread_sleep>

            /* Increment the counter.  */
            i++;
 80159de:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80159e0:	3301      	adds	r3, #1
 80159e2:	65fb      	str	r3, [r7, #92]	; 0x5c
        while ((i < TXM_MODULE_TIMEOUT) && (module_instance -> txm_module_instance_start_stop_thread.tx_thread_state != TX_COMPLETED))
 80159e4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80159e6:	2b63      	cmp	r3, #99	; 0x63
 80159e8:	d804      	bhi.n	80159f4 <_txm_module_manager_stop+0x118>
 80159ea:	68fb      	ldr	r3, [r7, #12]
 80159ec:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 80159f0:	2b01      	cmp	r3, #1
 80159f2:	d1f1      	bne.n	80159d8 <_txm_module_manager_stop+0xfc>
        }

        /* At this point, we need to terminate and delete the stop thread.  */
        _tx_thread_terminate(&(module_instance -> txm_module_instance_start_stop_thread));
 80159f4:	68fb      	ldr	r3, [r7, #12]
 80159f6:	33d0      	adds	r3, #208	; 0xd0
 80159f8:	4618      	mov	r0, r3
 80159fa:	f7f6 ffbb 	bl	800c974 <_tx_thread_terminate>
        _tx_thread_delete(&(module_instance -> txm_module_instance_start_stop_thread));
 80159fe:	68fb      	ldr	r3, [r7, #12]
 8015a00:	33d0      	adds	r3, #208	; 0xd0
 8015a02:	4618      	mov	r0, r3
 8015a04:	f7f5 ff8a 	bl	800b91c <_tx_thread_delete>
    }

    /* Delete the module's callback thread and queue for the callback thread.  */
    _tx_thread_terminate(&(module_instance -> txm_module_instance_callback_request_thread));
 8015a08:	68fb      	ldr	r3, [r7, #12]
 8015a0a:	f503 73dc 	add.w	r3, r3, #440	; 0x1b8
 8015a0e:	4618      	mov	r0, r3
 8015a10:	f7f6 ffb0 	bl	800c974 <_tx_thread_terminate>
    _tx_thread_delete(&(module_instance -> txm_module_instance_callback_request_thread));
 8015a14:	68fb      	ldr	r3, [r7, #12]
 8015a16:	f503 73dc 	add.w	r3, r3, #440	; 0x1b8
 8015a1a:	4618      	mov	r0, r3
 8015a1c:	f7f5 ff7e 	bl	800b91c <_tx_thread_delete>
    _tx_queue_delete(&(module_instance -> txm_module_instance_callback_request_queue));
 8015a20:	68fb      	ldr	r3, [r7, #12]
 8015a22:	f503 7328 	add.w	r3, r3, #672	; 0x2a0
 8015a26:	4618      	mov	r0, r3
 8015a28:	f7f4 fb36 	bl	800a098 <_tx_queue_delete>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8015a2c:	f3ef 8310 	mrs	r3, PRIMASK
 8015a30:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 8015a32:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 8015a34:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 8015a36:	b672      	cpsid	i
    return(int_posture);
 8015a38:	6a3b      	ldr	r3, [r7, #32]

    /* Disable interrupts.  */
    TX_DISABLE
 8015a3a:	65bb      	str	r3, [r7, #88]	; 0x58

    /* Temporarily disable preemption.  This will keep other threads from creating and deleting threads.  */
    _tx_thread_preempt_disable++;
 8015a3c:	4b36      	ldr	r3, [pc, #216]	; (8015b18 <_txm_module_manager_stop+0x23c>)
 8015a3e:	681b      	ldr	r3, [r3, #0]
 8015a40:	3301      	adds	r3, #1
 8015a42:	4a35      	ldr	r2, [pc, #212]	; (8015b18 <_txm_module_manager_stop+0x23c>)
 8015a44:	6013      	str	r3, [r2, #0]
 8015a46:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015a48:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015a4a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015a4c:	f383 8810 	msr	PRIMASK, r3
}
 8015a50:	bf00      	nop
    /* Call the USBX stop function.  */
    _txm_module_manager_usbx_stop(module_instance);
#endif

    /* Loop to delete any and all threads created by the module.  */
    i = _tx_thread_created_count;
 8015a52:	4b32      	ldr	r3, [pc, #200]	; (8015b1c <_txm_module_manager_stop+0x240>)
 8015a54:	681b      	ldr	r3, [r3, #0]
 8015a56:	65fb      	str	r3, [r7, #92]	; 0x5c
    thread_ptr =  _tx_thread_created_ptr;
 8015a58:	4b31      	ldr	r3, [pc, #196]	; (8015b20 <_txm_module_manager_stop+0x244>)
 8015a5a:	681b      	ldr	r3, [r3, #0]
 8015a5c:	67fb      	str	r3, [r7, #124]	; 0x7c
    while (i--)
 8015a5e:	e022      	b.n	8015aa6 <_txm_module_manager_stop+0x1ca>
    {

        /* Pickup the next thread pointer.  */
        next_thread_ptr =  thread_ptr -> tx_thread_created_next;
 8015a60:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8015a62:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8015a66:	633b      	str	r3, [r7, #48]	; 0x30

        /* Determine if the thread control block is inside the module.  */
        if ( (((CHAR *) thread_ptr) >= ((CHAR *) module_instance -> txm_module_instance_data_start)) &&
 8015a68:	68fb      	ldr	r3, [r7, #12]
 8015a6a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8015a6c:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8015a6e:	429a      	cmp	r2, r3
 8015a70:	d30b      	bcc.n	8015a8a <_txm_module_manager_stop+0x1ae>
             (((CHAR *) thread_ptr) < ((CHAR *) module_instance -> txm_module_instance_data_end)))
 8015a72:	68fb      	ldr	r3, [r7, #12]
 8015a74:	6b1b      	ldr	r3, [r3, #48]	; 0x30
        if ( (((CHAR *) thread_ptr) >= ((CHAR *) module_instance -> txm_module_instance_data_start)) &&
 8015a76:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8015a78:	429a      	cmp	r2, r3
 8015a7a:	d206      	bcs.n	8015a8a <_txm_module_manager_stop+0x1ae>
        {

            /* Terminate and delete this thread, since it is part of this module.  */
            _tx_thread_terminate(thread_ptr);
 8015a7c:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 8015a7e:	f7f6 ff79 	bl	800c974 <_tx_thread_terminate>
            _tx_thread_delete(thread_ptr);
 8015a82:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 8015a84:	f7f5 ff4a 	bl	800b91c <_tx_thread_delete>
 8015a88:	e00b      	b.n	8015aa2 <_txm_module_manager_stop+0x1c6>
        }

        /* Is this thread part of the module?  */
        else if (thread_ptr -> tx_thread_module_instance_ptr == module_instance)
 8015a8a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8015a8c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8015a90:	68fa      	ldr	r2, [r7, #12]
 8015a92:	429a      	cmp	r2, r3
 8015a94:	d105      	bne.n	8015aa2 <_txm_module_manager_stop+0x1c6>
        {

            /* Terminate and delete this thread, since it is part of this module.  */
            _tx_thread_terminate(thread_ptr);
 8015a96:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 8015a98:	f7f6 ff6c 	bl	800c974 <_tx_thread_terminate>
            _tx_thread_delete(thread_ptr);
 8015a9c:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 8015a9e:	f7f5 ff3d 	bl	800b91c <_tx_thread_delete>
        }

        /* Move to next thread.  */
        thread_ptr =  next_thread_ptr;
 8015aa2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015aa4:	67fb      	str	r3, [r7, #124]	; 0x7c
    while (i--)
 8015aa6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8015aa8:	1e5a      	subs	r2, r3, #1
 8015aaa:	65fa      	str	r2, [r7, #92]	; 0x5c
 8015aac:	2b00      	cmp	r3, #0
 8015aae:	d1d7      	bne.n	8015a60 <_txm_module_manager_stop+0x184>
    }

    /* Loop to delete any and all timers created by the module.  */
    i = _tx_timer_created_count;
 8015ab0:	4b1c      	ldr	r3, [pc, #112]	; (8015b24 <_txm_module_manager_stop+0x248>)
 8015ab2:	681b      	ldr	r3, [r3, #0]
 8015ab4:	65fb      	str	r3, [r7, #92]	; 0x5c
    timer_ptr =  _tx_timer_created_ptr;
 8015ab6:	4b1c      	ldr	r3, [pc, #112]	; (8015b28 <_txm_module_manager_stop+0x24c>)
 8015ab8:	681b      	ldr	r3, [r3, #0]
 8015aba:	67bb      	str	r3, [r7, #120]	; 0x78
    while (i--)
 8015abc:	e012      	b.n	8015ae4 <_txm_module_manager_stop+0x208>
    {

        /* Pickup the next timer pointer.  */
        next_timer_ptr =  timer_ptr -> tx_timer_created_next;
 8015abe:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8015ac0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8015ac2:	637b      	str	r3, [r7, #52]	; 0x34

        /* Check if this module created this timer.  */
        created_by_module =  _txm_module_manager_created_object_check(module_instance, (VOID *) timer_ptr);
 8015ac4:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 8015ac6:	68f8      	ldr	r0, [r7, #12]
 8015ac8:	f000 fdac 	bl	8016624 <_txm_module_manager_created_object_check>
 8015acc:	4603      	mov	r3, r0
 8015ace:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
        if (created_by_module == TX_TRUE)
 8015ad2:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8015ad6:	2b01      	cmp	r3, #1
 8015ad8:	d102      	bne.n	8015ae0 <_txm_module_manager_stop+0x204>
        {

            /* Delete this timer, since it is part of this module.  */
            _tx_timer_delete(timer_ptr);
 8015ada:	6fb8      	ldr	r0, [r7, #120]	; 0x78
 8015adc:	f7f7 fbb0 	bl	800d240 <_tx_timer_delete>
        }

        /* Move to next timer.  */
        timer_ptr =  next_timer_ptr;
 8015ae0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8015ae2:	67bb      	str	r3, [r7, #120]	; 0x78
    while (i--)
 8015ae4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8015ae6:	1e5a      	subs	r2, r3, #1
 8015ae8:	65fa      	str	r2, [r7, #92]	; 0x5c
 8015aea:	2b00      	cmp	r3, #0
 8015aec:	d1e7      	bne.n	8015abe <_txm_module_manager_stop+0x1e2>
    }

    /* Loop to delete any and all queues created by the module.  */
    i = _tx_queue_created_count;
 8015aee:	4b0f      	ldr	r3, [pc, #60]	; (8015b2c <_txm_module_manager_stop+0x250>)
 8015af0:	681b      	ldr	r3, [r3, #0]
 8015af2:	65fb      	str	r3, [r7, #92]	; 0x5c
    queue_ptr =  _tx_queue_created_ptr;
 8015af4:	4b0e      	ldr	r3, [pc, #56]	; (8015b30 <_txm_module_manager_stop+0x254>)
 8015af6:	681b      	ldr	r3, [r3, #0]
 8015af8:	677b      	str	r3, [r7, #116]	; 0x74
    while (i--)
 8015afa:	e03b      	b.n	8015b74 <_txm_module_manager_stop+0x298>
 8015afc:	2000efb8 	.word	0x2000efb8
 8015b00:	2000000c 	.word	0x2000000c
 8015b04:	2000f108 	.word	0x2000f108
 8015b08:	2000f6b0 	.word	0x2000f6b0
 8015b0c:	2000f674 	.word	0x2000f674
 8015b10:	4d4f4455 	.word	0x4d4f4455
 8015b14:	08017a80 	.word	0x08017a80
 8015b18:	2000f054 	.word	0x2000f054
 8015b1c:	2000efc4 	.word	0x2000efc4
 8015b20:	2000efc0 	.word	0x2000efc0
 8015b24:	2000f100 	.word	0x2000f100
 8015b28:	2000f0fc 	.word	0x2000f0fc
 8015b2c:	2000ef8c 	.word	0x2000ef8c
 8015b30:	2000ef88 	.word	0x2000ef88
    {

        /* Pickup the next queue pointer.  */
        next_queue_ptr =   queue_ptr -> tx_queue_created_next;
 8015b34:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015b36:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015b38:	63bb      	str	r3, [r7, #56]	; 0x38

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Determine if the queue callback function is associated with this module.  */
        if ((queue_ptr -> tx_queue_module_instance == module_instance) &&
 8015b3a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015b3c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8015b3e:	68fa      	ldr	r2, [r7, #12]
 8015b40:	429a      	cmp	r2, r3
 8015b42:	d107      	bne.n	8015b54 <_txm_module_manager_stop+0x278>
            (queue_ptr -> tx_queue_send_notify == _txm_module_manager_queue_notify_trampoline))
 8015b44:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015b46:	6b9b      	ldr	r3, [r3, #56]	; 0x38
        if ((queue_ptr -> tx_queue_module_instance == module_instance) &&
 8015b48:	4a86      	ldr	r2, [pc, #536]	; (8015d64 <_txm_module_manager_stop+0x488>)
 8015b4a:	4293      	cmp	r3, r2
 8015b4c:	d102      	bne.n	8015b54 <_txm_module_manager_stop+0x278>
        {

            /* Clear the callback notification for this queue since it is no longer valid.  */
            queue_ptr -> tx_queue_send_notify =  TX_NULL;
 8015b4e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015b50:	2200      	movs	r2, #0
 8015b52:	639a      	str	r2, [r3, #56]	; 0x38
        }
#endif

        /* Check if this module created this queue.  */
        created_by_module =  _txm_module_manager_created_object_check(module_instance, (VOID *) queue_ptr);
 8015b54:	6f79      	ldr	r1, [r7, #116]	; 0x74
 8015b56:	68f8      	ldr	r0, [r7, #12]
 8015b58:	f000 fd64 	bl	8016624 <_txm_module_manager_created_object_check>
 8015b5c:	4603      	mov	r3, r0
 8015b5e:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
        if (created_by_module == TX_TRUE)
 8015b62:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8015b66:	2b01      	cmp	r3, #1
 8015b68:	d102      	bne.n	8015b70 <_txm_module_manager_stop+0x294>
        {

            /* Delete this queue, since it is part of this module.  */
            _tx_queue_delete(queue_ptr);
 8015b6a:	6f78      	ldr	r0, [r7, #116]	; 0x74
 8015b6c:	f7f4 fa94 	bl	800a098 <_tx_queue_delete>
        }

        /* Move to next queue.  */
        queue_ptr =  next_queue_ptr;
 8015b70:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015b72:	677b      	str	r3, [r7, #116]	; 0x74
    while (i--)
 8015b74:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8015b76:	1e5a      	subs	r2, r3, #1
 8015b78:	65fa      	str	r2, [r7, #92]	; 0x5c
 8015b7a:	2b00      	cmp	r3, #0
 8015b7c:	d1da      	bne.n	8015b34 <_txm_module_manager_stop+0x258>
    }

    /* Loop to delete any and all event flag groups created by the module.  */
    i = _tx_event_flags_created_count;
 8015b7e:	4b7a      	ldr	r3, [pc, #488]	; (8015d68 <_txm_module_manager_stop+0x48c>)
 8015b80:	681b      	ldr	r3, [r3, #0]
 8015b82:	65fb      	str	r3, [r7, #92]	; 0x5c
    events_ptr =  _tx_event_flags_created_ptr;
 8015b84:	4b79      	ldr	r3, [pc, #484]	; (8015d6c <_txm_module_manager_stop+0x490>)
 8015b86:	681b      	ldr	r3, [r3, #0]
 8015b88:	673b      	str	r3, [r7, #112]	; 0x70
    while (i--)
 8015b8a:	e01f      	b.n	8015bcc <_txm_module_manager_stop+0x2f0>
    {

        /* Pickup the next event flags group pointer.  */
        next_events_ptr =   events_ptr -> tx_event_flags_group_created_next;
 8015b8c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8015b8e:	699b      	ldr	r3, [r3, #24]
 8015b90:	63fb      	str	r3, [r7, #60]	; 0x3c

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Determine if the event flags callback function is associated with this module.  */
        if ((events_ptr -> tx_event_flags_group_module_instance == module_instance) &&
 8015b92:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8015b94:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015b96:	68fa      	ldr	r2, [r7, #12]
 8015b98:	429a      	cmp	r2, r3
 8015b9a:	d107      	bne.n	8015bac <_txm_module_manager_stop+0x2d0>
            (events_ptr -> tx_event_flags_group_set_notify == _txm_module_manager_event_flags_notify_trampoline))
 8015b9c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8015b9e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
        if ((events_ptr -> tx_event_flags_group_module_instance == module_instance) &&
 8015ba0:	4a73      	ldr	r2, [pc, #460]	; (8015d70 <_txm_module_manager_stop+0x494>)
 8015ba2:	4293      	cmp	r3, r2
 8015ba4:	d102      	bne.n	8015bac <_txm_module_manager_stop+0x2d0>
        {

            /* Clear the callback notification for this event flag group since it is no longer valid.  */
            events_ptr -> tx_event_flags_group_set_notify =  TX_NULL;
 8015ba6:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8015ba8:	2200      	movs	r2, #0
 8015baa:	625a      	str	r2, [r3, #36]	; 0x24
        }
#endif

        /* Check if this module created this event flags.  */
        created_by_module =  _txm_module_manager_created_object_check(module_instance, (VOID *) events_ptr);
 8015bac:	6f39      	ldr	r1, [r7, #112]	; 0x70
 8015bae:	68f8      	ldr	r0, [r7, #12]
 8015bb0:	f000 fd38 	bl	8016624 <_txm_module_manager_created_object_check>
 8015bb4:	4603      	mov	r3, r0
 8015bb6:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
        if (created_by_module == TX_TRUE)
 8015bba:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8015bbe:	2b01      	cmp	r3, #1
 8015bc0:	d102      	bne.n	8015bc8 <_txm_module_manager_stop+0x2ec>
        {

            /* Delete this event flags group, since it is part of this module.  */
            _tx_event_flags_delete(events_ptr);
 8015bc2:	6f38      	ldr	r0, [r7, #112]	; 0x70
 8015bc4:	f7f2 fd7e 	bl	80086c4 <_tx_event_flags_delete>
        }

        /* Move to next event flags group.  */
        events_ptr =  next_events_ptr;
 8015bc8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015bca:	673b      	str	r3, [r7, #112]	; 0x70
    while (i--)
 8015bcc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8015bce:	1e5a      	subs	r2, r3, #1
 8015bd0:	65fa      	str	r2, [r7, #92]	; 0x5c
 8015bd2:	2b00      	cmp	r3, #0
 8015bd4:	d1da      	bne.n	8015b8c <_txm_module_manager_stop+0x2b0>
    }

    /* Loop to delete any and all semaphores created by the module.  */
    i = _tx_semaphore_created_count;
 8015bd6:	4b67      	ldr	r3, [pc, #412]	; (8015d74 <_txm_module_manager_stop+0x498>)
 8015bd8:	681b      	ldr	r3, [r3, #0]
 8015bda:	65fb      	str	r3, [r7, #92]	; 0x5c
    semaphore_ptr =  _tx_semaphore_created_ptr;
 8015bdc:	4b66      	ldr	r3, [pc, #408]	; (8015d78 <_txm_module_manager_stop+0x49c>)
 8015bde:	681b      	ldr	r3, [r3, #0]
 8015be0:	66fb      	str	r3, [r7, #108]	; 0x6c
    while (i--)
 8015be2:	e01f      	b.n	8015c24 <_txm_module_manager_stop+0x348>
    {

        /* Pickup the next semaphore pointer.  */
        next_semaphore_ptr =   semaphore_ptr -> tx_semaphore_created_next;
 8015be4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8015be6:	695b      	ldr	r3, [r3, #20]
 8015be8:	643b      	str	r3, [r7, #64]	; 0x40

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Determine if the semaphore callback function is associated with this module.  */
        if ((semaphore_ptr -> tx_semaphore_module_instance == module_instance) &&
 8015bea:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8015bec:	6a1b      	ldr	r3, [r3, #32]
 8015bee:	68fa      	ldr	r2, [r7, #12]
 8015bf0:	429a      	cmp	r2, r3
 8015bf2:	d107      	bne.n	8015c04 <_txm_module_manager_stop+0x328>
            (semaphore_ptr -> tx_semaphore_put_notify == _txm_module_manager_semaphore_notify_trampoline))
 8015bf4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8015bf6:	69db      	ldr	r3, [r3, #28]
        if ((semaphore_ptr -> tx_semaphore_module_instance == module_instance) &&
 8015bf8:	4a60      	ldr	r2, [pc, #384]	; (8015d7c <_txm_module_manager_stop+0x4a0>)
 8015bfa:	4293      	cmp	r3, r2
 8015bfc:	d102      	bne.n	8015c04 <_txm_module_manager_stop+0x328>
        {

            /* Clear the callback notification for this semaphore since it is no longer valid.  */
            semaphore_ptr -> tx_semaphore_put_notify =  TX_NULL;
 8015bfe:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8015c00:	2200      	movs	r2, #0
 8015c02:	61da      	str	r2, [r3, #28]
        }
#endif

        /* Check if this module created this semaphore.  */
        created_by_module =  _txm_module_manager_created_object_check(module_instance, (VOID *) semaphore_ptr);
 8015c04:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
 8015c06:	68f8      	ldr	r0, [r7, #12]
 8015c08:	f000 fd0c 	bl	8016624 <_txm_module_manager_created_object_check>
 8015c0c:	4603      	mov	r3, r0
 8015c0e:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
        if (created_by_module == TX_TRUE)
 8015c12:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8015c16:	2b01      	cmp	r3, #1
 8015c18:	d102      	bne.n	8015c20 <_txm_module_manager_stop+0x344>
        {

            /* Delete this semaphore, since it is part of this module.  */
            _tx_semaphore_delete(semaphore_ptr);
 8015c1a:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 8015c1c:	f7f5 faa0 	bl	800b160 <_tx_semaphore_delete>
        }

        /* Move to next semaphore.  */
        semaphore_ptr =  next_semaphore_ptr;
 8015c20:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015c22:	66fb      	str	r3, [r7, #108]	; 0x6c
    while (i--)
 8015c24:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8015c26:	1e5a      	subs	r2, r3, #1
 8015c28:	65fa      	str	r2, [r7, #92]	; 0x5c
 8015c2a:	2b00      	cmp	r3, #0
 8015c2c:	d1da      	bne.n	8015be4 <_txm_module_manager_stop+0x308>
    }

    /* Loop to delete any and all mutexes created by the module.  */
    i = _tx_mutex_created_count;
 8015c2e:	4b54      	ldr	r3, [pc, #336]	; (8015d80 <_txm_module_manager_stop+0x4a4>)
 8015c30:	681b      	ldr	r3, [r3, #0]
 8015c32:	65fb      	str	r3, [r7, #92]	; 0x5c
    mutex_ptr =  _tx_mutex_created_ptr;
 8015c34:	4b53      	ldr	r3, [pc, #332]	; (8015d84 <_txm_module_manager_stop+0x4a8>)
 8015c36:	681b      	ldr	r3, [r3, #0]
 8015c38:	66bb      	str	r3, [r7, #104]	; 0x68
    while (i--)
 8015c3a:	e012      	b.n	8015c62 <_txm_module_manager_stop+0x386>
    {

        /* Pickup the next mutex pointer.  */
        next_mutex_ptr =   mutex_ptr -> tx_mutex_created_next;
 8015c3c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8015c3e:	6a1b      	ldr	r3, [r3, #32]
 8015c40:	647b      	str	r3, [r7, #68]	; 0x44

        /* Check if this module created this mutex.  */
        created_by_module =  _txm_module_manager_created_object_check(module_instance, (VOID *) mutex_ptr);
 8015c42:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 8015c44:	68f8      	ldr	r0, [r7, #12]
 8015c46:	f000 fced 	bl	8016624 <_txm_module_manager_created_object_check>
 8015c4a:	4603      	mov	r3, r0
 8015c4c:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
        if (created_by_module == TX_TRUE)
 8015c50:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8015c54:	2b01      	cmp	r3, #1
 8015c56:	d102      	bne.n	8015c5e <_txm_module_manager_stop+0x382>
        {

            /* Delete this mutex, since it is part of this module.  */
            _tx_mutex_delete(mutex_ptr);
 8015c58:	6eb8      	ldr	r0, [r7, #104]	; 0x68
 8015c5a:	f7f3 fb1b 	bl	8009294 <_tx_mutex_delete>
        }

        /* Move to next mutex.  */
        mutex_ptr =  next_mutex_ptr;
 8015c5e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8015c60:	66bb      	str	r3, [r7, #104]	; 0x68
    while (i--)
 8015c62:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8015c64:	1e5a      	subs	r2, r3, #1
 8015c66:	65fa      	str	r2, [r7, #92]	; 0x5c
 8015c68:	2b00      	cmp	r3, #0
 8015c6a:	d1e7      	bne.n	8015c3c <_txm_module_manager_stop+0x360>
    }

    /* Loop to delete any and all block pools created by the module.  */
    i = _tx_block_pool_created_count;
 8015c6c:	4b46      	ldr	r3, [pc, #280]	; (8015d88 <_txm_module_manager_stop+0x4ac>)
 8015c6e:	681b      	ldr	r3, [r3, #0]
 8015c70:	65fb      	str	r3, [r7, #92]	; 0x5c
    block_pool_ptr =  _tx_block_pool_created_ptr;
 8015c72:	4b46      	ldr	r3, [pc, #280]	; (8015d8c <_txm_module_manager_stop+0x4b0>)
 8015c74:	681b      	ldr	r3, [r3, #0]
 8015c76:	667b      	str	r3, [r7, #100]	; 0x64
    while (i--)
 8015c78:	e012      	b.n	8015ca0 <_txm_module_manager_stop+0x3c4>
    {

        /* Pickup the next block pool pointer.  */
        next_block_pool_ptr =   block_pool_ptr -> tx_block_pool_created_next;
 8015c7a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8015c7c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015c7e:	64bb      	str	r3, [r7, #72]	; 0x48

        /* Check if this module created this block pool.  */
        created_by_module =  _txm_module_manager_created_object_check(module_instance, (VOID *) block_pool_ptr);
 8015c80:	6e79      	ldr	r1, [r7, #100]	; 0x64
 8015c82:	68f8      	ldr	r0, [r7, #12]
 8015c84:	f000 fcce 	bl	8016624 <_txm_module_manager_created_object_check>
 8015c88:	4603      	mov	r3, r0
 8015c8a:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
        if (created_by_module == TX_TRUE)
 8015c8e:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8015c92:	2b01      	cmp	r3, #1
 8015c94:	d102      	bne.n	8015c9c <_txm_module_manager_stop+0x3c0>
        {

            /* Delete this block pool, since it is part of this module.  */
            _tx_block_pool_delete(block_pool_ptr);
 8015c96:	6e78      	ldr	r0, [r7, #100]	; 0x64
 8015c98:	f7f1 fbe4 	bl	8007464 <_tx_block_pool_delete>
        }

        /* Move to next block pool.  */
        block_pool_ptr =  next_block_pool_ptr;
 8015c9c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8015c9e:	667b      	str	r3, [r7, #100]	; 0x64
    while (i--)
 8015ca0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8015ca2:	1e5a      	subs	r2, r3, #1
 8015ca4:	65fa      	str	r2, [r7, #92]	; 0x5c
 8015ca6:	2b00      	cmp	r3, #0
 8015ca8:	d1e7      	bne.n	8015c7a <_txm_module_manager_stop+0x39e>
    }

    /* Loop to delete any and all byte pools created by the module.  */
    i = _tx_byte_pool_created_count;
 8015caa:	4b39      	ldr	r3, [pc, #228]	; (8015d90 <_txm_module_manager_stop+0x4b4>)
 8015cac:	681b      	ldr	r3, [r3, #0]
 8015cae:	65fb      	str	r3, [r7, #92]	; 0x5c
    byte_pool_ptr =  _tx_byte_pool_created_ptr;
 8015cb0:	4b38      	ldr	r3, [pc, #224]	; (8015d94 <_txm_module_manager_stop+0x4b8>)
 8015cb2:	681b      	ldr	r3, [r3, #0]
 8015cb4:	663b      	str	r3, [r7, #96]	; 0x60
    while (i--)
 8015cb6:	e012      	b.n	8015cde <_txm_module_manager_stop+0x402>
    {

        /* Pickup the next byte pool pointer.  */
        next_byte_pool_ptr =   byte_pool_ptr -> tx_byte_pool_created_next;
 8015cb8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015cba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8015cbc:	653b      	str	r3, [r7, #80]	; 0x50

        /* Check if this module created this byte pool.  */
        created_by_module =  _txm_module_manager_created_object_check(module_instance, (VOID *) byte_pool_ptr);
 8015cbe:	6e39      	ldr	r1, [r7, #96]	; 0x60
 8015cc0:	68f8      	ldr	r0, [r7, #12]
 8015cc2:	f000 fcaf 	bl	8016624 <_txm_module_manager_created_object_check>
 8015cc6:	4603      	mov	r3, r0
 8015cc8:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
        if (created_by_module == TX_TRUE)
 8015ccc:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8015cd0:	2b01      	cmp	r3, #1
 8015cd2:	d102      	bne.n	8015cda <_txm_module_manager_stop+0x3fe>
        {

            /* Delete this byte pool, since it is part of this module.  */
            _tx_byte_pool_delete(byte_pool_ptr);
 8015cd4:	6e38      	ldr	r0, [r7, #96]	; 0x60
 8015cd6:	f7f1 ffed 	bl	8007cb4 <_tx_byte_pool_delete>
        }

        /* Move to next byte pool.  */
        byte_pool_ptr =  next_byte_pool_ptr;
 8015cda:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015cdc:	663b      	str	r3, [r7, #96]	; 0x60
    while (i--)
 8015cde:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8015ce0:	1e5a      	subs	r2, r3, #1
 8015ce2:	65fa      	str	r2, [r7, #92]	; 0x5c
 8015ce4:	2b00      	cmp	r3, #0
 8015ce6:	d1e7      	bne.n	8015cb8 <_txm_module_manager_stop+0x3dc>
        }
    }
#endif

    /* Delete the allocated objects for this module.  */
    while (module_instance -> txm_module_instance_object_list_count != 0)
 8015ce8:	e012      	b.n	8015d10 <_txm_module_manager_stop+0x434>
    {
        /* Pickup the current object pointer.  */
        object_ptr =  module_instance -> txm_module_instance_object_list_head;
 8015cea:	68fb      	ldr	r3, [r7, #12]
 8015cec:	f8d3 349c 	ldr.w	r3, [r3, #1180]	; 0x49c
 8015cf0:	657b      	str	r3, [r7, #84]	; 0x54

        /* Move the head pointer forward.  */
        module_instance -> txm_module_instance_object_list_head =  object_ptr -> txm_module_allocated_object_next;
 8015cf2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8015cf4:	685a      	ldr	r2, [r3, #4]
 8015cf6:	68fb      	ldr	r3, [r7, #12]
 8015cf8:	f8c3 249c 	str.w	r2, [r3, #1180]	; 0x49c

        /* Release the object.  */
        _tx_byte_release((VOID *) object_ptr);
 8015cfc:	6d78      	ldr	r0, [r7, #84]	; 0x54
 8015cfe:	f7f2 fae9 	bl	80082d4 <_tx_byte_release>

        /* Decrement count.  */
        module_instance -> txm_module_instance_object_list_count--;
 8015d02:	68fb      	ldr	r3, [r7, #12]
 8015d04:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
 8015d08:	1e5a      	subs	r2, r3, #1
 8015d0a:	68fb      	ldr	r3, [r7, #12]
 8015d0c:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
    while (module_instance -> txm_module_instance_object_list_count != 0)
 8015d10:	68fb      	ldr	r3, [r7, #12]
 8015d12:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
 8015d16:	2b00      	cmp	r3, #0
 8015d18:	d1e7      	bne.n	8015cea <_txm_module_manager_stop+0x40e>
    }

    /* Set the allocated list head pointer to NULL.  */
    module_instance -> txm_module_instance_object_list_head =  TX_NULL;
 8015d1a:	68fb      	ldr	r3, [r7, #12]
 8015d1c:	2200      	movs	r2, #0
 8015d1e:	f8c3 249c 	str.w	r2, [r3, #1180]	; 0x49c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8015d22:	f3ef 8310 	mrs	r3, PRIMASK
 8015d26:	61bb      	str	r3, [r7, #24]
    return(posture);
 8015d28:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8015d2a:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8015d2c:	b672      	cpsid	i
    return(int_posture);
 8015d2e:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts.  */
    TX_DISABLE
 8015d30:	65bb      	str	r3, [r7, #88]	; 0x58

    /* Enable preemption again.  */
    _tx_thread_preempt_disable--;
 8015d32:	4b19      	ldr	r3, [pc, #100]	; (8015d98 <_txm_module_manager_stop+0x4bc>)
 8015d34:	681b      	ldr	r3, [r3, #0]
 8015d36:	3b01      	subs	r3, #1
 8015d38:	4a17      	ldr	r2, [pc, #92]	; (8015d98 <_txm_module_manager_stop+0x4bc>)
 8015d3a:	6013      	str	r3, [r2, #0]

    /* Set the module state to indicate the module is stopped.  */
    module_instance -> txm_module_instance_state =  TXM_MODULE_STOPPED;
 8015d3c:	68fb      	ldr	r3, [r7, #12]
 8015d3e:	2204      	movs	r2, #4
 8015d40:	609a      	str	r2, [r3, #8]
 8015d42:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015d44:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015d46:	69fb      	ldr	r3, [r7, #28]
 8015d48:	f383 8810 	msr	PRIMASK, r3
}
 8015d4c:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Release the protection mutex.  */
    _tx_mutex_put(&_txm_module_manager_mutex);
 8015d4e:	4813      	ldr	r0, [pc, #76]	; (8015d9c <_txm_module_manager_stop+0x4c0>)
 8015d50:	f7f3 fe84 	bl	8009a5c <_tx_mutex_put>

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 8015d54:	f7f6 fb30 	bl	800c3b8 <_tx_thread_system_preempt_check>

    /* Return success.  */
    return(TX_SUCCESS);
 8015d58:	2300      	movs	r3, #0
}
 8015d5a:	4618      	mov	r0, r3
 8015d5c:	3784      	adds	r7, #132	; 0x84
 8015d5e:	46bd      	mov	sp, r7
 8015d60:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8015d62:	bf00      	nop
 8015d64:	08015599 	.word	0x08015599
 8015d68:	2000ef94 	.word	0x2000ef94
 8015d6c:	2000ef90 	.word	0x2000ef90
 8015d70:	0800fb65 	.word	0x0800fb65
 8015d74:	2000ef84 	.word	0x2000ef84
 8015d78:	2000ef80 	.word	0x2000ef80
 8015d7c:	0801564d 	.word	0x0801564d
 8015d80:	2000ef9c 	.word	0x2000ef9c
 8015d84:	2000ef98 	.word	0x2000ef98
 8015d88:	2000efa4 	.word	0x2000efa4
 8015d8c:	2000efa0 	.word	0x2000efa0
 8015d90:	2000efac 	.word	0x2000efac
 8015d94:	2000efa8 	.word	0x2000efa8
 8015d98:	2000f054 	.word	0x2000f054
 8015d9c:	2000f674 	.word	0x2000f674

08015da0 <_txm_module_manager_thread_create>:
                            VOID (*shell_function)(TX_THREAD *, TXM_MODULE_INSTANCE *),
                            VOID (*entry_function)(ULONG id), ULONG entry_input,
                            VOID *stack_start, ULONG stack_size, UINT priority, UINT preempt_threshold,
                            ULONG time_slice, UINT auto_start,
                            UINT thread_control_block_size, TXM_MODULE_INSTANCE *module_instance)
{
 8015da0:	b580      	push	{r7, lr}
 8015da2:	b0a0      	sub	sp, #128	; 0x80
 8015da4:	af00      	add	r7, sp, #0
 8015da6:	60f8      	str	r0, [r7, #12]
 8015da8:	60b9      	str	r1, [r7, #8]
 8015daa:	607a      	str	r2, [r7, #4]
 8015dac:	603b      	str	r3, [r7, #0]
UINT                    core_index;
#endif
TX_THREAD               *next_thread;
TX_THREAD               *previous_thread;
TX_THREAD               *saved_thread_ptr;
UINT                    saved_threshold =  ((UINT) 0);
 8015dae:	2300      	movs	r3, #0
 8015db0:	677b      	str	r3, [r7, #116]	; 0x74
TXM_MODULE_THREAD_ENTRY_INFO *thread_entry_info;
VOID                    *stack_end;
ULONG                   i;

    /* First, check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
 8015db2:	68fb      	ldr	r3, [r7, #12]
 8015db4:	2b00      	cmp	r3, #0
 8015db6:	d101      	bne.n	8015dbc <_txm_module_manager_thread_create+0x1c>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        return(TX_THREAD_ERROR);
 8015db8:	230e      	movs	r3, #14
 8015dba:	e236      	b.n	801622a <_txm_module_manager_thread_create+0x48a>
    }

    /* Now check for invalid thread control block size.  */
    else if (thread_control_block_size != (sizeof(TX_THREAD)))
 8015dbc:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8015dc0:	2be8      	cmp	r3, #232	; 0xe8
 8015dc2:	d001      	beq.n	8015dc8 <_txm_module_manager_thread_create+0x28>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        return(TX_THREAD_ERROR);
 8015dc4:	230e      	movs	r3, #14
 8015dc6:	e230      	b.n	801622a <_txm_module_manager_thread_create+0x48a>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8015dc8:	f3ef 8310 	mrs	r3, PRIMASK
 8015dcc:	64fb      	str	r3, [r7, #76]	; 0x4c
    return(posture);
 8015dce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    int_posture = __get_interrupt_posture();
 8015dd0:	64bb      	str	r3, [r7, #72]	; 0x48
    __asm__ volatile ("CPSID i" : : : "memory");
 8015dd2:	b672      	cpsid	i
    return(int_posture);
 8015dd4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    }

    /* Disable interrupts.  */
    TX_DISABLE
 8015dd6:	66fb      	str	r3, [r7, #108]	; 0x6c

    /* Increment the preempt disable flag.  */
    _tx_thread_preempt_disable++;
 8015dd8:	4b5e      	ldr	r3, [pc, #376]	; (8015f54 <_txm_module_manager_thread_create+0x1b4>)
 8015dda:	681b      	ldr	r3, [r3, #0]
 8015ddc:	3301      	adds	r3, #1
 8015dde:	4a5d      	ldr	r2, [pc, #372]	; (8015f54 <_txm_module_manager_thread_create+0x1b4>)
 8015de0:	6013      	str	r3, [r2, #0]
 8015de2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8015de4:	653b      	str	r3, [r7, #80]	; 0x50
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015de6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015de8:	f383 8810 	msr	PRIMASK, r3
}
 8015dec:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Next see if it is already in the created list.  */
    next_thread =  _tx_thread_created_ptr;
 8015dee:	4b5a      	ldr	r3, [pc, #360]	; (8015f58 <_txm_module_manager_thread_create+0x1b8>)
 8015df0:	681b      	ldr	r3, [r3, #0]
 8015df2:	67fb      	str	r3, [r7, #124]	; 0x7c
    stack_end   =  (VOID *) (((UCHAR *) ((VOID *) stack_start)) + (stack_size - 1));
 8015df4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8015df8:	3b01      	subs	r3, #1
 8015dfa:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 8015dfe:	4413      	add	r3, r2
 8015e00:	66bb      	str	r3, [r7, #104]	; 0x68
    for (i = 0; i < _tx_thread_created_count; i++)
 8015e02:	2300      	movs	r3, #0
 8015e04:	673b      	str	r3, [r7, #112]	; 0x70
 8015e06:	e019      	b.n	8015e3c <_txm_module_manager_thread_create+0x9c>
    {

        /* Determine if this thread matches the thread in the list.  */
        if (thread_ptr == next_thread)
 8015e08:	68fa      	ldr	r2, [r7, #12]
 8015e0a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8015e0c:	429a      	cmp	r2, r3
 8015e0e:	d01b      	beq.n	8015e48 <_txm_module_manager_thread_create+0xa8>

            break;
        }

        /* Check the stack pointer to see if it overlaps with this thread's stack.  */
        if ((((UCHAR *) ((VOID *) stack_start)) <= ((UCHAR *) ((VOID *) next_thread -> tx_thread_stack_end))) &&
 8015e10:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8015e12:	691b      	ldr	r3, [r3, #16]
 8015e14:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 8015e18:	429a      	cmp	r2, r3
 8015e1a:	d808      	bhi.n	8015e2e <_txm_module_manager_thread_create+0x8e>
            (((UCHAR *) ((VOID *) stack_end)) >= ((UCHAR *) ((VOID *) next_thread -> tx_thread_stack_start))))
 8015e1c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8015e1e:	68db      	ldr	r3, [r3, #12]
        if ((((UCHAR *) ((VOID *) stack_start)) <= ((UCHAR *) ((VOID *) next_thread -> tx_thread_stack_end))) &&
 8015e20:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8015e22:	429a      	cmp	r2, r3
 8015e24:	d303      	bcc.n	8015e2e <_txm_module_manager_thread_create+0x8e>
        {
            /* Stacks overlap, clear the stack pointer to force a stack error below.  */
            stack_start =  TX_NULL;
 8015e26:	2300      	movs	r3, #0
 8015e28:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
            break;
 8015e2c:	e00d      	b.n	8015e4a <_txm_module_manager_thread_create+0xaa>
        }

        /* Move to the next thread.  */
        next_thread =  next_thread -> tx_thread_created_next;
 8015e2e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8015e30:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8015e34:	67fb      	str	r3, [r7, #124]	; 0x7c
    for (i = 0; i < _tx_thread_created_count; i++)
 8015e36:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8015e38:	3301      	adds	r3, #1
 8015e3a:	673b      	str	r3, [r7, #112]	; 0x70
 8015e3c:	4b47      	ldr	r3, [pc, #284]	; (8015f5c <_txm_module_manager_thread_create+0x1bc>)
 8015e3e:	681b      	ldr	r3, [r3, #0]
 8015e40:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8015e42:	429a      	cmp	r2, r3
 8015e44:	d3e0      	bcc.n	8015e08 <_txm_module_manager_thread_create+0x68>
 8015e46:	e000      	b.n	8015e4a <_txm_module_manager_thread_create+0xaa>
            break;
 8015e48:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8015e4a:	f3ef 8310 	mrs	r3, PRIMASK
 8015e4e:	643b      	str	r3, [r7, #64]	; 0x40
    return(posture);
 8015e50:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    int_posture = __get_interrupt_posture();
 8015e52:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("CPSID i" : : : "memory");
 8015e54:	b672      	cpsid	i
    return(int_posture);
 8015e56:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    }

    /* Disable interrupts.  */
    TX_DISABLE
 8015e58:	66fb      	str	r3, [r7, #108]	; 0x6c

    /* Decrement the preempt disable flag.  */
    _tx_thread_preempt_disable--;
 8015e5a:	4b3e      	ldr	r3, [pc, #248]	; (8015f54 <_txm_module_manager_thread_create+0x1b4>)
 8015e5c:	681b      	ldr	r3, [r3, #0]
 8015e5e:	3b01      	subs	r3, #1
 8015e60:	4a3c      	ldr	r2, [pc, #240]	; (8015f54 <_txm_module_manager_thread_create+0x1b4>)
 8015e62:	6013      	str	r3, [r2, #0]
 8015e64:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8015e66:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015e68:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8015e6a:	f383 8810 	msr	PRIMASK, r3
}
 8015e6e:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 8015e70:	f7f6 faa2 	bl	800c3b8 <_tx_thread_system_preempt_check>

    /* At this point, check to see if there is a duplicate thread.  */
    if (thread_ptr == next_thread)
 8015e74:	68fa      	ldr	r2, [r7, #12]
 8015e76:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8015e78:	429a      	cmp	r2, r3
 8015e7a:	d101      	bne.n	8015e80 <_txm_module_manager_thread_create+0xe0>
    {

        /* Thread is already created, return appropriate error code.  */
        return(TX_THREAD_ERROR);
 8015e7c:	230e      	movs	r3, #14
 8015e7e:	e1d4      	b.n	801622a <_txm_module_manager_thread_create+0x48a>
    }

    /* Check for invalid starting address of stack.  */
    if (stack_start == TX_NULL)
 8015e80:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8015e84:	2b00      	cmp	r3, #0
 8015e86:	d101      	bne.n	8015e8c <_txm_module_manager_thread_create+0xec>
    {

        /* Invalid stack or entry point, return appropriate error code.  */
        return(TX_PTR_ERROR);
 8015e88:	2303      	movs	r3, #3
 8015e8a:	e1ce      	b.n	801622a <_txm_module_manager_thread_create+0x48a>
    }

    /* Check for invalid thread entry point.  */
    if (entry_function == TX_NULL)
 8015e8c:	683b      	ldr	r3, [r7, #0]
 8015e8e:	2b00      	cmp	r3, #0
 8015e90:	d101      	bne.n	8015e96 <_txm_module_manager_thread_create+0xf6>
    {

        /* Invalid stack or entry point, return appropriate error code.  */
        return(TX_PTR_ERROR);
 8015e92:	2303      	movs	r3, #3
 8015e94:	e1c9      	b.n	801622a <_txm_module_manager_thread_create+0x48a>
    }

    /* Check the stack size.  */
    if (stack_size < TX_MINIMUM_STACK)
 8015e96:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8015e9a:	2bc7      	cmp	r3, #199	; 0xc7
 8015e9c:	d801      	bhi.n	8015ea2 <_txm_module_manager_thread_create+0x102>
    {

        /* Stack is not big enough, return appropriate error code.  */
        return(TX_SIZE_ERROR);
 8015e9e:	2305      	movs	r3, #5
 8015ea0:	e1c3      	b.n	801622a <_txm_module_manager_thread_create+0x48a>
    }

    /* Check the priority specified.  */
    if (priority >= TX_MAX_PRIORITIES)
 8015ea2:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8015ea6:	2b1f      	cmp	r3, #31
 8015ea8:	d901      	bls.n	8015eae <_txm_module_manager_thread_create+0x10e>
    {

        /* Invalid priority selected, return appropriate error code.  */
        return(TX_PRIORITY_ERROR);
 8015eaa:	230f      	movs	r3, #15
 8015eac:	e1bd      	b.n	801622a <_txm_module_manager_thread_create+0x48a>
    }

    /* Check preemption threshold. */
    if (preempt_threshold > priority)
 8015eae:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8015eb2:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8015eb6:	429a      	cmp	r2, r3
 8015eb8:	d901      	bls.n	8015ebe <_txm_module_manager_thread_create+0x11e>
    {

        /* Invalid preempt threshold, return appropriate error code.  */
        return(TX_THRESH_ERROR);
 8015eba:	2318      	movs	r3, #24
 8015ebc:	e1b5      	b.n	801622a <_txm_module_manager_thread_create+0x48a>
    }

    /* Check the start selection.  */
    if (auto_start > TX_AUTO_START)
 8015ebe:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8015ec2:	2b01      	cmp	r3, #1
 8015ec4:	d901      	bls.n	8015eca <_txm_module_manager_thread_create+0x12a>
    {

        /* Invalid auto start selection, return appropriate error code.  */
        return(TX_START_ERROR);
 8015ec6:	2310      	movs	r3, #16
 8015ec8:	e1af      	b.n	801622a <_txm_module_manager_thread_create+0x48a>
#ifndef TX_TIMER_PROCESS_IN_ISR
    {
        TX_THREAD *current_thread;

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(current_thread)
 8015eca:	4b25      	ldr	r3, [pc, #148]	; (8015f60 <_txm_module_manager_thread_create+0x1c0>)
 8015ecc:	681b      	ldr	r3, [r3, #0]
 8015ece:	667b      	str	r3, [r7, #100]	; 0x64

        /* Check for invalid caller of this function.  First check for a calling thread.  */
        if (current_thread == &_tx_timer_thread)
 8015ed0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8015ed2:	4a24      	ldr	r2, [pc, #144]	; (8015f64 <_txm_module_manager_thread_create+0x1c4>)
 8015ed4:	4293      	cmp	r3, r2
 8015ed6:	d101      	bne.n	8015edc <_txm_module_manager_thread_create+0x13c>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            return(TX_CALLER_ERROR);
 8015ed8:	2313      	movs	r3, #19
 8015eda:	e1a6      	b.n	801622a <_txm_module_manager_thread_create+0x48a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8015edc:	f3ef 8305 	mrs	r3, IPSR
 8015ee0:	63bb      	str	r3, [r7, #56]	; 0x38
    return(ipsr_value);
 8015ee2:	6bba      	ldr	r2, [r7, #56]	; 0x38
        }
    }
#endif

    /* Check for interrupt call.  */
    if (TX_THREAD_GET_SYSTEM_STATE() != 0)
 8015ee4:	4b20      	ldr	r3, [pc, #128]	; (8015f68 <_txm_module_manager_thread_create+0x1c8>)
 8015ee6:	681b      	ldr	r3, [r3, #0]
 8015ee8:	4313      	orrs	r3, r2
 8015eea:	2b00      	cmp	r3, #0
 8015eec:	d00b      	beq.n	8015f06 <_txm_module_manager_thread_create+0x166>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8015eee:	f3ef 8305 	mrs	r3, IPSR
 8015ef2:	637b      	str	r3, [r7, #52]	; 0x34
    return(ipsr_value);
 8015ef4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    {

        /* Now, make sure the call is from an interrupt and not initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 8015ef6:	4b1c      	ldr	r3, [pc, #112]	; (8015f68 <_txm_module_manager_thread_create+0x1c8>)
 8015ef8:	681b      	ldr	r3, [r3, #0]
 8015efa:	4313      	orrs	r3, r2
 8015efc:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 8015f00:	d201      	bcs.n	8015f06 <_txm_module_manager_thread_create+0x166>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            return(TX_CALLER_ERROR);
 8015f02:	2313      	movs	r3, #19
 8015f04:	e191      	b.n	801622a <_txm_module_manager_thread_create+0x48a>
#ifndef TX_DISABLE_STACK_FILLING

    /* Set the thread stack to a pattern prior to creating the initial
       stack frame.  This pattern is used by the stack checking routines
       to see how much has been used.  */
    TX_MEMSET(stack_start, ((UCHAR) TX_STACK_FILL), stack_size);
 8015f06:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8015f0a:	21ef      	movs	r1, #239	; 0xef
 8015f0c:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 8015f10:	f000 fd68 	bl	80169e4 <memset>
    stack_start =  TX_ALIGN_TYPE_TO_POINTER_CONVERT(updated_stack_start);
#endif

    /* Allocate the thread entry information at the top of thread's stack - Leaving one
       ULONG worth of 0xEF pattern between the actual stack and the entry info structure.  */
    stack_size =  stack_size - (sizeof(TXM_MODULE_THREAD_ENTRY_INFO) + (3*sizeof(ULONG)));
 8015f14:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8015f18:	3b3c      	subs	r3, #60	; 0x3c
 8015f1a:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

    /* Prepare the thread control block prior to placing it on the created
       list.  */

    /* Initialize thread control block to all zeros.  */
    TX_MEMSET(thread_ptr, 0, sizeof(TX_THREAD));
 8015f1e:	22e8      	movs	r2, #232	; 0xe8
 8015f20:	2100      	movs	r1, #0
 8015f22:	68f8      	ldr	r0, [r7, #12]
 8015f24:	f000 fd5e 	bl	80169e4 <memset>

#if TXM_MODULE_MEMORY_PROTECTION
    /* If this is a memory protected module, allocate a kernel stack.  */
    if((module_instance -> txm_module_instance_property_flags) & TXM_MODULE_MEMORY_PROTECTION)
 8015f28:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015f2c:	68db      	ldr	r3, [r3, #12]
 8015f2e:	f003 0302 	and.w	r3, r3, #2
 8015f32:	2b00      	cmp	r3, #0
 8015f34:	d033      	beq.n	8015f9e <_txm_module_manager_thread_create+0x1fe>
    {
        ULONG status;

        /* Allocate kernel stack space. */
        status = _txm_module_manager_object_allocate((VOID **) &(thread_ptr -> tx_thread_module_kernel_stack_start), TXM_MODULE_KERNEL_STACK_SIZE, module_instance);
 8015f36:	68fb      	ldr	r3, [r7, #12]
 8015f38:	33a4      	adds	r3, #164	; 0xa4
 8015f3a:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8015f3e:	f44f 7140 	mov.w	r1, #768	; 0x300
 8015f42:	4618      	mov	r0, r3
 8015f44:	f7fe ffce 	bl	8014ee4 <_txm_module_manager_object_allocate>
 8015f48:	6638      	str	r0, [r7, #96]	; 0x60
        if(status)
 8015f4a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015f4c:	2b00      	cmp	r3, #0
 8015f4e:	d00d      	beq.n	8015f6c <_txm_module_manager_thread_create+0x1cc>
        {
            return(status);
 8015f50:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015f52:	e16a      	b.n	801622a <_txm_module_manager_thread_create+0x48a>
 8015f54:	2000f054 	.word	0x2000f054
 8015f58:	2000efc0 	.word	0x2000efc0
 8015f5c:	2000efc4 	.word	0x2000efc4
 8015f60:	2000efb8 	.word	0x2000efb8
 8015f64:	2000f108 	.word	0x2000f108
 8015f68:	2000000c 	.word	0x2000000c

#ifndef TX_DISABLE_STACK_FILLING
        /* Set the thread stack to a pattern prior to creating the initial
           stack frame.  This pattern is used by the stack checking routines
           to see how much has been used.  */
        TX_MEMSET(thread_ptr -> tx_thread_module_kernel_stack_start, ((UCHAR) TX_STACK_FILL), TXM_MODULE_KERNEL_STACK_SIZE);
 8015f6c:	68fb      	ldr	r3, [r7, #12]
 8015f6e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 8015f72:	f44f 7240 	mov.w	r2, #768	; 0x300
 8015f76:	21ef      	movs	r1, #239	; 0xef
 8015f78:	4618      	mov	r0, r3
 8015f7a:	f000 fd33 	bl	80169e4 <memset>
#endif

        /* Align kernel stack pointer.  */
        thread_ptr -> tx_thread_module_kernel_stack_end = (VOID *) (((ALIGN_TYPE)(thread_ptr -> tx_thread_module_kernel_stack_start) + TXM_MODULE_KERNEL_STACK_SIZE) & ~0x07);
 8015f7e:	68fb      	ldr	r3, [r7, #12]
 8015f80:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 8015f84:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8015f88:	f023 0307 	bic.w	r3, r3, #7
 8015f8c:	461a      	mov	r2, r3
 8015f8e:	68fb      	ldr	r3, [r7, #12]
 8015f90:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8

        /* Set kernel stack size.  */
        thread_ptr -> tx_thread_module_kernel_stack_size = TXM_MODULE_KERNEL_STACK_SIZE;
 8015f94:	68fb      	ldr	r3, [r7, #12]
 8015f96:	f44f 7240 	mov.w	r2, #768	; 0x300
 8015f9a:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
    }

    /* Place the stack parameters into the thread's control block.  */
    thread_ptr -> tx_thread_module_stack_start =  stack_start;
 8015f9e:	68fb      	ldr	r3, [r7, #12]
 8015fa0:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 8015fa4:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
    thread_ptr -> tx_thread_module_stack_size =   stack_size;
 8015fa8:	68fb      	ldr	r3, [r7, #12]
 8015faa:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8015fae:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
#endif

    /* Place the supplied parameters into the thread's control block.  */
    thread_ptr -> tx_thread_name =                name_ptr;
 8015fb2:	68fb      	ldr	r3, [r7, #12]
 8015fb4:	68ba      	ldr	r2, [r7, #8]
 8015fb6:	629a      	str	r2, [r3, #40]	; 0x28
    thread_ptr -> tx_thread_entry =               entry_function;
 8015fb8:	68fb      	ldr	r3, [r7, #12]
 8015fba:	683a      	ldr	r2, [r7, #0]
 8015fbc:	645a      	str	r2, [r3, #68]	; 0x44
    thread_ptr -> tx_thread_entry_parameter =     entry_input;
 8015fbe:	68fb      	ldr	r3, [r7, #12]
 8015fc0:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 8015fc4:	649a      	str	r2, [r3, #72]	; 0x48
    thread_ptr -> tx_thread_stack_start =         stack_start;
 8015fc6:	68fb      	ldr	r3, [r7, #12]
 8015fc8:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 8015fcc:	60da      	str	r2, [r3, #12]
    thread_ptr -> tx_thread_stack_size =          stack_size;
 8015fce:	68fb      	ldr	r3, [r7, #12]
 8015fd0:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8015fd4:	615a      	str	r2, [r3, #20]
    thread_ptr -> tx_thread_priority =            priority;
 8015fd6:	68fb      	ldr	r3, [r7, #12]
 8015fd8:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8015fdc:	62da      	str	r2, [r3, #44]	; 0x2c
    thread_ptr -> tx_thread_user_priority =       priority;
 8015fde:	68fb      	ldr	r3, [r7, #12]
 8015fe0:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8015fe4:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    thread_ptr -> tx_thread_time_slice =          time_slice;
 8015fe8:	68fb      	ldr	r3, [r7, #12]
 8015fea:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8015fee:	619a      	str	r2, [r3, #24]
    thread_ptr -> tx_thread_new_time_slice =      time_slice;
 8015ff0:	68fb      	ldr	r3, [r7, #12]
 8015ff2:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8015ff6:	61da      	str	r2, [r3, #28]
    thread_ptr -> tx_thread_inherit_priority =    ((UINT) TX_MAX_PRIORITIES);
 8015ff8:	68fb      	ldr	r3, [r7, #12]
 8015ffa:	2220      	movs	r2, #32
 8015ffc:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
    thread_ptr -> tx_thread_smp_core_mapped =  0;
#endif
#endif

    /* Calculate the end of the thread's stack area.  */
    temp_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(stack_start);
 8016000:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8016004:	65fb      	str	r3, [r7, #92]	; 0x5c
    temp_ptr =  (TX_UCHAR_POINTER_ADD(temp_ptr, (stack_size - ((ULONG) 1))));
 8016006:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 801600a:	3b01      	subs	r3, #1
 801600c:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801600e:	4413      	add	r3, r2
 8016010:	65fb      	str	r3, [r7, #92]	; 0x5c
    thread_ptr -> tx_thread_stack_end =         TX_UCHAR_TO_VOID_POINTER_CONVERT(temp_ptr);
 8016012:	68fb      	ldr	r3, [r7, #12]
 8016014:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8016016:	611a      	str	r2, [r3, #16]
#if TXM_MODULE_MEMORY_PROTECTION
    thread_ptr -> tx_thread_module_stack_end =  thread_ptr -> tx_thread_stack_end;
 8016018:	68fb      	ldr	r3, [r7, #12]
 801601a:	691a      	ldr	r2, [r3, #16]
 801601c:	68fb      	ldr	r3, [r7, #12]
 801601e:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
#endif /* TXM_MODULE_MEMORY_PROTECTION */

#ifndef TX_DISABLE_PREEMPTION_THRESHOLD

    /* Preemption-threshold is enabled, setup accordingly.  */
    thread_ptr -> tx_thread_preempt_threshold =       preempt_threshold;
 8016022:	68fb      	ldr	r3, [r7, #12]
 8016024:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8016028:	63da      	str	r2, [r3, #60]	; 0x3c
    thread_ptr -> tx_thread_user_preempt_threshold =  preempt_threshold;
 801602a:	68fb      	ldr	r3, [r7, #12]
 801602c:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8016030:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
        thread_ptr -> tx_thread_user_preempt_threshold =  priority;
    }
#endif

    /* Now fill in the values that are required for thread initialization.  */
    thread_ptr -> tx_thread_state =  TX_SUSPENDED;
 8016034:	68fb      	ldr	r3, [r7, #12]
 8016036:	2203      	movs	r2, #3
 8016038:	631a      	str	r2, [r3, #48]	; 0x30

    /* Setup the necessary fields in the thread timer block.  */
    TX_THREAD_CREATE_TIMEOUT_SETUP(thread_ptr)
 801603a:	68fb      	ldr	r3, [r7, #12]
 801603c:	4a7d      	ldr	r2, [pc, #500]	; (8016234 <_txm_module_manager_thread_create+0x494>)
 801603e:	655a      	str	r2, [r3, #84]	; 0x54
 8016040:	68fa      	ldr	r2, [r7, #12]
 8016042:	68fb      	ldr	r3, [r7, #12]
 8016044:	659a      	str	r2, [r3, #88]	; 0x58
    TX_THREAD_CREATE_INTERNAL_EXTENSION(thread_ptr)

    /* Setup pointer to the thread entry information structure, which will live at the top of each
       module thread's stack. This will allow the module thread entry function to avoid direct
       access to the actual thread control block.  */
    thread_entry_info =  (TXM_MODULE_THREAD_ENTRY_INFO *) (((UCHAR *) thread_ptr -> tx_thread_stack_end) + (2*sizeof(ULONG)) + 1);
 8016046:	68fb      	ldr	r3, [r7, #12]
 8016048:	691b      	ldr	r3, [r3, #16]
 801604a:	3309      	adds	r3, #9
 801604c:	65bb      	str	r3, [r7, #88]	; 0x58
    thread_entry_info =  (TXM_MODULE_THREAD_ENTRY_INFO *) (((ALIGN_TYPE)(thread_entry_info)) & (~0x3));
 801604e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016050:	f023 0303 	bic.w	r3, r3, #3
 8016054:	65bb      	str	r3, [r7, #88]	; 0x58

    /* Build the thread entry information structure.  */
    thread_entry_info -> txm_module_thread_entry_info_thread =                   thread_ptr;
 8016056:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016058:	68fa      	ldr	r2, [r7, #12]
 801605a:	601a      	str	r2, [r3, #0]
    thread_entry_info -> txm_module_thread_entry_info_module =                   module_instance;
 801605c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801605e:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8016062:	605a      	str	r2, [r3, #4]
    thread_entry_info -> txm_module_thread_entry_info_data_base_address =        module_instance -> txm_module_instance_module_data_base_address;
 8016064:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8016068:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 801606a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801606c:	609a      	str	r2, [r3, #8]
    thread_entry_info -> txm_module_thread_entry_info_code_base_address =        module_instance -> txm_module_instance_code_start;
 801606e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8016072:	699a      	ldr	r2, [r3, #24]
 8016074:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016076:	60da      	str	r2, [r3, #12]
    thread_entry_info -> txm_module_thread_entry_info_entry =                    thread_ptr -> tx_thread_entry;
 8016078:	68fb      	ldr	r3, [r7, #12]
 801607a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 801607c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801607e:	611a      	str	r2, [r3, #16]
    thread_entry_info -> txm_module_thread_entry_info_parameter =                thread_ptr -> tx_thread_entry_parameter;
 8016080:	68fb      	ldr	r3, [r7, #12]
 8016082:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8016084:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016086:	615a      	str	r2, [r3, #20]
    thread_entry_info -> txm_module_thread_entry_info_callback_request_queue =   &(module_instance -> txm_module_instance_callback_request_queue);
 8016088:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801608c:	f503 7228 	add.w	r2, r3, #672	; 0x2a0
 8016090:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016092:	625a      	str	r2, [r3, #36]	; 0x24
    thread_entry_info -> txm_module_thread_entry_info_callback_request_thread =  &(module_instance -> txm_module_instance_callback_request_thread);
 8016094:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8016098:	f503 72dc 	add.w	r2, r3, #440	; 0x1b8
 801609c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801609e:	621a      	str	r2, [r3, #32]

    /* Populate thread control block with some stock information from the module.  */
    TXM_MODULE_MANAGER_THREAD_SETUP(thread_ptr, module_instance)
 80160a0:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80160a4:	68db      	ldr	r3, [r3, #12]
 80160a6:	f003 0201 	and.w	r2, r3, #1
 80160aa:	68fb      	ldr	r3, [r7, #12]
 80160ac:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
 80160b0:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80160b4:	68db      	ldr	r3, [r3, #12]
 80160b6:	f003 0201 	and.w	r2, r3, #1
 80160ba:	68fb      	ldr	r3, [r7, #12]
 80160bc:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
 80160c0:	68fb      	ldr	r3, [r7, #12]
 80160c2:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80160c6:	2b00      	cmp	r3, #0
 80160c8:	d003      	beq.n	80160d2 <_txm_module_manager_thread_create+0x332>
 80160ca:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80160cc:	4a5a      	ldr	r2, [pc, #360]	; (8016238 <_txm_module_manager_thread_create+0x498>)
 80160ce:	62da      	str	r2, [r3, #44]	; 0x2c
 80160d0:	e002      	b.n	80160d8 <_txm_module_manager_thread_create+0x338>
 80160d2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80160d4:	4a59      	ldr	r2, [pc, #356]	; (801623c <_txm_module_manager_thread_create+0x49c>)
 80160d6:	62da      	str	r2, [r3, #44]	; 0x2c

#ifndef TX_DISABLE_NOTIFY_CALLBACKS
    thread_entry_info ->  txm_module_thread_entry_info_exit_notify =        thread_ptr -> tx_thread_entry_exit_notify;
 80160d8:	68fb      	ldr	r3, [r7, #12]
 80160da:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80160de:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80160e0:	619a      	str	r2, [r3, #24]
#else /* TX_DISABLE_NOTIFY_CALLBACKS */
    thread_entry_info ->  txm_module_thread_entry_info_exit_notify =        TX_NULL;
#endif /* TX_DISABLE_NOTIFY_CALLBACKS */
    if (thread_ptr -> tx_thread_entry == module_instance -> txm_module_instance_start_thread_entry)
 80160e2:	68fb      	ldr	r3, [r7, #12]
 80160e4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80160e6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80160ea:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80160ec:	429a      	cmp	r2, r3
 80160ee:	d103      	bne.n	80160f8 <_txm_module_manager_thread_create+0x358>
        thread_entry_info ->  txm_module_thread_entry_info_start_thread =   TX_TRUE;
 80160f0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80160f2:	2201      	movs	r2, #1
 80160f4:	61da      	str	r2, [r3, #28]
 80160f6:	e002      	b.n	80160fe <_txm_module_manager_thread_create+0x35e>
    else
        thread_entry_info ->  txm_module_thread_entry_info_start_thread =   TX_FALSE;
 80160f8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80160fa:	2200      	movs	r2, #0
 80160fc:	61da      	str	r2, [r3, #28]

    /* Place pointers to the thread info and module instance in the thread control block.  */
    thread_ptr -> tx_thread_module_instance_ptr =    (VOID *) module_instance;
 80160fe:	68fb      	ldr	r3, [r7, #12]
 8016100:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8016104:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    thread_ptr -> tx_thread_module_entry_info_ptr =  (VOID *) thread_entry_info;
 8016108:	68fb      	ldr	r3, [r7, #12]
 801610a:	6dba      	ldr	r2, [r7, #88]	; 0x58
 801610c:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

    /* Place the thread entry information pointer in the thread control block so it can be picked up
       in the following stack build function. This is supplied to the module's shell entry function
       to avoid direct access to the actual thread control block. Note that this is overwritten
       with the actual stack pointer at the end of stack build.  */
    thread_ptr -> tx_thread_stack_ptr =  (VOID *) thread_entry_info;
 8016110:	68fb      	ldr	r3, [r7, #12]
 8016112:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8016114:	609a      	str	r2, [r3, #8]

    /* Call the target specific stack frame building routine to build the
       thread's initial stack and to setup the actual stack pointer in the
       control block.  */
    _txm_module_manager_thread_stack_build(thread_ptr, shell_function);
 8016116:	6879      	ldr	r1, [r7, #4]
 8016118:	68f8      	ldr	r0, [r7, #12]
 801611a:	f7ea fb39 	bl	8000790 <_txm_module_manager_thread_stack_build>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801611e:	f3ef 8310 	mrs	r3, PRIMASK
 8016122:	633b      	str	r3, [r7, #48]	; 0x30
    return(posture);
 8016124:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    int_posture = __get_interrupt_posture();
 8016126:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("CPSID i" : : : "memory");
 8016128:	b672      	cpsid	i
    return(int_posture);
 801612a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    /* Setup the highest usage stack pointer.  */
    thread_ptr -> tx_thread_stack_highest_ptr =  thread_ptr -> tx_thread_stack_ptr;
#endif

    /* Prepare to make this thread a member of the created thread list.  */
    TX_DISABLE
 801612c:	66fb      	str	r3, [r7, #108]	; 0x6c

    /* Load the thread ID field in the thread control block.  */
    thread_ptr -> tx_thread_id =  TX_THREAD_ID;
 801612e:	68fb      	ldr	r3, [r7, #12]
 8016130:	4a43      	ldr	r2, [pc, #268]	; (8016240 <_txm_module_manager_thread_create+0x4a0>)
 8016132:	601a      	str	r2, [r3, #0]

    /* Place the thread on the list of created threads.  First,
       check for an empty list.  */
    if (_tx_thread_created_count == TX_EMPTY)
 8016134:	4b43      	ldr	r3, [pc, #268]	; (8016244 <_txm_module_manager_thread_create+0x4a4>)
 8016136:	681b      	ldr	r3, [r3, #0]
 8016138:	2b00      	cmp	r3, #0
 801613a:	d10b      	bne.n	8016154 <_txm_module_manager_thread_create+0x3b4>
    {

        /* The created thread list is empty.  Add thread to empty list.  */
        _tx_thread_created_ptr =                    thread_ptr;
 801613c:	4a42      	ldr	r2, [pc, #264]	; (8016248 <_txm_module_manager_thread_create+0x4a8>)
 801613e:	68fb      	ldr	r3, [r7, #12]
 8016140:	6013      	str	r3, [r2, #0]
        thread_ptr -> tx_thread_created_next =      thread_ptr;
 8016142:	68fb      	ldr	r3, [r7, #12]
 8016144:	68fa      	ldr	r2, [r7, #12]
 8016146:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        thread_ptr -> tx_thread_created_previous =  thread_ptr;
 801614a:	68fb      	ldr	r3, [r7, #12]
 801614c:	68fa      	ldr	r2, [r7, #12]
 801614e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
 8016152:	e016      	b.n	8016182 <_txm_module_manager_thread_create+0x3e2>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_thread =  _tx_thread_created_ptr;
 8016154:	4b3c      	ldr	r3, [pc, #240]	; (8016248 <_txm_module_manager_thread_create+0x4a8>)
 8016156:	681b      	ldr	r3, [r3, #0]
 8016158:	67fb      	str	r3, [r7, #124]	; 0x7c
        previous_thread =  next_thread -> tx_thread_created_previous;
 801615a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 801615c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8016160:	657b      	str	r3, [r7, #84]	; 0x54

        /* Place the new thread in the list.  */
        next_thread -> tx_thread_created_previous =  thread_ptr;
 8016162:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8016164:	68fa      	ldr	r2, [r7, #12]
 8016166:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        previous_thread -> tx_thread_created_next =  thread_ptr;
 801616a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801616c:	68fa      	ldr	r2, [r7, #12]
 801616e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

        /* Setup this thread's created links.  */
        thread_ptr -> tx_thread_created_previous =  previous_thread;
 8016172:	68fb      	ldr	r3, [r7, #12]
 8016174:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8016176:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        thread_ptr -> tx_thread_created_next =      next_thread;
 801617a:	68fb      	ldr	r3, [r7, #12]
 801617c:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 801617e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    }

    /* Increment the thread created count.  */
    _tx_thread_created_count++;
 8016182:	4b30      	ldr	r3, [pc, #192]	; (8016244 <_txm_module_manager_thread_create+0x4a4>)
 8016184:	681b      	ldr	r3, [r3, #0]
 8016186:	3301      	adds	r3, #1
 8016188:	4a2e      	ldr	r2, [pc, #184]	; (8016244 <_txm_module_manager_thread_create+0x4a4>)
 801618a:	6013      	str	r3, [r2, #0]
#else /* TX_THREAD_SMP */

#ifndef TX_NOT_INTERRUPTABLE

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 801618c:	4b2f      	ldr	r3, [pc, #188]	; (801624c <_txm_module_manager_thread_create+0x4ac>)
 801618e:	681b      	ldr	r3, [r3, #0]
 8016190:	3301      	adds	r3, #1
 8016192:	4a2e      	ldr	r2, [pc, #184]	; (801624c <_txm_module_manager_thread_create+0x4ac>)
 8016194:	6013      	str	r3, [r2, #0]
#endif

    /* Determine if an automatic start was requested.  If so, call the resume
       thread function and then check for a preemption condition.  */
    if (auto_start == TX_AUTO_START)
 8016196:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 801619a:	2b01      	cmp	r3, #1
 801619c:	d129      	bne.n	80161f2 <_txm_module_manager_thread_create+0x452>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 801619e:	f3ef 8305 	mrs	r3, IPSR
 80161a2:	62bb      	str	r3, [r7, #40]	; 0x28
    return(ipsr_value);
 80161a4:	6aba      	ldr	r2, [r7, #40]	; 0x28
    {

        /* Determine if the create call is being called from initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() >= TX_INITIALIZE_IN_PROGRESS)
 80161a6:	4b2a      	ldr	r3, [pc, #168]	; (8016250 <_txm_module_manager_thread_create+0x4b0>)
 80161a8:	681b      	ldr	r3, [r3, #0]
 80161aa:	4313      	orrs	r3, r2
 80161ac:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 80161b0:	d30d      	bcc.n	80161ce <_txm_module_manager_thread_create+0x42e>

            /* Pickup the current thread execute pointer, which corresponds to the
               highest priority thread ready to execute.  Interrupt lockout is
               not required, since interrupts are assumed to be disabled during
               initialization.  */
            saved_thread_ptr =  _tx_thread_execute_ptr;
 80161b2:	4b28      	ldr	r3, [pc, #160]	; (8016254 <_txm_module_manager_thread_create+0x4b4>)
 80161b4:	681b      	ldr	r3, [r3, #0]
 80161b6:	67bb      	str	r3, [r7, #120]	; 0x78

            /* Determine if there is thread ready for execution.  */
            if (saved_thread_ptr != TX_NULL)
 80161b8:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80161ba:	2b00      	cmp	r3, #0
 80161bc:	d009      	beq.n	80161d2 <_txm_module_manager_thread_create+0x432>
            {

                /* Yes, a thread is ready for execution when initialization completes.  */

                /* Save the current preemption-threshold.  */
                saved_threshold =  saved_thread_ptr -> tx_thread_preempt_threshold;
 80161be:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80161c0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80161c2:	677b      	str	r3, [r7, #116]	; 0x74

                /* For initialization, temporarily set the preemption-threshold to the
                   priority level to make sure the highest-priority thread runs once
                   initialization is complete.  */
                saved_thread_ptr -> tx_thread_preempt_threshold =  saved_thread_ptr -> tx_thread_priority;
 80161c4:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80161c6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80161c8:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80161ca:	63da      	str	r2, [r3, #60]	; 0x3c
 80161cc:	e001      	b.n	80161d2 <_txm_module_manager_thread_create+0x432>
        }
        else
        {

            /* Simply set the saved thread pointer to NULL.  */
            saved_thread_ptr =  TX_NULL;
 80161ce:	2300      	movs	r3, #0
 80161d0:	67bb      	str	r3, [r7, #120]	; 0x78
 80161d2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80161d4:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80161d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80161d8:	f383 8810 	msr	PRIMASK, r3
}
 80161dc:	bf00      	nop

        /* Perform any additional activities for tool or user purpose.  */
        TX_THREAD_CREATE_EXTENSION(thread_ptr)

        /* Call the resume thread function to make this thread ready.  */
        _tx_thread_system_resume(thread_ptr);
 80161de:	68f8      	ldr	r0, [r7, #12]
 80161e0:	f7f6 f924 	bl	800c42c <_tx_thread_system_resume>
#endif

        /* Determine if the thread's preemption-threshold needs to be restored.  */
        if (saved_thread_ptr != TX_NULL)
 80161e4:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80161e6:	2b00      	cmp	r3, #0
 80161e8:	d01e      	beq.n	8016228 <_txm_module_manager_thread_create+0x488>
        {

            /* Yes, restore the previous highest-priority thread's preemption-threshold. This
               can only happen if this routine is called from initialization.  */
            saved_thread_ptr -> tx_thread_preempt_threshold =  saved_threshold;
 80161ea:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80161ec:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 80161ee:	63da      	str	r2, [r3, #60]	; 0x3c
 80161f0:	e01a      	b.n	8016228 <_txm_module_manager_thread_create+0x488>
 80161f2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80161f4:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80161f6:	697b      	ldr	r3, [r7, #20]
 80161f8:	f383 8810 	msr	PRIMASK, r3
}
 80161fc:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80161fe:	f3ef 8310 	mrs	r3, PRIMASK
 8016202:	61fb      	str	r3, [r7, #28]
    return(posture);
 8016204:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 8016206:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8016208:	b672      	cpsid	i
    return(int_posture);
 801620a:	69bb      	ldr	r3, [r7, #24]

        /* Perform any additional activities for tool or user purpose.  */
        TX_THREAD_CREATE_EXTENSION(thread_ptr)

        /* Disable interrupts.  */
        TX_DISABLE
 801620c:	66fb      	str	r3, [r7, #108]	; 0x6c

        /* Re-enable preemption.  */
        _tx_thread_preempt_disable--;
 801620e:	4b0f      	ldr	r3, [pc, #60]	; (801624c <_txm_module_manager_thread_create+0x4ac>)
 8016210:	681b      	ldr	r3, [r3, #0]
 8016212:	3b01      	subs	r3, #1
 8016214:	4a0d      	ldr	r2, [pc, #52]	; (801624c <_txm_module_manager_thread_create+0x4ac>)
 8016216:	6013      	str	r3, [r2, #0]
 8016218:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801621a:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801621c:	6a3b      	ldr	r3, [r7, #32]
 801621e:	f383 8810 	msr	PRIMASK, r3
}
 8016222:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 8016224:	f7f6 f8c8 	bl	800c3b8 <_tx_thread_system_preempt_check>
    }

#endif /* TX_THREAD_SMP */

    /* Return success.  */
    return(TX_SUCCESS);
 8016228:	2300      	movs	r3, #0
}
 801622a:	4618      	mov	r0, r3
 801622c:	3780      	adds	r7, #128	; 0x80
 801622e:	46bd      	mov	sp, r7
 8016230:	bd80      	pop	{r7, pc}
 8016232:	bf00      	nop
 8016234:	0800cd9d 	.word	0x0800cd9d
 8016238:	080006e1 	.word	0x080006e1
 801623c:	080145b1 	.word	0x080145b1
 8016240:	54485244 	.word	0x54485244
 8016244:	2000efc4 	.word	0x2000efc4
 8016248:	2000efc0 	.word	0x2000efc0
 801624c:	2000f054 	.word	0x2000f054
 8016250:	2000000c 	.word	0x2000000c
 8016254:	2000efbc 	.word	0x2000efbc

08016258 <_txm_module_manager_thread_notify_trampoline>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
VOID  _txm_module_manager_thread_notify_trampoline(TX_THREAD *thread_ptr, UINT type)
{
 8016258:	b580      	push	{r7, lr}
 801625a:	b098      	sub	sp, #96	; 0x60
 801625c:	af00      	add	r7, sp, #0
 801625e:	6078      	str	r0, [r7, #4]
 8016260:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8016262:	f3ef 8310 	mrs	r3, PRIMASK
 8016266:	64fb      	str	r3, [r7, #76]	; 0x4c
    return(posture);
 8016268:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    int_posture = __get_interrupt_posture();
 801626a:	64bb      	str	r3, [r7, #72]	; 0x48
    __asm__ volatile ("CPSID i" : : : "memory");
 801626c:	b672      	cpsid	i
    return(int_posture);
 801626e:	6cbb      	ldr	r3, [r7, #72]	; 0x48


    /* We now know the callback is for a module.  */

    /* Disable interrupts.  */
    TX_DISABLE
 8016270:	65fb      	str	r3, [r7, #92]	; 0x5c

    /* Determine if the thread is valid.  */
    if ((thread_ptr) && (thread_ptr -> tx_thread_id == TX_THREAD_ID))
 8016272:	687b      	ldr	r3, [r7, #4]
 8016274:	2b00      	cmp	r3, #0
 8016276:	d050      	beq.n	801631a <_txm_module_manager_thread_notify_trampoline+0xc2>
 8016278:	687b      	ldr	r3, [r7, #4]
 801627a:	681b      	ldr	r3, [r3, #0]
 801627c:	4a2e      	ldr	r2, [pc, #184]	; (8016338 <_txm_module_manager_thread_notify_trampoline+0xe0>)
 801627e:	4293      	cmp	r3, r2
 8016280:	d14b      	bne.n	801631a <_txm_module_manager_thread_notify_trampoline+0xc2>
    {

        /* Pickup the module instance pointer.  */
        module_instance =  (TXM_MODULE_INSTANCE *) thread_ptr -> tx_thread_module_instance_ptr;
 8016282:	687b      	ldr	r3, [r7, #4]
 8016284:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8016288:	65bb      	str	r3, [r7, #88]	; 0x58

        /* Pickup the module's thread pointer.  */
        thread_info =  (TXM_MODULE_THREAD_ENTRY_INFO *) thread_ptr -> tx_thread_module_entry_info_ptr;
 801628a:	687b      	ldr	r3, [r7, #4]
 801628c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8016290:	657b      	str	r3, [r7, #84]	; 0x54

        /* Determine if this module is still valid.  */
        if ((module_instance) && (module_instance -> txm_module_instance_id == TXM_MODULE_ID) &&
 8016292:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016294:	2b00      	cmp	r3, #0
 8016296:	d034      	beq.n	8016302 <_txm_module_manager_thread_notify_trampoline+0xaa>
 8016298:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801629a:	681b      	ldr	r3, [r3, #0]
 801629c:	4a27      	ldr	r2, [pc, #156]	; (801633c <_txm_module_manager_thread_notify_trampoline+0xe4>)
 801629e:	4293      	cmp	r3, r2
 80162a0:	d12f      	bne.n	8016302 <_txm_module_manager_thread_notify_trampoline+0xaa>
            (module_instance -> txm_module_instance_state == TXM_MODULE_STARTED))
 80162a2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80162a4:	689b      	ldr	r3, [r3, #8]
        if ((module_instance) && (module_instance -> txm_module_instance_id == TXM_MODULE_ID) &&
 80162a6:	2b02      	cmp	r3, #2
 80162a8:	d12b      	bne.n	8016302 <_txm_module_manager_thread_notify_trampoline+0xaa>
        {

            /* Yes, the module is still valid.  */

            /* Pickup the module's callback message queue.  */
            module_callback_queue =  &(module_instance -> txm_module_instance_callback_request_queue);
 80162aa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80162ac:	f503 7328 	add.w	r3, r3, #672	; 0x2a0
 80162b0:	653b      	str	r3, [r7, #80]	; 0x50

            /* Build the queue notification message.  */
            callback_message.txm_module_callback_message_type =                  TXM_THREAD_ENTRY_EXIT_CALLBACK;
 80162b2:	2304      	movs	r3, #4
 80162b4:	60bb      	str	r3, [r7, #8]
            callback_message.txm_module_callback_message_activation_count =      1;
 80162b6:	2301      	movs	r3, #1
 80162b8:	60fb      	str	r3, [r7, #12]
            callback_message.txm_module_callback_message_application_function =  (VOID (*)(VOID)) thread_info -> txm_module_thread_entry_info_exit_notify;
 80162ba:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80162bc:	699b      	ldr	r3, [r3, #24]
 80162be:	613b      	str	r3, [r7, #16]
            callback_message.txm_module_callback_message_param_1 =               (ALIGN_TYPE) thread_ptr;
 80162c0:	687b      	ldr	r3, [r7, #4]
 80162c2:	617b      	str	r3, [r7, #20]
            callback_message.txm_module_callback_message_param_2 =               (ALIGN_TYPE) type;
 80162c4:	683b      	ldr	r3, [r7, #0]
 80162c6:	61bb      	str	r3, [r7, #24]
            callback_message.txm_module_callback_message_param_3 =               0;
 80162c8:	2300      	movs	r3, #0
 80162ca:	61fb      	str	r3, [r7, #28]
            callback_message.txm_module_callback_message_param_4 =               0;
 80162cc:	2300      	movs	r3, #0
 80162ce:	623b      	str	r3, [r7, #32]
            callback_message.txm_module_callback_message_param_5 =               0;
 80162d0:	2300      	movs	r3, #0
 80162d2:	627b      	str	r3, [r7, #36]	; 0x24
            callback_message.txm_module_callback_message_param_6 =               0;
 80162d4:	2300      	movs	r3, #0
 80162d6:	62bb      	str	r3, [r7, #40]	; 0x28
            callback_message.txm_module_callback_message_param_7 =               0;
 80162d8:	2300      	movs	r3, #0
 80162da:	62fb      	str	r3, [r7, #44]	; 0x2c
            callback_message.txm_module_callback_message_param_8 =               0;
 80162dc:	2300      	movs	r3, #0
 80162de:	633b      	str	r3, [r7, #48]	; 0x30
            callback_message.txm_module_callback_message_reserved1 =             0;
 80162e0:	2300      	movs	r3, #0
 80162e2:	637b      	str	r3, [r7, #52]	; 0x34
            callback_message.txm_module_callback_message_reserved2 =             0;
 80162e4:	2300      	movs	r3, #0
 80162e6:	63bb      	str	r3, [r7, #56]	; 0x38
 80162e8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80162ea:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80162ec:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80162ee:	f383 8810 	msr	PRIMASK, r3
}
 80162f2:	bf00      	nop
            /* Restore interrupts.  */
            TX_RESTORE

            /* Call the general processing that will place the callback on the
               module's callback request queue.  */
            _txm_module_manager_callback_request(module_callback_queue, &callback_message);
 80162f4:	f107 0308 	add.w	r3, r7, #8
 80162f8:	4619      	mov	r1, r3
 80162fa:	6d38      	ldr	r0, [r7, #80]	; 0x50
 80162fc:	f7f9 fb84 	bl	800fa08 <_txm_module_manager_callback_request>
 8016300:	e00a      	b.n	8016318 <_txm_module_manager_thread_notify_trampoline+0xc0>
        {

            /* Module no longer valid.  */

            /* Error, increment the error counter and return.  */
            _txm_module_manager_callback_error_count++;
 8016302:	4b0f      	ldr	r3, [pc, #60]	; (8016340 <_txm_module_manager_thread_notify_trampoline+0xe8>)
 8016304:	681b      	ldr	r3, [r3, #0]
 8016306:	3301      	adds	r3, #1
 8016308:	4a0d      	ldr	r2, [pc, #52]	; (8016340 <_txm_module_manager_thread_notify_trampoline+0xe8>)
 801630a:	6013      	str	r3, [r2, #0]
 801630c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801630e:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8016310:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016312:	f383 8810 	msr	PRIMASK, r3
}
 8016316:	bf00      	nop
        if ((module_instance) && (module_instance -> txm_module_instance_id == TXM_MODULE_ID) &&
 8016318:	e00a      	b.n	8016330 <_txm_module_manager_thread_notify_trampoline+0xd8>
    {

        /* Thread pointer is not valid.  */

        /* Error, increment the error counter and return.  */
        _txm_module_manager_callback_error_count++;
 801631a:	4b09      	ldr	r3, [pc, #36]	; (8016340 <_txm_module_manager_thread_notify_trampoline+0xe8>)
 801631c:	681b      	ldr	r3, [r3, #0]
 801631e:	3301      	adds	r3, #1
 8016320:	4a07      	ldr	r2, [pc, #28]	; (8016340 <_txm_module_manager_thread_notify_trampoline+0xe8>)
 8016322:	6013      	str	r3, [r2, #0]
 8016324:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8016326:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8016328:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801632a:	f383 8810 	msr	PRIMASK, r3
}
 801632e:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
    }
}
 8016330:	bf00      	nop
 8016332:	3760      	adds	r7, #96	; 0x60
 8016334:	46bd      	mov	sp, r7
 8016336:	bd80      	pop	{r7, pc}
 8016338:	54485244 	.word	0x54485244
 801633c:	4d4f4455 	.word	0x4d4f4455
 8016340:	2000f6b8 	.word	0x2000f6b8

08016344 <_txm_module_manager_thread_reset>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
UINT  _txm_module_manager_thread_reset(TX_THREAD *thread_ptr)
{
 8016344:	b580      	push	{r7, lr}
 8016346:	b08e      	sub	sp, #56	; 0x38
 8016348:	af00      	add	r7, sp, #0
 801634a:	6078      	str	r0, [r7, #4]
UINT            status;
TXM_MODULE_INSTANCE             *module_instance;
TXM_MODULE_THREAD_ENTRY_INFO    *thread_entry_info;

    /* Default a successful completion status.  */
    status =  TX_SUCCESS;
 801634c:	2300      	movs	r3, #0
 801634e:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8016350:	f3ef 8310 	mrs	r3, PRIMASK
 8016354:	623b      	str	r3, [r7, #32]
    return(posture);
 8016356:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 8016358:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 801635a:	b672      	cpsid	i
    return(int_posture);
 801635c:	69fb      	ldr	r3, [r7, #28]

    /* Disable interrupts.  */
    TX_DISABLE
 801635e:	637b      	str	r3, [r7, #52]	; 0x34

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
 8016360:	4b2c      	ldr	r3, [pc, #176]	; (8016414 <_txm_module_manager_thread_reset+0xd0>)
 8016362:	681b      	ldr	r3, [r3, #0]
 8016364:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Check for a call from the current thread, which is not allowed!  */
    if (current_thread == thread_ptr)
 8016366:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016368:	687b      	ldr	r3, [r7, #4]
 801636a:	429a      	cmp	r2, r3
 801636c:	d108      	bne.n	8016380 <_txm_module_manager_thread_reset+0x3c>
 801636e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016370:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8016372:	69bb      	ldr	r3, [r7, #24]
 8016374:	f383 8810 	msr	PRIMASK, r3
}
 8016378:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Thread not completed or terminated - return an error!  */
        status =  TX_NOT_DONE;
 801637a:	2320      	movs	r3, #32
 801637c:	633b      	str	r3, [r7, #48]	; 0x30
 801637e:	e009      	b.n	8016394 <_txm_module_manager_thread_reset+0x50>
    }
    else
    {

        /* Check for proper status of this thread to reset.  */
        if (thread_ptr -> tx_thread_state != TX_COMPLETED)
 8016380:	687b      	ldr	r3, [r7, #4]
 8016382:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8016384:	2b01      	cmp	r3, #1
 8016386:	d005      	beq.n	8016394 <_txm_module_manager_thread_reset+0x50>
        {

            /* Now check for terminated state.  */
            if (thread_ptr -> tx_thread_state != TX_TERMINATED)
 8016388:	687b      	ldr	r3, [r7, #4]
 801638a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801638c:	2b02      	cmp	r3, #2
 801638e:	d001      	beq.n	8016394 <_txm_module_manager_thread_reset+0x50>
            {

                /* Thread not completed or terminated - return an error!  */
                status =  TX_NOT_DONE;
 8016390:	2320      	movs	r3, #32
 8016392:	633b      	str	r3, [r7, #48]	; 0x30
            }
        }
    }

    /* Is the request valid?  */
    if (status == TX_SUCCESS)
 8016394:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016396:	2b00      	cmp	r3, #0
 8016398:	d130      	bne.n	80163fc <_txm_module_manager_thread_reset+0xb8>
    {

        /* Modify the thread status to prevent additional reset calls.  */
        thread_ptr -> tx_thread_state =  TX_NOT_DONE;
 801639a:	687b      	ldr	r3, [r7, #4]
 801639c:	2220      	movs	r2, #32
 801639e:	631a      	str	r2, [r3, #48]	; 0x30

        /* Get the module instance.  */
        module_instance =  thread_ptr -> tx_thread_module_instance_ptr;
 80163a0:	687b      	ldr	r3, [r7, #4]
 80163a2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80163a6:	62bb      	str	r3, [r7, #40]	; 0x28
 80163a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80163aa:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80163ac:	68fb      	ldr	r3, [r7, #12]
 80163ae:	f383 8810 	msr	PRIMASK, r3
}
 80163b2:	bf00      	nop
#ifndef TX_DISABLE_STACK_FILLING

        /* Set the thread stack to a pattern prior to creating the initial
           stack frame.  This pattern is used by the stack checking routines
           to see how much has been used.  */
        TX_MEMSET(thread_ptr -> tx_thread_stack_start, ((UCHAR) TX_STACK_FILL), thread_ptr -> tx_thread_stack_size);
 80163b4:	687b      	ldr	r3, [r7, #4]
 80163b6:	68d8      	ldr	r0, [r3, #12]
 80163b8:	687b      	ldr	r3, [r7, #4]
 80163ba:	695b      	ldr	r3, [r3, #20]
 80163bc:	461a      	mov	r2, r3
 80163be:	21ef      	movs	r1, #239	; 0xef
 80163c0:	f000 fb10 	bl	80169e4 <memset>
#endif

        /* Setup pointer to the thread entry information structure, which will live at the top of each
           module thread's stack. This will allow the module thread entry function to avoid direct
           access to the actual thread control block.  */
        thread_entry_info =  (TXM_MODULE_THREAD_ENTRY_INFO *) (((UCHAR *) thread_ptr -> tx_thread_stack_end) + (2*sizeof(ULONG)) + 1);
 80163c4:	687b      	ldr	r3, [r7, #4]
 80163c6:	691b      	ldr	r3, [r3, #16]
 80163c8:	3309      	adds	r3, #9
 80163ca:	627b      	str	r3, [r7, #36]	; 0x24
        thread_entry_info =  (TXM_MODULE_THREAD_ENTRY_INFO *) (((ALIGN_TYPE)(thread_entry_info)) & (~0x3));
 80163cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80163ce:	f023 0303 	bic.w	r3, r3, #3
 80163d2:	627b      	str	r3, [r7, #36]	; 0x24

        /* Place the thread entry information pointer in the thread control block so it can be picked up
           in the following stack build function. This is supplied to the module's shell entry function
           to avoid direct access to the actual thread control block. Note that this is overwritten
           with the actual stack pointer at the end of stack build.  */
        thread_ptr -> tx_thread_stack_ptr =  (VOID *) thread_entry_info;
 80163d4:	687b      	ldr	r3, [r7, #4]
 80163d6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80163d8:	609a      	str	r2, [r3, #8]

        /* Call the target specific stack frame building routine to build the
           thread's initial stack and to setup the actual stack pointer in the
           control block.  */
        _txm_module_manager_thread_stack_build(thread_ptr, module_instance -> txm_module_instance_shell_entry_function);
 80163da:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80163dc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80163de:	4619      	mov	r1, r3
 80163e0:	6878      	ldr	r0, [r7, #4]
 80163e2:	f7ea f9d5 	bl	8000790 <_txm_module_manager_thread_stack_build>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80163e6:	f3ef 8310 	mrs	r3, PRIMASK
 80163ea:	617b      	str	r3, [r7, #20]
    return(posture);
 80163ec:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 80163ee:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 80163f0:	b672      	cpsid	i
    return(int_posture);
 80163f2:	693b      	ldr	r3, [r7, #16]

        /* Disable interrupts.  */
        TX_DISABLE
 80163f4:	637b      	str	r3, [r7, #52]	; 0x34

        /* Finally, move into a suspended state to allow for the thread to be resumed.  */
        thread_ptr -> tx_thread_state =  TX_SUSPENDED;
 80163f6:	687b      	ldr	r3, [r7, #4]
 80163f8:	2203      	movs	r2, #3
 80163fa:	631a      	str	r2, [r3, #48]	; 0x30
 80163fc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80163fe:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8016400:	68bb      	ldr	r3, [r7, #8]
 8016402:	f383 8810 	msr	PRIMASK, r3
}
 8016406:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status to caller.  */
    return(status);
 8016408:	6b3b      	ldr	r3, [r7, #48]	; 0x30
}
 801640a:	4618      	mov	r0, r3
 801640c:	3738      	adds	r7, #56	; 0x38
 801640e:	46bd      	mov	sp, r7
 8016410:	bd80      	pop	{r7, pc}
 8016412:	bf00      	nop
 8016414:	2000efb8 	.word	0x2000efb8

08016418 <_txm_module_manager_timer_notify_trampoline>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
VOID  _txm_module_manager_timer_notify_trampoline(ULONG id)
{
 8016418:	b580      	push	{r7, lr}
 801641a:	b09a      	sub	sp, #104	; 0x68
 801641c:	af00      	add	r7, sp, #0
 801641e:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8016420:	f3ef 8310 	mrs	r3, PRIMASK
 8016424:	64fb      	str	r3, [r7, #76]	; 0x4c
    return(posture);
 8016426:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    int_posture = __get_interrupt_posture();
 8016428:	64bb      	str	r3, [r7, #72]	; 0x48
    __asm__ volatile ("CPSID i" : : : "memory");
 801642a:	b672      	cpsid	i
    return(int_posture);
 801642c:	6cbb      	ldr	r3, [r7, #72]	; 0x48


    /* We now know the callback is for a module.  */

    /* Disable interrupts.  */
    TX_DISABLE
 801642e:	667b      	str	r3, [r7, #100]	; 0x64

    /* Our expired timer pointer points to the internal timer,
     * we need to get to the full timer pointer.  */
    /* Pickup the current internal timer pointer.  */
    internal_ptr =  (CHAR *) _tx_timer_expired_timer_ptr;
 8016430:	4b2a      	ldr	r3, [pc, #168]	; (80164dc <_txm_module_manager_timer_notify_trampoline+0xc4>)
 8016432:	681b      	ldr	r3, [r3, #0]
 8016434:	663b      	str	r3, [r7, #96]	; 0x60

    /* Get the timer pointer from the internal pointer.  */
    TX_USER_TIMER_POINTER_GET((TX_TIMER_INTERNAL *) internal_ptr, timer_ptr);
 8016436:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016438:	65fb      	str	r3, [r7, #92]	; 0x5c
 801643a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801643c:	65bb      	str	r3, [r7, #88]	; 0x58
 801643e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8016440:	3b08      	subs	r3, #8
 8016442:	65fb      	str	r3, [r7, #92]	; 0x5c
 8016444:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8016446:	65bb      	str	r3, [r7, #88]	; 0x58

    /* Pickup the module instance pointer.  */
    module_instance =  (TXM_MODULE_INSTANCE *) timer_ptr -> tx_timer_module_instance;
 8016448:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801644a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801644c:	657b      	str	r3, [r7, #84]	; 0x54

    /* Determine if this module is still valid.  */
    if ((module_instance) && (module_instance -> txm_module_instance_id == TXM_MODULE_ID) &&
 801644e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016450:	2b00      	cmp	r3, #0
 8016452:	d034      	beq.n	80164be <_txm_module_manager_timer_notify_trampoline+0xa6>
 8016454:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016456:	681b      	ldr	r3, [r3, #0]
 8016458:	4a21      	ldr	r2, [pc, #132]	; (80164e0 <_txm_module_manager_timer_notify_trampoline+0xc8>)
 801645a:	4293      	cmp	r3, r2
 801645c:	d12f      	bne.n	80164be <_txm_module_manager_timer_notify_trampoline+0xa6>
        (module_instance -> txm_module_instance_state == TXM_MODULE_STARTED))
 801645e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016460:	689b      	ldr	r3, [r3, #8]
    if ((module_instance) && (module_instance -> txm_module_instance_id == TXM_MODULE_ID) &&
 8016462:	2b02      	cmp	r3, #2
 8016464:	d12b      	bne.n	80164be <_txm_module_manager_timer_notify_trampoline+0xa6>
    {

        /* Yes, the module is still valid.  */

        /* Pickup the module's callback message queue.  */
        module_callback_queue =  &(module_instance -> txm_module_instance_callback_request_queue);
 8016466:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016468:	f503 7328 	add.w	r3, r3, #672	; 0x2a0
 801646c:	653b      	str	r3, [r7, #80]	; 0x50

        /* Build the queue notification message.  */
        callback_message.txm_module_callback_message_type =                  TXM_TIMER_CALLBACK;
 801646e:	2300      	movs	r3, #0
 8016470:	60fb      	str	r3, [r7, #12]
        callback_message.txm_module_callback_message_activation_count =      1;
 8016472:	2301      	movs	r3, #1
 8016474:	613b      	str	r3, [r7, #16]
        callback_message.txm_module_callback_message_application_function =  (VOID (*)(VOID)) timer_ptr -> tx_timer_module_expiration_function;
 8016476:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016478:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801647a:	617b      	str	r3, [r7, #20]
        callback_message.txm_module_callback_message_param_1 =               (ULONG) id;
 801647c:	687b      	ldr	r3, [r7, #4]
 801647e:	61bb      	str	r3, [r7, #24]
        callback_message.txm_module_callback_message_param_2 =               0;
 8016480:	2300      	movs	r3, #0
 8016482:	61fb      	str	r3, [r7, #28]
        callback_message.txm_module_callback_message_param_3 =               0;
 8016484:	2300      	movs	r3, #0
 8016486:	623b      	str	r3, [r7, #32]
        callback_message.txm_module_callback_message_param_4 =               0;
 8016488:	2300      	movs	r3, #0
 801648a:	627b      	str	r3, [r7, #36]	; 0x24
        callback_message.txm_module_callback_message_param_5 =               0;
 801648c:	2300      	movs	r3, #0
 801648e:	62bb      	str	r3, [r7, #40]	; 0x28
        callback_message.txm_module_callback_message_param_6 =               0;
 8016490:	2300      	movs	r3, #0
 8016492:	62fb      	str	r3, [r7, #44]	; 0x2c
        callback_message.txm_module_callback_message_param_7 =               0;
 8016494:	2300      	movs	r3, #0
 8016496:	633b      	str	r3, [r7, #48]	; 0x30
        callback_message.txm_module_callback_message_param_8 =               0;
 8016498:	2300      	movs	r3, #0
 801649a:	637b      	str	r3, [r7, #52]	; 0x34
        callback_message.txm_module_callback_message_reserved1 =             0;
 801649c:	2300      	movs	r3, #0
 801649e:	63bb      	str	r3, [r7, #56]	; 0x38
        callback_message.txm_module_callback_message_reserved2 =             0;
 80164a0:	2300      	movs	r3, #0
 80164a2:	63fb      	str	r3, [r7, #60]	; 0x3c
 80164a4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80164a6:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80164a8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80164aa:	f383 8810 	msr	PRIMASK, r3
}
 80164ae:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE

        /* Call the general processing that will place the callback on the
           module's callback request queue.  */
        _txm_module_manager_callback_request(module_callback_queue, &callback_message);
 80164b0:	f107 030c 	add.w	r3, r7, #12
 80164b4:	4619      	mov	r1, r3
 80164b6:	6d38      	ldr	r0, [r7, #80]	; 0x50
 80164b8:	f7f9 faa6 	bl	800fa08 <_txm_module_manager_callback_request>
 80164bc:	e00a      	b.n	80164d4 <_txm_module_manager_timer_notify_trampoline+0xbc>
    {

        /* Module no longer valid.  */

        /* Error, increment the error counter and return.  */
        _txm_module_manager_callback_error_count++;
 80164be:	4b09      	ldr	r3, [pc, #36]	; (80164e4 <_txm_module_manager_timer_notify_trampoline+0xcc>)
 80164c0:	681b      	ldr	r3, [r3, #0]
 80164c2:	3301      	adds	r3, #1
 80164c4:	4a07      	ldr	r2, [pc, #28]	; (80164e4 <_txm_module_manager_timer_notify_trampoline+0xcc>)
 80164c6:	6013      	str	r3, [r2, #0]
 80164c8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80164ca:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80164cc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80164ce:	f383 8810 	msr	PRIMASK, r3
}
 80164d2:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
    }
}
 80164d4:	bf00      	nop
 80164d6:	3768      	adds	r7, #104	; 0x68
 80164d8:	46bd      	mov	sp, r7
 80164da:	bd80      	pop	{r7, pc}
 80164dc:	2000f104 	.word	0x2000f104
 80164e0:	4d4f4455 	.word	0x4d4f4455
 80164e4:	2000f6b8 	.word	0x2000f6b8

080164e8 <_txm_module_manager_unload>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
UINT  _txm_module_manager_unload(TXM_MODULE_INSTANCE *module_instance)
{
 80164e8:	b580      	push	{r7, lr}
 80164ea:	b08c      	sub	sp, #48	; 0x30
 80164ec:	af00      	add	r7, sp, #0
 80164ee:	6078      	str	r0, [r7, #4]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80164f0:	f3ef 8305 	mrs	r3, IPSR
 80164f4:	61fb      	str	r3, [r7, #28]
    return(ipsr_value);
 80164f6:	69fa      	ldr	r2, [r7, #28]
TXM_MODULE_INSTANCE *next_module, *previous_module;
CHAR                *memory_ptr;


    /* Check for interrupt call.  */
    if (TX_THREAD_GET_SYSTEM_STATE() != 0)
 80164f8:	4b44      	ldr	r3, [pc, #272]	; (801660c <_txm_module_manager_unload+0x124>)
 80164fa:	681b      	ldr	r3, [r3, #0]
 80164fc:	4313      	orrs	r3, r2
 80164fe:	2b00      	cmp	r3, #0
 8016500:	d00b      	beq.n	801651a <_txm_module_manager_unload+0x32>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8016502:	f3ef 8305 	mrs	r3, IPSR
 8016506:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 8016508:	69ba      	ldr	r2, [r7, #24]
    {

        /* Now, make sure the call is from an interrupt and not initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 801650a:	4b40      	ldr	r3, [pc, #256]	; (801660c <_txm_module_manager_unload+0x124>)
 801650c:	681b      	ldr	r3, [r3, #0]
 801650e:	4313      	orrs	r3, r2
 8016510:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 8016514:	d201      	bcs.n	801651a <_txm_module_manager_unload+0x32>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            return(TX_CALLER_ERROR);
 8016516:	2313      	movs	r3, #19
 8016518:	e073      	b.n	8016602 <_txm_module_manager_unload+0x11a>
        }
    }

    /* Determine if the module manager has not been initialized yet.  */
    if (_txm_module_manager_ready != TX_TRUE)
 801651a:	4b3d      	ldr	r3, [pc, #244]	; (8016610 <_txm_module_manager_unload+0x128>)
 801651c:	681b      	ldr	r3, [r3, #0]
 801651e:	2b01      	cmp	r3, #1
 8016520:	d001      	beq.n	8016526 <_txm_module_manager_unload+0x3e>
    {

        /* Module manager has not been initialized.  */
        return(TX_NOT_AVAILABLE);
 8016522:	231d      	movs	r3, #29
 8016524:	e06d      	b.n	8016602 <_txm_module_manager_unload+0x11a>
    }

    /* Determine if the module is valid.  */
    if (module_instance == TX_NULL)
 8016526:	687b      	ldr	r3, [r7, #4]
 8016528:	2b00      	cmp	r3, #0
 801652a:	d101      	bne.n	8016530 <_txm_module_manager_unload+0x48>
    {

        /* Invalid module pointer.  */
        return(TX_PTR_ERROR);
 801652c:	2303      	movs	r3, #3
 801652e:	e068      	b.n	8016602 <_txm_module_manager_unload+0x11a>
    }

    /* Get module manager protection mutex.  */
    _tx_mutex_get(&_txm_module_manager_mutex, TX_WAIT_FOREVER);
 8016530:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8016534:	4837      	ldr	r0, [pc, #220]	; (8016614 <_txm_module_manager_unload+0x12c>)
 8016536:	f7f2 ff57 	bl	80093e8 <_tx_mutex_get>

    /* Determine if the module is already valid.  */
    if (module_instance -> txm_module_instance_id != TXM_MODULE_ID)
 801653a:	687b      	ldr	r3, [r7, #4]
 801653c:	681b      	ldr	r3, [r3, #0]
 801653e:	4a36      	ldr	r2, [pc, #216]	; (8016618 <_txm_module_manager_unload+0x130>)
 8016540:	4293      	cmp	r3, r2
 8016542:	d004      	beq.n	801654e <_txm_module_manager_unload+0x66>
    {

        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 8016544:	4833      	ldr	r0, [pc, #204]	; (8016614 <_txm_module_manager_unload+0x12c>)
 8016546:	f7f3 fa89 	bl	8009a5c <_tx_mutex_put>

        /* Invalid module pointer.  */
        return(TX_PTR_ERROR);
 801654a:	2303      	movs	r3, #3
 801654c:	e059      	b.n	8016602 <_txm_module_manager_unload+0x11a>
    }

    /* Determine if the module instance is in the  state.  */
    if ((module_instance -> txm_module_instance_state != TXM_MODULE_LOADED) && (module_instance -> txm_module_instance_state != TXM_MODULE_STOPPED))
 801654e:	687b      	ldr	r3, [r7, #4]
 8016550:	689b      	ldr	r3, [r3, #8]
 8016552:	2b01      	cmp	r3, #1
 8016554:	d008      	beq.n	8016568 <_txm_module_manager_unload+0x80>
 8016556:	687b      	ldr	r3, [r7, #4]
 8016558:	689b      	ldr	r3, [r3, #8]
 801655a:	2b04      	cmp	r3, #4
 801655c:	d004      	beq.n	8016568 <_txm_module_manager_unload+0x80>
    {

        /* Release the protection mutex.  */
        _tx_mutex_put(&_txm_module_manager_mutex);
 801655e:	482d      	ldr	r0, [pc, #180]	; (8016614 <_txm_module_manager_unload+0x12c>)
 8016560:	f7f3 fa7c 	bl	8009a5c <_tx_mutex_put>

        /* Return error if the module is not ready.  */
        return(TX_NOT_DONE);
 8016564:	2320      	movs	r3, #32
 8016566:	e04c      	b.n	8016602 <_txm_module_manager_unload+0x11a>
    }

    /* Pickup the module data memory allocation address.  */
    memory_ptr =  module_instance -> txm_module_instance_data_allocation_ptr;
 8016568:	687b      	ldr	r3, [r7, #4]
 801656a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801656c:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Release the module's data memory.  */
    _tx_byte_release(memory_ptr);
 801656e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8016570:	f7f1 feb0 	bl	80082d4 <_tx_byte_release>

    /* Determine if there was memory allocated for the code.  */
    if (module_instance -> txm_module_instance_code_allocation_ptr)
 8016574:	687b      	ldr	r3, [r7, #4]
 8016576:	691b      	ldr	r3, [r3, #16]
 8016578:	2b00      	cmp	r3, #0
 801657a:	d005      	beq.n	8016588 <_txm_module_manager_unload+0xa0>
    {

        /* Yes, release the module's code memory.  */
        memory_ptr =  module_instance -> txm_module_instance_code_allocation_ptr;
 801657c:	687b      	ldr	r3, [r7, #4]
 801657e:	691b      	ldr	r3, [r3, #16]
 8016580:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Release the module's data memory.  */
        _tx_byte_release(memory_ptr);
 8016582:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8016584:	f7f1 fea6 	bl	80082d4 <_tx_byte_release>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8016588:	f3ef 8310 	mrs	r3, PRIMASK
 801658c:	617b      	str	r3, [r7, #20]
    return(posture);
 801658e:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 8016590:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 8016592:	b672      	cpsid	i
    return(int_posture);
 8016594:	693b      	ldr	r3, [r7, #16]
    }

    /* Temporarily disable interrupts.  */
    TX_DISABLE
 8016596:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Clear some of the module information.  */
    module_instance -> txm_module_instance_id =     0;
 8016598:	687b      	ldr	r3, [r7, #4]
 801659a:	2200      	movs	r2, #0
 801659c:	601a      	str	r2, [r3, #0]
    module_instance -> txm_module_instance_state =  TXM_MODULE_UNLOADED;
 801659e:	687b      	ldr	r3, [r7, #4]
 80165a0:	2205      	movs	r2, #5
 80165a2:	609a      	str	r2, [r3, #8]
    TXM_MODULE_MANAGER_MODULE_UNLOAD(module_instance);

    /* Remove the module from the linked list of loaded modules.  */

    /* See if the module is the only one on the list.  */
    if ((--_txm_module_manger_loaded_count) == 0)
 80165a4:	4b1d      	ldr	r3, [pc, #116]	; (801661c <_txm_module_manager_unload+0x134>)
 80165a6:	681b      	ldr	r3, [r3, #0]
 80165a8:	3b01      	subs	r3, #1
 80165aa:	4a1c      	ldr	r2, [pc, #112]	; (801661c <_txm_module_manager_unload+0x134>)
 80165ac:	6013      	str	r3, [r2, #0]
 80165ae:	4b1b      	ldr	r3, [pc, #108]	; (801661c <_txm_module_manager_unload+0x134>)
 80165b0:	681b      	ldr	r3, [r3, #0]
 80165b2:	2b00      	cmp	r3, #0
 80165b4:	d103      	bne.n	80165be <_txm_module_manager_unload+0xd6>
    {

        /* Only created module, just set the created list to NULL.  */
        _txm_module_manager_loaded_list_ptr =  TX_NULL;
 80165b6:	4b1a      	ldr	r3, [pc, #104]	; (8016620 <_txm_module_manager_unload+0x138>)
 80165b8:	2200      	movs	r2, #0
 80165ba:	601a      	str	r2, [r3, #0]
 80165bc:	e017      	b.n	80165ee <_txm_module_manager_unload+0x106>
    }
    else
    {

        /* Otherwise, not the only created module, link-up the neighbors.  */
        next_module =                                module_instance -> txm_module_instance_loaded_next;
 80165be:	687b      	ldr	r3, [r7, #4]
 80165c0:	f8d3 34a4 	ldr.w	r3, [r3, #1188]	; 0x4a4
 80165c4:	627b      	str	r3, [r7, #36]	; 0x24
        previous_module =                            module_instance -> txm_module_instance_loaded_previous;
 80165c6:	687b      	ldr	r3, [r7, #4]
 80165c8:	f8d3 34a8 	ldr.w	r3, [r3, #1192]	; 0x4a8
 80165cc:	623b      	str	r3, [r7, #32]
        next_module -> txm_module_instance_loaded_previous =  previous_module;
 80165ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80165d0:	6a3a      	ldr	r2, [r7, #32]
 80165d2:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
        previous_module -> txm_module_instance_loaded_next =  next_module;
 80165d6:	6a3b      	ldr	r3, [r7, #32]
 80165d8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80165da:	f8c3 24a4 	str.w	r2, [r3, #1188]	; 0x4a4

        /* See if we have to update the created list head pointer.  */
        if (_txm_module_manager_loaded_list_ptr == module_instance)
 80165de:	4b10      	ldr	r3, [pc, #64]	; (8016620 <_txm_module_manager_unload+0x138>)
 80165e0:	681b      	ldr	r3, [r3, #0]
 80165e2:	687a      	ldr	r2, [r7, #4]
 80165e4:	429a      	cmp	r2, r3
 80165e6:	d102      	bne.n	80165ee <_txm_module_manager_unload+0x106>
        {

            /* Yes, move the head pointer to the next link. */
            _txm_module_manager_loaded_list_ptr =  next_module;
 80165e8:	4a0d      	ldr	r2, [pc, #52]	; (8016620 <_txm_module_manager_unload+0x138>)
 80165ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80165ec:	6013      	str	r3, [r2, #0]
 80165ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80165f0:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80165f2:	68fb      	ldr	r3, [r7, #12]
 80165f4:	f383 8810 	msr	PRIMASK, r3
}
 80165f8:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Release the protection mutex.  */
    _tx_mutex_put(&_txm_module_manager_mutex);
 80165fa:	4806      	ldr	r0, [pc, #24]	; (8016614 <_txm_module_manager_unload+0x12c>)
 80165fc:	f7f3 fa2e 	bl	8009a5c <_tx_mutex_put>

    /* Return success.  */
    return(TX_SUCCESS);
 8016600:	2300      	movs	r3, #0
}
 8016602:	4618      	mov	r0, r3
 8016604:	3730      	adds	r7, #48	; 0x30
 8016606:	46bd      	mov	sp, r7
 8016608:	bd80      	pop	{r7, pc}
 801660a:	bf00      	nop
 801660c:	2000000c 	.word	0x2000000c
 8016610:	2000f6b0 	.word	0x2000f6b0
 8016614:	2000f674 	.word	0x2000f674
 8016618:	4d4f4455 	.word	0x4d4f4455
 801661c:	2000f6ac 	.word	0x2000f6ac
 8016620:	2000f6a8 	.word	0x2000f6a8

08016624 <_txm_module_manager_created_object_check>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
UCHAR _txm_module_manager_created_object_check(TXM_MODULE_INSTANCE *module_instance, VOID *object_ptr)
{
 8016624:	b480      	push	{r7}
 8016626:	b085      	sub	sp, #20
 8016628:	af00      	add	r7, sp, #0
 801662a:	6078      	str	r0, [r7, #4]
 801662c:	6039      	str	r1, [r7, #0]

TXM_MODULE_ALLOCATED_OBJECT     *allocated_object_ptr;

    /* Determine if the socket control block is inside the module.  */
    if ( (((CHAR *) object_ptr) >= ((CHAR *) module_instance -> txm_module_instance_data_start)) &&
 801662e:	687b      	ldr	r3, [r7, #4]
 8016630:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8016632:	683a      	ldr	r2, [r7, #0]
 8016634:	429a      	cmp	r2, r3
 8016636:	d306      	bcc.n	8016646 <_txm_module_manager_created_object_check+0x22>
         (((CHAR *) object_ptr) < ((CHAR *) module_instance -> txm_module_instance_data_end)))
 8016638:	687b      	ldr	r3, [r7, #4]
 801663a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    if ( (((CHAR *) object_ptr) >= ((CHAR *) module_instance -> txm_module_instance_data_start)) &&
 801663c:	683a      	ldr	r2, [r7, #0]
 801663e:	429a      	cmp	r2, r3
 8016640:	d201      	bcs.n	8016646 <_txm_module_manager_created_object_check+0x22>
    {
        return TX_TRUE;
 8016642:	2301      	movs	r3, #1
 8016644:	e01d      	b.n	8016682 <_txm_module_manager_created_object_check+0x5e>
    }

    /* Determine if this object control block was allocated by this module instance.  */
    else if (_txm_module_manager_object_pool_created)
 8016646:	4b12      	ldr	r3, [pc, #72]	; (8016690 <_txm_module_manager_created_object_check+0x6c>)
 8016648:	681b      	ldr	r3, [r3, #0]
 801664a:	2b00      	cmp	r3, #0
 801664c:	d018      	beq.n	8016680 <_txm_module_manager_created_object_check+0x5c>
    {

        /* Determine if the current object is from the pool of dynamically allocated objects.  */
        if ((((UCHAR *) object_ptr) >= _txm_module_manager_object_pool.tx_byte_pool_start) &&
 801664e:	4b11      	ldr	r3, [pc, #68]	; (8016694 <_txm_module_manager_created_object_check+0x70>)
 8016650:	699b      	ldr	r3, [r3, #24]
 8016652:	683a      	ldr	r2, [r7, #0]
 8016654:	429a      	cmp	r2, r3
 8016656:	d313      	bcc.n	8016680 <_txm_module_manager_created_object_check+0x5c>
            (((UCHAR *) object_ptr) < (_txm_module_manager_object_pool.tx_byte_pool_start + _txm_module_manager_object_pool.tx_byte_pool_size)))
 8016658:	4b0e      	ldr	r3, [pc, #56]	; (8016694 <_txm_module_manager_created_object_check+0x70>)
 801665a:	699a      	ldr	r2, [r3, #24]
 801665c:	4b0d      	ldr	r3, [pc, #52]	; (8016694 <_txm_module_manager_created_object_check+0x70>)
 801665e:	69db      	ldr	r3, [r3, #28]
 8016660:	4413      	add	r3, r2
        if ((((UCHAR *) object_ptr) >= _txm_module_manager_object_pool.tx_byte_pool_start) &&
 8016662:	683a      	ldr	r2, [r7, #0]
 8016664:	429a      	cmp	r2, r3
 8016666:	d20b      	bcs.n	8016680 <_txm_module_manager_created_object_check+0x5c>
        {

            /* Pickup object pointer.  */
            allocated_object_ptr =  (TXM_MODULE_ALLOCATED_OBJECT *) object_ptr;
 8016668:	683b      	ldr	r3, [r7, #0]
 801666a:	60fb      	str	r3, [r7, #12]

            /* Move back to get the header information.  */
            allocated_object_ptr--;
 801666c:	68fb      	ldr	r3, [r7, #12]
 801666e:	3b10      	subs	r3, #16
 8016670:	60fb      	str	r3, [r7, #12]

            /* Now determine if this object belongs to this module.  */
            if (allocated_object_ptr -> txm_module_allocated_object_module_instance == module_instance)
 8016672:	68fb      	ldr	r3, [r7, #12]
 8016674:	681b      	ldr	r3, [r3, #0]
 8016676:	687a      	ldr	r2, [r7, #4]
 8016678:	429a      	cmp	r2, r3
 801667a:	d101      	bne.n	8016680 <_txm_module_manager_created_object_check+0x5c>
            {
                return TX_TRUE;
 801667c:	2301      	movs	r3, #1
 801667e:	e000      	b.n	8016682 <_txm_module_manager_created_object_check+0x5e>
            }
        }
    }

    return TX_FALSE;
 8016680:	2300      	movs	r3, #0
}
 8016682:	4618      	mov	r0, r3
 8016684:	3714      	adds	r7, #20
 8016686:	46bd      	mov	sp, r7
 8016688:	f85d 7b04 	ldr.w	r7, [sp], #4
 801668c:	4770      	bx	lr
 801668e:	bf00      	nop
 8016690:	2000f670 	.word	0x2000f670
 8016694:	2000f63c 	.word	0x2000f63c

08016698 <_txm_module_manager_object_size_check>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
UINT  _txm_module_manager_object_size_check(ALIGN_TYPE object_ptr, ULONG object_size)
{
 8016698:	b480      	push	{r7}
 801669a:	b085      	sub	sp, #20
 801669c:	af00      	add	r7, sp, #0
 801669e:	6078      	str	r0, [r7, #4]
 80166a0:	6039      	str	r1, [r7, #0]
TXM_MODULE_ALLOCATED_OBJECT *module_allocated_object_ptr;
UINT                        return_value;

    /* Pickup the allocated object pointer.  */
    module_allocated_object_ptr = ((TXM_MODULE_ALLOCATED_OBJECT *) object_ptr) - 1;
 80166a2:	687b      	ldr	r3, [r7, #4]
 80166a4:	3b10      	subs	r3, #16
 80166a6:	60bb      	str	r3, [r7, #8]

    /* Does the allocated memory match the expected object size?  */
    if (module_allocated_object_ptr -> txm_module_object_size == object_size)
 80166a8:	68bb      	ldr	r3, [r7, #8]
 80166aa:	68db      	ldr	r3, [r3, #12]
 80166ac:	683a      	ldr	r2, [r7, #0]
 80166ae:	429a      	cmp	r2, r3
 80166b0:	d102      	bne.n	80166b8 <_txm_module_manager_object_size_check+0x20>
        return_value =  TX_SUCCESS;
 80166b2:	2300      	movs	r3, #0
 80166b4:	60fb      	str	r3, [r7, #12]
 80166b6:	e001      	b.n	80166bc <_txm_module_manager_object_size_check+0x24>
    else
        return_value =  TXM_MODULE_INVALID_MEMORY;
 80166b8:	23f4      	movs	r3, #244	; 0xf4
 80166ba:	60fb      	str	r3, [r7, #12]

    return(return_value);
 80166bc:	68fb      	ldr	r3, [r7, #12]
}
 80166be:	4618      	mov	r0, r3
 80166c0:	3714      	adds	r7, #20
 80166c2:	46bd      	mov	sp, r7
 80166c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80166c8:	4770      	bx	lr

080166ca <_txm_module_manager_object_name_compare>:
/*                                                                        */
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
UINT  _txm_module_manager_object_name_compare(CHAR *search_name, UINT search_name_length, CHAR *object_name)
{
 80166ca:	b480      	push	{r7}
 80166cc:	b087      	sub	sp, #28
 80166ce:	af00      	add	r7, sp, #0
 80166d0:	60f8      	str	r0, [r7, #12]
 80166d2:	60b9      	str	r1, [r7, #8]
 80166d4:	607a      	str	r2, [r7, #4]
CHAR    object_name_char;


    /* Is the object name null? Note that the search name has already been checked
       by the caller.  */
    if (object_name == TX_NULL)
 80166d6:	687b      	ldr	r3, [r7, #4]
 80166d8:	2b00      	cmp	r3, #0
 80166da:	d101      	bne.n	80166e0 <_txm_module_manager_object_name_compare+0x16>
    {

        /* The strings can't match.  */
        return(TX_FALSE);
 80166dc:	2300      	movs	r3, #0
 80166de:	e01f      	b.n	8016720 <_txm_module_manager_object_name_compare+0x56>
    /* Loop through the names.  */
    while (1)
    {

        /* Get the current characters from each name.  */
        search_name_char =  *search_name;
 80166e0:	68fb      	ldr	r3, [r7, #12]
 80166e2:	781b      	ldrb	r3, [r3, #0]
 80166e4:	75fb      	strb	r3, [r7, #23]
        object_name_char =  *object_name;
 80166e6:	687b      	ldr	r3, [r7, #4]
 80166e8:	781b      	ldrb	r3, [r3, #0]
 80166ea:	75bb      	strb	r3, [r7, #22]

        /* Check for match.  */
        if (search_name_char == object_name_char)
 80166ec:	7dfa      	ldrb	r2, [r7, #23]
 80166ee:	7dbb      	ldrb	r3, [r7, #22]
 80166f0:	429a      	cmp	r2, r3
 80166f2:	d104      	bne.n	80166fe <_txm_module_manager_object_name_compare+0x34>
        {

            /* Are they null-terminators?  */
            if (search_name_char == '\0')
 80166f4:	7dfb      	ldrb	r3, [r7, #23]
 80166f6:	2b00      	cmp	r3, #0
 80166f8:	d103      	bne.n	8016702 <_txm_module_manager_object_name_compare+0x38>
            {

                /* The strings match.  */
                return(TX_TRUE);
 80166fa:	2301      	movs	r3, #1
 80166fc:	e010      	b.n	8016720 <_txm_module_manager_object_name_compare+0x56>
        }
        else
        {

            /* The strings don't match.  */
            return(TX_FALSE);
 80166fe:	2300      	movs	r3, #0
 8016700:	e00e      	b.n	8016720 <_txm_module_manager_object_name_compare+0x56>
        }

        /* Are we at the end of the search name?  */
        if (search_name_length == 0)
 8016702:	68bb      	ldr	r3, [r7, #8]
 8016704:	2b00      	cmp	r3, #0
 8016706:	d101      	bne.n	801670c <_txm_module_manager_object_name_compare+0x42>
        {

            /* The strings don't match.  */
            return(TX_FALSE);
 8016708:	2300      	movs	r3, #0
 801670a:	e009      	b.n	8016720 <_txm_module_manager_object_name_compare+0x56>
        }

        /* Move to next character.  */
        search_name++;
 801670c:	68fb      	ldr	r3, [r7, #12]
 801670e:	3301      	adds	r3, #1
 8016710:	60fb      	str	r3, [r7, #12]
        object_name++;
 8016712:	687b      	ldr	r3, [r7, #4]
 8016714:	3301      	adds	r3, #1
 8016716:	607b      	str	r3, [r7, #4]
        search_name_length--;
 8016718:	68bb      	ldr	r3, [r7, #8]
 801671a:	3b01      	subs	r3, #1
 801671c:	60bb      	str	r3, [r7, #8]
        search_name_char =  *search_name;
 801671e:	e7df      	b.n	80166e0 <_txm_module_manager_object_name_compare+0x16>
    }
}
 8016720:	4618      	mov	r0, r3
 8016722:	371c      	adds	r7, #28
 8016724:	46bd      	mov	sp, r7
 8016726:	f85d 7b04 	ldr.w	r7, [sp], #4
 801672a:	4770      	bx	lr

0801672c <_txm_module_manager_util_code_allocation_size_and_alignment_get>:
/*  09-30-2020      Scott Larson            Initial Version 6.1           */
/*                                                                        */
/**************************************************************************/
UINT  _txm_module_manager_util_code_allocation_size_and_alignment_get(TXM_MODULE_PREAMBLE *module_preamble,
                                                                      ULONG *code_alignment_dest, ULONG *code_allocation_size_dest)
{
 801672c:	b580      	push	{r7, lr}
 801672e:	b08a      	sub	sp, #40	; 0x28
 8016730:	af02      	add	r7, sp, #8
 8016732:	60f8      	str	r0, [r7, #12]
 8016734:	60b9      	str	r1, [r7, #8]
 8016736:	607a      	str	r2, [r7, #4]
ULONG   data_size_ignored;
ULONG   data_alignment_ignored;


    /* Pickup the module code size.  */
    code_size =  module_preamble -> txm_module_preamble_code_size;
 8016738:	68fb      	ldr	r3, [r7, #12]
 801673a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801673c:	61fb      	str	r3, [r7, #28]

    /* Adjust the size of the module elements to be aligned to the default alignment.  */
    TXM_MODULE_MANAGER_UTIL_MATH_ADD_ULONG(code_size, TXM_MODULE_CODE_ALIGNMENT, code_size);
 801673e:	69fb      	ldr	r3, [r7, #28]
 8016740:	f113 0f05 	cmn.w	r3, #5
 8016744:	d901      	bls.n	801674a <_txm_module_manager_util_code_allocation_size_and_alignment_get+0x1e>
 8016746:	23f8      	movs	r3, #248	; 0xf8
 8016748:	e02a      	b.n	80167a0 <_txm_module_manager_util_code_allocation_size_and_alignment_get+0x74>
 801674a:	69fb      	ldr	r3, [r7, #28]
 801674c:	3304      	adds	r3, #4
 801674e:	61fb      	str	r3, [r7, #28]
    code_size =  ((code_size - 1)/TXM_MODULE_CODE_ALIGNMENT) * TXM_MODULE_CODE_ALIGNMENT;
 8016750:	69fb      	ldr	r3, [r7, #28]
 8016752:	3b01      	subs	r3, #1
 8016754:	f023 0303 	bic.w	r3, r3, #3
 8016758:	61fb      	str	r3, [r7, #28]

    /* Setup the default code and data alignments.  */
    code_alignment =  (ULONG) TXM_MODULE_CODE_ALIGNMENT;
 801675a:	2304      	movs	r3, #4
 801675c:	61bb      	str	r3, [r7, #24]

    /* Get the port-specific alignment for the code size. Note we only want code so we pass 'null' values for data.  */
    data_size_ignored = 1;
 801675e:	2301      	movs	r3, #1
 8016760:	617b      	str	r3, [r7, #20]
    data_alignment_ignored = 1;
 8016762:	2301      	movs	r3, #1
 8016764:	613b      	str	r3, [r7, #16]
    TXM_MODULE_MANAGER_ALIGNMENT_ADJUST(module_preamble, code_size, code_alignment, data_size_ignored, data_alignment_ignored)
 8016766:	f107 0014 	add.w	r0, r7, #20
 801676a:	f107 0218 	add.w	r2, r7, #24
 801676e:	f107 011c 	add.w	r1, r7, #28
 8016772:	f107 0310 	add.w	r3, r7, #16
 8016776:	9300      	str	r3, [sp, #0]
 8016778:	4603      	mov	r3, r0
 801677a:	68f8      	ldr	r0, [r7, #12]
 801677c:	f7f9 f915 	bl	800f9aa <_txm_module_manager_alignment_adjust>

    /* Calculate the code memory allocation size.  */
    TXM_MODULE_MANAGER_UTIL_MATH_ADD_ULONG(code_size, code_alignment, *code_allocation_size_dest);
 8016780:	69fb      	ldr	r3, [r7, #28]
 8016782:	43da      	mvns	r2, r3
 8016784:	69bb      	ldr	r3, [r7, #24]
 8016786:	429a      	cmp	r2, r3
 8016788:	d201      	bcs.n	801678e <_txm_module_manager_util_code_allocation_size_and_alignment_get+0x62>
 801678a:	23f8      	movs	r3, #248	; 0xf8
 801678c:	e008      	b.n	80167a0 <_txm_module_manager_util_code_allocation_size_and_alignment_get+0x74>
 801678e:	69fa      	ldr	r2, [r7, #28]
 8016790:	69bb      	ldr	r3, [r7, #24]
 8016792:	441a      	add	r2, r3
 8016794:	687b      	ldr	r3, [r7, #4]
 8016796:	601a      	str	r2, [r3, #0]

    /* Write the alignment result into the caller's destination address.  */
    *code_alignment_dest =  code_alignment;
 8016798:	69ba      	ldr	r2, [r7, #24]
 801679a:	68bb      	ldr	r3, [r7, #8]
 801679c:	601a      	str	r2, [r3, #0]

    /* Return success.  */
    return(TX_SUCCESS);
 801679e:	2300      	movs	r3, #0
}
 80167a0:	4618      	mov	r0, r3
 80167a2:	3720      	adds	r7, #32
 80167a4:	46bd      	mov	sp, r7
 80167a6:	bd80      	pop	{r7, pc}

080167a8 <std>:
 80167a8:	2300      	movs	r3, #0
 80167aa:	b510      	push	{r4, lr}
 80167ac:	4604      	mov	r4, r0
 80167ae:	6083      	str	r3, [r0, #8]
 80167b0:	8181      	strh	r1, [r0, #12]
 80167b2:	4619      	mov	r1, r3
 80167b4:	6643      	str	r3, [r0, #100]	; 0x64
 80167b6:	81c2      	strh	r2, [r0, #14]
 80167b8:	2208      	movs	r2, #8
 80167ba:	6183      	str	r3, [r0, #24]
 80167bc:	e9c0 3300 	strd	r3, r3, [r0]
 80167c0:	e9c0 3304 	strd	r3, r3, [r0, #16]
 80167c4:	305c      	adds	r0, #92	; 0x5c
 80167c6:	f000 f90d 	bl	80169e4 <memset>
 80167ca:	4b05      	ldr	r3, [pc, #20]	; (80167e0 <std+0x38>)
 80167cc:	6224      	str	r4, [r4, #32]
 80167ce:	6263      	str	r3, [r4, #36]	; 0x24
 80167d0:	4b04      	ldr	r3, [pc, #16]	; (80167e4 <std+0x3c>)
 80167d2:	62a3      	str	r3, [r4, #40]	; 0x28
 80167d4:	4b04      	ldr	r3, [pc, #16]	; (80167e8 <std+0x40>)
 80167d6:	62e3      	str	r3, [r4, #44]	; 0x2c
 80167d8:	4b04      	ldr	r3, [pc, #16]	; (80167ec <std+0x44>)
 80167da:	6323      	str	r3, [r4, #48]	; 0x30
 80167dc:	bd10      	pop	{r4, pc}
 80167de:	bf00      	nop
 80167e0:	080172c1 	.word	0x080172c1
 80167e4:	080172e3 	.word	0x080172e3
 80167e8:	0801731b 	.word	0x0801731b
 80167ec:	0801733f 	.word	0x0801733f

080167f0 <stdio_exit_handler>:
 80167f0:	4a02      	ldr	r2, [pc, #8]	; (80167fc <stdio_exit_handler+0xc>)
 80167f2:	4903      	ldr	r1, [pc, #12]	; (8016800 <stdio_exit_handler+0x10>)
 80167f4:	4803      	ldr	r0, [pc, #12]	; (8016804 <stdio_exit_handler+0x14>)
 80167f6:	f000 b869 	b.w	80168cc <_fwalk_sglue>
 80167fa:	bf00      	nop
 80167fc:	20000010 	.word	0x20000010
 8016800:	08017259 	.word	0x08017259
 8016804:	2000001c 	.word	0x2000001c

08016808 <cleanup_stdio>:
 8016808:	6841      	ldr	r1, [r0, #4]
 801680a:	4b0c      	ldr	r3, [pc, #48]	; (801683c <cleanup_stdio+0x34>)
 801680c:	4299      	cmp	r1, r3
 801680e:	b510      	push	{r4, lr}
 8016810:	4604      	mov	r4, r0
 8016812:	d001      	beq.n	8016818 <cleanup_stdio+0x10>
 8016814:	f000 fd20 	bl	8017258 <_fflush_r>
 8016818:	68a1      	ldr	r1, [r4, #8]
 801681a:	4b09      	ldr	r3, [pc, #36]	; (8016840 <cleanup_stdio+0x38>)
 801681c:	4299      	cmp	r1, r3
 801681e:	d002      	beq.n	8016826 <cleanup_stdio+0x1e>
 8016820:	4620      	mov	r0, r4
 8016822:	f000 fd19 	bl	8017258 <_fflush_r>
 8016826:	68e1      	ldr	r1, [r4, #12]
 8016828:	4b06      	ldr	r3, [pc, #24]	; (8016844 <cleanup_stdio+0x3c>)
 801682a:	4299      	cmp	r1, r3
 801682c:	d004      	beq.n	8016838 <cleanup_stdio+0x30>
 801682e:	4620      	mov	r0, r4
 8016830:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8016834:	f000 bd10 	b.w	8017258 <_fflush_r>
 8016838:	bd10      	pop	{r4, pc}
 801683a:	bf00      	nop
 801683c:	2000f71c 	.word	0x2000f71c
 8016840:	2000f784 	.word	0x2000f784
 8016844:	2000f7ec 	.word	0x2000f7ec

08016848 <global_stdio_init.part.0>:
 8016848:	b510      	push	{r4, lr}
 801684a:	4b0b      	ldr	r3, [pc, #44]	; (8016878 <global_stdio_init.part.0+0x30>)
 801684c:	2104      	movs	r1, #4
 801684e:	4c0b      	ldr	r4, [pc, #44]	; (801687c <global_stdio_init.part.0+0x34>)
 8016850:	4a0b      	ldr	r2, [pc, #44]	; (8016880 <global_stdio_init.part.0+0x38>)
 8016852:	4620      	mov	r0, r4
 8016854:	601a      	str	r2, [r3, #0]
 8016856:	2200      	movs	r2, #0
 8016858:	f7ff ffa6 	bl	80167a8 <std>
 801685c:	f104 0068 	add.w	r0, r4, #104	; 0x68
 8016860:	2201      	movs	r2, #1
 8016862:	2109      	movs	r1, #9
 8016864:	f7ff ffa0 	bl	80167a8 <std>
 8016868:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 801686c:	2202      	movs	r2, #2
 801686e:	2112      	movs	r1, #18
 8016870:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8016874:	f7ff bf98 	b.w	80167a8 <std>
 8016878:	2000f854 	.word	0x2000f854
 801687c:	2000f71c 	.word	0x2000f71c
 8016880:	080167f1 	.word	0x080167f1

08016884 <__sfp_lock_acquire>:
 8016884:	4801      	ldr	r0, [pc, #4]	; (801688c <__sfp_lock_acquire+0x8>)
 8016886:	f000 b8df 	b.w	8016a48 <__retarget_lock_acquire_recursive>
 801688a:	bf00      	nop
 801688c:	2000f859 	.word	0x2000f859

08016890 <__sfp_lock_release>:
 8016890:	4801      	ldr	r0, [pc, #4]	; (8016898 <__sfp_lock_release+0x8>)
 8016892:	f000 b8da 	b.w	8016a4a <__retarget_lock_release_recursive>
 8016896:	bf00      	nop
 8016898:	2000f859 	.word	0x2000f859

0801689c <__sinit>:
 801689c:	b510      	push	{r4, lr}
 801689e:	4604      	mov	r4, r0
 80168a0:	f7ff fff0 	bl	8016884 <__sfp_lock_acquire>
 80168a4:	6a23      	ldr	r3, [r4, #32]
 80168a6:	b11b      	cbz	r3, 80168b0 <__sinit+0x14>
 80168a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80168ac:	f7ff bff0 	b.w	8016890 <__sfp_lock_release>
 80168b0:	4b04      	ldr	r3, [pc, #16]	; (80168c4 <__sinit+0x28>)
 80168b2:	6223      	str	r3, [r4, #32]
 80168b4:	4b04      	ldr	r3, [pc, #16]	; (80168c8 <__sinit+0x2c>)
 80168b6:	681b      	ldr	r3, [r3, #0]
 80168b8:	2b00      	cmp	r3, #0
 80168ba:	d1f5      	bne.n	80168a8 <__sinit+0xc>
 80168bc:	f7ff ffc4 	bl	8016848 <global_stdio_init.part.0>
 80168c0:	e7f2      	b.n	80168a8 <__sinit+0xc>
 80168c2:	bf00      	nop
 80168c4:	08016809 	.word	0x08016809
 80168c8:	2000f854 	.word	0x2000f854

080168cc <_fwalk_sglue>:
 80168cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80168d0:	4607      	mov	r7, r0
 80168d2:	4688      	mov	r8, r1
 80168d4:	4614      	mov	r4, r2
 80168d6:	2600      	movs	r6, #0
 80168d8:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 80168dc:	f1b9 0901 	subs.w	r9, r9, #1
 80168e0:	d505      	bpl.n	80168ee <_fwalk_sglue+0x22>
 80168e2:	6824      	ldr	r4, [r4, #0]
 80168e4:	2c00      	cmp	r4, #0
 80168e6:	d1f7      	bne.n	80168d8 <_fwalk_sglue+0xc>
 80168e8:	4630      	mov	r0, r6
 80168ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80168ee:	89ab      	ldrh	r3, [r5, #12]
 80168f0:	2b01      	cmp	r3, #1
 80168f2:	d907      	bls.n	8016904 <_fwalk_sglue+0x38>
 80168f4:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 80168f8:	3301      	adds	r3, #1
 80168fa:	d003      	beq.n	8016904 <_fwalk_sglue+0x38>
 80168fc:	4629      	mov	r1, r5
 80168fe:	4638      	mov	r0, r7
 8016900:	47c0      	blx	r8
 8016902:	4306      	orrs	r6, r0
 8016904:	3568      	adds	r5, #104	; 0x68
 8016906:	e7e9      	b.n	80168dc <_fwalk_sglue+0x10>

08016908 <iprintf>:
 8016908:	b40f      	push	{r0, r1, r2, r3}
 801690a:	b507      	push	{r0, r1, r2, lr}
 801690c:	4906      	ldr	r1, [pc, #24]	; (8016928 <iprintf+0x20>)
 801690e:	ab04      	add	r3, sp, #16
 8016910:	6808      	ldr	r0, [r1, #0]
 8016912:	f853 2b04 	ldr.w	r2, [r3], #4
 8016916:	6881      	ldr	r1, [r0, #8]
 8016918:	9301      	str	r3, [sp, #4]
 801691a:	f000 f8cd 	bl	8016ab8 <_vfiprintf_r>
 801691e:	b003      	add	sp, #12
 8016920:	f85d eb04 	ldr.w	lr, [sp], #4
 8016924:	b004      	add	sp, #16
 8016926:	4770      	bx	lr
 8016928:	20000068 	.word	0x20000068

0801692c <_puts_r>:
 801692c:	6a03      	ldr	r3, [r0, #32]
 801692e:	b570      	push	{r4, r5, r6, lr}
 8016930:	4605      	mov	r5, r0
 8016932:	460e      	mov	r6, r1
 8016934:	6884      	ldr	r4, [r0, #8]
 8016936:	b90b      	cbnz	r3, 801693c <_puts_r+0x10>
 8016938:	f7ff ffb0 	bl	801689c <__sinit>
 801693c:	6e63      	ldr	r3, [r4, #100]	; 0x64
 801693e:	07db      	lsls	r3, r3, #31
 8016940:	d405      	bmi.n	801694e <_puts_r+0x22>
 8016942:	89a3      	ldrh	r3, [r4, #12]
 8016944:	0598      	lsls	r0, r3, #22
 8016946:	d402      	bmi.n	801694e <_puts_r+0x22>
 8016948:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801694a:	f000 f87d 	bl	8016a48 <__retarget_lock_acquire_recursive>
 801694e:	89a3      	ldrh	r3, [r4, #12]
 8016950:	0719      	lsls	r1, r3, #28
 8016952:	d513      	bpl.n	801697c <_puts_r+0x50>
 8016954:	6923      	ldr	r3, [r4, #16]
 8016956:	b18b      	cbz	r3, 801697c <_puts_r+0x50>
 8016958:	3e01      	subs	r6, #1
 801695a:	68a3      	ldr	r3, [r4, #8]
 801695c:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8016960:	3b01      	subs	r3, #1
 8016962:	60a3      	str	r3, [r4, #8]
 8016964:	b9e9      	cbnz	r1, 80169a2 <_puts_r+0x76>
 8016966:	2b00      	cmp	r3, #0
 8016968:	da2e      	bge.n	80169c8 <_puts_r+0x9c>
 801696a:	4622      	mov	r2, r4
 801696c:	210a      	movs	r1, #10
 801696e:	4628      	mov	r0, r5
 8016970:	f000 fce9 	bl	8017346 <__swbuf_r>
 8016974:	3001      	adds	r0, #1
 8016976:	d007      	beq.n	8016988 <_puts_r+0x5c>
 8016978:	250a      	movs	r5, #10
 801697a:	e007      	b.n	801698c <_puts_r+0x60>
 801697c:	4621      	mov	r1, r4
 801697e:	4628      	mov	r0, r5
 8016980:	f000 fd1e 	bl	80173c0 <__swsetup_r>
 8016984:	2800      	cmp	r0, #0
 8016986:	d0e7      	beq.n	8016958 <_puts_r+0x2c>
 8016988:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 801698c:	6e63      	ldr	r3, [r4, #100]	; 0x64
 801698e:	07da      	lsls	r2, r3, #31
 8016990:	d405      	bmi.n	801699e <_puts_r+0x72>
 8016992:	89a3      	ldrh	r3, [r4, #12]
 8016994:	059b      	lsls	r3, r3, #22
 8016996:	d402      	bmi.n	801699e <_puts_r+0x72>
 8016998:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801699a:	f000 f856 	bl	8016a4a <__retarget_lock_release_recursive>
 801699e:	4628      	mov	r0, r5
 80169a0:	bd70      	pop	{r4, r5, r6, pc}
 80169a2:	2b00      	cmp	r3, #0
 80169a4:	da04      	bge.n	80169b0 <_puts_r+0x84>
 80169a6:	69a2      	ldr	r2, [r4, #24]
 80169a8:	429a      	cmp	r2, r3
 80169aa:	dc06      	bgt.n	80169ba <_puts_r+0x8e>
 80169ac:	290a      	cmp	r1, #10
 80169ae:	d004      	beq.n	80169ba <_puts_r+0x8e>
 80169b0:	6823      	ldr	r3, [r4, #0]
 80169b2:	1c5a      	adds	r2, r3, #1
 80169b4:	6022      	str	r2, [r4, #0]
 80169b6:	7019      	strb	r1, [r3, #0]
 80169b8:	e7cf      	b.n	801695a <_puts_r+0x2e>
 80169ba:	4622      	mov	r2, r4
 80169bc:	4628      	mov	r0, r5
 80169be:	f000 fcc2 	bl	8017346 <__swbuf_r>
 80169c2:	3001      	adds	r0, #1
 80169c4:	d1c9      	bne.n	801695a <_puts_r+0x2e>
 80169c6:	e7df      	b.n	8016988 <_puts_r+0x5c>
 80169c8:	6823      	ldr	r3, [r4, #0]
 80169ca:	250a      	movs	r5, #10
 80169cc:	1c5a      	adds	r2, r3, #1
 80169ce:	6022      	str	r2, [r4, #0]
 80169d0:	701d      	strb	r5, [r3, #0]
 80169d2:	e7db      	b.n	801698c <_puts_r+0x60>

080169d4 <puts>:
 80169d4:	4b02      	ldr	r3, [pc, #8]	; (80169e0 <puts+0xc>)
 80169d6:	4601      	mov	r1, r0
 80169d8:	6818      	ldr	r0, [r3, #0]
 80169da:	f7ff bfa7 	b.w	801692c <_puts_r>
 80169de:	bf00      	nop
 80169e0:	20000068 	.word	0x20000068

080169e4 <memset>:
 80169e4:	4402      	add	r2, r0
 80169e6:	4603      	mov	r3, r0
 80169e8:	4293      	cmp	r3, r2
 80169ea:	d100      	bne.n	80169ee <memset+0xa>
 80169ec:	4770      	bx	lr
 80169ee:	f803 1b01 	strb.w	r1, [r3], #1
 80169f2:	e7f9      	b.n	80169e8 <memset+0x4>

080169f4 <__errno>:
 80169f4:	4b01      	ldr	r3, [pc, #4]	; (80169fc <__errno+0x8>)
 80169f6:	6818      	ldr	r0, [r3, #0]
 80169f8:	4770      	bx	lr
 80169fa:	bf00      	nop
 80169fc:	20000068 	.word	0x20000068

08016a00 <__libc_init_array>:
 8016a00:	b570      	push	{r4, r5, r6, lr}
 8016a02:	4d0d      	ldr	r5, [pc, #52]	; (8016a38 <__libc_init_array+0x38>)
 8016a04:	2600      	movs	r6, #0
 8016a06:	4c0d      	ldr	r4, [pc, #52]	; (8016a3c <__libc_init_array+0x3c>)
 8016a08:	1b64      	subs	r4, r4, r5
 8016a0a:	10a4      	asrs	r4, r4, #2
 8016a0c:	42a6      	cmp	r6, r4
 8016a0e:	d109      	bne.n	8016a24 <__libc_init_array+0x24>
 8016a10:	4d0b      	ldr	r5, [pc, #44]	; (8016a40 <__libc_init_array+0x40>)
 8016a12:	2600      	movs	r6, #0
 8016a14:	4c0b      	ldr	r4, [pc, #44]	; (8016a44 <__libc_init_array+0x44>)
 8016a16:	f000 fe5f 	bl	80176d8 <_init>
 8016a1a:	1b64      	subs	r4, r4, r5
 8016a1c:	10a4      	asrs	r4, r4, #2
 8016a1e:	42a6      	cmp	r6, r4
 8016a20:	d105      	bne.n	8016a2e <__libc_init_array+0x2e>
 8016a22:	bd70      	pop	{r4, r5, r6, pc}
 8016a24:	f855 3b04 	ldr.w	r3, [r5], #4
 8016a28:	3601      	adds	r6, #1
 8016a2a:	4798      	blx	r3
 8016a2c:	e7ee      	b.n	8016a0c <__libc_init_array+0xc>
 8016a2e:	f855 3b04 	ldr.w	r3, [r5], #4
 8016a32:	3601      	adds	r6, #1
 8016a34:	4798      	blx	r3
 8016a36:	e7f2      	b.n	8016a1e <__libc_init_array+0x1e>
 8016a38:	08017bd0 	.word	0x08017bd0
 8016a3c:	08017bd0 	.word	0x08017bd0
 8016a40:	08017bd0 	.word	0x08017bd0
 8016a44:	08017bd4 	.word	0x08017bd4

08016a48 <__retarget_lock_acquire_recursive>:
 8016a48:	4770      	bx	lr

08016a4a <__retarget_lock_release_recursive>:
 8016a4a:	4770      	bx	lr

08016a4c <memcpy>:
 8016a4c:	440a      	add	r2, r1
 8016a4e:	1e43      	subs	r3, r0, #1
 8016a50:	4291      	cmp	r1, r2
 8016a52:	d100      	bne.n	8016a56 <memcpy+0xa>
 8016a54:	4770      	bx	lr
 8016a56:	b510      	push	{r4, lr}
 8016a58:	f811 4b01 	ldrb.w	r4, [r1], #1
 8016a5c:	4291      	cmp	r1, r2
 8016a5e:	f803 4f01 	strb.w	r4, [r3, #1]!
 8016a62:	d1f9      	bne.n	8016a58 <memcpy+0xc>
 8016a64:	bd10      	pop	{r4, pc}

08016a66 <__sfputc_r>:
 8016a66:	6893      	ldr	r3, [r2, #8]
 8016a68:	3b01      	subs	r3, #1
 8016a6a:	2b00      	cmp	r3, #0
 8016a6c:	6093      	str	r3, [r2, #8]
 8016a6e:	b410      	push	{r4}
 8016a70:	da08      	bge.n	8016a84 <__sfputc_r+0x1e>
 8016a72:	6994      	ldr	r4, [r2, #24]
 8016a74:	42a3      	cmp	r3, r4
 8016a76:	db01      	blt.n	8016a7c <__sfputc_r+0x16>
 8016a78:	290a      	cmp	r1, #10
 8016a7a:	d103      	bne.n	8016a84 <__sfputc_r+0x1e>
 8016a7c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8016a80:	f000 bc61 	b.w	8017346 <__swbuf_r>
 8016a84:	6813      	ldr	r3, [r2, #0]
 8016a86:	1c58      	adds	r0, r3, #1
 8016a88:	6010      	str	r0, [r2, #0]
 8016a8a:	4608      	mov	r0, r1
 8016a8c:	7019      	strb	r1, [r3, #0]
 8016a8e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8016a92:	4770      	bx	lr

08016a94 <__sfputs_r>:
 8016a94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8016a96:	4606      	mov	r6, r0
 8016a98:	460f      	mov	r7, r1
 8016a9a:	4614      	mov	r4, r2
 8016a9c:	18d5      	adds	r5, r2, r3
 8016a9e:	42ac      	cmp	r4, r5
 8016aa0:	d101      	bne.n	8016aa6 <__sfputs_r+0x12>
 8016aa2:	2000      	movs	r0, #0
 8016aa4:	e007      	b.n	8016ab6 <__sfputs_r+0x22>
 8016aa6:	463a      	mov	r2, r7
 8016aa8:	f814 1b01 	ldrb.w	r1, [r4], #1
 8016aac:	4630      	mov	r0, r6
 8016aae:	f7ff ffda 	bl	8016a66 <__sfputc_r>
 8016ab2:	1c43      	adds	r3, r0, #1
 8016ab4:	d1f3      	bne.n	8016a9e <__sfputs_r+0xa>
 8016ab6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08016ab8 <_vfiprintf_r>:
 8016ab8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016abc:	460d      	mov	r5, r1
 8016abe:	b09d      	sub	sp, #116	; 0x74
 8016ac0:	4614      	mov	r4, r2
 8016ac2:	4698      	mov	r8, r3
 8016ac4:	4606      	mov	r6, r0
 8016ac6:	b118      	cbz	r0, 8016ad0 <_vfiprintf_r+0x18>
 8016ac8:	6a03      	ldr	r3, [r0, #32]
 8016aca:	b90b      	cbnz	r3, 8016ad0 <_vfiprintf_r+0x18>
 8016acc:	f7ff fee6 	bl	801689c <__sinit>
 8016ad0:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8016ad2:	07d9      	lsls	r1, r3, #31
 8016ad4:	d405      	bmi.n	8016ae2 <_vfiprintf_r+0x2a>
 8016ad6:	89ab      	ldrh	r3, [r5, #12]
 8016ad8:	059a      	lsls	r2, r3, #22
 8016ada:	d402      	bmi.n	8016ae2 <_vfiprintf_r+0x2a>
 8016adc:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8016ade:	f7ff ffb3 	bl	8016a48 <__retarget_lock_acquire_recursive>
 8016ae2:	89ab      	ldrh	r3, [r5, #12]
 8016ae4:	071b      	lsls	r3, r3, #28
 8016ae6:	d501      	bpl.n	8016aec <_vfiprintf_r+0x34>
 8016ae8:	692b      	ldr	r3, [r5, #16]
 8016aea:	b99b      	cbnz	r3, 8016b14 <_vfiprintf_r+0x5c>
 8016aec:	4629      	mov	r1, r5
 8016aee:	4630      	mov	r0, r6
 8016af0:	f000 fc66 	bl	80173c0 <__swsetup_r>
 8016af4:	b170      	cbz	r0, 8016b14 <_vfiprintf_r+0x5c>
 8016af6:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8016af8:	07dc      	lsls	r4, r3, #31
 8016afa:	d504      	bpl.n	8016b06 <_vfiprintf_r+0x4e>
 8016afc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8016b00:	b01d      	add	sp, #116	; 0x74
 8016b02:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8016b06:	89ab      	ldrh	r3, [r5, #12]
 8016b08:	0598      	lsls	r0, r3, #22
 8016b0a:	d4f7      	bmi.n	8016afc <_vfiprintf_r+0x44>
 8016b0c:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8016b0e:	f7ff ff9c 	bl	8016a4a <__retarget_lock_release_recursive>
 8016b12:	e7f3      	b.n	8016afc <_vfiprintf_r+0x44>
 8016b14:	2300      	movs	r3, #0
 8016b16:	f8cd 800c 	str.w	r8, [sp, #12]
 8016b1a:	f04f 0901 	mov.w	r9, #1
 8016b1e:	f8df 81b8 	ldr.w	r8, [pc, #440]	; 8016cd8 <_vfiprintf_r+0x220>
 8016b22:	9309      	str	r3, [sp, #36]	; 0x24
 8016b24:	2320      	movs	r3, #32
 8016b26:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8016b2a:	2330      	movs	r3, #48	; 0x30
 8016b2c:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8016b30:	4623      	mov	r3, r4
 8016b32:	469a      	mov	sl, r3
 8016b34:	f813 2b01 	ldrb.w	r2, [r3], #1
 8016b38:	b10a      	cbz	r2, 8016b3e <_vfiprintf_r+0x86>
 8016b3a:	2a25      	cmp	r2, #37	; 0x25
 8016b3c:	d1f9      	bne.n	8016b32 <_vfiprintf_r+0x7a>
 8016b3e:	ebba 0b04 	subs.w	fp, sl, r4
 8016b42:	d00b      	beq.n	8016b5c <_vfiprintf_r+0xa4>
 8016b44:	465b      	mov	r3, fp
 8016b46:	4622      	mov	r2, r4
 8016b48:	4629      	mov	r1, r5
 8016b4a:	4630      	mov	r0, r6
 8016b4c:	f7ff ffa2 	bl	8016a94 <__sfputs_r>
 8016b50:	3001      	adds	r0, #1
 8016b52:	f000 80a9 	beq.w	8016ca8 <_vfiprintf_r+0x1f0>
 8016b56:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8016b58:	445a      	add	r2, fp
 8016b5a:	9209      	str	r2, [sp, #36]	; 0x24
 8016b5c:	f89a 3000 	ldrb.w	r3, [sl]
 8016b60:	2b00      	cmp	r3, #0
 8016b62:	f000 80a1 	beq.w	8016ca8 <_vfiprintf_r+0x1f0>
 8016b66:	2300      	movs	r3, #0
 8016b68:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8016b6c:	f10a 0a01 	add.w	sl, sl, #1
 8016b70:	9304      	str	r3, [sp, #16]
 8016b72:	9307      	str	r3, [sp, #28]
 8016b74:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8016b78:	931a      	str	r3, [sp, #104]	; 0x68
 8016b7a:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8016b7e:	4654      	mov	r4, sl
 8016b80:	2205      	movs	r2, #5
 8016b82:	4855      	ldr	r0, [pc, #340]	; (8016cd8 <_vfiprintf_r+0x220>)
 8016b84:	f814 1b01 	ldrb.w	r1, [r4], #1
 8016b88:	f000 fd4c 	bl	8017624 <memchr>
 8016b8c:	9a04      	ldr	r2, [sp, #16]
 8016b8e:	b9d8      	cbnz	r0, 8016bc8 <_vfiprintf_r+0x110>
 8016b90:	06d1      	lsls	r1, r2, #27
 8016b92:	bf44      	itt	mi
 8016b94:	2320      	movmi	r3, #32
 8016b96:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8016b9a:	0713      	lsls	r3, r2, #28
 8016b9c:	bf44      	itt	mi
 8016b9e:	232b      	movmi	r3, #43	; 0x2b
 8016ba0:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8016ba4:	f89a 3000 	ldrb.w	r3, [sl]
 8016ba8:	2b2a      	cmp	r3, #42	; 0x2a
 8016baa:	d015      	beq.n	8016bd8 <_vfiprintf_r+0x120>
 8016bac:	9a07      	ldr	r2, [sp, #28]
 8016bae:	4654      	mov	r4, sl
 8016bb0:	2000      	movs	r0, #0
 8016bb2:	f04f 0c0a 	mov.w	ip, #10
 8016bb6:	4621      	mov	r1, r4
 8016bb8:	f811 3b01 	ldrb.w	r3, [r1], #1
 8016bbc:	3b30      	subs	r3, #48	; 0x30
 8016bbe:	2b09      	cmp	r3, #9
 8016bc0:	d94d      	bls.n	8016c5e <_vfiprintf_r+0x1a6>
 8016bc2:	b1b0      	cbz	r0, 8016bf2 <_vfiprintf_r+0x13a>
 8016bc4:	9207      	str	r2, [sp, #28]
 8016bc6:	e014      	b.n	8016bf2 <_vfiprintf_r+0x13a>
 8016bc8:	eba0 0308 	sub.w	r3, r0, r8
 8016bcc:	46a2      	mov	sl, r4
 8016bce:	fa09 f303 	lsl.w	r3, r9, r3
 8016bd2:	4313      	orrs	r3, r2
 8016bd4:	9304      	str	r3, [sp, #16]
 8016bd6:	e7d2      	b.n	8016b7e <_vfiprintf_r+0xc6>
 8016bd8:	9b03      	ldr	r3, [sp, #12]
 8016bda:	1d19      	adds	r1, r3, #4
 8016bdc:	681b      	ldr	r3, [r3, #0]
 8016bde:	2b00      	cmp	r3, #0
 8016be0:	9103      	str	r1, [sp, #12]
 8016be2:	bfbb      	ittet	lt
 8016be4:	425b      	neglt	r3, r3
 8016be6:	f042 0202 	orrlt.w	r2, r2, #2
 8016bea:	9307      	strge	r3, [sp, #28]
 8016bec:	9307      	strlt	r3, [sp, #28]
 8016bee:	bfb8      	it	lt
 8016bf0:	9204      	strlt	r2, [sp, #16]
 8016bf2:	7823      	ldrb	r3, [r4, #0]
 8016bf4:	2b2e      	cmp	r3, #46	; 0x2e
 8016bf6:	d10c      	bne.n	8016c12 <_vfiprintf_r+0x15a>
 8016bf8:	7863      	ldrb	r3, [r4, #1]
 8016bfa:	2b2a      	cmp	r3, #42	; 0x2a
 8016bfc:	d134      	bne.n	8016c68 <_vfiprintf_r+0x1b0>
 8016bfe:	9b03      	ldr	r3, [sp, #12]
 8016c00:	3402      	adds	r4, #2
 8016c02:	1d1a      	adds	r2, r3, #4
 8016c04:	681b      	ldr	r3, [r3, #0]
 8016c06:	2b00      	cmp	r3, #0
 8016c08:	9203      	str	r2, [sp, #12]
 8016c0a:	bfb8      	it	lt
 8016c0c:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
 8016c10:	9305      	str	r3, [sp, #20]
 8016c12:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 8016ce8 <_vfiprintf_r+0x230>
 8016c16:	2203      	movs	r2, #3
 8016c18:	7821      	ldrb	r1, [r4, #0]
 8016c1a:	4650      	mov	r0, sl
 8016c1c:	f000 fd02 	bl	8017624 <memchr>
 8016c20:	b138      	cbz	r0, 8016c32 <_vfiprintf_r+0x17a>
 8016c22:	eba0 000a 	sub.w	r0, r0, sl
 8016c26:	2240      	movs	r2, #64	; 0x40
 8016c28:	9b04      	ldr	r3, [sp, #16]
 8016c2a:	3401      	adds	r4, #1
 8016c2c:	4082      	lsls	r2, r0
 8016c2e:	4313      	orrs	r3, r2
 8016c30:	9304      	str	r3, [sp, #16]
 8016c32:	f814 1b01 	ldrb.w	r1, [r4], #1
 8016c36:	2206      	movs	r2, #6
 8016c38:	4828      	ldr	r0, [pc, #160]	; (8016cdc <_vfiprintf_r+0x224>)
 8016c3a:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8016c3e:	f000 fcf1 	bl	8017624 <memchr>
 8016c42:	2800      	cmp	r0, #0
 8016c44:	d03f      	beq.n	8016cc6 <_vfiprintf_r+0x20e>
 8016c46:	4b26      	ldr	r3, [pc, #152]	; (8016ce0 <_vfiprintf_r+0x228>)
 8016c48:	bb1b      	cbnz	r3, 8016c92 <_vfiprintf_r+0x1da>
 8016c4a:	9b03      	ldr	r3, [sp, #12]
 8016c4c:	3307      	adds	r3, #7
 8016c4e:	f023 0307 	bic.w	r3, r3, #7
 8016c52:	3308      	adds	r3, #8
 8016c54:	9303      	str	r3, [sp, #12]
 8016c56:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8016c58:	443b      	add	r3, r7
 8016c5a:	9309      	str	r3, [sp, #36]	; 0x24
 8016c5c:	e768      	b.n	8016b30 <_vfiprintf_r+0x78>
 8016c5e:	fb0c 3202 	mla	r2, ip, r2, r3
 8016c62:	460c      	mov	r4, r1
 8016c64:	2001      	movs	r0, #1
 8016c66:	e7a6      	b.n	8016bb6 <_vfiprintf_r+0xfe>
 8016c68:	2300      	movs	r3, #0
 8016c6a:	3401      	adds	r4, #1
 8016c6c:	f04f 0c0a 	mov.w	ip, #10
 8016c70:	4619      	mov	r1, r3
 8016c72:	9305      	str	r3, [sp, #20]
 8016c74:	4620      	mov	r0, r4
 8016c76:	f810 2b01 	ldrb.w	r2, [r0], #1
 8016c7a:	3a30      	subs	r2, #48	; 0x30
 8016c7c:	2a09      	cmp	r2, #9
 8016c7e:	d903      	bls.n	8016c88 <_vfiprintf_r+0x1d0>
 8016c80:	2b00      	cmp	r3, #0
 8016c82:	d0c6      	beq.n	8016c12 <_vfiprintf_r+0x15a>
 8016c84:	9105      	str	r1, [sp, #20]
 8016c86:	e7c4      	b.n	8016c12 <_vfiprintf_r+0x15a>
 8016c88:	fb0c 2101 	mla	r1, ip, r1, r2
 8016c8c:	4604      	mov	r4, r0
 8016c8e:	2301      	movs	r3, #1
 8016c90:	e7f0      	b.n	8016c74 <_vfiprintf_r+0x1bc>
 8016c92:	ab03      	add	r3, sp, #12
 8016c94:	462a      	mov	r2, r5
 8016c96:	a904      	add	r1, sp, #16
 8016c98:	4630      	mov	r0, r6
 8016c9a:	9300      	str	r3, [sp, #0]
 8016c9c:	4b11      	ldr	r3, [pc, #68]	; (8016ce4 <_vfiprintf_r+0x22c>)
 8016c9e:	f3af 8000 	nop.w
 8016ca2:	4607      	mov	r7, r0
 8016ca4:	1c78      	adds	r0, r7, #1
 8016ca6:	d1d6      	bne.n	8016c56 <_vfiprintf_r+0x19e>
 8016ca8:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8016caa:	07d9      	lsls	r1, r3, #31
 8016cac:	d405      	bmi.n	8016cba <_vfiprintf_r+0x202>
 8016cae:	89ab      	ldrh	r3, [r5, #12]
 8016cb0:	059a      	lsls	r2, r3, #22
 8016cb2:	d402      	bmi.n	8016cba <_vfiprintf_r+0x202>
 8016cb4:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8016cb6:	f7ff fec8 	bl	8016a4a <__retarget_lock_release_recursive>
 8016cba:	89ab      	ldrh	r3, [r5, #12]
 8016cbc:	065b      	lsls	r3, r3, #25
 8016cbe:	f53f af1d 	bmi.w	8016afc <_vfiprintf_r+0x44>
 8016cc2:	9809      	ldr	r0, [sp, #36]	; 0x24
 8016cc4:	e71c      	b.n	8016b00 <_vfiprintf_r+0x48>
 8016cc6:	ab03      	add	r3, sp, #12
 8016cc8:	462a      	mov	r2, r5
 8016cca:	a904      	add	r1, sp, #16
 8016ccc:	4630      	mov	r0, r6
 8016cce:	9300      	str	r3, [sp, #0]
 8016cd0:	4b04      	ldr	r3, [pc, #16]	; (8016ce4 <_vfiprintf_r+0x22c>)
 8016cd2:	f000 f91d 	bl	8016f10 <_printf_i>
 8016cd6:	e7e4      	b.n	8016ca2 <_vfiprintf_r+0x1ea>
 8016cd8:	08017b94 	.word	0x08017b94
 8016cdc:	08017b9e 	.word	0x08017b9e
 8016ce0:	00000000 	.word	0x00000000
 8016ce4:	08016a95 	.word	0x08016a95
 8016ce8:	08017b9a 	.word	0x08017b9a

08016cec <sbrk_aligned>:
 8016cec:	b570      	push	{r4, r5, r6, lr}
 8016cee:	4e0e      	ldr	r6, [pc, #56]	; (8016d28 <sbrk_aligned+0x3c>)
 8016cf0:	460c      	mov	r4, r1
 8016cf2:	4605      	mov	r5, r0
 8016cf4:	6831      	ldr	r1, [r6, #0]
 8016cf6:	b911      	cbnz	r1, 8016cfe <sbrk_aligned+0x12>
 8016cf8:	f000 fc72 	bl	80175e0 <_sbrk_r>
 8016cfc:	6030      	str	r0, [r6, #0]
 8016cfe:	4621      	mov	r1, r4
 8016d00:	4628      	mov	r0, r5
 8016d02:	f000 fc6d 	bl	80175e0 <_sbrk_r>
 8016d06:	1c43      	adds	r3, r0, #1
 8016d08:	d00a      	beq.n	8016d20 <sbrk_aligned+0x34>
 8016d0a:	1cc4      	adds	r4, r0, #3
 8016d0c:	f024 0403 	bic.w	r4, r4, #3
 8016d10:	42a0      	cmp	r0, r4
 8016d12:	d007      	beq.n	8016d24 <sbrk_aligned+0x38>
 8016d14:	1a21      	subs	r1, r4, r0
 8016d16:	4628      	mov	r0, r5
 8016d18:	f000 fc62 	bl	80175e0 <_sbrk_r>
 8016d1c:	3001      	adds	r0, #1
 8016d1e:	d101      	bne.n	8016d24 <sbrk_aligned+0x38>
 8016d20:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8016d24:	4620      	mov	r0, r4
 8016d26:	bd70      	pop	{r4, r5, r6, pc}
 8016d28:	2000f860 	.word	0x2000f860

08016d2c <_malloc_r>:
 8016d2c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8016d30:	1ccd      	adds	r5, r1, #3
 8016d32:	4607      	mov	r7, r0
 8016d34:	f025 0503 	bic.w	r5, r5, #3
 8016d38:	3508      	adds	r5, #8
 8016d3a:	2d0c      	cmp	r5, #12
 8016d3c:	bf38      	it	cc
 8016d3e:	250c      	movcc	r5, #12
 8016d40:	2d00      	cmp	r5, #0
 8016d42:	db01      	blt.n	8016d48 <_malloc_r+0x1c>
 8016d44:	42a9      	cmp	r1, r5
 8016d46:	d905      	bls.n	8016d54 <_malloc_r+0x28>
 8016d48:	230c      	movs	r3, #12
 8016d4a:	2600      	movs	r6, #0
 8016d4c:	603b      	str	r3, [r7, #0]
 8016d4e:	4630      	mov	r0, r6
 8016d50:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8016d54:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 8016e28 <_malloc_r+0xfc>
 8016d58:	f000 faa6 	bl	80172a8 <__malloc_lock>
 8016d5c:	f8d8 3000 	ldr.w	r3, [r8]
 8016d60:	461c      	mov	r4, r3
 8016d62:	bb5c      	cbnz	r4, 8016dbc <_malloc_r+0x90>
 8016d64:	4629      	mov	r1, r5
 8016d66:	4638      	mov	r0, r7
 8016d68:	f7ff ffc0 	bl	8016cec <sbrk_aligned>
 8016d6c:	1c43      	adds	r3, r0, #1
 8016d6e:	4604      	mov	r4, r0
 8016d70:	d155      	bne.n	8016e1e <_malloc_r+0xf2>
 8016d72:	f8d8 4000 	ldr.w	r4, [r8]
 8016d76:	4626      	mov	r6, r4
 8016d78:	2e00      	cmp	r6, #0
 8016d7a:	d145      	bne.n	8016e08 <_malloc_r+0xdc>
 8016d7c:	2c00      	cmp	r4, #0
 8016d7e:	d048      	beq.n	8016e12 <_malloc_r+0xe6>
 8016d80:	6823      	ldr	r3, [r4, #0]
 8016d82:	4631      	mov	r1, r6
 8016d84:	4638      	mov	r0, r7
 8016d86:	eb04 0903 	add.w	r9, r4, r3
 8016d8a:	f000 fc29 	bl	80175e0 <_sbrk_r>
 8016d8e:	4581      	cmp	r9, r0
 8016d90:	d13f      	bne.n	8016e12 <_malloc_r+0xe6>
 8016d92:	6821      	ldr	r1, [r4, #0]
 8016d94:	4638      	mov	r0, r7
 8016d96:	1a6d      	subs	r5, r5, r1
 8016d98:	4629      	mov	r1, r5
 8016d9a:	f7ff ffa7 	bl	8016cec <sbrk_aligned>
 8016d9e:	3001      	adds	r0, #1
 8016da0:	d037      	beq.n	8016e12 <_malloc_r+0xe6>
 8016da2:	6823      	ldr	r3, [r4, #0]
 8016da4:	442b      	add	r3, r5
 8016da6:	6023      	str	r3, [r4, #0]
 8016da8:	f8d8 3000 	ldr.w	r3, [r8]
 8016dac:	2b00      	cmp	r3, #0
 8016dae:	d038      	beq.n	8016e22 <_malloc_r+0xf6>
 8016db0:	685a      	ldr	r2, [r3, #4]
 8016db2:	42a2      	cmp	r2, r4
 8016db4:	d12b      	bne.n	8016e0e <_malloc_r+0xe2>
 8016db6:	2200      	movs	r2, #0
 8016db8:	605a      	str	r2, [r3, #4]
 8016dba:	e00f      	b.n	8016ddc <_malloc_r+0xb0>
 8016dbc:	6822      	ldr	r2, [r4, #0]
 8016dbe:	1b52      	subs	r2, r2, r5
 8016dc0:	d41f      	bmi.n	8016e02 <_malloc_r+0xd6>
 8016dc2:	2a0b      	cmp	r2, #11
 8016dc4:	d917      	bls.n	8016df6 <_malloc_r+0xca>
 8016dc6:	1961      	adds	r1, r4, r5
 8016dc8:	42a3      	cmp	r3, r4
 8016dca:	6025      	str	r5, [r4, #0]
 8016dcc:	bf18      	it	ne
 8016dce:	6059      	strne	r1, [r3, #4]
 8016dd0:	6863      	ldr	r3, [r4, #4]
 8016dd2:	bf08      	it	eq
 8016dd4:	f8c8 1000 	streq.w	r1, [r8]
 8016dd8:	5162      	str	r2, [r4, r5]
 8016dda:	604b      	str	r3, [r1, #4]
 8016ddc:	f104 060b 	add.w	r6, r4, #11
 8016de0:	4638      	mov	r0, r7
 8016de2:	f000 fa67 	bl	80172b4 <__malloc_unlock>
 8016de6:	1d23      	adds	r3, r4, #4
 8016de8:	f026 0607 	bic.w	r6, r6, #7
 8016dec:	1af2      	subs	r2, r6, r3
 8016dee:	d0ae      	beq.n	8016d4e <_malloc_r+0x22>
 8016df0:	1b9b      	subs	r3, r3, r6
 8016df2:	50a3      	str	r3, [r4, r2]
 8016df4:	e7ab      	b.n	8016d4e <_malloc_r+0x22>
 8016df6:	42a3      	cmp	r3, r4
 8016df8:	6862      	ldr	r2, [r4, #4]
 8016dfa:	d1dd      	bne.n	8016db8 <_malloc_r+0x8c>
 8016dfc:	f8c8 2000 	str.w	r2, [r8]
 8016e00:	e7ec      	b.n	8016ddc <_malloc_r+0xb0>
 8016e02:	4623      	mov	r3, r4
 8016e04:	6864      	ldr	r4, [r4, #4]
 8016e06:	e7ac      	b.n	8016d62 <_malloc_r+0x36>
 8016e08:	4634      	mov	r4, r6
 8016e0a:	6876      	ldr	r6, [r6, #4]
 8016e0c:	e7b4      	b.n	8016d78 <_malloc_r+0x4c>
 8016e0e:	4613      	mov	r3, r2
 8016e10:	e7cc      	b.n	8016dac <_malloc_r+0x80>
 8016e12:	230c      	movs	r3, #12
 8016e14:	4638      	mov	r0, r7
 8016e16:	603b      	str	r3, [r7, #0]
 8016e18:	f000 fa4c 	bl	80172b4 <__malloc_unlock>
 8016e1c:	e797      	b.n	8016d4e <_malloc_r+0x22>
 8016e1e:	6025      	str	r5, [r4, #0]
 8016e20:	e7dc      	b.n	8016ddc <_malloc_r+0xb0>
 8016e22:	605b      	str	r3, [r3, #4]
 8016e24:	deff      	udf	#255	; 0xff
 8016e26:	bf00      	nop
 8016e28:	2000f85c 	.word	0x2000f85c

08016e2c <_printf_common>:
 8016e2c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8016e30:	4616      	mov	r6, r2
 8016e32:	4699      	mov	r9, r3
 8016e34:	688a      	ldr	r2, [r1, #8]
 8016e36:	4607      	mov	r7, r0
 8016e38:	690b      	ldr	r3, [r1, #16]
 8016e3a:	460c      	mov	r4, r1
 8016e3c:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8016e40:	4293      	cmp	r3, r2
 8016e42:	bfb8      	it	lt
 8016e44:	4613      	movlt	r3, r2
 8016e46:	6033      	str	r3, [r6, #0]
 8016e48:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8016e4c:	b10a      	cbz	r2, 8016e52 <_printf_common+0x26>
 8016e4e:	3301      	adds	r3, #1
 8016e50:	6033      	str	r3, [r6, #0]
 8016e52:	6823      	ldr	r3, [r4, #0]
 8016e54:	0699      	lsls	r1, r3, #26
 8016e56:	bf42      	ittt	mi
 8016e58:	6833      	ldrmi	r3, [r6, #0]
 8016e5a:	3302      	addmi	r3, #2
 8016e5c:	6033      	strmi	r3, [r6, #0]
 8016e5e:	6825      	ldr	r5, [r4, #0]
 8016e60:	f015 0506 	ands.w	r5, r5, #6
 8016e64:	d106      	bne.n	8016e74 <_printf_common+0x48>
 8016e66:	f104 0a19 	add.w	sl, r4, #25
 8016e6a:	68e3      	ldr	r3, [r4, #12]
 8016e6c:	6832      	ldr	r2, [r6, #0]
 8016e6e:	1a9b      	subs	r3, r3, r2
 8016e70:	42ab      	cmp	r3, r5
 8016e72:	dc2b      	bgt.n	8016ecc <_printf_common+0xa0>
 8016e74:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 8016e78:	1e13      	subs	r3, r2, #0
 8016e7a:	6822      	ldr	r2, [r4, #0]
 8016e7c:	bf18      	it	ne
 8016e7e:	2301      	movne	r3, #1
 8016e80:	0692      	lsls	r2, r2, #26
 8016e82:	d430      	bmi.n	8016ee6 <_printf_common+0xba>
 8016e84:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8016e88:	4649      	mov	r1, r9
 8016e8a:	4638      	mov	r0, r7
 8016e8c:	47c0      	blx	r8
 8016e8e:	3001      	adds	r0, #1
 8016e90:	d023      	beq.n	8016eda <_printf_common+0xae>
 8016e92:	6823      	ldr	r3, [r4, #0]
 8016e94:	341a      	adds	r4, #26
 8016e96:	f854 2c0a 	ldr.w	r2, [r4, #-10]
 8016e9a:	f003 0306 	and.w	r3, r3, #6
 8016e9e:	2b04      	cmp	r3, #4
 8016ea0:	bf0a      	itet	eq
 8016ea2:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
 8016ea6:	2500      	movne	r5, #0
 8016ea8:	6833      	ldreq	r3, [r6, #0]
 8016eaa:	f04f 0600 	mov.w	r6, #0
 8016eae:	bf08      	it	eq
 8016eb0:	1aed      	subeq	r5, r5, r3
 8016eb2:	f854 3c12 	ldr.w	r3, [r4, #-18]
 8016eb6:	bf08      	it	eq
 8016eb8:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8016ebc:	4293      	cmp	r3, r2
 8016ebe:	bfc4      	itt	gt
 8016ec0:	1a9b      	subgt	r3, r3, r2
 8016ec2:	18ed      	addgt	r5, r5, r3
 8016ec4:	42b5      	cmp	r5, r6
 8016ec6:	d11a      	bne.n	8016efe <_printf_common+0xd2>
 8016ec8:	2000      	movs	r0, #0
 8016eca:	e008      	b.n	8016ede <_printf_common+0xb2>
 8016ecc:	2301      	movs	r3, #1
 8016ece:	4652      	mov	r2, sl
 8016ed0:	4649      	mov	r1, r9
 8016ed2:	4638      	mov	r0, r7
 8016ed4:	47c0      	blx	r8
 8016ed6:	3001      	adds	r0, #1
 8016ed8:	d103      	bne.n	8016ee2 <_printf_common+0xb6>
 8016eda:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8016ede:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8016ee2:	3501      	adds	r5, #1
 8016ee4:	e7c1      	b.n	8016e6a <_printf_common+0x3e>
 8016ee6:	18e1      	adds	r1, r4, r3
 8016ee8:	1c5a      	adds	r2, r3, #1
 8016eea:	2030      	movs	r0, #48	; 0x30
 8016eec:	3302      	adds	r3, #2
 8016eee:	4422      	add	r2, r4
 8016ef0:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 8016ef4:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8016ef8:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8016efc:	e7c2      	b.n	8016e84 <_printf_common+0x58>
 8016efe:	2301      	movs	r3, #1
 8016f00:	4622      	mov	r2, r4
 8016f02:	4649      	mov	r1, r9
 8016f04:	4638      	mov	r0, r7
 8016f06:	47c0      	blx	r8
 8016f08:	3001      	adds	r0, #1
 8016f0a:	d0e6      	beq.n	8016eda <_printf_common+0xae>
 8016f0c:	3601      	adds	r6, #1
 8016f0e:	e7d9      	b.n	8016ec4 <_printf_common+0x98>

08016f10 <_printf_i>:
 8016f10:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8016f14:	7e0f      	ldrb	r7, [r1, #24]
 8016f16:	4691      	mov	r9, r2
 8016f18:	4680      	mov	r8, r0
 8016f1a:	460c      	mov	r4, r1
 8016f1c:	2f78      	cmp	r7, #120	; 0x78
 8016f1e:	469a      	mov	sl, r3
 8016f20:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8016f22:	f101 0243 	add.w	r2, r1, #67	; 0x43
 8016f26:	d807      	bhi.n	8016f38 <_printf_i+0x28>
 8016f28:	2f62      	cmp	r7, #98	; 0x62
 8016f2a:	d80a      	bhi.n	8016f42 <_printf_i+0x32>
 8016f2c:	2f00      	cmp	r7, #0
 8016f2e:	f000 80d3 	beq.w	80170d8 <_printf_i+0x1c8>
 8016f32:	2f58      	cmp	r7, #88	; 0x58
 8016f34:	f000 80bf 	beq.w	80170b6 <_printf_i+0x1a6>
 8016f38:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8016f3c:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 8016f40:	e03a      	b.n	8016fb8 <_printf_i+0xa8>
 8016f42:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 8016f46:	2b15      	cmp	r3, #21
 8016f48:	d8f6      	bhi.n	8016f38 <_printf_i+0x28>
 8016f4a:	a101      	add	r1, pc, #4	; (adr r1, 8016f50 <_printf_i+0x40>)
 8016f4c:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8016f50:	08016fa9 	.word	0x08016fa9
 8016f54:	08016fbd 	.word	0x08016fbd
 8016f58:	08016f39 	.word	0x08016f39
 8016f5c:	08016f39 	.word	0x08016f39
 8016f60:	08016f39 	.word	0x08016f39
 8016f64:	08016f39 	.word	0x08016f39
 8016f68:	08016fbd 	.word	0x08016fbd
 8016f6c:	08016f39 	.word	0x08016f39
 8016f70:	08016f39 	.word	0x08016f39
 8016f74:	08016f39 	.word	0x08016f39
 8016f78:	08016f39 	.word	0x08016f39
 8016f7c:	080170bf 	.word	0x080170bf
 8016f80:	08016fe9 	.word	0x08016fe9
 8016f84:	0801707b 	.word	0x0801707b
 8016f88:	08016f39 	.word	0x08016f39
 8016f8c:	08016f39 	.word	0x08016f39
 8016f90:	080170e1 	.word	0x080170e1
 8016f94:	08016f39 	.word	0x08016f39
 8016f98:	08016fe9 	.word	0x08016fe9
 8016f9c:	08016f39 	.word	0x08016f39
 8016fa0:	08016f39 	.word	0x08016f39
 8016fa4:	08017083 	.word	0x08017083
 8016fa8:	682b      	ldr	r3, [r5, #0]
 8016faa:	1d1a      	adds	r2, r3, #4
 8016fac:	681b      	ldr	r3, [r3, #0]
 8016fae:	602a      	str	r2, [r5, #0]
 8016fb0:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8016fb4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8016fb8:	2301      	movs	r3, #1
 8016fba:	e09e      	b.n	80170fa <_printf_i+0x1ea>
 8016fbc:	6820      	ldr	r0, [r4, #0]
 8016fbe:	682b      	ldr	r3, [r5, #0]
 8016fc0:	0607      	lsls	r7, r0, #24
 8016fc2:	f103 0104 	add.w	r1, r3, #4
 8016fc6:	6029      	str	r1, [r5, #0]
 8016fc8:	d501      	bpl.n	8016fce <_printf_i+0xbe>
 8016fca:	681e      	ldr	r6, [r3, #0]
 8016fcc:	e003      	b.n	8016fd6 <_printf_i+0xc6>
 8016fce:	0646      	lsls	r6, r0, #25
 8016fd0:	d5fb      	bpl.n	8016fca <_printf_i+0xba>
 8016fd2:	f9b3 6000 	ldrsh.w	r6, [r3]
 8016fd6:	2e00      	cmp	r6, #0
 8016fd8:	da03      	bge.n	8016fe2 <_printf_i+0xd2>
 8016fda:	232d      	movs	r3, #45	; 0x2d
 8016fdc:	4276      	negs	r6, r6
 8016fde:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8016fe2:	4859      	ldr	r0, [pc, #356]	; (8017148 <_printf_i+0x238>)
 8016fe4:	230a      	movs	r3, #10
 8016fe6:	e012      	b.n	801700e <_printf_i+0xfe>
 8016fe8:	682b      	ldr	r3, [r5, #0]
 8016fea:	6820      	ldr	r0, [r4, #0]
 8016fec:	1d19      	adds	r1, r3, #4
 8016fee:	6029      	str	r1, [r5, #0]
 8016ff0:	0605      	lsls	r5, r0, #24
 8016ff2:	d501      	bpl.n	8016ff8 <_printf_i+0xe8>
 8016ff4:	681e      	ldr	r6, [r3, #0]
 8016ff6:	e002      	b.n	8016ffe <_printf_i+0xee>
 8016ff8:	0641      	lsls	r1, r0, #25
 8016ffa:	d5fb      	bpl.n	8016ff4 <_printf_i+0xe4>
 8016ffc:	881e      	ldrh	r6, [r3, #0]
 8016ffe:	2f6f      	cmp	r7, #111	; 0x6f
 8017000:	4851      	ldr	r0, [pc, #324]	; (8017148 <_printf_i+0x238>)
 8017002:	bf0c      	ite	eq
 8017004:	2308      	moveq	r3, #8
 8017006:	230a      	movne	r3, #10
 8017008:	2100      	movs	r1, #0
 801700a:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 801700e:	6865      	ldr	r5, [r4, #4]
 8017010:	2d00      	cmp	r5, #0
 8017012:	60a5      	str	r5, [r4, #8]
 8017014:	bfa2      	ittt	ge
 8017016:	6821      	ldrge	r1, [r4, #0]
 8017018:	f021 0104 	bicge.w	r1, r1, #4
 801701c:	6021      	strge	r1, [r4, #0]
 801701e:	b90e      	cbnz	r6, 8017024 <_printf_i+0x114>
 8017020:	2d00      	cmp	r5, #0
 8017022:	d04a      	beq.n	80170ba <_printf_i+0x1aa>
 8017024:	4615      	mov	r5, r2
 8017026:	fbb6 f1f3 	udiv	r1, r6, r3
 801702a:	fb03 6711 	mls	r7, r3, r1, r6
 801702e:	5dc7      	ldrb	r7, [r0, r7]
 8017030:	f805 7d01 	strb.w	r7, [r5, #-1]!
 8017034:	4637      	mov	r7, r6
 8017036:	460e      	mov	r6, r1
 8017038:	42bb      	cmp	r3, r7
 801703a:	d9f4      	bls.n	8017026 <_printf_i+0x116>
 801703c:	2b08      	cmp	r3, #8
 801703e:	d10b      	bne.n	8017058 <_printf_i+0x148>
 8017040:	6823      	ldr	r3, [r4, #0]
 8017042:	07de      	lsls	r6, r3, #31
 8017044:	d508      	bpl.n	8017058 <_printf_i+0x148>
 8017046:	6923      	ldr	r3, [r4, #16]
 8017048:	6861      	ldr	r1, [r4, #4]
 801704a:	4299      	cmp	r1, r3
 801704c:	bfde      	ittt	le
 801704e:	2330      	movle	r3, #48	; 0x30
 8017050:	f805 3c01 	strble.w	r3, [r5, #-1]
 8017054:	f105 35ff 	addle.w	r5, r5, #4294967295	; 0xffffffff
 8017058:	1b52      	subs	r2, r2, r5
 801705a:	6122      	str	r2, [r4, #16]
 801705c:	464b      	mov	r3, r9
 801705e:	aa03      	add	r2, sp, #12
 8017060:	4621      	mov	r1, r4
 8017062:	4640      	mov	r0, r8
 8017064:	f8cd a000 	str.w	sl, [sp]
 8017068:	f7ff fee0 	bl	8016e2c <_printf_common>
 801706c:	3001      	adds	r0, #1
 801706e:	d149      	bne.n	8017104 <_printf_i+0x1f4>
 8017070:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8017074:	b004      	add	sp, #16
 8017076:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801707a:	6823      	ldr	r3, [r4, #0]
 801707c:	f043 0320 	orr.w	r3, r3, #32
 8017080:	6023      	str	r3, [r4, #0]
 8017082:	2778      	movs	r7, #120	; 0x78
 8017084:	4831      	ldr	r0, [pc, #196]	; (801714c <_printf_i+0x23c>)
 8017086:	6823      	ldr	r3, [r4, #0]
 8017088:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
 801708c:	061f      	lsls	r7, r3, #24
 801708e:	6829      	ldr	r1, [r5, #0]
 8017090:	f851 6b04 	ldr.w	r6, [r1], #4
 8017094:	d402      	bmi.n	801709c <_printf_i+0x18c>
 8017096:	065f      	lsls	r7, r3, #25
 8017098:	bf48      	it	mi
 801709a:	b2b6      	uxthmi	r6, r6
 801709c:	07df      	lsls	r7, r3, #31
 801709e:	6029      	str	r1, [r5, #0]
 80170a0:	bf44      	itt	mi
 80170a2:	f043 0320 	orrmi.w	r3, r3, #32
 80170a6:	6023      	strmi	r3, [r4, #0]
 80170a8:	b91e      	cbnz	r6, 80170b2 <_printf_i+0x1a2>
 80170aa:	6823      	ldr	r3, [r4, #0]
 80170ac:	f023 0320 	bic.w	r3, r3, #32
 80170b0:	6023      	str	r3, [r4, #0]
 80170b2:	2310      	movs	r3, #16
 80170b4:	e7a8      	b.n	8017008 <_printf_i+0xf8>
 80170b6:	4824      	ldr	r0, [pc, #144]	; (8017148 <_printf_i+0x238>)
 80170b8:	e7e5      	b.n	8017086 <_printf_i+0x176>
 80170ba:	4615      	mov	r5, r2
 80170bc:	e7be      	b.n	801703c <_printf_i+0x12c>
 80170be:	682b      	ldr	r3, [r5, #0]
 80170c0:	6826      	ldr	r6, [r4, #0]
 80170c2:	1d18      	adds	r0, r3, #4
 80170c4:	6961      	ldr	r1, [r4, #20]
 80170c6:	6028      	str	r0, [r5, #0]
 80170c8:	0635      	lsls	r5, r6, #24
 80170ca:	681b      	ldr	r3, [r3, #0]
 80170cc:	d501      	bpl.n	80170d2 <_printf_i+0x1c2>
 80170ce:	6019      	str	r1, [r3, #0]
 80170d0:	e002      	b.n	80170d8 <_printf_i+0x1c8>
 80170d2:	0670      	lsls	r0, r6, #25
 80170d4:	d5fb      	bpl.n	80170ce <_printf_i+0x1be>
 80170d6:	8019      	strh	r1, [r3, #0]
 80170d8:	2300      	movs	r3, #0
 80170da:	4615      	mov	r5, r2
 80170dc:	6123      	str	r3, [r4, #16]
 80170de:	e7bd      	b.n	801705c <_printf_i+0x14c>
 80170e0:	682b      	ldr	r3, [r5, #0]
 80170e2:	2100      	movs	r1, #0
 80170e4:	1d1a      	adds	r2, r3, #4
 80170e6:	602a      	str	r2, [r5, #0]
 80170e8:	681d      	ldr	r5, [r3, #0]
 80170ea:	6862      	ldr	r2, [r4, #4]
 80170ec:	4628      	mov	r0, r5
 80170ee:	f000 fa99 	bl	8017624 <memchr>
 80170f2:	b108      	cbz	r0, 80170f8 <_printf_i+0x1e8>
 80170f4:	1b40      	subs	r0, r0, r5
 80170f6:	6060      	str	r0, [r4, #4]
 80170f8:	6863      	ldr	r3, [r4, #4]
 80170fa:	6123      	str	r3, [r4, #16]
 80170fc:	2300      	movs	r3, #0
 80170fe:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8017102:	e7ab      	b.n	801705c <_printf_i+0x14c>
 8017104:	6923      	ldr	r3, [r4, #16]
 8017106:	462a      	mov	r2, r5
 8017108:	4649      	mov	r1, r9
 801710a:	4640      	mov	r0, r8
 801710c:	47d0      	blx	sl
 801710e:	3001      	adds	r0, #1
 8017110:	d0ae      	beq.n	8017070 <_printf_i+0x160>
 8017112:	6823      	ldr	r3, [r4, #0]
 8017114:	079b      	lsls	r3, r3, #30
 8017116:	d413      	bmi.n	8017140 <_printf_i+0x230>
 8017118:	68e0      	ldr	r0, [r4, #12]
 801711a:	9b03      	ldr	r3, [sp, #12]
 801711c:	4298      	cmp	r0, r3
 801711e:	bfb8      	it	lt
 8017120:	4618      	movlt	r0, r3
 8017122:	e7a7      	b.n	8017074 <_printf_i+0x164>
 8017124:	2301      	movs	r3, #1
 8017126:	4632      	mov	r2, r6
 8017128:	4649      	mov	r1, r9
 801712a:	4640      	mov	r0, r8
 801712c:	47d0      	blx	sl
 801712e:	3001      	adds	r0, #1
 8017130:	d09e      	beq.n	8017070 <_printf_i+0x160>
 8017132:	3501      	adds	r5, #1
 8017134:	68e3      	ldr	r3, [r4, #12]
 8017136:	9903      	ldr	r1, [sp, #12]
 8017138:	1a5b      	subs	r3, r3, r1
 801713a:	42ab      	cmp	r3, r5
 801713c:	dcf2      	bgt.n	8017124 <_printf_i+0x214>
 801713e:	e7eb      	b.n	8017118 <_printf_i+0x208>
 8017140:	2500      	movs	r5, #0
 8017142:	f104 0619 	add.w	r6, r4, #25
 8017146:	e7f5      	b.n	8017134 <_printf_i+0x224>
 8017148:	08017ba5 	.word	0x08017ba5
 801714c:	08017bb6 	.word	0x08017bb6

08017150 <__sflush_r>:
 8017150:	898a      	ldrh	r2, [r1, #12]
 8017152:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8017156:	4605      	mov	r5, r0
 8017158:	0710      	lsls	r0, r2, #28
 801715a:	460c      	mov	r4, r1
 801715c:	d458      	bmi.n	8017210 <__sflush_r+0xc0>
 801715e:	684b      	ldr	r3, [r1, #4]
 8017160:	2b00      	cmp	r3, #0
 8017162:	dc05      	bgt.n	8017170 <__sflush_r+0x20>
 8017164:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 8017166:	2b00      	cmp	r3, #0
 8017168:	dc02      	bgt.n	8017170 <__sflush_r+0x20>
 801716a:	2000      	movs	r0, #0
 801716c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8017170:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8017172:	2e00      	cmp	r6, #0
 8017174:	d0f9      	beq.n	801716a <__sflush_r+0x1a>
 8017176:	2300      	movs	r3, #0
 8017178:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 801717c:	682f      	ldr	r7, [r5, #0]
 801717e:	6a21      	ldr	r1, [r4, #32]
 8017180:	602b      	str	r3, [r5, #0]
 8017182:	d032      	beq.n	80171ea <__sflush_r+0x9a>
 8017184:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8017186:	89a3      	ldrh	r3, [r4, #12]
 8017188:	075a      	lsls	r2, r3, #29
 801718a:	d505      	bpl.n	8017198 <__sflush_r+0x48>
 801718c:	6863      	ldr	r3, [r4, #4]
 801718e:	1ac0      	subs	r0, r0, r3
 8017190:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8017192:	b10b      	cbz	r3, 8017198 <__sflush_r+0x48>
 8017194:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8017196:	1ac0      	subs	r0, r0, r3
 8017198:	2300      	movs	r3, #0
 801719a:	4602      	mov	r2, r0
 801719c:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 801719e:	4628      	mov	r0, r5
 80171a0:	6a21      	ldr	r1, [r4, #32]
 80171a2:	47b0      	blx	r6
 80171a4:	1c43      	adds	r3, r0, #1
 80171a6:	89a3      	ldrh	r3, [r4, #12]
 80171a8:	d106      	bne.n	80171b8 <__sflush_r+0x68>
 80171aa:	6829      	ldr	r1, [r5, #0]
 80171ac:	291d      	cmp	r1, #29
 80171ae:	d82b      	bhi.n	8017208 <__sflush_r+0xb8>
 80171b0:	4a28      	ldr	r2, [pc, #160]	; (8017254 <__sflush_r+0x104>)
 80171b2:	410a      	asrs	r2, r1
 80171b4:	07d6      	lsls	r6, r2, #31
 80171b6:	d427      	bmi.n	8017208 <__sflush_r+0xb8>
 80171b8:	2200      	movs	r2, #0
 80171ba:	04d9      	lsls	r1, r3, #19
 80171bc:	6062      	str	r2, [r4, #4]
 80171be:	6922      	ldr	r2, [r4, #16]
 80171c0:	6022      	str	r2, [r4, #0]
 80171c2:	d504      	bpl.n	80171ce <__sflush_r+0x7e>
 80171c4:	1c42      	adds	r2, r0, #1
 80171c6:	d101      	bne.n	80171cc <__sflush_r+0x7c>
 80171c8:	682b      	ldr	r3, [r5, #0]
 80171ca:	b903      	cbnz	r3, 80171ce <__sflush_r+0x7e>
 80171cc:	6560      	str	r0, [r4, #84]	; 0x54
 80171ce:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80171d0:	602f      	str	r7, [r5, #0]
 80171d2:	2900      	cmp	r1, #0
 80171d4:	d0c9      	beq.n	801716a <__sflush_r+0x1a>
 80171d6:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80171da:	4299      	cmp	r1, r3
 80171dc:	d002      	beq.n	80171e4 <__sflush_r+0x94>
 80171de:	4628      	mov	r0, r5
 80171e0:	f000 fa2e 	bl	8017640 <_free_r>
 80171e4:	2000      	movs	r0, #0
 80171e6:	6360      	str	r0, [r4, #52]	; 0x34
 80171e8:	e7c0      	b.n	801716c <__sflush_r+0x1c>
 80171ea:	2301      	movs	r3, #1
 80171ec:	4628      	mov	r0, r5
 80171ee:	47b0      	blx	r6
 80171f0:	1c41      	adds	r1, r0, #1
 80171f2:	d1c8      	bne.n	8017186 <__sflush_r+0x36>
 80171f4:	682b      	ldr	r3, [r5, #0]
 80171f6:	2b00      	cmp	r3, #0
 80171f8:	d0c5      	beq.n	8017186 <__sflush_r+0x36>
 80171fa:	2b1d      	cmp	r3, #29
 80171fc:	d001      	beq.n	8017202 <__sflush_r+0xb2>
 80171fe:	2b16      	cmp	r3, #22
 8017200:	d101      	bne.n	8017206 <__sflush_r+0xb6>
 8017202:	602f      	str	r7, [r5, #0]
 8017204:	e7b1      	b.n	801716a <__sflush_r+0x1a>
 8017206:	89a3      	ldrh	r3, [r4, #12]
 8017208:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801720c:	81a3      	strh	r3, [r4, #12]
 801720e:	e7ad      	b.n	801716c <__sflush_r+0x1c>
 8017210:	690f      	ldr	r7, [r1, #16]
 8017212:	2f00      	cmp	r7, #0
 8017214:	d0a9      	beq.n	801716a <__sflush_r+0x1a>
 8017216:	0793      	lsls	r3, r2, #30
 8017218:	680e      	ldr	r6, [r1, #0]
 801721a:	600f      	str	r7, [r1, #0]
 801721c:	bf0c      	ite	eq
 801721e:	694b      	ldreq	r3, [r1, #20]
 8017220:	2300      	movne	r3, #0
 8017222:	eba6 0807 	sub.w	r8, r6, r7
 8017226:	608b      	str	r3, [r1, #8]
 8017228:	f1b8 0f00 	cmp.w	r8, #0
 801722c:	dd9d      	ble.n	801716a <__sflush_r+0x1a>
 801722e:	4643      	mov	r3, r8
 8017230:	463a      	mov	r2, r7
 8017232:	6a21      	ldr	r1, [r4, #32]
 8017234:	4628      	mov	r0, r5
 8017236:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8017238:	47b0      	blx	r6
 801723a:	2800      	cmp	r0, #0
 801723c:	dc06      	bgt.n	801724c <__sflush_r+0xfc>
 801723e:	89a3      	ldrh	r3, [r4, #12]
 8017240:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8017244:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8017248:	81a3      	strh	r3, [r4, #12]
 801724a:	e78f      	b.n	801716c <__sflush_r+0x1c>
 801724c:	4407      	add	r7, r0
 801724e:	eba8 0800 	sub.w	r8, r8, r0
 8017252:	e7e9      	b.n	8017228 <__sflush_r+0xd8>
 8017254:	dfbffffe 	.word	0xdfbffffe

08017258 <_fflush_r>:
 8017258:	b538      	push	{r3, r4, r5, lr}
 801725a:	690b      	ldr	r3, [r1, #16]
 801725c:	4605      	mov	r5, r0
 801725e:	460c      	mov	r4, r1
 8017260:	b913      	cbnz	r3, 8017268 <_fflush_r+0x10>
 8017262:	2500      	movs	r5, #0
 8017264:	4628      	mov	r0, r5
 8017266:	bd38      	pop	{r3, r4, r5, pc}
 8017268:	b118      	cbz	r0, 8017272 <_fflush_r+0x1a>
 801726a:	6a03      	ldr	r3, [r0, #32]
 801726c:	b90b      	cbnz	r3, 8017272 <_fflush_r+0x1a>
 801726e:	f7ff fb15 	bl	801689c <__sinit>
 8017272:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8017276:	2b00      	cmp	r3, #0
 8017278:	d0f3      	beq.n	8017262 <_fflush_r+0xa>
 801727a:	6e62      	ldr	r2, [r4, #100]	; 0x64
 801727c:	07d0      	lsls	r0, r2, #31
 801727e:	d404      	bmi.n	801728a <_fflush_r+0x32>
 8017280:	0599      	lsls	r1, r3, #22
 8017282:	d402      	bmi.n	801728a <_fflush_r+0x32>
 8017284:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8017286:	f7ff fbdf 	bl	8016a48 <__retarget_lock_acquire_recursive>
 801728a:	4628      	mov	r0, r5
 801728c:	4621      	mov	r1, r4
 801728e:	f7ff ff5f 	bl	8017150 <__sflush_r>
 8017292:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8017294:	4605      	mov	r5, r0
 8017296:	07da      	lsls	r2, r3, #31
 8017298:	d4e4      	bmi.n	8017264 <_fflush_r+0xc>
 801729a:	89a3      	ldrh	r3, [r4, #12]
 801729c:	059b      	lsls	r3, r3, #22
 801729e:	d4e1      	bmi.n	8017264 <_fflush_r+0xc>
 80172a0:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80172a2:	f7ff fbd2 	bl	8016a4a <__retarget_lock_release_recursive>
 80172a6:	e7dd      	b.n	8017264 <_fflush_r+0xc>

080172a8 <__malloc_lock>:
 80172a8:	4801      	ldr	r0, [pc, #4]	; (80172b0 <__malloc_lock+0x8>)
 80172aa:	f7ff bbcd 	b.w	8016a48 <__retarget_lock_acquire_recursive>
 80172ae:	bf00      	nop
 80172b0:	2000f858 	.word	0x2000f858

080172b4 <__malloc_unlock>:
 80172b4:	4801      	ldr	r0, [pc, #4]	; (80172bc <__malloc_unlock+0x8>)
 80172b6:	f7ff bbc8 	b.w	8016a4a <__retarget_lock_release_recursive>
 80172ba:	bf00      	nop
 80172bc:	2000f858 	.word	0x2000f858

080172c0 <__sread>:
 80172c0:	b510      	push	{r4, lr}
 80172c2:	460c      	mov	r4, r1
 80172c4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80172c8:	f000 f978 	bl	80175bc <_read_r>
 80172cc:	2800      	cmp	r0, #0
 80172ce:	bfab      	itete	ge
 80172d0:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 80172d2:	89a3      	ldrhlt	r3, [r4, #12]
 80172d4:	181b      	addge	r3, r3, r0
 80172d6:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 80172da:	bfac      	ite	ge
 80172dc:	6563      	strge	r3, [r4, #84]	; 0x54
 80172de:	81a3      	strhlt	r3, [r4, #12]
 80172e0:	bd10      	pop	{r4, pc}

080172e2 <__swrite>:
 80172e2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80172e6:	461f      	mov	r7, r3
 80172e8:	898b      	ldrh	r3, [r1, #12]
 80172ea:	4605      	mov	r5, r0
 80172ec:	460c      	mov	r4, r1
 80172ee:	05db      	lsls	r3, r3, #23
 80172f0:	4616      	mov	r6, r2
 80172f2:	d505      	bpl.n	8017300 <__swrite+0x1e>
 80172f4:	2302      	movs	r3, #2
 80172f6:	2200      	movs	r2, #0
 80172f8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80172fc:	f000 f94c 	bl	8017598 <_lseek_r>
 8017300:	89a3      	ldrh	r3, [r4, #12]
 8017302:	4632      	mov	r2, r6
 8017304:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8017308:	4628      	mov	r0, r5
 801730a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 801730e:	81a3      	strh	r3, [r4, #12]
 8017310:	463b      	mov	r3, r7
 8017312:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8017316:	f000 b973 	b.w	8017600 <_write_r>

0801731a <__sseek>:
 801731a:	b510      	push	{r4, lr}
 801731c:	460c      	mov	r4, r1
 801731e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8017322:	f000 f939 	bl	8017598 <_lseek_r>
 8017326:	1c43      	adds	r3, r0, #1
 8017328:	89a3      	ldrh	r3, [r4, #12]
 801732a:	bf15      	itete	ne
 801732c:	6560      	strne	r0, [r4, #84]	; 0x54
 801732e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8017332:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8017336:	81a3      	strheq	r3, [r4, #12]
 8017338:	bf18      	it	ne
 801733a:	81a3      	strhne	r3, [r4, #12]
 801733c:	bd10      	pop	{r4, pc}

0801733e <__sclose>:
 801733e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8017342:	f000 b8f7 	b.w	8017534 <_close_r>

08017346 <__swbuf_r>:
 8017346:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8017348:	460e      	mov	r6, r1
 801734a:	4614      	mov	r4, r2
 801734c:	4605      	mov	r5, r0
 801734e:	b118      	cbz	r0, 8017358 <__swbuf_r+0x12>
 8017350:	6a03      	ldr	r3, [r0, #32]
 8017352:	b90b      	cbnz	r3, 8017358 <__swbuf_r+0x12>
 8017354:	f7ff faa2 	bl	801689c <__sinit>
 8017358:	69a3      	ldr	r3, [r4, #24]
 801735a:	60a3      	str	r3, [r4, #8]
 801735c:	89a3      	ldrh	r3, [r4, #12]
 801735e:	071a      	lsls	r2, r3, #28
 8017360:	d525      	bpl.n	80173ae <__swbuf_r+0x68>
 8017362:	6923      	ldr	r3, [r4, #16]
 8017364:	b31b      	cbz	r3, 80173ae <__swbuf_r+0x68>
 8017366:	6823      	ldr	r3, [r4, #0]
 8017368:	b2f6      	uxtb	r6, r6
 801736a:	6922      	ldr	r2, [r4, #16]
 801736c:	4637      	mov	r7, r6
 801736e:	1a98      	subs	r0, r3, r2
 8017370:	6963      	ldr	r3, [r4, #20]
 8017372:	4283      	cmp	r3, r0
 8017374:	dc04      	bgt.n	8017380 <__swbuf_r+0x3a>
 8017376:	4621      	mov	r1, r4
 8017378:	4628      	mov	r0, r5
 801737a:	f7ff ff6d 	bl	8017258 <_fflush_r>
 801737e:	b9e0      	cbnz	r0, 80173ba <__swbuf_r+0x74>
 8017380:	68a3      	ldr	r3, [r4, #8]
 8017382:	3b01      	subs	r3, #1
 8017384:	60a3      	str	r3, [r4, #8]
 8017386:	6823      	ldr	r3, [r4, #0]
 8017388:	1c5a      	adds	r2, r3, #1
 801738a:	6022      	str	r2, [r4, #0]
 801738c:	701e      	strb	r6, [r3, #0]
 801738e:	1c43      	adds	r3, r0, #1
 8017390:	6962      	ldr	r2, [r4, #20]
 8017392:	429a      	cmp	r2, r3
 8017394:	d004      	beq.n	80173a0 <__swbuf_r+0x5a>
 8017396:	89a3      	ldrh	r3, [r4, #12]
 8017398:	07db      	lsls	r3, r3, #31
 801739a:	d506      	bpl.n	80173aa <__swbuf_r+0x64>
 801739c:	2e0a      	cmp	r6, #10
 801739e:	d104      	bne.n	80173aa <__swbuf_r+0x64>
 80173a0:	4621      	mov	r1, r4
 80173a2:	4628      	mov	r0, r5
 80173a4:	f7ff ff58 	bl	8017258 <_fflush_r>
 80173a8:	b938      	cbnz	r0, 80173ba <__swbuf_r+0x74>
 80173aa:	4638      	mov	r0, r7
 80173ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80173ae:	4621      	mov	r1, r4
 80173b0:	4628      	mov	r0, r5
 80173b2:	f000 f805 	bl	80173c0 <__swsetup_r>
 80173b6:	2800      	cmp	r0, #0
 80173b8:	d0d5      	beq.n	8017366 <__swbuf_r+0x20>
 80173ba:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 80173be:	e7f4      	b.n	80173aa <__swbuf_r+0x64>

080173c0 <__swsetup_r>:
 80173c0:	b538      	push	{r3, r4, r5, lr}
 80173c2:	4b2a      	ldr	r3, [pc, #168]	; (801746c <__swsetup_r+0xac>)
 80173c4:	4605      	mov	r5, r0
 80173c6:	460c      	mov	r4, r1
 80173c8:	6818      	ldr	r0, [r3, #0]
 80173ca:	b118      	cbz	r0, 80173d4 <__swsetup_r+0x14>
 80173cc:	6a03      	ldr	r3, [r0, #32]
 80173ce:	b90b      	cbnz	r3, 80173d4 <__swsetup_r+0x14>
 80173d0:	f7ff fa64 	bl	801689c <__sinit>
 80173d4:	89a3      	ldrh	r3, [r4, #12]
 80173d6:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 80173da:	0718      	lsls	r0, r3, #28
 80173dc:	d422      	bmi.n	8017424 <__swsetup_r+0x64>
 80173de:	06d9      	lsls	r1, r3, #27
 80173e0:	d407      	bmi.n	80173f2 <__swsetup_r+0x32>
 80173e2:	2309      	movs	r3, #9
 80173e4:	602b      	str	r3, [r5, #0]
 80173e6:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 80173ea:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80173ee:	81a3      	strh	r3, [r4, #12]
 80173f0:	e034      	b.n	801745c <__swsetup_r+0x9c>
 80173f2:	0758      	lsls	r0, r3, #29
 80173f4:	d512      	bpl.n	801741c <__swsetup_r+0x5c>
 80173f6:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80173f8:	b141      	cbz	r1, 801740c <__swsetup_r+0x4c>
 80173fa:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80173fe:	4299      	cmp	r1, r3
 8017400:	d002      	beq.n	8017408 <__swsetup_r+0x48>
 8017402:	4628      	mov	r0, r5
 8017404:	f000 f91c 	bl	8017640 <_free_r>
 8017408:	2300      	movs	r3, #0
 801740a:	6363      	str	r3, [r4, #52]	; 0x34
 801740c:	89a3      	ldrh	r3, [r4, #12]
 801740e:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 8017412:	81a3      	strh	r3, [r4, #12]
 8017414:	2300      	movs	r3, #0
 8017416:	6063      	str	r3, [r4, #4]
 8017418:	6923      	ldr	r3, [r4, #16]
 801741a:	6023      	str	r3, [r4, #0]
 801741c:	89a3      	ldrh	r3, [r4, #12]
 801741e:	f043 0308 	orr.w	r3, r3, #8
 8017422:	81a3      	strh	r3, [r4, #12]
 8017424:	6923      	ldr	r3, [r4, #16]
 8017426:	b94b      	cbnz	r3, 801743c <__swsetup_r+0x7c>
 8017428:	89a3      	ldrh	r3, [r4, #12]
 801742a:	f403 7320 	and.w	r3, r3, #640	; 0x280
 801742e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8017432:	d003      	beq.n	801743c <__swsetup_r+0x7c>
 8017434:	4621      	mov	r1, r4
 8017436:	4628      	mov	r0, r5
 8017438:	f000 f83f 	bl	80174ba <__smakebuf_r>
 801743c:	89a0      	ldrh	r0, [r4, #12]
 801743e:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8017442:	f010 0301 	ands.w	r3, r0, #1
 8017446:	d00a      	beq.n	801745e <__swsetup_r+0x9e>
 8017448:	2300      	movs	r3, #0
 801744a:	60a3      	str	r3, [r4, #8]
 801744c:	6963      	ldr	r3, [r4, #20]
 801744e:	425b      	negs	r3, r3
 8017450:	61a3      	str	r3, [r4, #24]
 8017452:	6923      	ldr	r3, [r4, #16]
 8017454:	b943      	cbnz	r3, 8017468 <__swsetup_r+0xa8>
 8017456:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 801745a:	d1c4      	bne.n	80173e6 <__swsetup_r+0x26>
 801745c:	bd38      	pop	{r3, r4, r5, pc}
 801745e:	0781      	lsls	r1, r0, #30
 8017460:	bf58      	it	pl
 8017462:	6963      	ldrpl	r3, [r4, #20]
 8017464:	60a3      	str	r3, [r4, #8]
 8017466:	e7f4      	b.n	8017452 <__swsetup_r+0x92>
 8017468:	2000      	movs	r0, #0
 801746a:	e7f7      	b.n	801745c <__swsetup_r+0x9c>
 801746c:	20000068 	.word	0x20000068

08017470 <__swhatbuf_r>:
 8017470:	b570      	push	{r4, r5, r6, lr}
 8017472:	460c      	mov	r4, r1
 8017474:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8017478:	b096      	sub	sp, #88	; 0x58
 801747a:	4615      	mov	r5, r2
 801747c:	2900      	cmp	r1, #0
 801747e:	461e      	mov	r6, r3
 8017480:	da0c      	bge.n	801749c <__swhatbuf_r+0x2c>
 8017482:	89a3      	ldrh	r3, [r4, #12]
 8017484:	2100      	movs	r1, #0
 8017486:	f013 0f80 	tst.w	r3, #128	; 0x80
 801748a:	bf0c      	ite	eq
 801748c:	f44f 6380 	moveq.w	r3, #1024	; 0x400
 8017490:	2340      	movne	r3, #64	; 0x40
 8017492:	2000      	movs	r0, #0
 8017494:	6031      	str	r1, [r6, #0]
 8017496:	602b      	str	r3, [r5, #0]
 8017498:	b016      	add	sp, #88	; 0x58
 801749a:	bd70      	pop	{r4, r5, r6, pc}
 801749c:	466a      	mov	r2, sp
 801749e:	f000 f859 	bl	8017554 <_fstat_r>
 80174a2:	2800      	cmp	r0, #0
 80174a4:	dbed      	blt.n	8017482 <__swhatbuf_r+0x12>
 80174a6:	9901      	ldr	r1, [sp, #4]
 80174a8:	f401 4170 	and.w	r1, r1, #61440	; 0xf000
 80174ac:	f5a1 5300 	sub.w	r3, r1, #8192	; 0x2000
 80174b0:	4259      	negs	r1, r3
 80174b2:	4159      	adcs	r1, r3
 80174b4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80174b8:	e7eb      	b.n	8017492 <__swhatbuf_r+0x22>

080174ba <__smakebuf_r>:
 80174ba:	898b      	ldrh	r3, [r1, #12]
 80174bc:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80174be:	079d      	lsls	r5, r3, #30
 80174c0:	4606      	mov	r6, r0
 80174c2:	460c      	mov	r4, r1
 80174c4:	d507      	bpl.n	80174d6 <__smakebuf_r+0x1c>
 80174c6:	f104 0347 	add.w	r3, r4, #71	; 0x47
 80174ca:	6023      	str	r3, [r4, #0]
 80174cc:	6123      	str	r3, [r4, #16]
 80174ce:	2301      	movs	r3, #1
 80174d0:	6163      	str	r3, [r4, #20]
 80174d2:	b002      	add	sp, #8
 80174d4:	bd70      	pop	{r4, r5, r6, pc}
 80174d6:	ab01      	add	r3, sp, #4
 80174d8:	466a      	mov	r2, sp
 80174da:	f7ff ffc9 	bl	8017470 <__swhatbuf_r>
 80174de:	9900      	ldr	r1, [sp, #0]
 80174e0:	4605      	mov	r5, r0
 80174e2:	4630      	mov	r0, r6
 80174e4:	f7ff fc22 	bl	8016d2c <_malloc_r>
 80174e8:	b948      	cbnz	r0, 80174fe <__smakebuf_r+0x44>
 80174ea:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80174ee:	059a      	lsls	r2, r3, #22
 80174f0:	d4ef      	bmi.n	80174d2 <__smakebuf_r+0x18>
 80174f2:	f023 0303 	bic.w	r3, r3, #3
 80174f6:	f043 0302 	orr.w	r3, r3, #2
 80174fa:	81a3      	strh	r3, [r4, #12]
 80174fc:	e7e3      	b.n	80174c6 <__smakebuf_r+0xc>
 80174fe:	89a3      	ldrh	r3, [r4, #12]
 8017500:	6020      	str	r0, [r4, #0]
 8017502:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8017506:	6120      	str	r0, [r4, #16]
 8017508:	81a3      	strh	r3, [r4, #12]
 801750a:	9b00      	ldr	r3, [sp, #0]
 801750c:	6163      	str	r3, [r4, #20]
 801750e:	9b01      	ldr	r3, [sp, #4]
 8017510:	b15b      	cbz	r3, 801752a <__smakebuf_r+0x70>
 8017512:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8017516:	4630      	mov	r0, r6
 8017518:	f000 f82e 	bl	8017578 <_isatty_r>
 801751c:	b128      	cbz	r0, 801752a <__smakebuf_r+0x70>
 801751e:	89a3      	ldrh	r3, [r4, #12]
 8017520:	f023 0303 	bic.w	r3, r3, #3
 8017524:	f043 0301 	orr.w	r3, r3, #1
 8017528:	81a3      	strh	r3, [r4, #12]
 801752a:	89a3      	ldrh	r3, [r4, #12]
 801752c:	431d      	orrs	r5, r3
 801752e:	81a5      	strh	r5, [r4, #12]
 8017530:	e7cf      	b.n	80174d2 <__smakebuf_r+0x18>
	...

08017534 <_close_r>:
 8017534:	b538      	push	{r3, r4, r5, lr}
 8017536:	2300      	movs	r3, #0
 8017538:	4d05      	ldr	r5, [pc, #20]	; (8017550 <_close_r+0x1c>)
 801753a:	4604      	mov	r4, r0
 801753c:	4608      	mov	r0, r1
 801753e:	602b      	str	r3, [r5, #0]
 8017540:	f7e9 ffc3 	bl	80014ca <_close>
 8017544:	1c43      	adds	r3, r0, #1
 8017546:	d102      	bne.n	801754e <_close_r+0x1a>
 8017548:	682b      	ldr	r3, [r5, #0]
 801754a:	b103      	cbz	r3, 801754e <_close_r+0x1a>
 801754c:	6023      	str	r3, [r4, #0]
 801754e:	bd38      	pop	{r3, r4, r5, pc}
 8017550:	2000f864 	.word	0x2000f864

08017554 <_fstat_r>:
 8017554:	b538      	push	{r3, r4, r5, lr}
 8017556:	2300      	movs	r3, #0
 8017558:	4d06      	ldr	r5, [pc, #24]	; (8017574 <_fstat_r+0x20>)
 801755a:	4604      	mov	r4, r0
 801755c:	4608      	mov	r0, r1
 801755e:	4611      	mov	r1, r2
 8017560:	602b      	str	r3, [r5, #0]
 8017562:	f7e9 ffbe 	bl	80014e2 <_fstat>
 8017566:	1c43      	adds	r3, r0, #1
 8017568:	d102      	bne.n	8017570 <_fstat_r+0x1c>
 801756a:	682b      	ldr	r3, [r5, #0]
 801756c:	b103      	cbz	r3, 8017570 <_fstat_r+0x1c>
 801756e:	6023      	str	r3, [r4, #0]
 8017570:	bd38      	pop	{r3, r4, r5, pc}
 8017572:	bf00      	nop
 8017574:	2000f864 	.word	0x2000f864

08017578 <_isatty_r>:
 8017578:	b538      	push	{r3, r4, r5, lr}
 801757a:	2300      	movs	r3, #0
 801757c:	4d05      	ldr	r5, [pc, #20]	; (8017594 <_isatty_r+0x1c>)
 801757e:	4604      	mov	r4, r0
 8017580:	4608      	mov	r0, r1
 8017582:	602b      	str	r3, [r5, #0]
 8017584:	f7e9 ffbd 	bl	8001502 <_isatty>
 8017588:	1c43      	adds	r3, r0, #1
 801758a:	d102      	bne.n	8017592 <_isatty_r+0x1a>
 801758c:	682b      	ldr	r3, [r5, #0]
 801758e:	b103      	cbz	r3, 8017592 <_isatty_r+0x1a>
 8017590:	6023      	str	r3, [r4, #0]
 8017592:	bd38      	pop	{r3, r4, r5, pc}
 8017594:	2000f864 	.word	0x2000f864

08017598 <_lseek_r>:
 8017598:	b538      	push	{r3, r4, r5, lr}
 801759a:	4604      	mov	r4, r0
 801759c:	4d06      	ldr	r5, [pc, #24]	; (80175b8 <_lseek_r+0x20>)
 801759e:	4608      	mov	r0, r1
 80175a0:	4611      	mov	r1, r2
 80175a2:	2200      	movs	r2, #0
 80175a4:	602a      	str	r2, [r5, #0]
 80175a6:	461a      	mov	r2, r3
 80175a8:	f7e9 ffb6 	bl	8001518 <_lseek>
 80175ac:	1c43      	adds	r3, r0, #1
 80175ae:	d102      	bne.n	80175b6 <_lseek_r+0x1e>
 80175b0:	682b      	ldr	r3, [r5, #0]
 80175b2:	b103      	cbz	r3, 80175b6 <_lseek_r+0x1e>
 80175b4:	6023      	str	r3, [r4, #0]
 80175b6:	bd38      	pop	{r3, r4, r5, pc}
 80175b8:	2000f864 	.word	0x2000f864

080175bc <_read_r>:
 80175bc:	b538      	push	{r3, r4, r5, lr}
 80175be:	4604      	mov	r4, r0
 80175c0:	4d06      	ldr	r5, [pc, #24]	; (80175dc <_read_r+0x20>)
 80175c2:	4608      	mov	r0, r1
 80175c4:	4611      	mov	r1, r2
 80175c6:	2200      	movs	r2, #0
 80175c8:	602a      	str	r2, [r5, #0]
 80175ca:	461a      	mov	r2, r3
 80175cc:	f7e9 ff44 	bl	8001458 <_read>
 80175d0:	1c43      	adds	r3, r0, #1
 80175d2:	d102      	bne.n	80175da <_read_r+0x1e>
 80175d4:	682b      	ldr	r3, [r5, #0]
 80175d6:	b103      	cbz	r3, 80175da <_read_r+0x1e>
 80175d8:	6023      	str	r3, [r4, #0]
 80175da:	bd38      	pop	{r3, r4, r5, pc}
 80175dc:	2000f864 	.word	0x2000f864

080175e0 <_sbrk_r>:
 80175e0:	b538      	push	{r3, r4, r5, lr}
 80175e2:	2300      	movs	r3, #0
 80175e4:	4d05      	ldr	r5, [pc, #20]	; (80175fc <_sbrk_r+0x1c>)
 80175e6:	4604      	mov	r4, r0
 80175e8:	4608      	mov	r0, r1
 80175ea:	602b      	str	r3, [r5, #0]
 80175ec:	f7e9 ffa2 	bl	8001534 <_sbrk>
 80175f0:	1c43      	adds	r3, r0, #1
 80175f2:	d102      	bne.n	80175fa <_sbrk_r+0x1a>
 80175f4:	682b      	ldr	r3, [r5, #0]
 80175f6:	b103      	cbz	r3, 80175fa <_sbrk_r+0x1a>
 80175f8:	6023      	str	r3, [r4, #0]
 80175fa:	bd38      	pop	{r3, r4, r5, pc}
 80175fc:	2000f864 	.word	0x2000f864

08017600 <_write_r>:
 8017600:	b538      	push	{r3, r4, r5, lr}
 8017602:	4604      	mov	r4, r0
 8017604:	4d06      	ldr	r5, [pc, #24]	; (8017620 <_write_r+0x20>)
 8017606:	4608      	mov	r0, r1
 8017608:	4611      	mov	r1, r2
 801760a:	2200      	movs	r2, #0
 801760c:	602a      	str	r2, [r5, #0]
 801760e:	461a      	mov	r2, r3
 8017610:	f7e9 ff3f 	bl	8001492 <_write>
 8017614:	1c43      	adds	r3, r0, #1
 8017616:	d102      	bne.n	801761e <_write_r+0x1e>
 8017618:	682b      	ldr	r3, [r5, #0]
 801761a:	b103      	cbz	r3, 801761e <_write_r+0x1e>
 801761c:	6023      	str	r3, [r4, #0]
 801761e:	bd38      	pop	{r3, r4, r5, pc}
 8017620:	2000f864 	.word	0x2000f864

08017624 <memchr>:
 8017624:	b2c9      	uxtb	r1, r1
 8017626:	4402      	add	r2, r0
 8017628:	b510      	push	{r4, lr}
 801762a:	4290      	cmp	r0, r2
 801762c:	4603      	mov	r3, r0
 801762e:	d101      	bne.n	8017634 <memchr+0x10>
 8017630:	2300      	movs	r3, #0
 8017632:	e003      	b.n	801763c <memchr+0x18>
 8017634:	781c      	ldrb	r4, [r3, #0]
 8017636:	3001      	adds	r0, #1
 8017638:	428c      	cmp	r4, r1
 801763a:	d1f6      	bne.n	801762a <memchr+0x6>
 801763c:	4618      	mov	r0, r3
 801763e:	bd10      	pop	{r4, pc}

08017640 <_free_r>:
 8017640:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8017642:	2900      	cmp	r1, #0
 8017644:	d043      	beq.n	80176ce <_free_r+0x8e>
 8017646:	f851 3c04 	ldr.w	r3, [r1, #-4]
 801764a:	1f0c      	subs	r4, r1, #4
 801764c:	9001      	str	r0, [sp, #4]
 801764e:	2b00      	cmp	r3, #0
 8017650:	bfb8      	it	lt
 8017652:	18e4      	addlt	r4, r4, r3
 8017654:	f7ff fe28 	bl	80172a8 <__malloc_lock>
 8017658:	4a1e      	ldr	r2, [pc, #120]	; (80176d4 <_free_r+0x94>)
 801765a:	9801      	ldr	r0, [sp, #4]
 801765c:	6813      	ldr	r3, [r2, #0]
 801765e:	b933      	cbnz	r3, 801766e <_free_r+0x2e>
 8017660:	6063      	str	r3, [r4, #4]
 8017662:	6014      	str	r4, [r2, #0]
 8017664:	b003      	add	sp, #12
 8017666:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 801766a:	f7ff be23 	b.w	80172b4 <__malloc_unlock>
 801766e:	42a3      	cmp	r3, r4
 8017670:	d908      	bls.n	8017684 <_free_r+0x44>
 8017672:	6825      	ldr	r5, [r4, #0]
 8017674:	1961      	adds	r1, r4, r5
 8017676:	428b      	cmp	r3, r1
 8017678:	bf01      	itttt	eq
 801767a:	6819      	ldreq	r1, [r3, #0]
 801767c:	685b      	ldreq	r3, [r3, #4]
 801767e:	1949      	addeq	r1, r1, r5
 8017680:	6021      	streq	r1, [r4, #0]
 8017682:	e7ed      	b.n	8017660 <_free_r+0x20>
 8017684:	461a      	mov	r2, r3
 8017686:	685b      	ldr	r3, [r3, #4]
 8017688:	b10b      	cbz	r3, 801768e <_free_r+0x4e>
 801768a:	42a3      	cmp	r3, r4
 801768c:	d9fa      	bls.n	8017684 <_free_r+0x44>
 801768e:	6811      	ldr	r1, [r2, #0]
 8017690:	1855      	adds	r5, r2, r1
 8017692:	42a5      	cmp	r5, r4
 8017694:	d10b      	bne.n	80176ae <_free_r+0x6e>
 8017696:	6824      	ldr	r4, [r4, #0]
 8017698:	4421      	add	r1, r4
 801769a:	1854      	adds	r4, r2, r1
 801769c:	6011      	str	r1, [r2, #0]
 801769e:	42a3      	cmp	r3, r4
 80176a0:	d1e0      	bne.n	8017664 <_free_r+0x24>
 80176a2:	681c      	ldr	r4, [r3, #0]
 80176a4:	685b      	ldr	r3, [r3, #4]
 80176a6:	440c      	add	r4, r1
 80176a8:	6053      	str	r3, [r2, #4]
 80176aa:	6014      	str	r4, [r2, #0]
 80176ac:	e7da      	b.n	8017664 <_free_r+0x24>
 80176ae:	d902      	bls.n	80176b6 <_free_r+0x76>
 80176b0:	230c      	movs	r3, #12
 80176b2:	6003      	str	r3, [r0, #0]
 80176b4:	e7d6      	b.n	8017664 <_free_r+0x24>
 80176b6:	6825      	ldr	r5, [r4, #0]
 80176b8:	1961      	adds	r1, r4, r5
 80176ba:	428b      	cmp	r3, r1
 80176bc:	bf02      	ittt	eq
 80176be:	6819      	ldreq	r1, [r3, #0]
 80176c0:	685b      	ldreq	r3, [r3, #4]
 80176c2:	1949      	addeq	r1, r1, r5
 80176c4:	6063      	str	r3, [r4, #4]
 80176c6:	bf08      	it	eq
 80176c8:	6021      	streq	r1, [r4, #0]
 80176ca:	6054      	str	r4, [r2, #4]
 80176cc:	e7ca      	b.n	8017664 <_free_r+0x24>
 80176ce:	b003      	add	sp, #12
 80176d0:	bd30      	pop	{r4, r5, pc}
 80176d2:	bf00      	nop
 80176d4:	2000f85c 	.word	0x2000f85c

080176d8 <_init>:
 80176d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80176da:	bf00      	nop
 80176dc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80176de:	bc08      	pop	{r3}
 80176e0:	469e      	mov	lr, r3
 80176e2:	4770      	bx	lr

080176e4 <_fini>:
 80176e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80176e6:	bf00      	nop
 80176e8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80176ea:	bc08      	pop	{r3}
 80176ec:	469e      	mov	lr, r3
 80176ee:	4770      	bx	lr
